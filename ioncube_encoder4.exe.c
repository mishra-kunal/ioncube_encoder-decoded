/* This file was generated by the Hex-Rays decompiler version 7.7.0.220118.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

// int __usercall sub_401000@<eax>(int *a1@<eax>, _DWORD *a2);
// int __usercall sub_4014B0@<eax>(int *a1@<edx>, int a2@<edi>);
int sub_4015A0();
void __noreturn sub_401830(const char *a1, ...);
int sub_4018B0();
int sub_4019C0();
int sub_401B00();
char *__cdecl sub_401B60(int a1, char *String, int a3);
// int __usercall sub_402130@<eax>(char **a1@<edi>, int a2);
// void __usercall sub_402230(const char *a1@<eax>, void *Block);
// void __usercall sub_402420(int *a1@<esi>);
// _DWORD *__usercall sub_402520@<eax>(_DWORD *a1@<esi>);
int sub_4025B0();
int sub_402740();
// char *__usercall sub_403A70@<eax>(char **a1@<ebx>);
// int __usercall sub_403B20@<eax>(char *a1@<eax>, _DWORD *a2@<edi>);
_DWORD *__cdecl sub_403C70(int a1, int *a2);
// _BYTE *__usercall sub_405490@<eax>(const char *a1@<eax>);
// int __usercall sub_405510@<eax>(_DWORD *a1@<ebx>, FILE *a2@<esi>);
int __cdecl sub_405BB0(char *FileName); // idb
// _DWORD *__usercall sub_405D00@<eax>(int *a1@<eax>, _DWORD *a2);
void __cdecl sub_4061B0(int a1, char *Source, int a3, const char *a4);
// _DWORD *__usercall sub_406360@<eax>(_DWORD *a1@<eax>);
// void *__usercall sub_406420@<eax>(int *a1@<edi>);
int sub_406500(); // weak
int sub_406510(); // weak
int sub_406520(char *Format, ...);
int __cdecl sub_406580(int, char *Source, int, char *Format, va_list ArgList); // idb
size_t __cdecl sub_406610(void *Buffer, size_t ElementCount);
FILE *__cdecl sub_406630(char *FileName, _DWORD *a2);
int __cdecl sub_406680(int a1, int a2, int a3);
void sub_406690();
// void __usercall sub_406870(const char *a1@<ebx>, _DWORD *a2@<edi>, char *FileName);
// int __usercall sub_406940@<eax>(int a1@<edx>, char *a2@<ecx>, char *a3, int a4, int a5);
// BOOL __usercall sub_407050@<eax>(char *FileName@<ecx>, char *a2@<eax>, _DWORD *a3);
// char *__usercall sub_4070A0@<eax>(char **a1@<eax>, int a2, int a3);
int sub_4072F0();
// void __usercall __noreturn sub_4075F0(int a1@<edi>);
// int __usercall sub_407650@<eax>(DWORD dwMessageId@<ecx>, const char *a2@<eax>, FILE *Stream, int a4, va_list ArgList, char *Buffer);
void __noreturn sub_407850(const char *a1, ...);
// void __usercall __noreturn sub_407880(va_list a1@<eax>, const char *a2);
void __noreturn sub_4078E0(const char *a1, ...);
int sub_4078F0(const char *a1, ...);
void __noreturn sub_407920(const char *a1, ...);
int sub_407970(const char *a1, ...);
int sub_4079A0(const char *a1, ...);
int sub_4079D0(const char *a1, ...);
int sub_4079F0(const char *a1, ...);
int __cdecl sub_407A20(const char **a1, int a2, int (__cdecl *a3)(const char **, char **, int, int), unsigned __int8 (__cdecl *a4)(char *, int), int a5);
// const char *__usercall sub_408060@<eax>(const char *a1@<esi>, struct _stat32 *Stat);
// int __usercall sub_408110@<eax>(const char *a1@<eax>, int a2, int (__cdecl *a3)(const char **, char **, int, int), unsigned __int8 (__cdecl *a4)(char *, int), int a5);
// CHAR *__usercall sub_408210@<eax>(const CHAR *a1@<eax>);
// int __usercall sub_4082B0@<eax>(const char *a1@<eax>);
// int __usercall sub_408360@<eax>(int result@<eax>, _BYTE *a2@<ecx>);
// HANDLE __usercall sub_408390@<eax>(const CHAR *a1@<ebx>, const CHAR *lpFileName);
// char *__usercall sub_408460@<eax>(int a1@<edi>);
// int __usercall sub_408570@<eax>(int a1@<eax>);
void __cdecl sub_408620(int a1, int *a2);
// void *__usercall sub_408790@<eax>(char *FileName@<ecx>, int a2@<eax>);
int __cdecl sub_408860(_DWORD *a1, int a2, int a3, int a4);
// _DWORD *__usercall sub_408890@<eax>(int *a1@<ebx>, _DWORD *a2, int a3, int *a4, int a5);
int __cdecl sub_408A50(char *FileName, char *); // idb
int __cdecl sub_408B70(int *a1, int a2, int a3);
// int __usercall sub_408D20@<eax>(char *a1@<eax>, int a2@<edi>, char *a3@<esi>, int a4);
int __cdecl sub_408DB0(char *FileName); // idb
BOOL __cdecl sub_408F60(char *FileNamea);
// int __usercall sub_408FB0@<eax>(int ArgList@<ecx>, int a2@<eax>);
int __cdecl sub_409000(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_4092F0(char **a1, int a2, char a3);
// void __usercall sub_409470(int a1@<ecx>, _DWORD *a2@<ebx>, const char *a3, char *FileName, int a5, int a6, int a7);
BOOL __cdecl sub_409910(char *FileName);
// BOOL __usercall sub_409BB0@<eax>(int *a1@<ebx>, char *a2);
// int __usercall sub_409C30@<eax>(int *a1@<eax>, char *FileName, int *a3);
// int __usercall sub_409D10@<eax>(int *a1@<ebx>, char *a2);
// void *__usercall sub_409DA0@<eax>(int *a1@<edx>, _DWORD *a2@<ecx>, char *pszPath, int a4, char *a5, int *a6, int a7);
// _DWORD *__usercall sub_40A170@<eax>(int *a1@<edx>, _DWORD *a2@<ecx>, int *a3, char *a4, int *a5, int a6, _DWORD *a7);
// int __usercall sub_40A440@<eax>(const char *a1@<eax>, int *a2@<ebx>);
char __cdecl sub_40A510(_DWORD *a1);
int __cdecl sub_40A650(int *a1, const char *a2);
int __cdecl main(int argc, const char **argv, const char **envp);
// int __usercall sub_40BD70@<eax>(const char *a1@<eax>, int ArgList, int a3, char a4, int *a5);
// int __usercall sub_40BEA0@<eax>(char *a1@<eax>, _DWORD *a2@<edi>, _DWORD *a3);
// int __usercall sub_40BF50@<eax>(int *a1@<eax>, int a2, int a3, char *Source, const char *a5);
// int __usercall sub_40C040@<eax>(_DWORD *a1@<esi>, char *Source);
// int __usercall sub_40C0A0@<eax>(char *a1@<edi>, int a2, int a3, const char *a4, int *a5, _DWORD *a6);
// int __usercall sub_40C170@<eax>(const char *ArgList@<ecx>, _DWORD *a2@<ebx>, _DWORD *a3@<esi>, int *a4);
// int __usercall sub_40C420@<eax>(_DWORD *a1@<ebx>);
// char *__usercall sub_40CF10@<eax>(int a1@<ecx>, _DWORD *a2@<ebx>);
// int __usercall sub_40CF70@<eax>(int a1@<esi>);
int __cdecl sub_40D250(unsigned __int8 *a1, char *a2, unsigned int a3, int a4, unsigned int a5);
char *__cdecl sub_40DED0(int a1);
int __cdecl sub_40DFA0(int a1, const char *a2, unsigned int a3, unsigned int a4, BOOL a5, unsigned int a6);
// _DWORD *__usercall sub_40E440@<eax>(_DWORD *a1@<eax>);
void __cdecl sub_40E4C0(_DWORD *a1, int a2);
// BOOL __usercall sub_40E5E0@<eax>(_BYTE *a1@<edi>, char *a2);
// BOOL __usercall sub_40E700@<eax>(const char *a1@<eax>, const char *a2@<edx>);
_DWORD *__cdecl sub_40E780(int *a1, int a2, int a3, int a4);
char __cdecl sub_40EF40(char *a1, int a2);
// _DWORD *__usercall sub_40EFB0@<eax>(_DWORD *a1@<eax>);
int __cdecl sub_40F000(int a1, const char *a2);
char *__cdecl sub_40F030(int a1, int a2);
// char *__usercall sub_40F100@<eax>(char *a1@<eax>);
// char *__usercall sub_40F160@<eax>(int a1@<esi>);
int __cdecl sub_40F1F0(_DWORD *a1, int (__cdecl *a2)(int, int, bool, int), int (__cdecl *a3)(_DWORD, int, int), int a4);
// char *__usercall sub_40F2B0@<eax>(const char *a1@<eax>);
// int __usercall sub_40F3A0@<eax>(int a1@<esi>);
int sub_40F420();
int __cdecl array_init(int a1);
char __cdecl zval_ptr_dtor(int *a1);
int zend_register_ini_entries();
char zend_is_executing();
const char *zend_ini_string();
int __cdecl zend_highlight(_DWORD); // weak
int __cdecl zend_register_extension(const void *a1, int a2);
BOOL __cdecl sub_40F690(int a1);
int sub_40F6B0(); // weak
int (__cdecl *__cdecl sub_40F6D0(int a1, int a2))(int);
int __cdecl init_op_array(int a1, char a2, int a3);
_DWORD *__cdecl destroy_zend_function(_BYTE *a1);
void __cdecl destroy_zend_class(int a1);
_DWORD *__cdecl destroy_op_array(int a1);
// _DWORD *__usercall sub_40F8F0@<eax>(_DWORD *a1@<edi>);
unsigned int __thiscall sub_40F9A0(_DWORD *this);
int (__cdecl *__cdecl sub_40F9E0(int a1, int a2))(int);
// int __usercall sub_40FA00@<eax>(int a1@<esi>);
// int __usercall sub_40FAA0@<eax>(int a1@<eax>, int a2@<ebx>, _DWORD *a3, double *a4);
unsigned int __cdecl convert_scalar_to_number(int a1);
int __cdecl zend_str_tolower(_BYTE *a1, int a2);
char __cdecl convert_to_long(int a1);
char __cdecl convert_to_long_base(int a1, int Radix);
char __cdecl convert_to_string(int a1);
int __cdecl zend_binary_strcasecmp(unsigned __int8 *a1, unsigned int a2, unsigned __int8 *a3, unsigned int a4);
int __cdecl mul_function(int a1, int a2, int a3);
// _BYTE *__usercall sub_41027C@<eax>(_BYTE *result@<eax>, int a2);
// int __usercall sub_410291@<eax>(int a1@<edi>);
// char *__usercall sub_410344@<eax>(char *a1@<eax>);
int __cdecl sub_4103A7(int a1, int *a2, char *a3, int *a4);
// int __usercall sub_410CF0@<eax>(int a1@<eax>, _DWORD *a2);
int __cdecl sub_412910(_DWORD *a1);
int __cdecl sub_412960(_DWORD *a1, char *Src, int a3);
int __cdecl sub_412A60(_DWORD *a1, _BYTE *a2);
int sub_412C50();
// int __usercall sub_412CD0@<eax>(_BYTE *a1@<eax>);
int __cdecl sub_412D40(int a1, int a2, int a3, int a4);
// int __usercall sub_412F50@<eax>(_DWORD *a1@<eax>, unsigned __int8 *a2@<ecx>, _BYTE *a3);
int __cdecl sub_4130E0(unsigned __int8 *a1, _BYTE *a2, _DWORD *a3);
// unsigned int __usercall sub_413110@<eax>(_DWORD *a1@<eax>, unsigned __int8 *a2@<edx>, _BYTE *a3);
unsigned int __cdecl sub_4132A0(unsigned __int8 *a1, _BYTE *a2, _DWORD *a3);
int __cdecl sub_4132D0(int *a1);
// int __usercall sub_4132F0@<eax>(_BYTE *a1@<eax>);
int __cdecl sub_413350(unsigned int *a1);
int __cdecl sub_4133C0(int a1, int a2, int a3);
int __cdecl sub_4134A0(unsigned int *a1);
size_t __cdecl sub_413530(_BYTE *a1, size_t Size, int a3);
int __cdecl sub_413570(int a1);
int __cdecl sub_4135B0(_BYTE *a1, _DWORD *a2, int a3);
int __cdecl sub_413600(int a1, int a2, unsigned int *a3);
int __cdecl sub_413640(_BYTE *a1, int *a2, unsigned int a3, _DWORD *a4);
int __cdecl sub_4137E0(unsigned int a1, int a2, int a3, int a4, int a5, unsigned int *a6);
int __cdecl sub_413880(int a1, unsigned int a2, int a3, void (*a4)(void));
int __cdecl sub_4139B0(const char *a1);
int __cdecl sub_413A10(unsigned int a1, int a2, int a3, int a4, _DWORD *a5);
int __cdecl sub_413AD0(const char *a1);
int __cdecl sub_413B30(const char *a1);
unsigned int __cdecl sub_413B90(unsigned int a1);
int __cdecl sub_413BC0(unsigned __int8 *a1, int a2, int a3, int *a4);
// _BYTE *__usercall sub_414210@<eax>(unsigned __int8 *a1@<eax>, int a2@<ecx>, _BYTE *a3);
_BYTE *__cdecl sub_414750(unsigned __int8 *a1, _BYTE *a2, int a3);
_BYTE *__cdecl sub_414780(_BYTE *a1, _DWORD *a2);
_BYTE *__cdecl sub_414D60(int a1, _BYTE *a2, _DWORD *a3);
int __cdecl sub_414D90(int *a1);
// int __usercall sub_414DD0@<eax>(int a1@<eax>, _BYTE *a2@<ecx>);
int __cdecl sub_414E60(_BYTE *a1, int a2, void (*a3)(void));
int (__cdecl *__cdecl sub_414F02(int a1, int (__cdecl *a2)(int, char *Format, char ArgList), _BYTE *a3))(int, char *Format, char ArgList);
const char *__cdecl xmlBuildQName(const char *a1, const char *Src, char *a3, int a4);
_BYTE *__cdecl xmlSplitQName2(char *Src, _DWORD *a2);
int __cdecl xmlSplitQName3(char *a1, _DWORD *a2);
int __cdecl xmlValidateNCName(unsigned __int8 *a1, int a2);
int __cdecl xmlValidateQName(unsigned __int8 *a1, int a2);
int __cdecl xmlValidateName(unsigned __int8 *a1, int a2);
int __cdecl xmlValidateNMToken(unsigned __int8 *a1, int a2);
unsigned int __cdecl xmlSetBufferAllocationScheme(unsigned int a1);
int xmlGetBufferAllocationScheme();
_DWORD *__cdecl xmlNewNs(int a1, char *Src, char *a3);
int __cdecl xmlSetNs(int a1, int a2);
int __cdecl xmlFreeNs(_DWORD *Block);
_DWORD *__cdecl xmlFreeNsList(_DWORD *Block);
_DWORD *__cdecl xmlNewDtd(int a1, _BYTE *Src, _BYTE *a3, _BYTE *a4);
int __cdecl xmlGetIntSubset(int a1);
_DWORD *__cdecl xmlCreateIntSubset(_DWORD *a1, _BYTE *Src, _BYTE *a3, _BYTE *a4);
void __cdecl xmlFreeDtd(_DWORD *Block);
_DWORD *__cdecl xmlNewDoc(char *Src);
void __cdecl xmlFreeDoc(void *Block);
_DWORD *__cdecl xmlStringLenGetNodeList(int (__cdecl *a1)(int, char *Format, char ArgList), char *Src, int a3);
char *__cdecl xmlStringGetNodeList(int (__cdecl *a1)(int, char *Format, char ArgList), unsigned __int8 *Src);
_BYTE *__cdecl xmlNodeListGetString(_DWORD *a1, int Src, int a3);
_BYTE *__cdecl xmlNodeListGetRawString(_DWORD *a1, int Src, int a3);
// _DWORD *__usercall sub_416DFC@<eax>(_DWORD *a1@<eax>, int a2, char *Block, char *Src, int a5);
_DWORD *__cdecl xmlNewProp(_DWORD *a1, char *Block, char *a3);
_DWORD *__cdecl xmlNewNsProp(_DWORD *a1, int a2, char *Block, char *a4);
_DWORD *__cdecl xmlNewNsPropEatName(_DWORD *a1, int a2, char *Block, char *a4);
_DWORD *__cdecl xmlNewDocProp(int a1, char *Src, unsigned __int8 *a3);
_DWORD *__cdecl xmlFreePropList(_DWORD *Block);
void __cdecl xmlFreeProp(_DWORD *Block);
int __cdecl xmlRemoveProp(_DWORD *Block);
_DWORD *__cdecl xmlNewDocPI(int a1, char *Src, _BYTE *a3);
_DWORD *__cdecl xmlNewPI(char *Src, _BYTE *a2);
_DWORD *__cdecl xmlNewNode(int a1, _BYTE *Src);
_DWORD *__cdecl xmlNewNodeEatName(int a1, int a2);
_DWORD *__cdecl xmlNewDocNode(int a1, int a2, char *Src, unsigned __int8 *a4);
_DWORD *__cdecl xmlNewDocNodeEatName(int a1, int a2, void *Block, unsigned __int8 *a4);
_DWORD *__cdecl xmlNewDocRawNode(int a1, int a2, char *Src, _BYTE *a4);
_DWORD *__cdecl xmlNewDocFragment(int a1);
_DWORD *__cdecl xmlNewText(_BYTE *Src);
_DWORD *__cdecl xmlNewTextChild(_DWORD *a1, int a2, char *Src, _BYTE *a4);
_DWORD *__cdecl xmlNewCharRef(int a1, char *Src);
_DWORD *__cdecl xmlNewReference(_DWORD *a1, char *Src);
_DWORD *__cdecl xmlNewDocText(int a1, _BYTE *a2);
_DWORD *__cdecl xmlNewTextLen(void *Src, int Size);
_DWORD *__cdecl xmlNewDocTextLen(int a1, void *a2, int a3);
_DWORD *__cdecl xmlNewComment(_BYTE *Src);
_DWORD *__cdecl xmlNewCDataBlock(int a1, void *Src, int Size);
_DWORD *__cdecl xmlNewDocComment(int a1, _BYTE *a2);
void __cdecl xmlSetTreeDoc(_DWORD *a1, int a2);
int __cdecl xmlSetListDoc(int a1, int a2);
_DWORD *__cdecl xmlNewChild(_DWORD *a1, int a2, char *Src, unsigned __int8 *a4);
// int __usercall sub_41797A@<eax>(int a1@<ebx>, _DWORD *a2@<edi>, int a3@<esi>);
char *__cdecl xmlAddNextSibling(char *a1, char *Block);
char *__cdecl xmlAddPrevSibling(int a1, char *Block);
char *__cdecl xmlAddSibling(char *a1, char *Block);
_DWORD *__cdecl xmlAddChildList(_DWORD *a1, _BYTE **Block);
char *__cdecl xmlAddChild(char *a1, char *Block);
int __cdecl xmlGetLastChild(int a1);
int __cdecl xmlChildElementCount(int a1);
int __cdecl xmlFirstElementChild(int a1);
int __cdecl xmlLastElementChild(int a1);
int __cdecl xmlPreviousElementSibling(int a1);
int __cdecl xmlNextElementSibling(int a1);
void __cdecl xmlFreeNodeList(_DWORD *Block);
void __cdecl xmlFreeNode(char *Block);
void __cdecl xmlUnlinkNode(int a1);
_DWORD *__cdecl xmlReplaceNode(_DWORD *a1, _DWORD *a2);
_DWORD *__cdecl xmlCopyNamespace(int a1);
_DWORD *__cdecl xmlCopyNamespaceList(_DWORD *a1);
_DWORD *__cdecl sub_4184CE(int a1, _DWORD *a2, int *a3);
_DWORD *__cdecl xmlCopyProp(_DWORD *a1, int *a2);
_DWORD *__cdecl xmlCopyPropList(_DWORD *a1, int *a2);
char *__cdecl sub_4186C8(int a1, int a2, char *a3, int a4);
// char *__usercall sub_41894F@<eax>(int a1@<eax>, int a2@<edi>, char *a3);
int __cdecl xmlCopyNode(int a1, int a2);
char *__cdecl xmlDocCopyNode(int a1, int a2, int a3);
char *__cdecl xmlDocCopyNodeList(int a1, int a2);
char *__cdecl xmlCopyNodeList(int a1);
_DWORD *__cdecl xmlCopyDtd(int a1);
_DWORD *__cdecl xmlCopyDoc(int a1, int a2);
int __cdecl xmlGetLineNo(int a1);
char *__cdecl xmlGetNodePath(int a1);
int __cdecl xmlDocGetRootElement(int a1);
char *__cdecl xmlDocSetRootElement(int a1, char *a2);
void __cdecl xmlNodeSetLang(_DWORD *a1, char *a2);
_BYTE *__cdecl xmlNodeGetLang(int a1);
void __cdecl xmlNodeSetSpacePreserve(_DWORD *a1, int a2);
int __cdecl xmlNodeGetSpacePreserve(int a1);
void __cdecl xmlNodeSetName(_DWORD *a1, char *Src);
void __cdecl xmlNodeSetBase(_DWORD *a1, char *Src);
unsigned __int8 *__cdecl xmlNodeGetBase(_DWORD *a1, _DWORD *a2);
int __cdecl xmlNodeBufGetContent(int *a1, int a2);
_BYTE *__cdecl xmlNodeGetContent(int a1);
void __cdecl xmlNodeSetContent(int a1, _BYTE *Src);
void __cdecl xmlNodeSetContentLen(int a1, void *Src, int Size);
void __cdecl xmlNodeAddContentLen(int a1, _BYTE *Src, signed int Size);
void __cdecl xmlNodeAddContent(int a1, _BYTE *a2);
char *__cdecl xmlTextMerge(int a1, char *Block);
_DWORD *__cdecl xmlGetNsList(int a1, int a2);
// _DWORD *__usercall sub_419BDE@<eax>(int a1@<ebx>);
_DWORD *__cdecl xmlSearchNs(int a1, _DWORD *a2, char *a3);
// int __usercall sub_419D93@<eax>(_DWORD *a1@<eax>, _DWORD *a2, char *a3);
int **__cdecl xmlSearchNsByHref(int a1, _DWORD *a2, char *a3);
// int **__usercall sub_419F60@<eax>(int a1@<ebx>, _DWORD *a2@<edi>, int a3@<esi>);
int __cdecl xmlReconciliateNs(int a1, _DWORD *a2);
// int __usercall sub_41A331@<eax>(int a1@<eax>, char *a2, char *a3, int a4);
int __cdecl xmlHasProp(int a1, char *a2);
int __cdecl xmlHasNsProp(int a1, char *a2, char *a3);
_BYTE *__cdecl xmlGetProp(int a1, char *a2);
_BYTE *__cdecl xmlGetNoNsProp(int a1, char *a2);
_BYTE *__cdecl xmlGetNsProp(int a1, char *a2, char *a3);
int __cdecl xmlUnsetProp(int a1, char *a2);
int __cdecl xmlUnsetNsProp(int a1, int a2, char *a3);
_DWORD *__cdecl xmlSetProp(int Size, char *Src, char *a3);
_DWORD *__cdecl xmlSetNsProp(int a1, int a2, char *Block, char *Src);
BOOL __cdecl xmlNodeIsText(int a1);
int __cdecl xmlIsBlankNode(int a1);
int __cdecl xmlTextConcat(_DWORD *a1, _BYTE *Src, signed int Size);
_DWORD *xmlBufferCreate();
_DWORD *__cdecl xmlBufferCreateSize(int a1);
int __cdecl xmlBufferDetach(int *a1);
_DWORD *__cdecl xmlBufferCreateStatic(int a1, int a2);
void __cdecl xmlBufferSetAllocationScheme(int a1, unsigned int a2);
void __cdecl xmlBufferFree(int *Block);
int __cdecl xmlBufferEmpty(int a1);
int __cdecl xmlBufferShrink(int a1, unsigned int a2);
int __cdecl xmlBufferGrow(int a1, unsigned int a2);
size_t __cdecl xmlBufferDump(FILE *Stream, int a2);
int __cdecl xmlBufferContent(int a1);
int __cdecl xmlBufferLength(int a1);
int __cdecl xmlBufferResize(_DWORD *a1, size_t Size);
int __cdecl xmlBufferAdd(int *a1, _BYTE *Src, int a3);
int __cdecl xmlBufferAddHead(const void **a1, _BYTE *Src, signed int Size);
int __cdecl xmlBufferCat(int *a1, _BYTE *Src);
int __cdecl xmlBufferCCat(_DWORD *a1, _BYTE *a2);
int *__cdecl xmlBufferWriteCHAR(int *a1, _BYTE *Src);
int __cdecl xmlBufferWriteChar(_DWORD *a1, _BYTE *a2);
void __cdecl xmlBufferWriteQuotedString(int *a1, _BYTE *Src);
int __cdecl xmlGetDocCompressMode(int a1);
int __cdecl xmlSetDocCompressMode(int a1, int a2);
int xmlGetCompressMode();
int __cdecl xmlSetCompressMode(int a1);
// int __usercall sub_41B0F6@<eax>(int a1@<edi>);
// _DWORD *__usercall sub_41B12E@<eax>(_DWORD **a1@<ebx>, int a2, int a3, int a4, int a5);
// _DWORD *__usercall sub_41B1EE@<eax>(_DWORD *result@<eax>, char *a2, char *a3);
_DWORD *xmlDOMWrapNewCtxt();
int __cdecl xmlDOMWrapFreeCtxt(_DWORD *Block);
// int __usercall sub_41B2A3@<eax>(_DWORD *a1@<eax>, _DWORD **a2);
// int __usercall sub_41B36A@<eax>(int *a1@<ebx>, int *a2@<edi>, void **a3@<esi>, int a4, int a5);
int __cdecl xmlDOMWrapRemoveNode(int a1, _DWORD *a2, _DWORD *a3);
// int __usercall sub_41B56C@<eax>(int a1@<eax>, _DWORD *a2, char *a3, int ***a4);
// int __usercall sub_41B68A@<eax>(_DWORD *a1@<eax>, char *a2@<ebx>, int a3);
// _DWORD *__usercall sub_41B70C@<eax>(const char *a1@<ecx>, int a2@<edi>, int a3, char *a4, int a5);
int __cdecl sub_41B7E6(_DWORD *a1, int a2, int a3, _DWORD *a4, _DWORD **a5, int a6, int a7);
int __cdecl xmlDOMWrapReconcileNamespaces(int a1, _DWORD *a2, char a3);
int __cdecl sub_41BE42(int a1, _DWORD *a2, int a3, _DWORD *a4, _DWORD *a5);
int __cdecl xmlDOMWrapCloneNode(int a1, _DWORD *a2, int a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, int a7);
// int __usercall sub_41CC04@<eax>(_DWORD *a1@<eax>, unsigned int *a2@<esi>, int a3, int a4, _DWORD *a5);
int __cdecl xmlDOMWrapAdoptNode(int a1, _DWORD *a2, void *Block, _DWORD *a4, int a5);
int __cdecl xmlIsXHTML(char *a1, char *a2);
int (__cdecl *__cdecl sub_41D125(_BYTE *a1))(int, char *Format, char ArgList);
int (__cdecl *__cdecl sub_41D13A(int a1, int (__cdecl *a2)(int, char *Format, char ArgList), _BYTE *a3))(int, char *Format, char ArgList);
// _BYTE *__usercall sub_41D187@<eax>(int a1@<eax>, _BYTE *a2@<ecx>);
int __cdecl sub_41D287(char *a1, _DWORD *a2, char *a3, _DWORD *a4);
// void __usercall sub_41D4DA(_DWORD *a1@<esi>);
// int __usercall sub_41D56B@<eax>(int a1@<esi>);
// int __usercall sub_41D595@<eax>(char *a1@<edi>, int a2);
// void __usercall sub_41D62A(int a1@<ebx>, int a2@<edi>);
// int __usercall sub_41D68D@<eax>(int a1@<eax>, char *a2);
// void __usercall sub_41D701(int a1@<edi>, int a2@<esi>);
// void __usercall sub_41D767(int a1@<eax>, int a2@<ebx>, _DWORD *a3);
// int __usercall sub_41D81D@<eax>(int result@<eax>, int a2@<edi>);
// int __usercall sub_41D957@<eax>(int result@<eax>, int a2@<ecx>);
// int __usercall sub_41D9DF@<eax>(int result@<eax>, int a2@<esi>);
void __cdecl sub_41DA5E(int a1, void *Src);
int __cdecl sub_41DEDF(int a1, _DWORD *Src);
int __cdecl xmlSaveToFd(int a1, char *a2, int a3);
int __cdecl xmlSaveToFilename(char *a1, char *a2, int a3);
int __cdecl xmlSaveToBuffer(int a1, char *a2, int a3);
int __cdecl xmlSaveToIO(int a1, int a2, int a3, char *a4, int a5);
int __cdecl xmlSaveDoc(int a1, _DWORD *Src);
int __cdecl xmlSaveTree(int a1, void *a2);
int __cdecl xmlSaveFlush(int a1);
int __cdecl xmlSaveClose(int a1);
int __cdecl xmlSaveSetEscape(int a1, int a2);
int __cdecl xmlSaveSetAttrEscape(int a1, int a2);
unsigned __int8 *__cdecl xmlAttrSerializeTxtContent(int *a1, int a2, int (__cdecl *a3)(int, char *Format, char ArgList), unsigned __int8 *Src);
int __cdecl xmlNodeDump(int a1, int a2, void *a3, int a4, int a5);
_DWORD *__cdecl xmlElemDump(int a1, int a2, int (__cdecl *a3)(int, char *Format, char ArgList));
void __cdecl xmlNodeDumpOutput(int a1, int a2, void *a3, int a4, int a5, const char *a6);
int (__cdecl *__cdecl xmlDocDumpFormatMemoryEnc(_DWORD *a1, int (__cdecl *a2)(int, char *Format, char ArgList), int *a3, char *a4, int a5))(int, char *Format, char ArgList);
int (__cdecl *__cdecl xmlDocDumpMemory(_DWORD *a1, int (__cdecl *a2)(int, char *Format, char ArgList), int *a3))(int, char *Format, char ArgList);
int (__cdecl *__cdecl xmlDocDumpFormatMemory(_DWORD *a1, int (__cdecl *a2)(int, char *Format, char ArgList), int *a3, int a4))(int, char *Format, char ArgList);
int (__cdecl *__cdecl xmlDocDumpMemoryEnc(_DWORD *a1, int (__cdecl *a2)(int, char *Format, char ArgList), int *a3, char *a4))(int, char *Format, char ArgList);
int __cdecl xmlDocFormatDump(int a1, _DWORD *Src, int a3);
int __cdecl xmlDocDump(int a1, _DWORD *Src);
int __cdecl xmlSaveFileTo(_DWORD *Block, _DWORD *Src, int a3);
int __cdecl xmlSaveFormatFileTo(_DWORD *Block, _DWORD *Src, int a3, int a4);
int __cdecl xmlSaveFormatFileEnc(char *a1, _DWORD *Src, const char *a3, int a4);
int __cdecl xmlSaveFileEnc(char *a1, _DWORD *Src, const char *a3);
int __cdecl xmlSaveFormatFile(char *a1, _DWORD *Src, int a3);
int __cdecl xmlSaveFile(char *a1, _DWORD *Src);
// int __usercall sub_41EB1F@<eax>(int *a1@<eax>, int a2@<ecx>, unsigned int a3);
// int (__cdecl *__usercall sub_41EBBA@<eax>(int (__cdecl *result)(int, char *Format, char ArgList)@<eax>, int *a2@<edi>, _BYTE *Src))(int, char *Format, char ArgList);
// void __usercall sub_41EC3F(int a1@<ecx>, int *a2@<ebx>, _BYTE *Src);
// int (__cdecl *__usercall sub_41EFC6@<eax>(int (__cdecl *result)(int, char *Format, char ArgList)@<eax>, int *a2@<edi>, const char *ArgList))(int, char *Format, char ArgList);
// int (__cdecl *__usercall sub_41F01E@<eax>(int a1@<ecx>, _BYTE *a2@<esi>, int a3, char *Format))(int, char *Format, char ArgList);
// int (__cdecl *__usercall sub_41F093@<eax>(int (__cdecl *result)(int, char *Format, char ArgList)@<eax>, int *a2@<edi>, char *Format, int ArgList))(int, char *Format, char ArgList);
// int (__cdecl *__usercall sub_41F0ED@<eax>(int (__cdecl *result)(int, char *Format, char ArgList)@<eax>, int *a2@<edi>, char *Format, _BYTE *Src, int a5, _BYTE *a6))(int, char *Format, char ArgList);
// int (__cdecl *__usercall sub_41F152@<eax>(int (__cdecl *result)(int, char *Format, char ArgList)@<eax>, int *a2@<edi>, char *Format, _BYTE *Src))(int, char *Format, char ArgList);
// int (__cdecl *__usercall sub_41F1AC@<eax>(int *a1@<ecx>, int a2@<edx>, char *Format, _BYTE *Src))(int, char *Format, char ArgList);
// int (__cdecl *__usercall sub_41F1EB@<eax>(int (__cdecl *result)(int, char *Format, char ArgList)@<eax>, int *a2@<edi>, char *Format, _BYTE *Src, _BYTE *a5, _BYTE *a6))(int, char *Format, char ArgList);
int (__cdecl *__cdecl sub_41F241(char *Format, _BYTE *Src, _BYTE *a3))(int, char *Format, char ArgList);
int __cdecl xmlHasFeature(int a1);
// void __usercall sub_41F321(int a1@<esi>);
char *__fastcall sub_41F3B9(char *a1, char *a2);
// const char *__usercall sub_41F3F9@<eax>(int *a1@<eax>, char *a2@<ebx>, int a3);
// int __usercall sub_41F496@<eax>(char *a1@<eax>, int a2@<edi>, char *Src, char *a4);
// int __usercall sub_41F666@<eax>(int a1@<eax>, char *a2, char *a3, void *a4);
int __cdecl sub_41F6C9(int a1, int a2, char *a3, char *a4);
// void __usercall sub_41F6ED(int a1@<esi>);
BOOL __cdecl xmlCheckLanguageID(unsigned __int8 *a1);
// int __usercall sub_41F940@<eax>(int a1@<ebx>, _DWORD *a2@<esi>, int a3);
// int __usercall sub_41FA49@<eax>(int result@<eax>, int a2@<esi>);
// int __usercall sub_41FAA2@<eax>(int a1@<esi>, int a2);
int __cdecl inputPush(int a1, int ***Block);
int __cdecl inputPop(_DWORD *a1);
int __cdecl nodePush(int a1, int a2);
int __cdecl nodePop(_DWORD *a1);
// int __usercall sub_41FCA8@<eax>(int a1@<edi>, int a2@<esi>, int a3, int a4, int a5);
int __thiscall sub_41FD84(_DWORD *this);
int __cdecl namePush(int a1, int a2);
int __cdecl namePop(_DWORD *a1);
// int __usercall sub_41FE7B@<eax>(int a1@<edi>, int a2@<esi>);
int __fastcall sub_41FEF7(int a1, _DWORD *a2);
// char __usercall sub_41FF30@<al>(_DWORD *a1@<esi>);
// char __usercall sub_41FF5D@<al>(int a1@<esi>);
int __cdecl xmlSkipBlankChars(int a1);
char __cdecl xmlPopInput(_DWORD *a1);
int __cdecl xmlPushInput(_DWORD *a1, const char **Block);
unsigned int __cdecl xmlParseCharRef(int *a1);
// unsigned int __usercall sub_42043E@<eax>(unsigned __int8 **a1@<eax>, int *a2@<ecx>);
void __cdecl j_xmlFree(void *Block);
_DWORD *__cdecl sub_4205B0(int *a1, int a2);
void __cdecl xmlParserHandlePEReference(int *a1);
_BYTE *__cdecl xmlStringLenDecodeEntities(int *a1, unsigned __int8 *ArgList, int a3, int a4, unsigned __int8 a5, unsigned __int8 a6, unsigned __int8 a7);
_BYTE *__cdecl xmlStringDecodeEntities(int *a1, unsigned __int8 *ArgList, int a3, unsigned __int8 a4, unsigned __int8 a5, unsigned __int8 a6);
// int __usercall sub_420DB2@<eax>(_DWORD *a1@<eax>, int a2, int a3, int a4);
_BYTE *__cdecl xmlSplitQName(int *a1, char *a2, _DWORD *a3);
// int __usercall sub_4211E0@<eax>(int a1@<eax>, signed int a2@<ecx>);
// BOOL __usercall sub_4213B6@<eax>(int a1@<eax>, signed int a2@<ecx>);
// unsigned __int8 *__usercall sub_421658@<eax>(int a1@<eax>);
unsigned __int8 *__cdecl xmlParseName(int a1);
// unsigned __int8 *__usercall sub_421CEA@<eax>(int a1@<eax>);
// unsigned __int8 *__usercall sub_421E2A@<eax>(int a1@<esi>);
// unsigned __int8 *__usercall sub_421ECF@<eax>(int a1@<eax>, unsigned __int8 *a2);
_BYTE *__cdecl sub_421F46(unsigned __int8 **a1);
_BYTE *__cdecl xmlParseNmtoken(int *a1);
_BYTE *__cdecl xmlParseEntityValue(int *a1, _DWORD *a2);
char *__cdecl sub_422666(int *a1, signed int *a2, int a3);
char *__cdecl xmlParseAttValue(int *a1);
void *__cdecl xmlParseSystemLiteral(int *a1);
void *__cdecl xmlParsePubidLiteral(int *a1);
void __cdecl xmlParseCharData(int *a1, int a2);
void __cdecl sub_4233D6(int a1);
void *__cdecl xmlParseExternalID(int *a1, _DWORD *a2, int a3);
// int __usercall sub_4239A0@<eax>(int *a1@<eax>, _BYTE *Block, int a3, int a4);
int __cdecl xmlParseComment(int *a1);
char *__cdecl xmlParsePITarget(int *a1);
void __cdecl xmlParsePI(int *Block);
void __cdecl xmlParseNotationDecl(int *Block);
void __cdecl xmlParseEntityDecl(int *Src);
int __cdecl xmlParseDefaultDecl(int a1, char **a2);
void **__cdecl xmlParseNotationType(int *a1);
void **__cdecl xmlParseEnumerationType(int *a1);
int __cdecl xmlParseEnumeratedType(int *a1, void ***a2);
int __cdecl xmlParseAttributeType(int *a1, void ***a2);
void __cdecl xmlParseAttributeListDecl(int *a1);
int *__cdecl xmlParseElementMixedContentDecl(int *a1, int a2);
int *__cdecl sub_425F26(int *a1, int a2, int a3);
int *__cdecl xmlParseElementChildrenContentDecl(int *a1, int a2);
int __cdecl xmlParseElementContentDecl(int *a1, _BYTE *a2, int **a3);
int __cdecl xmlParseElementDecl(int *a1);
void __cdecl sub_42687B(int *Block);
void __cdecl xmlParseMarkupDecl(int *Block);
void __cdecl xmlParseTextDecl(int *a1);
void __cdecl xmlParseExternalSubset(int *Block, _BYTE *a2, _BYTE *a3);
void __cdecl xmlParseReference(int a1);
_DWORD *__cdecl xmlParseEntityRef(int *a1);
// _DWORD *__usercall sub_427A16@<eax>(int *a1@<eax>, _BYTE **a2);
void __cdecl xmlParsePEReference(int *a1);
// int __usercall sub_427D3D@<eax>(int *a1@<eax>, int a2);
// int __usercall sub_427FAB@<eax>(int *a1@<eax>, _BYTE **a2);
void __cdecl xmlParseDocTypeDecl(int *a1);
// void __usercall sub_4281C3(int *a1@<eax>);
unsigned __int8 *__cdecl xmlParseAttribute(int a1, unsigned __int8 **a2);
unsigned __int8 *__cdecl xmlParseStartTag(int *Block);
// int (__cdecl *__usercall sub_4286F2@<eax>(int a1@<eax>, int a2))(int, char *Format, char ArgList);
int (__cdecl *__cdecl xmlParseEndTag(int a1))(int, char *Format, char ArgList);
// int __usercall sub_428877@<eax>(_DWORD *a1@<ecx>, int a2@<esi>);
// unsigned __int8 *__usercall sub_4288BC@<eax>(int a1@<eax>, unsigned __int8 **a2);
// unsigned __int8 *__usercall sub_428A4F@<eax>(int a1@<eax>, unsigned __int8 *a2, unsigned __int8 *a3);
// char *__usercall sub_428B02@<eax>(int *a1@<eax>, signed int *a2, _DWORD *a3, int a4);
// char *__usercall sub_428DF1@<eax>(int a1@<eax>, char *a2, unsigned __int8 *a3, unsigned __int8 **a4, char **a5, signed int *a6, _DWORD *a7);
// unsigned __int8 *__usercall sub_428FDD@<eax>(int a1@<eax>, char **a2, int *a3, _DWORD *a4);
// void __usercall sub_429A1C(int a1@<eax>, unsigned __int8 *a2, int a3, int a4, int a5, int a6);
void __cdecl xmlParseCDSect(int *a1);
void __cdecl xmlParseContent(int *Block);
void __cdecl xmlParseElement(int *Block);
_BYTE *__cdecl xmlParseVersionNum(int *a1);
_BYTE *__cdecl xmlParseVersionInfo(int *a1);
unsigned __int8 *__cdecl xmlParseEncName(int *a1);
unsigned __int8 *__cdecl xmlParseEncodingDecl(int *a1);
int __cdecl xmlParseSDDecl(int *a1);
void __cdecl xmlParseXMLDecl(int *a1);
unsigned __int8 *__cdecl xmlParseMisc(int *Block);
int __cdecl xmlParseDocument(int *Block);
int __cdecl xmlParseExtParsedEnt(int *Block);
// int __usercall sub_42B4D7@<eax>(int a1@<ebx>, char a2, unsigned __int8 a3, unsigned __int8 a4);
// unsigned int __usercall sub_42B576@<eax>(unsigned int result@<eax>, unsigned int *a2@<edi>, unsigned int *a3);
// int __usercall sub_42B64B@<eax>(int a1@<esi>, int a2);
int __cdecl sub_42B8AE(int a1);
int __cdecl xmlParseChunk(int *Block, _BYTE *Src, int a3, int a4);
int *__cdecl xmlCreatePushParserCtxt(_DWORD *a1, int a2, char *Src, int a4, char *Source);
_DWORD *__cdecl xmlStopParser(_DWORD *a1);
int *__cdecl xmlCreateIOParserCtxt(_DWORD *a1, int a2, void *Block, void (__cdecl *a4)(int), int a5, int a6);
int __cdecl xmlParseCtxtExternalEntity(int a1, char *a2, int a3, _DWORD *a4);
// int __usercall sub_42D227@<eax>(int a1@<eax>, _DWORD *a2, int a3, int a4, int a5, char *a6, int a7, _DWORD *a8);
int __cdecl xmlParseExternalEntity(int a1, int a2, int a3, int a4, char *a5, int a6, _DWORD *a7);
int __cdecl xmlParseBalancedChunkMemory(_DWORD *a1, int a2, int a3, int a4, _BYTE *a5, _DWORD *a6);
// int __usercall sub_42D5D2@<eax>(int *a1@<eax>, _BYTE *a2, int a3, _DWORD *a4);
int __cdecl xmlParseInNodeContext(int a1, _BYTE *a2, int a3, int a4, _DWORD **a5);
int __cdecl xmlParseBalancedChunkMemoryRecover(_DWORD *a1, int a2, int a3, int a4, _BYTE *a5, _DWORD *a6, int a7);
int __cdecl xmlSAXParseEntity(int a1, char *a2);
int __cdecl xmlParseEntity(char *a1);
// int *__usercall sub_42DF6E@<eax>(int a1@<eax>, char *Source, int a3, _BYTE *a4);
int *__cdecl xmlCreateEntityParserCtxt(char *a1, int a2, _BYTE *a3);
int *__cdecl xmlCreateURLParserCtxt(char *Source, int a2);
int *__cdecl xmlCreateFileParserCtxt(char *a1);
int __cdecl xmlSAXParseFileWithData(int a1, char *Source, int a3, int a4);
int __cdecl xmlSAXParseFile(int a1, char *a2, int a3);
int __cdecl xmlRecoverDoc(_BYTE *a1);
int __cdecl xmlParseFile(char *a1);
int __cdecl xmlRecoverFile(char *a1);
void __cdecl xmlSetupParserForBuffer(_DWORD *a1, int **a2, char *Source);
int __cdecl xmlSAXUserParseFile(int a1, int a2, char *a3);
int *__cdecl xmlCreateMemoryParserCtxt(_BYTE *Src, int a2);
int *__cdecl xmlSAXParseMemoryWithData(int a1, _BYTE *a2, int a3, int a4, int a5);
int *__cdecl xmlSAXParseMemory(int a1, _BYTE *a2, int a3, int a4);
int *__cdecl xmlParseMemory(_BYTE *a1, int a2);
int *__cdecl xmlRecoverMemory(_BYTE *a1, int a2);
int __cdecl xmlSAXUserParseMemory(int a1, int a2, _BYTE *a3, int a4);
int *__cdecl xmlCreateDocParserCtxt(_BYTE *a1);
int __cdecl xmlSAXParseDoc(int a1, _BYTE *a2, int a3);
int __cdecl xmlParseDoc(_BYTE *a1);
int xmlInitParser();
void xmlCleanupParser();
void __cdecl xmlCtxtReset(_DWORD *a1);
int __cdecl xmlCtxtResetPush(int *a1, char *a2, int a3, char *Source, char *Src);
// int __usercall sub_42E9D0@<eax>(int a1@<eax>, _DWORD *a2@<esi>, _BYTE *Src);
int __cdecl xmlCtxtUseOptions(_DWORD *a1, int a2);
// int __usercall sub_42EC03@<eax>(int *Block@<ecx>, int a2@<eax>, _BYTE *Src, char *a4, int a5);
int __cdecl xmlReadDoc(_BYTE *a1, _BYTE *a2, char *a3, int a4);
int *__cdecl xmlReadFile(char *a1, char *a2, int a3);
int *__cdecl xmlReadMemory(_BYTE *a1, int a2, _BYTE *a3, char *a4, int a5);
int __cdecl xmlReadFd(int a1, _BYTE *a2, char *a3, int a4);
int __cdecl xmlReadIO(int a1, void (__cdecl *a2)(int), int a3, _BYTE *a4, char *a5, int a6);
int __cdecl xmlCtxtReadDoc(int *Block, char *ArgList, _BYTE *a3, char *a4, int a5);
int __cdecl xmlCtxtReadFile(int *Block, char *Source, char *a3, int a4);
int __cdecl xmlCtxtReadMemory(int *Block, _BYTE *Src, int a3, _BYTE *a4, char *a5, int a6);
int __cdecl xmlCtxtReadFd(int *Block, int a2, _BYTE *a3, char *a4, int a5);
int __cdecl xmlCtxtReadIO(int *Block, int a2, void (__cdecl *a3)(int), int a4, _BYTE *a5, char *a6, int a7);
_BYTE *__cdecl xmlStrndup(void *Src, int Size);
_BYTE *__cdecl xmlStrdup(_BYTE *Src);
int __cdecl xmlCharStrndup(int a1, int a2);
_BYTE *__cdecl xmlCharStrdup(_BYTE *a1);
int __cdecl xmlStrcmp(unsigned __int8 *a1, char *a2);
int __cdecl xmlStrEqual(char *a1, char *a2);
int __cdecl xmlStrQEqual(char *a1, char *a2, char *a3);
int __cdecl xmlStrncmp(unsigned __int8 *a1, char *a2, int a3);
int __cdecl xmlStrcasecmp(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl xmlStrncasecmp(unsigned __int8 *a1, char *a2, int a3);
_BYTE *__cdecl xmlStrchr(_BYTE *a1, char a2);
unsigned __int8 *__cdecl xmlStrstr(unsigned __int8 *a1, char *a2);
unsigned __int8 *__cdecl xmlStrcasestr(unsigned __int8 *a1, char *a2);
_BYTE *__cdecl xmlStrsub(_BYTE *Src, int a2, int Size);
int __cdecl xmlStrlen(_BYTE *a1);
_BYTE *__cdecl xmlStrncat(_BYTE *Block, void *Src, int Size);
char *__cdecl xmlStrncatNew(_BYTE *Src, _BYTE *a2, signed int Size);
_BYTE *__cdecl xmlStrcat(_BYTE *Block, _BYTE *Src);
int xmlStrPrintf(char *Buffer, size_t BufferCount, char *Format, ...);
int __cdecl xmlStrVPrintf(char *Buffer, size_t BufferCount, char *Format, va_list ArgList); // idb
int __cdecl xmlUTF8Size(unsigned __int8 *a1);
int __cdecl xmlUTF8Charcmp(unsigned __int8 *a1, char *a2);
int __cdecl xmlUTF8Strlen(char *a1);
int __cdecl xmlGetUTF8Char(unsigned __int8 *a1, int *a2);
int __cdecl xmlCheckUTF8(char *a1);
_BYTE *__cdecl xmlUTF8Strsize(char *a1, int a2);
void *__cdecl xmlUTF8Strndup(char *Src, int a2);
char *__cdecl xmlUTF8Strpos(char *a1, int a2);
int __cdecl xmlUTF8Strloc(unsigned __int8 *a1, char *a2);
void *__cdecl xmlUTF8Strsub(char *Src, int a2, int a3);
int (__cdecl *__cdecl sub_42F97B(_BYTE *Src))(int, char *Format, char ArgList);
// int (__cdecl *__usercall sub_42FA00@<eax>(int a1@<eax>, const char *ArgList))(int, char *Format, char ArgList);
int *__cdecl xmlNewDocElementContent(int a1, char *Src, int Size);
int *__cdecl xmlNewElementContent(char *Src, int Size);
_DWORD *__cdecl xmlCopyDocElementContent(int a1, _DWORD *a2);
_DWORD *__cdecl xmlCopyElementContent(_DWORD *a1);
int (__cdecl *__cdecl xmlFreeDocElementContent(int a1, void *Block))(int, char *Format, char ArgList);
int (__cdecl *__cdecl xmlFreeElementContent(void *Block))(int, char *Format, char ArgList);
void __cdecl sub_42FDEB(int *a1, int a2, int a3);
void __cdecl xmlSnprintfElementContent(char *a1, int a2, _DWORD *a3, int a4);
int __cdecl sub_43020C(void *Block); // idb
_DWORD *__cdecl xmlAddElementDecl(int a1, _DWORD *a2, char *Src, int a4, _DWORD *a5);
void __cdecl xmlFreeElementTable(_DWORD *Block);
_DWORD *__cdecl sub_430500(int a1);
void ***__cdecl xmlCopyElementTable(_DWORD *a1);
void __cdecl xmlDumpElementDecl(int *a1, int a2);
void __cdecl sub_4306A7(int a1, int *a2);
void __cdecl xmlDumpElementTable(int a1, _DWORD *a2);
_DWORD *__cdecl xmlCreateEnumeration(_BYTE *Src);
int __cdecl xmlFreeEnumeration(void **Block);
_DWORD *__cdecl xmlCopyEnumeration(int a1);
// int __usercall sub_43077D@<eax>(int result@<eax>, int *a2@<edi>);
void __cdecl sub_4307B8(void *Block);
void *__cdecl xmlAddAttributeDecl(int a1, _DWORD *a2, char *a3, char *Src, char *a5, int a6, int a7, char *a8, void **Block);
void __cdecl xmlFreeAttributeTable(_DWORD *Block);
_DWORD *__cdecl sub_430B1A(int a1);
void ***__cdecl xmlCopyAttributeTable(_DWORD *a1);
void __cdecl xmlDumpAttributeDecl(int *a1, int a2);
int sub_430D31(); // weak
void __cdecl xmlDumpAttributeTable(int a1, _DWORD *a2);
int __cdecl sub_430D65(_DWORD *Block);
_DWORD *__cdecl xmlAddNotationDecl(int a1, int a2, unsigned __int8 *Src, _BYTE *a4, _BYTE *a5);
void __cdecl xmlFreeNotationTable(_DWORD *Block);
_DWORD *__cdecl sub_430E7D(int a1);
void ***__cdecl xmlCopyNotationTable(_DWORD *a1);
int __cdecl xmlDumpNotationDecl(int *a1, _BYTE **a2);
int __cdecl sub_430F7D(_BYTE **a1, int *a2);
void __cdecl xmlDumpNotationTable(int a1, _DWORD *a2);
void __cdecl sub_430FB1(_DWORD *Block);
_DWORD *__cdecl xmlAddID(int a1, int a2, unsigned __int8 *Src, int a4);
void __cdecl xmlFreeIDTable(_DWORD *Block);
int __cdecl xmlIsID(_DWORD *a1, int a2, int a3);
int __cdecl xmlRemoveID(_DWORD *a1, int a2);
int __cdecl xmlGetID(int a1, char *a2);
int __cdecl sub_431398(int a1);
int __cdecl sub_4313D3(_DWORD **Block);
int __cdecl sub_4313E0(int a1, int *a2);
_DWORD *__cdecl xmlAddRef(int a1, int a2, char *Src, int a4);
void __cdecl xmlFreeRefTable(_DWORD *Block);
int __cdecl xmlIsRef(_DWORD *a1, int a2, int a3);
int __cdecl xmlRemoveRef(_DWORD *Block, int a2);
int __cdecl xmlGetRefs(int a1, char *a2);
int __cdecl xmlGetDtdElementDesc(int a1, char *a2);
// _DWORD *__usercall sub_431712@<eax>(int a1@<eax>, char *Src);
int __cdecl xmlGetDtdQElementDesc(int a1, char *a2, char *a3);
int __cdecl xmlGetDtdAttrDesc(int a1, char *a2, char *a3);
int __cdecl xmlGetDtdQAttrDesc(int a1, char *a2, char *a3, char *a4);
int __cdecl xmlGetDtdNotationDesc(int a1, char *a2);
int __cdecl xmlIsMixedElement(int a1, char *a2);
int sub_431949(int a1, char *Format, ...);
int (*__cdecl initGenericErrorDefaultFunc(_DWORD *a1))(_DWORD, const char *, ...);
int (*__cdecl xmlSetGenericErrorFunc(FILE *a1, int (*a2)(_DWORD, const char *, ...)))(_DWORD, const char *, ...);
int __cdecl xmlSetStructuredErrorFunc(int a1, int a2);
int __cdecl xmlParserPrintFileInfo(int a1);
// int __usercall sub_4319FE@<eax>(int a1@<edx>, void (*a2)(int, const char *, ...), int a3);
int __cdecl xmlParserPrintFileContext(int a1);
// int __usercall sub_431AFF@<eax>(_DWORD *a1@<edx>, _BYTE *a2@<ecx>, int *a3, int (__cdecl *a4)(int, char *Format, char ArgList), FILE *a5);
int (__cdecl *_xmlRaiseError(int (__cdecl *a1)(FILE *, int *), int (__cdecl *a2)(int, char *Format, char ArgList), FILE *a3, int *a4, int (__cdecl *a5)(int, char *Format, char ArgList), int a6, int a7, int a8, _BYTE *a9, int a10, _BYTE *Src, _BYTE *a12, _BYTE *a13, int a14, int a15, char *Format, ...))(int, char *Format, char ArgList);
int (__cdecl *__cdecl _xmlSimpleError(int a1, int a2, int (__cdecl *a3)(int, char *Format, char ArgList), char *Format, _BYTE *Src))(int, char *Format, char ArgList);
int xmlParserError(_DWORD *a1, char *Format, ...);
int xmlParserWarning(_DWORD *a1, char *Format, ...);
int xmlParserValidityError(_DWORD *a1, char *Format, ...);
int xmlParserValidityWarning(_DWORD *a1, char *Format, ...);
void *xmlGetLastError();
void *__cdecl xmlResetError(_DWORD *a1);
void *xmlResetLastError();
int __cdecl xmlCtxtGetLastError(int a1);
void *__cdecl xmlCtxtResetLastError(_DWORD *a1);
int __cdecl xmlCopyError(int a1, _DWORD *a2);
int (__cdecl *__cdecl sub_43279D(_BYTE *a1))(int, char *Format, char ArgList);
int (__cdecl *__cdecl sub_4327B2(int a1, char *a2))(int, char *Format, char ArgList);
// void __usercall sub_4327C9(int a1@<esi>);
// _DWORD *__usercall sub_432908@<eax>(char *a1@<ebx>, _DWORD *a2@<edi>, char *Src, int a4, char *a5, _BYTE *a6);
// _DWORD *__usercall sub_432A02@<eax>(_DWORD *a1@<eax>, char *a2, int a3, char *a4, char *a5, _BYTE *a6);
void *__cdecl xmlGetPredefinedEntity(char *a1);
_DWORD *__cdecl xmlAddDtdEntity(int a1, char *a2, int a3, char *a4, char *a5, _BYTE *a6);
_DWORD *__cdecl xmlAddDocEntity(int a1, char *a2, int a3, char *a4, char *a5, _BYTE *a6);
_DWORD *__cdecl xmlNewEntity(int a1, char *a2, int a3, char *a4, char *a5, _BYTE *a6);
int __cdecl xmlGetParameterEntity(int a1, char *a2);
int __cdecl xmlGetDtdEntity(int a1, char *a2);
void *__cdecl xmlGetDocEntity(_DWORD *a1, char *a2);
char *__cdecl xmlEncodeEntitiesReentrant(int a1, unsigned __int8 *a2);
_BYTE *__cdecl xmlEncodeSpecialChars(int a1, char *a2);
_DWORD *xmlCreateEntitiesTable();
void __cdecl sub_433171(int a1);
void __cdecl xmlFreeEntitiesTable(_DWORD *Block);
_DWORD *__cdecl sub_433192(int a1);
void ***__cdecl xmlCopyEntitiesTable(_DWORD *a1);
// void __usercall sub_43324C(_BYTE *a1@<eax>, int *a2@<edi>);
void __cdecl xmlDumpEntityDecl(int *a1, int a2);
void __cdecl sub_43349E(int a1, int *a2);
void __cdecl xmlDumpEntitiesTable(int a1, _DWORD *a2);
int __cdecl xmlCheckVersion(int a1);
int __cdecl xmlErrMemory(int, void *Src); // idb
int (__cdecl *__cdecl _xmlErrEncoding(int *a1, int (__cdecl *a2)(int, char *Format, char ArgList), char *Format, _BYTE *Src, _BYTE *a5))(int, char *Format, char ArgList);
// int (__cdecl *__usercall sub_43361B@<eax>(int *a1@<edi>, char *Format, _BYTE *Src))(int, char *Format, char ArgList);
// int __usercall sub_433675@<eax>(int *a1@<edi>, char *Format, int ArgList);
BOOL __cdecl xmlIsLetter(signed int a1);
int __cdecl xmlParserInputRead(_DWORD *a1, int a2);
int __cdecl xmlParserInputGrow(int *a1, int a2);
void __cdecl xmlParserInputShrink(_DWORD *a1);
void __cdecl xmlNextChar(int *a1);
int __cdecl xmlCurrentChar(int *a1, _DWORD *a2);
unsigned int __cdecl xmlStringCurrentChar(int *a1, unsigned __int8 *a2, _DWORD *a3);
int __cdecl xmlCopyCharMultiByte(_BYTE *a1, int a2);
int __cdecl xmlCopyChar(int a1, _BYTE *a2, int a3);
int __cdecl xmlSwitchEncoding(int *a1, int a2);
// int __usercall sub_434321@<eax>(const char **a1@<edx>, _DWORD *a2@<ebx>, int *a3, int a4);
int __cdecl xmlSwitchInputEncoding(int *a1, _DWORD *a2, const char **a3);
// int __usercall sub_4344CF@<eax>(int *a1@<eax>, const char **a2@<edx>, int a3);
int __cdecl xmlSwitchToEncoding(int *a1, const char **a2);
int __cdecl xmlFreeInputStream(int ***Block);
_DWORD *__cdecl xmlNewInputStream(int a1);
_DWORD *__cdecl xmlNewIOInputStream(int *a1, int a2, int a3);
int __cdecl xmlNewEntityInputStream(int *a1, int a2);
int __cdecl xmlNewStringInputStream(int *a1, char *ArgList);
int *__cdecl xmlNewInputFromFile(int *a1, char *ArgList);
int __cdecl xmlInitParserCtxt(int *a1);
void __cdecl xmlFreeParserCtxt(_DWORD *Block);
int *xmlNewParserCtxt();
void __cdecl xmlClearParserCtxt(_DWORD *a1);
_DWORD *__cdecl xmlParserFindNodeInfo(int a1, unsigned int a2);
_DWORD *__cdecl xmlInitNodeInfoSeq(_DWORD *a1);
_DWORD *__cdecl xmlClearNodeInfoSeq(_DWORD *a1);
int __cdecl xmlParserFindNodeInfoIndex(int a1, unsigned int a2);
void __cdecl xmlParserAddNodeInfo(int a1, unsigned int *a2);
int __cdecl xmlPedanticParserDefault(int a1);
int __cdecl xmlLineNumbersDefault(int a1);
int __cdecl xmlSubstituteEntitiesDefault(int a1);
int __cdecl xmlKeepBlanksDefault(int a1);
// int __usercall sub_435057@<eax>(_BYTE *a1@<eax>, char *a2@<ecx>, int a3, _BYTE *a4);
// int __usercall sub_4350DF@<eax>(unsigned __int8 *a1@<eax>, char *a2@<ecx>, int a3, _BYTE *a4, _BYTE *a5, _BYTE *a6, _BYTE *a7);
_DWORD *__cdecl xmlHashCreate(int a1);
_DWORD *__cdecl xmlHashCreateDict(int a1, _DWORD *a2);
// int __usercall sub_435280@<eax>(int a1@<eax>, void ***a2@<ebx>);
void __cdecl xmlHashFree(_DWORD *Block, void (__cdecl *a2)(int, _DWORD));
int __cdecl xmlHashAddEntry(void ***a1, unsigned __int8 *Src, void *a3);
int __cdecl xmlHashAddEntry2(void ***a1, unsigned __int8 *Src, unsigned __int8 *a3, void *a4);
int __cdecl xmlHashUpdateEntry(_DWORD *a1, unsigned __int8 *Src, int a3, void (__cdecl *a4)(_DWORD, char *));
int __cdecl xmlHashUpdateEntry2(_DWORD *a1, unsigned __int8 *Src, unsigned __int8 *a3, int a4, void (__cdecl *a5)(_DWORD, char *));
int __cdecl xmlHashLookup(_DWORD *a1, char *a2);
int __cdecl xmlHashLookup2(_DWORD *a1, char *a2, char *a3);
int __cdecl xmlHashQLookup(_DWORD *a1, char *a2, unsigned __int8 *a3);
int __cdecl xmlHashQLookup2(_DWORD *a1, char *a2, unsigned __int8 *a3, char *a4, char *a5);
int __cdecl xmlHashAddEntry3(void ***a1, unsigned __int8 *Src, unsigned __int8 *a3, char *a4, void *a5);
int __cdecl xmlHashUpdateEntry3(_DWORD *a1, unsigned __int8 *Src, unsigned __int8 *a3, unsigned __int8 *a4, int a5, void (__cdecl *a6)(_DWORD, char *));
int __cdecl xmlHashLookup3(_DWORD *a1, char *a2, char *a3, char *a4);
int __cdecl xmlHashQLookup3(_DWORD *a1, char *a2, unsigned __int8 *a3, char *a4, char *a5, char *a6, char *a7);
int __cdecl sub_435AFF(int a1, int a2, int a3);
void __cdecl xmlHashScan(_DWORD *a1, int a2, int a3);
void __cdecl xmlHashScanFull(_DWORD *a1, void (__cdecl *a2)(int, int, _DWORD, _DWORD, _DWORD), int a3);
int __cdecl xmlHashScan3(_DWORD *a1, char *a2, char *a3, char *a4, void (__cdecl *a5)(int, int, int, int, int), int a6);
int __cdecl xmlHashScanFull3(_DWORD *a1, char *a2, char *a3, char *a4, void (__cdecl *a5)(int, int, int, int, int), int a6);
void ***__cdecl xmlHashCopy(_DWORD *a1, int (__cdecl *a2)(int, int));
int __cdecl xmlHashSize(int a1);
int __cdecl xmlHashRemoveEntry(_DWORD *a1, char *a2, void (__cdecl *a3)(int, _DWORD));
int __cdecl xmlHashRemoveEntry2(_DWORD *a1, char *a2, char *a3, void (__cdecl *a4)(int, _DWORD));
int __cdecl xmlHashRemoveEntry3(_DWORD *a1, char *a2, char *a3, char *a4, void (__cdecl *a5)(int, _DWORD));
// int __usercall sub_435E79@<eax>(_DWORD *a1@<ebx>, void **a2@<edi>);
// int __usercall sub_435EEB@<eax>(char **a1@<ebx>, int a2@<edi>);
// int __usercall sub_436054@<eax>(void **a1@<ebx>, int a2@<esi>);
// int __usercall sub_4361E6@<eax>(int a1@<edx>, char **a2@<esi>);
// int __usercall sub_43622F@<eax>(char **a1@<ebx>, int a2@<edi>);
// int __usercall sub_43634D@<eax>(char **a1@<esi>);
// int __usercall sub_4363D0@<eax>(int a1@<ebx>, char **a2);
// int __usercall sub_43658C@<eax>(int a1@<eax>, char **a2);
// BOOL __usercall sub_4365F3@<eax>(char **a1@<esi>, char a2, int a3);
// BOOL __usercall sub_436795@<eax>(char **a1@<ebx>, int a2@<edi>);
// BOOL __usercall sub_436806@<eax>(char *a1@<ecx>, int a2@<edi>, int a3);
// BOOL __usercall sub_4368A2@<eax>(int a1@<edi>, char **a2);
// BOOL __usercall sub_436921@<eax>(char **a1@<ebx>, int a2@<edi>);
// int __usercall sub_436999@<eax>(int a1@<eax>, char *a2@<ecx>, char **a3@<esi>);
// int __usercall sub_436AE7@<eax>(_DWORD *a1@<eax>, char *a2@<ecx>, _BYTE *a3);
int __cdecl sub_436C86(_DWORD *a1, _BYTE *a2);
// int __usercall sub_436D05@<eax>(_DWORD *a1@<eax>, _BYTE *a2);
_DWORD *__cdecl xmlParseURI(_BYTE *a1);
int __cdecl xmlParseURIReference(_DWORD *a1, _BYTE *a2);
_DWORD *__cdecl xmlParseURIRaw(_BYTE *a1, int a2);
void *xmlCreateURI();
void *__cdecl xmlSaveUri(_DWORD *a1);
const char *__cdecl xmlPrintURI(FILE *Stream, _DWORD *a2);
// void __usercall sub_4378D5(_DWORD *a1@<esi>);
int __cdecl xmlFreeURI(_DWORD *Block);
int __cdecl xmlNormalizeURIPath(_BYTE *a1);
// BOOL __usercall sub_437B7E@<eax>(char a1@<al>);
int __cdecl xmlURIUnescapeString(const char *a1, int a2, int a3);
_BYTE *__cdecl xmlURIEscapeStr(char *Src, _BYTE *a2);
_BYTE *__cdecl xmlURIEscape(_BYTE *a1);
void *__cdecl xmlBuildURI(_BYTE *Src, _BYTE *a2);
char *__cdecl xmlBuildRelativeURI(_BYTE *Src, _BYTE *a2);
_BYTE *__cdecl xmlCanonicPath(char *Source);
_BYTE *__cdecl xmlPathToURI(char *Src);
int xmlInitializeDict();
void xmlDictCleanup();
// _DWORD *__usercall sub_438A08@<eax>(int a1@<eax>, void *Src, int Size);
// _DWORD *__usercall sub_438AA6@<eax>(size_t a1@<ebx>, int a2, void *Src, size_t Size, void *a5);
// unsigned int __usercall sub_438B7E@<eax>(int a1@<edx>, int a2@<ecx>, int a3);
// unsigned int __usercall sub_438BC0@<eax>(int a1@<eax>, int a2, int a3, int a4, int a5);
int __fastcall sub_438C2B(unsigned __int8 *a1, int a2);
// int __usercall sub_438CB3@<eax>(int a1@<eax>, unsigned __int8 *a2@<edx>, unsigned __int8 *a3@<ecx>, int a4, int a5);
int xmlDictCreate();
int __cdecl xmlDictCreateSub(_DWORD *a1);
int __cdecl xmlDictReference(_DWORD *a1);
// int __usercall sub_438EA7@<eax>(int a1@<eax>, _DWORD *a2@<ebx>);
void __cdecl xmlDictFree(void **Block);
unsigned __int8 *__cdecl xmlDictLookup(_DWORD *a1, char *Src, int Size);
unsigned __int8 *__cdecl xmlDictExists(_DWORD *a1, char *a2, int a3);
unsigned __int8 *__cdecl xmlDictQLookup(_DWORD *a1, char *a2, char *Src);
int __cdecl xmlDictOwns(int a1, unsigned int a2);
int __cdecl xmlDictSize(int a1);
int __cdecl xmlCharInRange(unsigned int a1, _DWORD *a2);
int __cdecl xmlIsBaseChar(unsigned int a1);
BOOL __cdecl xmlIsBlank(unsigned int a1);
int __cdecl xmlIsChar(unsigned int a1);
int __cdecl xmlIsCombining(unsigned int a1);
int __cdecl xmlIsDigit(unsigned int a1);
int __cdecl xmlIsExtender(unsigned int a1);
BOOL __cdecl xmlIsIdeographic(unsigned int a1);
int __cdecl xmlIsPubidChar(unsigned int a1);
int (__cdecl *__cdecl sub_439A1A(_BYTE *a1))(int, char *Format, char ArgList);
int (__cdecl *__cdecl sub_439A2F(int a1, char *Format, _BYTE *Src))(int, char *Format, char ArgList);
int __cdecl sub_439A59(_BYTE *a1, int a2, unsigned __int8 *a3, _DWORD *a4);
int __cdecl sub_439ADA(_BYTE *a1, int a2, char *a3, _DWORD *a4);
int __cdecl isolat1ToUTF8(_BYTE *a1, _DWORD *a2, _BYTE *a3, _DWORD *a4);
int __cdecl sub_439CD8(void *a1, signed int *a2, void *Src, signed int *a4);
int __cdecl UTF8Toisolat1(_BYTE *a1, int a2, char *a3, _DWORD *a4);
int __cdecl sub_439E61(_BYTE *a1, int a2, char *a3, _DWORD *a4);
int __cdecl sub_439FEC(unsigned int a1, _DWORD *a2, unsigned __int8 *a3, _DWORD *a4);
int __cdecl sub_43A1B0(unsigned int a1, _DWORD *a2, unsigned __int8 *a3, _DWORD *a4);
int __cdecl sub_43A1E6(_BYTE *a1, int a2, unsigned __int8 *a3, _DWORD *a4);
int __cdecl sub_43A363(_BYTE *a1, int *a2, _BYTE *a3, _DWORD *a4);
int __cdecl xmlDetectCharEncoding(char *a1, int a2);
_DWORD *xmlCleanupEncodingAliases();
int __cdecl xmlGetEncodingAlias(int a1);
int __cdecl xmlAddEncodingAlias(void *a1, int a2);
int __cdecl xmlDelEncodingAlias(_BYTE *a1);
int __cdecl xmlParseCharEncoding(int a1);
const char *__cdecl xmlGetCharEncodingName(int a1);
int *__cdecl xmlNewCharEncodingHandler(int a1, int a2, int a3);
void xmlInitCharEncodingHandlers();
_DWORD *xmlCleanupCharEncodingHandlers();
int (__cdecl *__cdecl xmlRegisterCharEncodingHandler(int a1))(int, char *Format, char ArgList);
int __cdecl xmlGetCharEncodingHandler(int a1);
int __cdecl xmlFindCharEncodingHandler(const char *a1);
// int __usercall sub_43B279@<eax>(_DWORD *a1@<edi>, _DWORD *a2@<esi>, int a3, int a4);
int __cdecl xmlCharEncFirstLine(int a1, _DWORD *a2, _DWORD *a3);
int __cdecl xmlCharEncInFunc(int a1, _DWORD *a2, unsigned __int8 **a3);
int __cdecl xmlCharEncOutFunc(int a1, _DWORD *a2, unsigned __int8 **a3);
int __cdecl xmlCharEncCloseFunc(_DWORD *a1);
int __cdecl xmlByteConsumed(int a1);
WCHAR *__cdecl sub_43B710(LPCCH lpMultiByteStr);
int (__cdecl *__cdecl sub_43B76D(_BYTE *a1))(int, char *Format, char ArgList);
// int (__cdecl *__usercall sub_43B782@<eax>(int a1@<eax>, _BYTE *a2))(int, char *Format, char ArgList);
// int (__cdecl *__usercall sub_43BAB2@<eax>(int *a1@<edx>, char *Format, _BYTE *Src))(int, char *Format, char ArgList);
void xmlCleanupInputCallbacks();
int xmlPopInputCallbacks();
void xmlCleanupOutputCallbacks();
FILE *__cdecl sub_43BBEE(char *FileName, int a2);
int __cdecl sub_43BC4C(char *FileName, struct _stat32 *Stat); // idb
FILE *__cdecl sub_43BC8E(char *FileName, int a2);
int __cdecl j___stat32(const char *FileName, struct _stat32 *Stat);
void sub_43BCB1();
int __cdecl xmlCheckFilename(char *FileName); // idb
int __cdecl sub_43BD70(int FileHandle, void *DstBuf, unsigned int MaxCharCount); // idb
int __cdecl sub_43BD9C(int FileHandle, void *Buf, int MaxCharCount);
int sub_43BDD0(); // weak
int xmlIsMainThread();
// void **__usercall sub_43BDF6@<eax>(char *a1@<ebx>);
void **__cdecl xmlFileOpen(char *a1);
void **__cdecl sub_43BEC7(char *a1);
int __cdecl xmlFileRead(FILE *Stream, void *Buffer, size_t ElementCount); // idb
size_t __cdecl sub_43BF80(FILE *Stream, void *Buffer, size_t ElementSize);
int __cdecl xmlFileClose(FILE *Stream); // idb
int __cdecl sub_43C041(FILE *Stream); // idb
int __cdecl sub_43C075(int *a1, _BYTE *Src, int a3);
int __cdecl xmlRegisterInputCallbacks(int a1, int a2, int a3, int a4);
int __cdecl xmlRegisterOutputCallbacks(int a1, int a2, int a3, int a4);
int xmlRegisterDefaultInputCallbacks();
int xmlRegisterDefaultOutputCallbacks();
_DWORD *__cdecl xmlAllocParserInputBuffer(int a1);
_DWORD *__cdecl xmlAllocOutputBuffer(int a1);
// _DWORD *__usercall sub_43C2B4@<eax>(int a1@<ebx>);
void __cdecl xmlFreeParserInputBuffer(int **Block);
int __cdecl xmlOutputBufferClose(_DWORD *Block);
_DWORD *__cdecl sub_43C40D(int a1, int a2);
_DWORD *__cdecl xmlParserInputBufferCreateFilename(int a1, int a2);
_DWORD *__cdecl sub_43C4BA(char *a1, int a2);
_DWORD *__cdecl xmlOutputBufferCreateFilename(char *a1, int a2);
_DWORD *__cdecl xmlParserInputBufferCreateFile(int a1, int a2);
_DWORD *__cdecl xmlOutputBufferCreateFile(int a1, int a2);
_DWORD *__cdecl xmlOutputBufferCreateBuffer(int a1, int a2);
_DWORD *__cdecl xmlParserInputBufferCreateFd(int a1, int a2);
_DWORD *__cdecl xmlParserInputBufferCreateMem(_BYTE *Src, int a2, int a3);
int *__cdecl xmlParserInputBufferCreateStatic(int a1, int a2, int a3);
_DWORD *__cdecl xmlOutputBufferCreateFd(int a1, int a2);
_DWORD *__cdecl xmlParserInputBufferCreateIO(int a1, int a2, int a3, int a4);
_DWORD *__cdecl xmlOutputBufferCreateIO(int a1, int a2, int a3, int a4);
_DWORD *(__cdecl *__cdecl xmlParserInputBufferCreateFilenameDefault(int (__cdecl *a1)(_DWORD, _DWORD)))(int a1, int a2);
int (*__cdecl xmlOutputBufferCreateFilenameDefault(int (*a1)(void)))(void);
int __cdecl xmlParserInputBufferPush(int a1, int a2, _BYTE *Src);
int __cdecl xmlParserInputBufferGrow(int a1, int a2);
int __cdecl xmlParserInputBufferRead(_DWORD *a1, int a2);
int __cdecl xmlOutputBufferWrite(_DWORD *a1, int a2, char *Src);
int __cdecl sub_43CBE2(_BYTE *a1, int *a2, char *a3, _DWORD *a4);
int __cdecl xmlOutputBufferWriteEscape(int a1, const char *a2, int (__cdecl *a3)(_BYTE *a1, int *a2, char *a3, int *a4));
int __cdecl xmlOutputBufferWriteString(_DWORD *a1, char *Src);
int __cdecl xmlOutputBufferFlush(_DWORD *a1);
int __cdecl xmlParserGetDirectory(char *Source); // idb
int __cdecl xmlCheckHTTPInput(int a1, int a2);
// unsigned __int8 *__usercall sub_43D0D7@<eax>(unsigned __int8 *result@<eax>);
int *__cdecl sub_43D119(unsigned __int8 *ArgList, char *a2, int *a3);
int (__cdecl *__cdecl xmlSetExternalEntityLoader(int (__cdecl *a1)(char ArgList, int, int)))(char ArgList, int, int);
int (__cdecl *xmlGetExternalEntityLoader())(char ArgList, int, int);
int __cdecl xmlLoadExternalEntity(char *Source, int, int); // idb
int __cdecl xmlNoNetExternalEntityLoader(unsigned __int8 *ArgList, int a2, int a3);
// void __usercall sub_43D25F(_DWORD *a1@<esi>, int a2);
// void __usercall sub_43D29A(int a1@<ecx>, _BYTE *a2@<edx>, _BYTE *a3@<ebx>, int a4@<esi>, char *Format);
// int (__cdecl *__usercall sub_43D314@<eax>(int (__cdecl *result)(int, char *Format, char ArgList)@<eax>, int *a2@<edi>, char *Format, _BYTE *Src))(int, char *Format, char ArgList);
int (__cdecl *__cdecl sub_43D372(char *Src))(int, char *Format, char ArgList);
// int (__cdecl *__usercall sub_43D3B5@<eax>(int *a1@<ecx>, int a2@<edx>, char *Format, _BYTE *Src, _BYTE *a5))(int, char *Format, char ArgList);
// int (__cdecl *__usercall sub_43D3FA@<eax>(int *a1@<ecx>, int a2@<edx>, char *Format, _BYTE *Src, _BYTE *a5))(int, char *Format, char ArgList);
int xmlSAX2GetPublicId();
int __cdecl xmlSAX2GetSystemId(int a1);
int __cdecl xmlSAX2GetLineNumber(int a1);
int __cdecl xmlSAX2GetColumnNumber(int a1);
BOOL __cdecl xmlSAX2IsStandalone(int a1);
BOOL __cdecl xmlSAX2HasInternalSubset(int a1);
BOOL __cdecl xmlSAX2HasExternalSubset(int a1);
void __cdecl xmlSAX2InternalSubset(_DWORD *a1, _BYTE *a2, _BYTE *a3, _BYTE *a4);
void __cdecl xmlSAX2ExternalSubset(int *Block, _BYTE *a2, _BYTE *a3, char *Source);
int __cdecl xmlSAX2ResolveEntity(int a1, int a2, _BYTE *a3);
_DWORD *__cdecl xmlSAX2GetEntity(int *a1, char *a2);
int __cdecl xmlSAX2GetParameterEntity(int a1, char *a2);
void __cdecl xmlSAX2EntityDecl(int *a1, char *Src, int a3, char *a4, char *a5, _BYTE *a6);
void __cdecl xmlSAX2AttributeDecl(int *a1, char *a2, char *a3, int a4, int a5, char *a6, void **a7);
void __cdecl xmlSAX2ElementDecl(int *a1, char *Src, int a3, _DWORD *a4);
void __cdecl xmlSAX2NotationDecl(int *a1, unsigned __int8 *Src, _BYTE *a3, _BYTE *a4);
void __cdecl xmlSAX2UnparsedEntityDecl(int *a1, char *a2, char *a3, char *a4, _BYTE *a5);
void __cdecl xmlSAX2StartDocument(int a1);
void __cdecl xmlSAX2EndDocument(_DWORD *a1);
// void __usercall sub_43DD53(int a1@<eax>, char *Src, unsigned __int8 *ArgList);
// void __usercall sub_43E22D(_DWORD *a1@<edx>, char **a2@<ecx>, char *a3, char *a4);
void __cdecl xmlSAX2StartElement(int *Block, char *a2, char **a3);
int __cdecl xmlSAX2EndElement(int a1);
// int __usercall sub_43E7BC@<eax>(int a1@<eax>, _BYTE *Src, int Size);
// _DWORD *__usercall sub_43E934@<eax>(int a1@<ecx>, _BYTE *a2@<eax>, char *Block, char *a4, char *Src);
void __cdecl xmlSAX2StartElementNs(int a1, char *Src, char *a3, int a4, char *a5, char **a6, int a7, int a8, int a9);
int __cdecl xmlSAX2EndElementNs(_DWORD *a1);
void __cdecl xmlSAX2Reference(int a1, char *a2);
void __cdecl xmlSAX2Characters(int a1, _BYTE *Src, size_t Size);
void __cdecl xmlSAX2ProcessingInstruction(int *a1, char *Src, _BYTE *a3);
void __cdecl xmlSAX2Comment(int *a1, _BYTE *a2);
void __cdecl xmlSAX2CDataBlock(int a1, _BYTE *a2, signed int a3);
int __cdecl xmlSAXDefaultVersion(int a1);
int __cdecl xmlSAXVersion(_DWORD *a1, int a2);
int (*__cdecl xmlSAX2InitDefaultSAXHandler(_DWORD *a1, int a2))(_DWORD *a1, char *Format, ...);
int xmlDefaultSAXHandlerInit();
int sub_43F3DF();
_DWORD *__cdecl xmlMallocLoc(int a1, int a2, int a3);
_DWORD *__cdecl xmlMallocAtomicLoc(int a1, int a2, int a3);
_DWORD *__cdecl xmlMemMalloc(int a1);
_DWORD *__cdecl xmlReallocLoc(int a1, int a2, int a3, int a4);
_DWORD *__cdecl xmlMemRealloc(int a1, int a2);
void __cdecl xmlMemFree(_DWORD *a1);
char *__cdecl xmlMemStrdupLoc(const char *a1, int a2, int a3);
char *__cdecl xmlMemoryStrdup(const char *a1);
int xmlMemUsed();
int xmlMemBlocks();
void __cdecl xmlMemDisplayLast(FILE *Stream, int a2);
FILE *__cdecl xmlMemDisplay(FILE *Stream);
int __cdecl sub_43F8DA(const void *ArgList);
int __cdecl xmlMemShow(FILE *Stream); // idb
int xmlInitMemory();
void xmlCleanupMemory();
int __cdecl xmlMemSetup(int a1, int (__cdecl *a2)(_DWORD), int (__cdecl *a3)(LPVOID lpMem, SIZE_T dwBytes), int (__cdecl *a4)(void *Src));
int __cdecl xmlMemGet(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
int __cdecl xmlGcMemSetup(int a1, int (__cdecl *a2)(_DWORD), int (__cdecl *a3)(size_t Size), int (__cdecl *a4)(LPVOID lpMem, SIZE_T dwBytes), int (__cdecl *a5)(void *Src));
int __cdecl xmlGcMemGet(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5);
void xmlInitGlobals();
void xmlCleanupGlobals();
void *__cdecl xmlInitializeGlobalState(_DWORD *a1);
int (__cdecl *__cdecl xmlThrDefSetGenericErrorFunc(int a1, int (__cdecl *a2)(int, char *Format, char ArgList)))(int, char *Format, char ArgList);
int __cdecl xmlThrDefSetStructuredErrorFunc(int a1, int a2);
int __cdecl xmlRegisterNodeDefault(int a1);
int __cdecl xmlThrDefRegisterNodeDefault(int a1);
int __cdecl xmlDeregisterNodeDefault(int a1);
int __cdecl xmlThrDefDeregisterNodeDefault(int a1);
_DWORD *(__cdecl *__cdecl xmlThrDefParserInputBufferCreateFilenameDefault(int a1))(int a1, int a2);
_DWORD *(__cdecl *__cdecl xmlThrDefOutputBufferCreateFilenameDefault(int a1))(char *a1, int a2);
void *_xmlLastError();
void *_oldXMLWDcompatibility();
int *_xmlBufferAllocScheme();
int __cdecl xmlThrDefBufferAllocScheme(int a1);
int *_xmlDefaultBufferSize();
int __cdecl xmlThrDefDefaultBufferSize(int a1);
int (__cdecl **_xmlDefaultSAXHandler())(int, int, int, int);
int (**_xmlDefaultSAXLocator())();
int *_xmlDoValidityCheckingDefaultValue();
int __cdecl xmlThrDefDoValidityCheckingDefaultValue(int a1);
int (__cdecl **_xmlGenericError())(int, char *Format, char ArgList);
int *_xmlStructuredError();
FILE **_xmlGenericErrorContext();
int *_xmlStructuredErrorContext();
int *_xmlGetWarningsDefaultValue();
int __cdecl xmlThrDefGetWarningsDefaultValue(int a1);
int *_xmlIndentTreeOutput();
int __cdecl xmlThrDefIndentTreeOutput(int a1);
void **_xmlTreeIndentString();
char *__cdecl xmlThrDefTreeIndentString(char *a1);
int *_xmlKeepBlanksDefaultValue();
int __cdecl xmlThrDefKeepBlanksDefaultValue(int a1);
int *_xmlLineNumbersDefaultValue();
int __cdecl xmlThrDefLineNumbersDefaultValue(int a1);
int *_xmlLoadExtDtdDefaultValue();
int __cdecl xmlThrDefLoadExtDtdDefaultValue(int a1);
int *_xmlParserDebugEntities();
int __cdecl xmlThrDefParserDebugEntities(int a1);
char **_xmlParserVersion();
int *_xmlPedanticParserDefaultValue();
int __cdecl xmlThrDefPedanticParserDefaultValue(int a1);
int *_xmlSaveNoEmptyTags();
int __cdecl xmlThrDefSaveNoEmptyTags(int a1);
int *_xmlSubstituteEntitiesDefaultValue();
int __cdecl xmlThrDefSubstituteEntitiesDefaultValue(int a1);
int *_xmlRegisterNodeDefaultValue();
int *_xmlDeregisterNodeDefaultValue();
int *_xmlParserInputBufferCreateFilenameValue();
int *_xmlOutputBufferCreateFilenameValue();
void __cdecl xmlFreeRMutex(void *Block);
void *xmlNewRMutex();
int xmlUnlockLibrary(); // weak
// int __usercall sub_43FED1@<eax>(_DWORD **a1@<esi>, int a2);
int __cdecl sub_43FEF8(unsigned int a1, unsigned int a2);
// _DWORD *__usercall sub_43FF12@<eax>(int a1@<edi>, int a2);
// _DWORD *__usercall sub_43FF3C@<eax>(_DWORD **a1@<edi>, int a2);
// int __usercall sub_43FF68@<eax>(int result@<eax>, int a2);
// _DWORD **__usercall sub_43FF9D@<eax>(_DWORD **result@<eax>, int a2);
_DWORD *__cdecl xmlListCreate(int a1, int a2);
int __cdecl xmlListSearch(int a1, int a2);
_DWORD *__cdecl xmlListReverseSearch(_DWORD **a1, int a2);
int __cdecl xmlListInsert(int a1, int a2);
int __cdecl xmlListAppend(_DWORD **a1, int a2);
int __cdecl xmlListDelete(_DWORD **Block);
int __cdecl xmlListRemoveFirst(int a1, int a2);
int __cdecl xmlListRemoveLast(_DWORD **a1, int a2);
int __cdecl xmlListRemoveAll(int a1, int a2);
_DWORD *__cdecl xmlListClear(_DWORD **a1);
int __cdecl xmlListEmpty(_DWORD **a1);
int __cdecl xmlListFront(int a1);
int __cdecl xmlListEnd(int a1);
int __cdecl xmlListSize(_DWORD **a1);
int __cdecl xmlListPopFront(_DWORD **a1);
int __cdecl xmlListPopBack(_DWORD **a1);
int __cdecl xmlListPushFront(int *a1, int a2);
int __cdecl xmlListPushBack(int a1, int a2);
int __cdecl xmlLinkGetData(int a1);
// _DWORD *__usercall xmlListReverse@<eax>(_DWORD *result@<eax>, _DWORD **a2);
void __cdecl xmlListSort(_DWORD **Block);
void __cdecl xmlListWalk(_DWORD **a1, int (__cdecl *a2)(_DWORD, int), int a3);
void __cdecl xmlListReverseWalk(int a1, int (__cdecl *a2)(_DWORD, int), int a3);
_DWORD *__cdecl xmlListMerge(_DWORD **Block, _DWORD **a2);
_DWORD *__cdecl xmlListDup(int a1);
int __cdecl xmlListCopy(_DWORD **Block, _DWORD **a2);
int __cdecl sub_4404B0(int a1, _DWORD *a2, int a3);
// _BYTE *__usercall sub_440950@<eax>(_DWORD *a1@<esi>, int a2, int a3);
// int __usercall sub_4409A0@<eax>(int *a1@<edi>, FILE *Stream);
// int *__usercall sub_440A50@<eax>(_DWORD *a1@<edi>, int a2);
// void __usercall sub_440B20(int a1@<eax>, int a2@<ecx>, int a3@<esi>);
// char __usercall sub_440BE0@<al>(const char *a1@<ebx>, _DWORD *a2, size_t *a3);
// bool __usercall sub_440CB0@<al>(int a1@<eax>, int a2@<edi>, int *a3, _DWORD *a4);
char __cdecl sub_440D50(const char *a1, _DWORD *a2, _DWORD *a3);
int __cdecl sub_440DD0(char *Source, int, int); // idb
// char __usercall sub_440E90@<al>(int *a1@<esi>, int a2, int *a3);
// int __usercall sub_440F20@<eax>(int *a1@<ebx>, _DWORD *a2@<edi>, int a3);
// char __usercall sub_440FB0@<al>(int *a1@<eax>, int *a2@<edx>, int a3@<ecx>);
_BYTE *sub_441010();
int sub_441080();
_DWORD *__cdecl sub_441210(char *Source);
// unsigned int __usercall sub_441290@<eax>(int *a1@<edi>);
// void __usercall sub_441340(int a1@<esi>);
void __cdecl sub_4414A0(int a1, int a2);
int __cdecl sub_4415A0(int a1, int a2, int a3);
int __cdecl sub_441690(int a1, int a2, int a3);
// int __usercall sub_441860@<eax>(int a1@<ebx>, int a2@<edi>, int a3, char a4);
// int __usercall sub_4418A0@<eax>(int a1@<esi>, int *a2);
int __cdecl sub_441990(int a1);
// FILE *__usercall sub_442DF0@<eax>(const char *a1@<eax>, int a2, int a3, int a4);
int __cdecl sub_442F90(int a1, int a2);
void sub_443190();
int (__cdecl *sub_443270())(_DWORD, _DWORD);
void *sub_4432B0();
void sub_443320();
void __cdecl sub_4433B0(_DWORD *a1);
// int __usercall sub_443D20@<eax>(_DWORD *a1@<edx>, int a2@<ecx>, _BYTE *a3, size_t Size, int a5);
_WORD *__cdecl sub_443F30(int a1, size_t Size);
// int __usercall sub_4441E0@<eax>(size_t a1@<edx>, void *Src, FILE *a3);
int __cdecl sub_444310(char *FileName, char *a2);
// int __usercall sub_444480@<eax>(DWORD a1@<ebx>, int a2@<edi>, char *Format, va_list ArgList, HLOCAL Buffer);
int sub_444570(char *a1, ...);
int sub_4445A0(char *Format, ...);
int sub_444630(char *a1, ...);
int sub_444660();
// int *__usercall sub_4446D0@<eax>(unsigned int a1@<edx>, _DWORD *a2@<ecx>, int *Src);
// int __usercall sub_444810@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>, char a3);
// _BYTE *__usercall sub_4448D0@<eax>(size_t Size@<ecx>, int a2@<edi>, _BYTE *Src);
// _BYTE *__usercall sub_444A00@<eax>(const char *a1@<eax>, int a2);
// char *__usercall sub_444A70@<eax>(int a1@<eax>, void *Src);
// char __usercall sub_444AB0@<al>(int a1@<eax>, int a2, int a3);
_BYTE *__cdecl sub_444B50(int a1, int a2, int a3);
void __cdecl sub_444C80(int a1, const char **a2, _DWORD *a3);
void *__cdecl sub_444DE0(int a1, int a2);
// const char **__usercall sub_445360@<eax>(int *a1@<edi>, char *String2);
// BOOL __usercall sub_4453A0@<eax>(int *a1@<edi>, char *a2@<esi>);
// int __usercall sub_4453E0@<eax>(const char *a1@<ebx>, int *a2@<edi>);
// int __usercall sub_445500@<eax>(int a1@<edi>, int *a2@<esi>, int a3);
// int __usercall sub_4455A0@<eax>(const char *a1@<ebx>, int a2@<edi>);
// void *__usercall sub_4455F0@<eax>(int *a1@<esi>, int a2);
// unsigned int __usercall sub_445670@<eax>(unsigned int result@<eax>, int a2@<ecx>, int a3, int a4);
int *__cdecl sub_445700(int a1, const char *Src, int a3);
BOOL __cdecl sub_4459D0(int a1, char *FileName, int a3);
size_t __cdecl sub_445B10(int a1, void *Buffer, size_t ElementCount);
int sub_445B30(); // weak
int sub_445B60(); // weak
int __cdecl sub_445BA0(int a1);
int sub_445C10(); // weak
int sub_445CB0(); // weak
_DWORD *sub_445CD0();
size_t __cdecl sub_445D30(int a1, void *a2, size_t Size);
int __cdecl sub_445D60(int a1, int a2);
int __cdecl sub_445D80(_DWORD *a1, unsigned __int8 *Src, int Size);
int sub_445F20();
int __cdecl sub_445F30(int a1, int a2, int a3);
// _DWORD *__usercall sub_445F90@<eax>(int a1@<ebx>);
int __cdecl sub_446010(_DWORD **a1);
int __cdecl sub_4460B0(char *String2, int); // idb
int __cdecl CompareFunction(const char **a1, const char **a2);
void sub_446150();
int sub_4462C0();
int __cdecl sub_446320(const char *a1);
// int __usercall sub_4463C0@<eax>(int result@<eax>, int a2@<ecx>);
// int __usercall sub_4464F0@<eax>(int a1@<edi>, int a2@<esi>);
int __cdecl sub_446580(int a1, int a2);
// char __usercall sub_446800@<al>(int *a1@<eax>, int *a2@<edi>, int a3@<esi>, int a4);
// int __usercall sub_4468A0@<eax>(int *a1@<edi>, int a2, int a3);
_DWORD *__cdecl sub_446A80(int a1, int a2);
// _DWORD *__usercall sub_446AC0@<eax>(int a1@<edi>, int a2@<esi>);
// void __usercall sub_446B10(int a1@<ebx>, void **Block);
char *__cdecl sub_446B50(_DWORD *a1);
// int *__usercall sub_446E30@<eax>(int a1@<edx>, _DWORD *a2@<edi>);
void __cdecl sub_446F10(_DWORD *a1);
// _DWORD *__usercall sub_447050@<eax>(_DWORD *a1@<edi>, int a2);
void __cdecl sub_4470C0(_DWORD *a1);
void __cdecl sub_447300(_DWORD *a1);
// int __usercall sub_447540@<eax>(int a1@<eax>);
// void __usercall sub_447720(int a1@<esi>);
// int __usercall sub_4477D0@<eax>(int a1@<edx>, int *a2@<esi>);
// int __usercall sub_447810@<eax>(int a1@<eax>, int a2@<ecx>, unsigned int *a3@<edi>, unsigned int a4@<esi>);
// int __usercall sub_447860@<eax>(int a1@<eax>, int a2@<ebx>, int a3);
// _DWORD *__usercall sub_447910@<eax>(unsigned int a1@<eax>, int a2@<esi>);
// int __usercall sub_447980@<eax>(int a1@<ebx>, int a2@<esi>);
void __cdecl sub_4479D0(int a1, int a2, int a3);
// void __usercall sub_447A70(int *a1@<eax>, int a2@<ecx>, int a3@<edi>, _BYTE *Block);
int __cdecl sub_447AE0(int a1);
// int __usercall sub_447BE0@<eax>(int a1@<esi>, int a2);
int __cdecl sub_447D10(int a1, int a2, int *a3, int a4);
int __cdecl sub_4481A0(int a1, char **a2, int *a3, int a4);
int __cdecl sub_4486A0(int a1, int a2);
// void __usercall sub_448860(_DWORD *a1@<esi>);
void __cdecl sub_4488C0(_DWORD *a1, int a2, unsigned int a3);
size_t __cdecl sub_448AE0(int a1, void *Src, size_t Size);
// int __usercall sub_448B40@<eax>(int a1@<eax>, int a2);
int __cdecl sub_448C10(int a1);
int __cdecl sub_448C20(int a1);
int __cdecl sub_448C30(int a1, int a2, int a3);
// int __usercall sub_448CC0@<eax>(int a1@<eax>, int a2@<ebx>, unsigned int a3);
_DWORD *__cdecl sub_448D50(int a1, unsigned int a2);
int __cdecl sub_448DD0(int a1, int a2, int *a3, _DWORD *a4);
// int __usercall sub_449070@<eax>(int a1@<esi>, _DWORD *a2);
// int __usercall sub_4490E0@<eax>(int a1@<edx>, int a2);
int __cdecl sub_44A210(_DWORD *a1);
int __cdecl sub_44A2A0(_DWORD *a1, char *Src, int a3);
int __cdecl sub_44A3B0(_DWORD *a1, int a2);
int sub_44A540();
// int __usercall sub_44A550@<eax>(int *a1@<eax>, _DWORD *a2);
int __cdecl sub_44ABE0(_DWORD *a1);
int __cdecl sub_44AC10(_DWORD *a1, int *Src, int a3);
int __cdecl sub_44AD10(_DWORD *a1, _DWORD *a2);
// int __usercall sub_44AE30@<eax>(_DWORD *a1@<eax>, unsigned int a2);
// int __usercall sub_44B010@<eax>(int result@<eax>, __int16 a2@<cx>);
// int __usercall sub_44B040@<eax>(int a1@<eax>);
// int __usercall sub_44B090@<eax>(int a1@<edi>, int a2);
// unsigned int __usercall sub_44B2E0@<eax>(int a1@<esi>);
// int __usercall sub_44B3A0@<eax>(int a1@<esi>);
// unsigned int __usercall sub_44B430@<eax>(unsigned int a1@<eax>, _DWORD *a2@<edi>);
// void *__usercall sub_44B590@<eax>(int *a1@<esi>);
int __cdecl sub_44B6D0(int *a1, int a2);
int __cdecl sub_44B8B0(int a1, int a2);
int __cdecl sub_44BBE0(int *a1, int a2);
void *__cdecl sub_44C020(int a1, size_t Count, size_t Size);
void __cdecl sub_44C040(int a1, void *Block);
int __fastcall sub_44C050(int a1, int a2);
int __fastcall sub_44C0B0(int a1, int a2);
// int __usercall sub_44C130@<eax>(int result@<eax>, int a2@<edi>, int a3);
// _DWORD *__usercall sub_44C200@<eax>(_DWORD *result@<eax>, int *a2@<ecx>);
// int __usercall sub_44C420@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>);
// int __usercall sub_44C4B0@<eax>(_DWORD *a1@<esi>, int *a2);
// int __usercall sub_44C6B0@<eax>(int result@<eax>, int a2@<ecx>, _WORD *a3);
// int __usercall sub_44C790@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_44CCA0@<eax>(int a1@<eax>);
// int __usercall sub_44CD70@<eax>(int a1@<eax>, int a2, int a3, int a4);
// _DWORD *__usercall sub_44CFD0@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4);
// int __usercall sub_44D060@<eax>(int a1@<eax>);
// int __usercall sub_44D250@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<edi>, _BYTE *a4);
// int __usercall sub_44D440@<eax>(int result@<eax>, int a2, int a3);
// int __usercall sub_44D840@<eax>(int result@<eax>);
// int __usercall sub_44D8F0@<eax>(int result@<eax>);
// int __usercall sub_44D970@<eax>(int result@<eax>);
// _DWORD *__usercall sub_44D9D0@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>);
// void __fastcall __security_check_cookie(uintptr_t StackCookie);
// void *__cdecl malloc(size_t Size);
// _LocaleUpdate *__thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *__hidden this, struct localeinfo_struct *); idb
// int __cdecl _stricmp(const char *String1, const char *String2);
// double __cdecl strtod(const char *String, char **EndPtr);
// int sprintf(char *const Buffer, const char *const Format, ...);
// __time32_t __cdecl _time32(__time32_t *Time);
// int sscanf(const char *const Buffer, const char *const Format, ...);
// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
// int __cdecl isalpha(int C);
// int __cdecl isupper(int C);
// int __cdecl islower(int C);
// int __cdecl isdigit(int C);
// int __cdecl isxdigit(int C);
// int __cdecl isspace(int C);
// int __cdecl ispunct(int C);
// int __cdecl isalnum(int C);
// int __cdecl isprint(int C);
// int __cdecl iscntrl(int C);
// void __cdecl free(void *Block);
// int _open(const char *FileName, int OpenFlag, ...);
// int __cdecl fputs(const char *Buffer, FILE *Stream);
void **sub_44F01A();
// _DWORD __cdecl flsall(_DWORD); weak
// int __cdecl fflush(FILE *Stream);
int sub_44F3AC();
// int __cdecl atoi(const char *String);
// int *__cdecl _errno();
// int __cdecl strtol(const char *String, char **EndPtr, int Radix);
// unsigned int __cdecl strtoul(const char *String, char **EndPtr, int Radix);
// struct tm *__cdecl _localtime32(const __time32_t *Time);
// int __cdecl tolower(int C);
// char *__cdecl strncpy(char *Destination, const char *Source, size_t Count);
// int printf(const char *const Format, ...);
// int __cdecl _read(int FileHandle, void *DstBuf, unsigned int MaxCharCount);
// int fprintf(FILE *const Stream, const char *const Format, ...);
// int __cdecl _fstat32(int FileHandle, struct _stat32 *Stat);
// char *__cdecl _strdup(const char *Source);
// int __cdecl toupper(int C);
// void *__cdecl realloc(void *Block, size_t Size);
// __time32_t __cdecl _mktime32(struct tm *Tm);
// int __cdecl puts(const char *Buffer);
// char *__cdecl strpbrk(const char *Str, const char *Control);
// int __cdecl _close(int FileHandle);
// struct tm *__cdecl _gmtime32(const __time32_t *Time);
// void __cdecl rewind(FILE *Stream);
// int __cdecl fgetc(FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl _chmod(const char *FileName, int Mode);
// int __cdecl _vsnprintf(char *const Buffer, const size_t BufferCount, const char *const Format, va_list ArgList);
// int __cdecl _utime32(const char *FileName, struct __utimbuf32 *Time);
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// int __cdecl _stat32(const char *FileName, struct _stat32 *Stat);
// DWORD __stdcall GetCurrentProcessId();
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl fclose(FILE *Stream);
// int __cdecl vsprintf(char *const Buffer, const char *const Format, va_list ArgList);
// void __cdecl qsort(void *Base, size_t NumOfElements, size_t SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction CompareFunction);
// void __cdecl __noreturn exit(int Code);
// void __cdecl __noreturn _exit(int Code);
// int __cdecl _mkdir(const char *Path);
// char *__cdecl _getcwd(char *DstBuf, int SizeInBytes);
// int __cdecl rename(const char *OldFilename, const char *NewFilename);
// int __cdecl _strnicmp(const char *String1, const char *String2, size_t MaxCount);
// int __cdecl _rmdir(const char *Path);
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// int __cdecl _unlink(const char *FileName);
// int __cdecl _write(int FileHandle, const void *Buf, unsigned int MaxCharCount);
// char *__cdecl getenv(const char *VarName);
// char *__cdecl strstr(const char *Str, const char *SubStr);
// void *__cdecl memchr(const void *Buf, int Val, size_t MaxCount);
// int __cdecl _findclose(intptr_t FindHandle);
// intptr_t __cdecl _findfirst32(const char *FileName, struct _finddata32_t *FindData);
// int __cdecl _findnext32(intptr_t FindHandle, struct _finddata32_t *FindData);
// int __cdecl _finite(double X);
// void *__cdecl calloc(size_t Count, size_t Size);
// int _snprintf(char *const Buffer, const size_t BufferCount, const char *const Format, ...);
// void __cdecl __noreturn longjmp(jmp_buf Buf, int Value);
// void *__cdecl memset(void *, int Val, size_t Size);
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
// char *__cdecl strchr(const char *Str, int Val);
// clock_t __cdecl clock();
// void *__cdecl memcpy_0(void *, const void *Src, size_t Size);
// int __cdecl vfprintf(FILE *const Stream, const char *const Format, va_list ArgList);
// FILE *__cdecl _wfopen(const wchar_t *FileName, const wchar_t *Mode);
// int __cdecl ferror(FILE *Stream);
// int __cdecl _wstat32(const wchar_t *FileName, struct _stat32 *Stat);
// int __cdecl _fileno(FILE *Stream);
// char *__cdecl strrchr(const char *Str, int Ch);
int __cdecl sub_456950(int a1);
// _DWORD __cdecl _encode_pointer(_DWORD); weak
// int _encoded_null(void); weak
// _DWORD __cdecl _decode_pointer(_DWORD); weak
int __cdecl sub_45792E(int a1);
// int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_45A552(_DWORD *a1);
int __cdecl sub_45B0E4(_DWORD *a1);
int __cdecl sub_45B11D(_DWORD *a1);
int __cdecl sub_45B156(_DWORD *a1);
int *sub_45B18F();
int *sub_45B195();
int *sub_45B19B();
void **sub_45B1A1();
void *sub_45C6DA();
void __cdecl sub_45C700(); // idb
int sub_45CA9C();
int __cdecl sub_45CC59(int a1);
int __cdecl sub_45CC68(int a1);
int __cdecl sub_45CC77(int a1);
// int __cdecl _isatty(int FileHandle);
// LONG __stdcall __CxxUnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo); idb
int sub_45D298();
// int _get_sse2_info(void); weak
int sub_45DBDE();
void sub_45E40C();
int __cdecl sub_45E414(int a1, int a2, int a3);
int __cdecl sub_45EBC6(unsigned __int16 *a1, _DWORD *a2);
int __cdecl sub_45F10A(unsigned __int16 *a1, _DWORD *a2);
// _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl _sopen_helper_0(LPCWSTR lpFileName, int, int, int, int, int); idb
int __cdecl sub_462536(int, LPCWSTR lpFileName, int, int, int); // idb
int __cdecl sub_462AD7(_DWORD *a1, int a2, struct localeinfo_struct *a3);
int __cdecl sub_462B7F(_DWORD *a1, int a2, struct localeinfo_struct *a3);
// FILE *__cdecl _fdopen(int FileHandle, const char *Mode);
// int __usercall sub_463FAA@<eax>(int a1@<ebx>, _BYTE *a2, int a3);
// char *__usercall sub_464149@<eax>(char *a1@<eax>, _BYTE *a2@<ecx>);
// _BYTE *__usercall sub_46418A@<eax>(_BYTE *result@<eax>, _BYTE *a2@<ecx>);
// int __usercall sub_4641C8@<eax>(int *a1@<eax>, _DWORD *a2@<ecx>);
int __thiscall sub_4646CF(_DWORD *this);
// int __usercall sub_4646F8@<eax>(unsigned int a1@<edx>, _DWORD *a2@<ecx>, int *a3);
void __cdecl sub_46486C(int a1);
// int __usercall sub_4649EF@<eax>(int a1@<eax>, _BYTE *a2, _DWORD *a3);
int __cdecl sub_464CBD(int a1, int Size, _BYTE *a3, signed int a4);
void __cdecl sub_46506E(FILE *a1, int *a2);
// _BYTE *__usercall sub_4651F0@<eax>(_BYTE *result@<eax>, int a2@<edx>, int a3@<ecx>);
int sub_465210();
int __cdecl zend_stack_apply(_DWORD *a1, int a2, int (__cdecl *a3)(_DWORD));
int __cdecl zend_stack_count(int a1);
int __cdecl zend_stack_base(int a1);
BOOL __cdecl zend_stack_is_empty(_DWORD *a1);
int __cdecl zend_stack_top(int *a1, _DWORD *a2);
int __cdecl zend_stack_destroy(_DWORD *a1);
int __cdecl zend_stack_int_top(int *a1);
int __cdecl zend_stack_del_top(int *a1);
int __cdecl zend_stack_init(_DWORD *a1);
int __cdecl zend_stack_push(_DWORD *a1, void *Src, size_t Size);
int __cdecl zval_add_ref(int *a1);
char __cdecl zval_dtor(int a1);
int __cdecl zval_copy_ctor(int a1);
int __cdecl zend_output_debug_string(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int zend_get_configuration_directive();
int (*zend_message_dispatcher())(void);
// _DWORD *__usercall sub_467A70@<eax>(_DWORD *result@<eax>);
char sub_467A90();
unsigned int __cdecl free_estring(int *a1);
HANDLE j_start_memory_manager();
void __cdecl __noreturn zend_bailout(int a1, int a2);
int __cdecl zend_execute_scripts(int a1, int a2, int a3);
_DWORD *zend_error(int a1, char *Format, ...);
// _DWORD *__usercall sub_468060@<eax>(char *a1@<eax>);
int sub_468070();
int sub_468120(); // weak
// int __usercall sub_468150@<eax>(int a1@<esi>);
int __cdecl zend_llist_apply_with_argument(_DWORD **a1, int (__cdecl *a2)(_DWORD *, int), int a3);
int __cdecl zend_llist_apply(_DWORD **a1, int (__cdecl *a2)(_DWORD *));
int __cdecl zend_llist_init(int a1, int a2, int a3, char a4);
void __cdecl zend_llist_apply_with_del(int a1, int (__cdecl *a2)(_DWORD *));
_DWORD *__cdecl zend_llist_remove_tail(int a1);
void __cdecl zend_llist_destroy(int a1);
void __cdecl zend_llist_del_element(int a1, int a2, int (__cdecl *a3)(_DWORD *, int));
void *__cdecl zend_llist_prepend_element(int a1, void *Src);
void *__cdecl zend_llist_add_element(int a1, void *Src);
void *__cdecl zend_llist_copy(int a1, int a2);
// void __usercall sub_468640(void *a1@<eax>);
// void *__usercall sub_468650@<eax>(void *Block@<ecx>, size_t a2@<eax>);
// void *__usercall sub_468660@<eax>(size_t a1@<eax>);
// void __usercall sub_468670(int a1@<esi>);
char sub_4686A0();
char __thiscall sub_4686D0(void *this);
// int __usercall sub_468720@<eax>(int a1@<eax>);
int sub_4687C0();
BOOL __cdecl sub_4688A0(int a1, int a2);
int sub_4688D0();
// char __usercall sub_4688E0@<al>(_DWORD *a1@<eax>);
// BOOL __usercall sub_468920@<eax>(FILE *a1@<edi>, FILE **a2@<esi>);
void __cdecl zend_destroy_file_handle(int a1);
unsigned int __cdecl zend_file_handle_dtor(int a1);
int __cdecl zend_restore_lexical_state(int a1);
int __cdecl zend_save_lexical_state(_DWORD *a1);
unsigned int sub_468A70();
// _DWORD *__usercall sub_468A90@<eax>(char *a1@<eax>);
int sub_468AA0();
int __cdecl sub_468AE0(int a1);
// _DWORD *__usercall sub_468B60@<eax>(int a1@<edi>, unsigned int a2);
// FILE **__usercall sub_468BD0@<eax>(FILE *a1@<edi>);
char __cdecl sub_468C30(FILE *a1);
char __cdecl sub_468C60(char *a1);
int sub_468D10();
int __cdecl lex_scan(int a1);
int __cdecl zend_prepare_string_for_scanning(int *a1, char *String);
int __cdecl compile_filename(int a1, int *a2);
int __cdecl open_file_for_scanning(_DWORD *Src);
int __cdecl highlight_string(int *a1, int a2, char *String);
int __cdecl highlight_file(int a1);
int __cdecl compile_string(int *a1, char *String);
_DWORD *__cdecl compile_file(_DWORD *Src, int a2);
bool __thiscall sub_46BF30(_DWORD **this);
int __thiscall sub_46BF70(_DWORD *this);
char zend_is_compiling();
int zend_get_compiled_lineno();
int zend_get_compiled_filename();
int __cdecl zend_restore_compiled_filename(int a1);
int sub_46BFE0();
int __cdecl sub_46C030(int a1);
char sub_46C090();
int sub_46C0C0();
// int __usercall sub_46C0E0@<eax>(_DWORD *a1@<ecx>, _DWORD *a2@<esi>);
int sub_46C130();
int __fastcall sub_46C1B0(int a1, int a2);
// char __usercall sub_46C1F0@<al>(int a1@<esi>);
void *sub_46C250();
// void *__usercall sub_46C270@<eax>(_DWORD *a1@<ebx>, int *a2@<edi>, int *a3@<esi>);
// void *__usercall sub_46C390@<eax>(_DWORD *a1@<ebx>, int *a2@<edi>, int *a3@<esi>);
int sub_46C4B0();
// int __usercall sub_46C540@<eax>(int *a1@<edi>, int a2@<esi>, int a3);
int sub_46C5F0();
void *sub_46C610();
// int __usercall sub_46C660@<eax>(int *a1@<eax>);
// char __usercall sub_46C6C0@<al>(_DWORD *a1@<eax>, int a2@<ebx>, int a3@<esi>);
// int __usercall sub_46C770@<eax>(void *a1@<eax>);
// char __usercall sub_46C790@<al>(_DWORD *a1@<eax>, int a2@<edi>);
int sub_46C800();
_DWORD *sub_46C830();
// void *__usercall sub_46C880@<eax>(_DWORD *a1@<ebx>, int *a2@<edi>, int *a3@<esi>);
_DWORD *__cdecl zend_set_compiled_filename(char *String);
int sub_46C920();
int __cdecl sub_46C960(int a1);
// int __usercall sub_46CA20@<eax>(char *String@<ecx>, int a2@<eax>);
void sub_46CA40();
void sub_46CA90();
void sub_46CAC0();
void sub_46CAF0();
// int __usercall sub_46CB20@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<ebx>, _DWORD *a3, int a4);
// _DWORD *__usercall sub_46CBE0@<eax>(_DWORD *a1@<ebx>, _DWORD *a2, int a3);
// _DWORD *__usercall sub_46CCA0@<eax>(_DWORD *a1@<ebx>, _DWORD *a2@<esi>);
// _DWORD *__usercall sub_46CD20@<eax>(_DWORD *a1@<esi>);
// int __usercall sub_46CD60@<eax>(_DWORD *a1@<ebx>);
// _DWORD *__usercall sub_46CDC0@<eax>(int a1@<ebx>, _DWORD *a2@<esi>);
// char __usercall sub_46CE10@<al>(int a1@<eax>, _DWORD *a2);
// int __usercall sub_46CE90@<eax>(_DWORD *a1@<ebx>, int a2, _DWORD *a3, _DWORD *a4, int a5);
// void __usercall sub_46CFC0(_DWORD *a1@<ebx>, int a2, _DWORD *a3);
// int __usercall sub_46D050@<eax>(_DWORD *a1@<ebx>, _DWORD *a2, int a3);
// _DWORD *__usercall sub_46D0E0@<eax>(_DWORD *a1@<ebx>, _DWORD *a2@<esi>, _DWORD *a3, int a4);
// int __usercall sub_46D180@<eax>(_DWORD *a1@<ebx>, _DWORD *a2, _DWORD *a3, int a4);
// int __usercall sub_46D260@<eax>(_DWORD *a1@<eax>, _DWORD *a2);
// int __usercall sub_46D350@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, _DWORD *a3);
// int __usercall sub_46D410@<eax>(_DWORD *a1@<ebx>, int a2);
_DWORD *__cdecl sub_46D550(_DWORD *a1, int a2);
int __cdecl sub_46D600(int a1, int a2);
// _DWORD *__usercall sub_46D660@<eax>(_DWORD *a1@<eax>, _DWORD *a2, int a3);
// int __usercall sub_46D780@<eax>(_DWORD *a1@<eax>);
_DWORD *__cdecl sub_46D8A0(int *a1);
// _DWORD *__usercall sub_46D960@<eax>(_DWORD *a1@<esi>, char a2);
// int __usercall sub_46D9D0@<eax>(_DWORD *a1@<esi>, int a2, int a3);
_DWORD *sub_46DA40();
// int __usercall sub_46DA60@<eax>(_DWORD *a1@<ebx>, _DWORD *a2@<esi>, _DWORD *a3, int a4);
// int __usercall sub_46DB00@<eax>(_DWORD *a1@<ebx>, int a2);
// int __usercall sub_46DBB0@<eax>(_DWORD *a1@<ebx>, _DWORD *a2@<esi>, _DWORD *a3, int a4);
// int __usercall sub_46DC50@<eax>(_DWORD *a1@<ebx>, int a2);
void __cdecl function_add_ref(int a1);
int __cdecl sub_46DD50(_DWORD *a1);
int sub_46DDB0(); // weak
// int __usercall sub_46DE10@<eax>(_DWORD *a1@<ebx>, _DWORD *a2, int a3, int a4, int a5);
// int __usercall sub_46DED0@<eax>(_DWORD *a1@<ebx>, _DWORD *a2);
// char __usercall sub_46E000@<al>(_DWORD *a1@<ebx>, _DWORD *a2@<esi>, int a3, _DWORD *a4, char a5);
// int __usercall sub_46E140@<eax>(int a1@<eax>, int a2@<ecx>, int a3, char a4);
// char __usercall sub_46E2C0@<al>(int a1@<eax>);
// _DWORD *__usercall sub_46E3B0@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<esi>, _DWORD *a3);
// _DWORD *__usercall sub_46E590@<eax>(_DWORD *a1@<ebx>, _DWORD *a2@<esi>, _DWORD *a3);
// _DWORD *__usercall sub_46E640@<eax>(_DWORD *a1@<ebx>, _DWORD *a2@<esi>, _DWORD *a3);
// int __usercall sub_46E6F0@<eax>(_DWORD *a1@<ebx>);
int __cdecl sub_46E750(int a1, int a2);
int __cdecl sub_46E850(int a1, int a2);
// _DWORD *__usercall sub_46E8F0@<eax>(_DWORD *a1@<esi>, int a2);
// int __usercall sub_46E950@<eax>(_DWORD *a1@<ebx>, _DWORD *a2, char a3);
// int __usercall sub_46E9E0@<eax>(_DWORD *a1@<ebx>, _DWORD *a2, char a3);
// int __usercall sub_46EA70@<eax>(int a1@<esi>);
_DWORD *__cdecl sub_46EAD0(int a1, int a2);
// _DWORD *__usercall sub_46EB30@<eax>(_DWORD *a1@<esi>, int a2);
// int __usercall sub_46EB80@<eax>(int a1@<esi>, int a2);
// _DWORD *__usercall sub_46EBE0@<eax>(_DWORD *a1@<esi>, int a2);
// int __usercall sub_46EC40@<eax>(_DWORD *a1@<ebx>, _DWORD *a2, _DWORD *a3);
// _DWORD *__usercall sub_46ECF0@<eax>(_DWORD *a1@<ebx>, _DWORD *a2, _DWORD *a3);
// _DWORD *__usercall sub_46EDA0@<eax>(_DWORD *a1@<esi>);
// int __usercall sub_46EDE0@<eax>(_DWORD *a1@<ebx>, _DWORD *a2);
// void *__usercall sub_46EE60@<eax>(int a1@<ebx>, _DWORD *a2, int a3, char a4);
// _DWORD *__usercall sub_46EFC0@<eax>(_DWORD *a1@<ebx>, char a2, _DWORD *a3, _DWORD *a4);
// int __usercall sub_46F070@<eax>(_DWORD *a1@<ebx>, char a2, _DWORD *a3);
// _DWORD *__usercall sub_46F100@<eax>(_DWORD *a1@<ebx>, char a2, _DWORD *a3, _DWORD *a4);
// int __usercall sub_46F1B0@<eax>(int a1@<esi>, _DWORD *a2);
_DWORD *__cdecl sub_46F220(_DWORD *a1, _DWORD *a2, _DWORD *a3);
// int __usercall sub_46F3E0@<eax>(_DWORD *a1@<ebx>, int a2, _DWORD *a3);
int __cdecl sub_46F480(int *a1, int a2);
// _DWORD *__usercall sub_46F6D0@<eax>(_DWORD *a1@<eax>, int a2@<edi>, _DWORD *a3@<esi>, int a4);
// _DWORD *__usercall sub_46F760@<eax>(int a1@<eax>, int a2@<ebx>);
// void __usercall sub_46F9F0(void *a1@<ecx>, int a2@<esi>);
// _DWORD *__usercall sub_46FA60@<eax>(_DWORD *a1@<esi>, int a2);
// _DWORD *__usercall sub_46FB20@<eax>(int a1@<eax>, int a2, int a3);
// void __usercall sub_46FCA0(_DWORD **a1@<ecx>, _DWORD *a2@<esi>);
// int __usercall sub_46FD50@<eax>(int *a1@<ebx>);
int __cdecl sub_46FE30(int a1);
// void *__usercall sub_46FE80@<eax>(int a1@<eax>, _DWORD *a2@<ecx>, int a3@<ebx>);
// void *__usercall sub_46FE90@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<esi>, int a3);
// int __usercall sub_46FF00@<eax>(int a1@<eax>, _DWORD *a2, int a3);
void *__thiscall sub_470090(void *this);
// void __usercall sub_4700C0(_DWORD *a1@<eax>, _DWORD *a2@<edi>);
// void *__usercall sub_470130@<eax>(int *a1@<eax>, int a2@<ecx>, int *a3@<esi>);
int __cdecl do_bind_function_or_class(_DWORD *Src, int a2, int a3, int a4);
int sub_470410();
_DWORD *__cdecl shutdown_memory_manager(int a1, int a2);
HANDLE start_memory_manager();
int zend_set_memory_limit();
_BYTE *__cdecl zend_strndup(void *Src, size_t Size);
unsigned int __cdecl efree(int a1);
_DWORD *__cdecl emalloc(int a1);
_DWORD *__cdecl estrndup(void *Src, size_t Size);
_DWORD *__cdecl estrdup(const char *Src);
_DWORD *__cdecl erealloc(int a1, int a2, int a3);
_DWORD *__cdecl ecalloc(unsigned int a1, int a2);
int __cdecl zend_hash_next_free_element(int a1);
int __cdecl zend_hash_minmax(_DWORD *a1, int (__cdecl *a2)(_DWORD **, _DWORD **), int a3, _DWORD *a4);
int __cdecl zend_hash_get_current_data_ex(int a1, _DWORD *a2, int *a3);
int __cdecl zend_hash_get_current_key_type_ex(int a1, int *a2);
int __cdecl zend_hash_move_backwards_ex(int a1, int a2);
int __cdecl zend_hash_move_forward_ex(int a1, int a2);
_DWORD *__cdecl zend_hash_internal_pointer_end_ex(_DWORD *a1, _DWORD *a2);
_DWORD *__cdecl zend_hash_internal_pointer_reset_ex(_DWORD *a1, _DWORD *a2);
int __cdecl zend_hash_num_elements(int a1);
int __cdecl zend_hash_index_exists(int a1, int a2);
int __cdecl zend_hash_index_find(int a1, int a2, _DWORD *a3);
int __cdecl zend_hash_quick_find(int a1, int a2, unsigned int a3, int a4, _DWORD *a5);
// int __usercall sub_470D10@<eax>(int a1@<ecx>, int a2@<edi>, void *a3@<esi>);
void *__cdecl zend_hash_clean(int a1);
void __cdecl zend_hash_destroy(void *Block);
int __cdecl zend_hash_rehash(int a1);
char __cdecl zend_hash_set_apply_protection(int a1, char a2);
int __fastcall sub_470F60(char *a1, int a2);
int __cdecl zend_hash_exists(int a1, char *String, unsigned int a3);
int __cdecl zend_hash_find(int a1, char *String, unsigned int a3, _DWORD *a4);
int __cdecl zend_get_hash_value(int a1, char *a2, int a3);
void __cdecl zend_hash_graceful_reverse_destroy(void *Block);
void __cdecl zend_hash_graceful_destroy(void *Block);
int __cdecl zend_hash_del_key_or_index(_DWORD *a1, char *String, unsigned int a3, int a4, int a5);
int __cdecl zend_hash_func(char *a1, int a2);
int __cdecl zend_hash_sort(int a1, void (__cdecl *a2)(int *, int, int, int), int a3, int a4);
int __cdecl zend_hash_init(int a1, unsigned int a2, int a3, int a4, int a5);
int __cdecl zend_hash_get_current_key_ex(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, char a5, _DWORD **a6);
// int __usercall sub_471640@<eax>(int a1@<esi>);
int __cdecl zend_hash_index_update_or_next_insert(int a1, int a2, _DWORD *Src, size_t Size, _DWORD *a5, char a6);
int __cdecl zend_hash_quick_add_or_update(int a1, char *a2, size_t a3, int a4, _DWORD *Src, size_t Size, _DWORD *a7, char a8);
int __cdecl zend_hash_add_or_update(int a1, char *String, size_t a3, size_t *Src, size_t Size, _DWORD *a6, char a7);
int __cdecl zend_hash_init_ex(int a1, unsigned int a2, int a3, int a4, int a5, char a6);
int __cdecl zend_hash_compare(_DWORD *a1, int a2, int (__cdecl *a3)(_DWORD, int), char a4);
int (__cdecl *__cdecl zend_hash_merge_ex(int a1, int a2, int (__cdecl *a3)(_DWORD), size_t Size, int (__cdecl *a5)(int, _DWORD)))(_DWORD);
int (__cdecl *__cdecl zend_hash_merge(int a1, int a2, int (__cdecl *a3)(_DWORD), int a4, size_t Size, int a6))(_DWORD);
int __cdecl zend_hash_copy(int a1, int a2, int (__cdecl *a3)(int), int a4, size_t Size);
void __cdecl zend_hash_reverse_apply(int a1, int (__cdecl *a2)(_DWORD));
void zend_hash_apply_with_arguments(int a1, int (__cdecl *a2)(int, int, char *, int *), int a3, ...);
void __cdecl zend_hash_apply_with_argument(int a1, int (__cdecl *a2)(_DWORD, int), int a3);
void __cdecl zend_hash_apply(int a1, int (__cdecl *a2)(_DWORD));
int __cdecl zend_hash_add_empty_element(int, char *String, size_t); // idb
// int __usercall sub_4725CD@<eax>(SOCKET a1@<eax>, int a2@<ecx>, char a3);
int __cdecl sub_47263F(SOCKET s, BOOL argp);
int sub_472661();
char *__cdecl sub_47270A(SOCKET s);
// int __usercall sub_47279E@<eax>(const char *a1@<ebx>);
_DWORD *__cdecl sub_472882(const char *a1);
int __cdecl sub_472937(const char *a1, const char *a2);
int __cdecl sub_472A5D(int a1);
int __cdecl sub_472A69(int *a1);
int nullsub_1(); // weak
int nullsub_2(); // weak
int sub_472AAE(); // weak
int sub_472AB6(); // weak
unsigned int __fastcall sub_472ACC(unsigned int a1);
unsigned int __cdecl sub_472B02(unsigned int a1);
unsigned int __cdecl sub_472B1A(int a1);
int sub_472B48(); // weak
int sub_472B50(); // weak
int __cdecl sub_472B66(int a1, int *a2);
// void __usercall sub_472BE5(void **a1@<esi>);
char __thiscall sub_472C1C(_DWORD *this);
int __cdecl sub_472C42(int *a1);
// int __usercall sub_472C66@<eax>(int result@<eax>, char a2);
int __thiscall sub_472C7D(_DWORD *this);
// int __usercall sub_472CD2@<eax>(int *a1@<esi>);
int __cdecl sub_472D0B(int a1);
_DWORD *sub_472D23();
int __cdecl sub_472D69(unsigned int a1, int a2);
unsigned int __cdecl sub_472E11(int *a1);
unsigned int __cdecl sub_472F28(int *a1);
// int __usercall sub_47304A@<eax>(int a1@<esi>);
_DWORD *sub_47305B();
// int __usercall sub_4730B3@<eax>(_DWORD *a1@<esi>);
int __cdecl sub_4730D6(int a1);
int sub_47314A(); // weak
_DWORD *sub_47315E();
void __noreturn sub_473200(void); // weak
char *sub_47320D();
int sub_4732D9();
int sub_473303();
void *sub_4733A9();
// _BYTE *__usercall sub_4733BD@<eax>(unsigned __int8 *a1@<eax>);
// _BYTE *__usercall sub_4733E7@<eax>(unsigned __int8 *a1@<eax>);
int __cdecl sub_473408(int Src);
int __cdecl sub_473493(int Src);
int __cdecl zend_list_addref(int a1);
int __cdecl zend_list_find(int a1, _DWORD *a2);
int __cdecl zend_list_delete(int a1);
int __cdecl zend_list_insert(int a1, int a2);
// _DWORD __cdecl _setjmp3(_DWORD, _DWORD);

//-------------------------------------------------------------------------
// Data declarations

// extern void (__stdcall *GetSystemInfo)(LPSYSTEM_INFO lpSystemInfo);
// extern BOOL (__stdcall *GetVersionExA)(LPOSVERSIONINFOA lpVersionInformation);
// extern DWORD (__stdcall *FormatMessageA)(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments);
// extern DWORD (__stdcall *GetLastError)();
// extern HLOCAL (__stdcall *LocalFree)(HLOCAL hMem);
// extern HANDLE (__stdcall *CreateFileA)(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern BOOL (__stdcall *SetFileTime)(HANDLE hFile, const FILETIME *lpCreationTime, const FILETIME *lpLastAccessTime, const FILETIME *lpLastWriteTime);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern BOOL (__stdcall *GetFileTime)(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern BOOL (__stdcall *IsDBCSLeadByte)(BYTE TestChar);
// extern DWORD (__stdcall *GetModuleFileNameA)(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern int (__stdcall *MultiByteToWideChar)(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// extern LPVOID (__stdcall *HeapReAlloc)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes);
// extern LPVOID (__stdcall *HeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// extern BOOL (__stdcall *HeapFree)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// extern BOOL (__stdcall *HeapDestroy)(HANDLE hHeap);
// extern HANDLE (__stdcall *HeapCreate)(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// extern BOOL (__stdcall *PathCanonicalizeA)(LPSTR pszBuf, LPCSTR pszPath);
// extern BOOL (__stdcall *PathIsRelativeA)(LPCSTR pszPath);
// extern int (__stdcall *connect)(SOCKET s, const struct sockaddr *name, int namelen);
// extern unsigned int (__stdcall *inet_addr)(const char *cp);
// extern int (__stdcall *select)(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timeval *timeout);
// extern int (__stdcall *WSAGetLastError)();
// extern u_short (__stdcall *htons)(u_short hostshort);
// extern struct protoent *(__stdcall *getprotobyname)(const char *name);
// extern int (__stdcall *ioctlsocket)(SOCKET s, int cmd, u_long *argp);
// extern SOCKET (__stdcall *socket)(int af, int type, int protocol);
// extern int (__stdcall *closesocket)(SOCKET s);
// extern struct hostent *(__stdcall *gethostbyname)(const char *name);
// extern int (__stdcall *send)(SOCKET s, const char *buf, int len, int flags);
// extern int (__stdcall *WSAStartup)(WORD wVersionRequested, LPWSADATA lpWSAData);
// extern int (__stdcall *gethostname)(char *name, int namelen);
// extern int (__stdcall *recv)(SOCKET s, char *buf, int len, int flags);
_UNKNOWN unk_4756C4; // weak
char byte_4756E8[] = { '\v' }; // weak
char byte_4756E9[] = { 'w' }; // weak
char byte_4756EA[] = { '\xE9' }; // weak
char byte_4756EB[17] =
{
  '\x9C',
  '\x92',
  '\xBE',
  ';',
  'h',
  '\xE3',
  '\x8F',
  '\xEA',
  '\xE7',
  '$',
  '\xCF',
  '\xE4',
  '\xF1',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
_UNKNOWN unk_4756FC; // weak
_UNKNOWN unk_475F74; // weak
_UNKNOWN unk_475F9C; // weak
_UNKNOWN unk_475FB4; // weak
_UNKNOWN unk_475FC8; // weak
_UNKNOWN unk_475FDC; // weak
_UNKNOWN unk_476000; // weak
_UNKNOWN unk_476040; // weak
_UNKNOWN unk_476080; // weak
_UNKNOWN unk_4760B0; // weak
_UNKNOWN unk_476100; // weak
_UNKNOWN unk_476140; // weak
_UNKNOWN unk_476164; // weak
_UNKNOWN unk_47618C; // weak
_UNKNOWN unk_4761B8; // weak
_UNKNOWN unk_4761BC; // weak
_UNKNOWN unk_4761E4; // weak
_UNKNOWN unk_476214; // weak
_UNKNOWN unk_476230; // weak
_UNKNOWN unk_47623C; // weak
_UNKNOWN unk_476240; // weak
_UNKNOWN unk_476254; // weak
_UNKNOWN unk_476264; // weak
_UNKNOWN unk_47626C; // weak
_UNKNOWN unk_476274; // weak
const char byte_47627C[4] = { '\0', '\0', '\0', '\0' }; // idb
_UNKNOWN unk_476280; // weak
_UNKNOWN unk_47628C; // weak
_UNKNOWN unk_4762B0; // weak
_UNKNOWN unk_476340; // weak
_UNKNOWN unk_47635C; // weak
_UNKNOWN unk_476384; // weak
_UNKNOWN unk_4763C0; // weak
_UNKNOWN unk_4763F0; // weak
_UNKNOWN unk_476420; // weak
_UNKNOWN unk_476460; // weak
_UNKNOWN unk_4764A8; // weak
_UNKNOWN unk_4764C8; // weak
_UNKNOWN unk_4764E0; // weak
_UNKNOWN unk_47650C; // weak
_UNKNOWN unk_476510; // weak
_UNKNOWN unk_476534; // weak
_UNKNOWN unk_476568; // weak
_UNKNOWN unk_476580; // weak
_UNKNOWN unk_4765C0; // weak
_UNKNOWN unk_476604; // weak
_UNKNOWN unk_47661C; // weak
_UNKNOWN unk_476630; // weak
_UNKNOWN unk_476688; // weak
_UNKNOWN unk_476698; // weak
_UNKNOWN unk_4766E8; // weak
_UNKNOWN unk_4766F4; // weak
_UNKNOWN unk_476720; // weak
_UNKNOWN unk_47673C; // weak
_UNKNOWN unk_476760; // weak
_UNKNOWN unk_476778; // weak
_UNKNOWN unk_4767B0; // weak
_UNKNOWN unk_4767D0; // weak
_UNKNOWN unk_476804; // weak
_UNKNOWN unk_476820; // weak
_UNKNOWN unk_476868; // weak
_UNKNOWN unk_4768AC; // weak
_UNKNOWN unk_4768D4; // weak
_UNKNOWN unk_4768E8; // weak
_UNKNOWN unk_476934; // weak
_UNKNOWN unk_476968; // weak
_UNKNOWN unk_47698C; // weak
_UNKNOWN unk_4769A8; // weak
_UNKNOWN unk_4769F8; // weak
_UNKNOWN unk_476A14; // weak
_UNKNOWN unk_476A40; // weak
_UNKNOWN unk_476A90; // weak
_UNKNOWN unk_476AAC; // weak
_UNKNOWN unk_476AD4; // weak
_UNKNOWN unk_476AE8; // weak
_UNKNOWN unk_476B34; // weak
_UNKNOWN unk_476B68; // weak
_UNKNOWN unk_476B8C; // weak
_UNKNOWN unk_476BA4; // weak
_UNKNOWN unk_476BDC; // weak
_UNKNOWN unk_476BF8; // weak
_UNKNOWN unk_476C48; // weak
_UNKNOWN unk_476CAC; // weak
_UNKNOWN unk_476CD4; // weak
_UNKNOWN unk_476CDC; // weak
_UNKNOWN unk_476CFC; // weak
_UNKNOWN unk_476D1C; // weak
_UNKNOWN unk_476D5C; // weak
_UNKNOWN unk_476D70; // weak
_UNKNOWN unk_476D90; // weak
_UNKNOWN unk_476DB8; // weak
_UNKNOWN unk_476E08; // weak
_UNKNOWN unk_476E58; // weak
_UNKNOWN unk_476EA4; // weak
_UNKNOWN unk_476EC0; // weak
_UNKNOWN unk_476EF8; // weak
_UNKNOWN unk_476F00; // weak
_UNKNOWN unk_476F20; // weak
_UNKNOWN unk_476F68; // weak
_UNKNOWN unk_476F88; // weak
_UNKNOWN unk_476FCC; // weak
_UNKNOWN unk_476FF0; // weak
_UNKNOWN unk_477034; // weak
_UNKNOWN unk_477048; // weak
_UNKNOWN unk_477080; // weak
_UNKNOWN unk_477094; // weak
_UNKNOWN unk_4770CC; // weak
_UNKNOWN unk_4770E0; // weak
_UNKNOWN unk_477124; // weak
_UNKNOWN unk_477138; // weak
_UNKNOWN unk_477184; // weak
_UNKNOWN unk_477194; // weak
_UNKNOWN unk_4771A8; // weak
_UNKNOWN unk_4771F4; // weak
_UNKNOWN unk_477218; // weak
_UNKNOWN unk_477230; // weak
_UNKNOWN unk_477270; // weak
_UNKNOWN unk_477284; // weak
_UNKNOWN unk_4772C0; // weak
_UNKNOWN unk_477308; // weak
_UNKNOWN unk_477324; // weak
_UNKNOWN unk_477340; // weak
_UNKNOWN unk_477390; // weak
_UNKNOWN unk_4773D8; // weak
_UNKNOWN unk_477430; // weak
_UNKNOWN unk_477480; // weak
_UNKNOWN unk_4774A0; // weak
_UNKNOWN unk_4774BC; // weak
_UNKNOWN unk_4774F8; // weak
_UNKNOWN unk_477524; // weak
_UNKNOWN unk_477560; // weak
_UNKNOWN unk_4775B0; // weak
_UNKNOWN unk_4775F8; // weak
_UNKNOWN unk_477634; // weak
_UNKNOWN unk_477664; // weak
_UNKNOWN unk_47768C; // weak
_UNKNOWN unk_4776C4; // weak
_UNKNOWN unk_4776E0; // weak
_UNKNOWN unk_477730; // weak
_UNKNOWN unk_477780; // weak
_UNKNOWN unk_4777A0; // weak
_UNKNOWN unk_4777FC; // weak
_UNKNOWN unk_477808; // weak
_UNKNOWN unk_477858; // weak
_UNKNOWN unk_47787C; // weak
_UNKNOWN unk_4778A0; // weak
_UNKNOWN unk_477918; // weak
_UNKNOWN unk_4779CC; // weak
_UNKNOWN unk_4779E8; // weak
_UNKNOWN unk_477A38; // weak
_UNKNOWN unk_477A60; // weak
_UNKNOWN unk_477AA0; // weak
_UNKNOWN unk_477AC8; // weak
_UNKNOWN unk_477B0C; // weak
_UNKNOWN unk_477B24; // weak
_UNKNOWN unk_477B60; // weak
_UNKNOWN unk_477B80; // weak
_UNKNOWN unk_477BC8; // weak
_UNKNOWN unk_477C00; // weak
_UNKNOWN unk_477C20; // weak
_UNKNOWN unk_477C68; // weak
_UNKNOWN unk_477C7C; // weak
_UNKNOWN unk_477C98; // weak
_UNKNOWN unk_477CE4; // weak
_UNKNOWN unk_477D08; // weak
_UNKNOWN unk_477D50; // weak
_UNKNOWN unk_477D98; // weak
_UNKNOWN unk_477DC8; // weak
_UNKNOWN unk_477DE8; // weak
_UNKNOWN unk_477E34; // weak
_UNKNOWN unk_477E48; // weak
_UNKNOWN unk_477E60; // weak
_UNKNOWN unk_477EB0; // weak
_UNKNOWN unk_477EFC; // weak
_UNKNOWN unk_477F18; // weak
_UNKNOWN unk_477F30; // weak
_UNKNOWN unk_477F80; // weak
_UNKNOWN unk_477FAC; // weak
_UNKNOWN unk_477FD0; // weak
_UNKNOWN unk_478028; // weak
_UNKNOWN unk_478078; // weak
_UNKNOWN unk_4780C8; // weak
_UNKNOWN unk_4780D4; // weak
_UNKNOWN unk_4780F8; // weak
_UNKNOWN unk_478140; // weak
_UNKNOWN unk_478188; // weak
_UNKNOWN unk_478198; // weak
_UNKNOWN unk_4781E8; // weak
_UNKNOWN unk_478230; // weak
_UNKNOWN unk_478280; // weak
_UNKNOWN unk_4782C8; // weak
_UNKNOWN unk_478310; // weak
_UNKNOWN unk_47835C; // weak
_UNKNOWN unk_47837C; // weak
_UNKNOWN unk_4783B0; // weak
_UNKNOWN unk_478400; // weak
_UNKNOWN unk_478448; // weak
_UNKNOWN unk_478478; // weak
_UNKNOWN unk_4784A0; // weak
_UNKNOWN unk_4784E4; // weak
_UNKNOWN unk_47851C; // weak
_UNKNOWN unk_478540; // weak
_UNKNOWN unk_478590; // weak
_UNKNOWN unk_47859C; // weak
_UNKNOWN unk_4785A4; // weak
_UNKNOWN unk_4785C0; // weak
_UNKNOWN unk_478604; // weak
_UNKNOWN unk_478620; // weak
_UNKNOWN unk_47866C; // weak
_UNKNOWN unk_478680; // weak
_UNKNOWN unk_4786A8; // weak
_UNKNOWN unk_4786F8; // weak
_UNKNOWN unk_47873C; // weak
_UNKNOWN unk_478758; // weak
_UNKNOWN unk_4787B0; // weak
_UNKNOWN unk_4787F0; // weak
_UNKNOWN unk_478810; // weak
_UNKNOWN unk_47885C; // weak
_UNKNOWN unk_478874; // weak
_UNKNOWN unk_478888; // weak
_UNKNOWN unk_4788C4; // weak
_UNKNOWN unk_4788D8; // weak
_UNKNOWN unk_47890C; // weak
_UNKNOWN unk_478920; // weak
_UNKNOWN unk_478940; // weak
_UNKNOWN unk_478950; // weak
_UNKNOWN unk_478968; // weak
_UNKNOWN unk_4789B0; // weak
_UNKNOWN unk_4789BC; // weak
_UNKNOWN unk_4789C8; // weak
_UNKNOWN unk_4789D4; // weak
_UNKNOWN unk_4789E0; // weak
_UNKNOWN unk_4789EC; // weak
_UNKNOWN unk_4789F4; // weak
_UNKNOWN unk_4789FC; // weak
_UNKNOWN unk_478A20; // weak
_UNKNOWN unk_478A28; // weak
_UNKNOWN unk_478A34; // weak
_UNKNOWN unk_478A40; // weak
_UNKNOWN unk_478A4C; // weak
_UNKNOWN unk_478A64; // weak
_UNKNOWN unk_478A70; // weak
_UNKNOWN unk_478A74; // weak
_UNKNOWN unk_478A9C; // weak
_UNKNOWN unk_478AC0; // weak
_UNKNOWN unk_478AC8; // weak
_UNKNOWN unk_478AD4; // weak
_UNKNOWN unk_478AFC; // weak
_UNKNOWN unk_478B04; // weak
_UNKNOWN unk_478B38; // weak
_UNKNOWN unk_478C94; // weak
__int16 word_478CA4 = 46; // weak
_UNKNOWN unk_478CAC; // weak
_UNKNOWN unk_478CDC; // weak
_UNKNOWN unk_478CF4; // weak
_UNKNOWN unk_478D20; // weak
_UNKNOWN unk_478D80; // weak
_UNKNOWN unk_478DE0; // weak
_UNKNOWN unk_478DEC; // weak
_UNKNOWN unk_478E28; // weak
_UNKNOWN unk_478E48; // weak
_UNKNOWN unk_478E88; // weak
_UNKNOWN unk_478EC4; // weak
_UNKNOWN unk_478ECC; // weak
_UNKNOWN unk_478EE0; // weak
_UNKNOWN unk_478EF4; // weak
_UNKNOWN unk_478F0C; // weak
_UNKNOWN unk_478F20; // weak
_UNKNOWN unk_478F38; // weak
_UNKNOWN unk_478F50; // weak
_UNKNOWN unk_478F68; // weak
_UNKNOWN unk_478F80; // weak
_UNKNOWN unk_478F8C; // weak
_UNKNOWN unk_478FA0; // weak
_UNKNOWN unk_478FB4; // weak
_UNKNOWN unk_478FCC; // weak
_UNKNOWN unk_478FE0; // weak
_UNKNOWN unk_478FF8; // weak
_UNKNOWN unk_479008; // weak
_UNKNOWN unk_479014; // weak
_UNKNOWN unk_479028; // weak
_UNKNOWN unk_47903C; // weak
_UNKNOWN unk_47904C; // weak
_UNKNOWN unk_47905C; // weak
_UNKNOWN unk_47906C; // weak
_UNKNOWN unk_479084; // weak
_UNKNOWN unk_47909C; // weak
_UNKNOWN unk_4790A4; // weak
_UNKNOWN unk_4790B4; // weak
_UNKNOWN unk_4790C4; // weak
const char asc_4790E4[] = "-"; // idb
_UNKNOWN unk_4790EC; // weak
_UNKNOWN unk_4790F4; // weak
_UNKNOWN unk_4790FC; // weak
_UNKNOWN unk_479108; // weak
_UNKNOWN unk_479114; // weak
_UNKNOWN unk_47911C; // weak
_UNKNOWN unk_479128; // weak
_UNKNOWN unk_479134; // weak
_UNKNOWN unk_479140; // weak
_UNKNOWN unk_479170; // weak
_UNKNOWN unk_479178; // weak
_UNKNOWN unk_479210; // weak
_UNKNOWN unk_479224; // weak
_UNKNOWN unk_479238; // weak
_UNKNOWN unk_479498; // weak
_UNKNOWN unk_4794B0; // weak
_UNKNOWN unk_4794C8; // weak
_UNKNOWN unk_4797F8; // weak
_UNKNOWN unk_479BA8; // weak
_UNKNOWN unk_479C54; // weak
_UNKNOWN unk_479C6C; // weak
_UNKNOWN unk_479C78; // weak
_UNKNOWN unk_479C84; // weak
_UNKNOWN unk_479C9C; // weak
_UNKNOWN unk_479CAC; // weak
_UNKNOWN unk_479CBC; // weak
_UNKNOWN unk_479CCC; // weak
_UNKNOWN unk_479CD4; // weak
_UNKNOWN unk_479CE0; // weak
_UNKNOWN unk_479D38; // weak
_UNKNOWN unk_479D3C; // weak
_UNKNOWN unk_479D44; // weak
_UNKNOWN unk_479D50; // weak
_UNKNOWN unk_479D68; // weak
_UNKNOWN unk_479D80; // weak
_UNKNOWN unk_479DA0; // weak
_UNKNOWN unk_479DAC; // weak
_UNKNOWN unk_479DCC; // weak
_UNKNOWN unk_479DE8; // weak
_UNKNOWN unk_479DF0; // weak
_UNKNOWN unk_479E00; // weak
_UNKNOWN unk_479E10; // weak
_UNKNOWN unk_479E1C; // weak
_UNKNOWN unk_479E2C; // weak
_UNKNOWN unk_479E44; // weak
_UNKNOWN unk_479E5C; // weak
_UNKNOWN unk_479E6C; // weak
_UNKNOWN unk_479E88; // weak
_UNKNOWN unk_479EA0; // weak
_UNKNOWN unk_479EBC; // weak
_UNKNOWN unk_479ED4; // weak
_UNKNOWN unk_479EF4; // weak
_UNKNOWN unk_479F14; // weak
_UNKNOWN unk_479F2C; // weak
_UNKNOWN unk_479F48; // weak
_UNKNOWN unk_479F68; // weak
_UNKNOWN unk_479F88; // weak
_UNKNOWN unk_479FA0; // weak
_UNKNOWN unk_479FC4; // weak
_UNKNOWN unk_479FDC; // weak
_UNKNOWN unk_479FEC; // weak
_UNKNOWN unk_479FF8; // weak
_UNKNOWN unk_47A004; // weak
_UNKNOWN unk_47A030; // weak
_UNKNOWN unk_47A05C; // weak
_UNKNOWN unk_47A080; // weak
_UNKNOWN unk_47A0A0; // weak
_UNKNOWN unk_47A0B4; // weak
_UNKNOWN unk_47A0D0; // weak
_UNKNOWN unk_47A0E0; // weak
_UNKNOWN unk_47A100; // weak
_UNKNOWN unk_47A110; // weak
_UNKNOWN unk_47A128; // weak
_UNKNOWN unk_47A148; // weak
_UNKNOWN unk_47A1DC; // weak
_UNKNOWN unk_47A1FC; // weak
_UNKNOWN unk_47A228; // weak
_UNKNOWN unk_47A260; // weak
_UNKNOWN unk_47A2A4; // weak
_UNKNOWN unk_47A2C0; // weak
_UNKNOWN unk_47A2E4; // weak
_UNKNOWN unk_47A30C; // weak
_UNKNOWN unk_47A338; // weak
_UNKNOWN unk_47A34C; // weak
_UNKNOWN unk_47A37C; // weak
_UNKNOWN unk_47A3B0; // weak
_UNKNOWN unk_47A3D0; // weak
_UNKNOWN unk_47A400; // weak
_UNKNOWN unk_47A410; // weak
_UNKNOWN unk_47A46C; // weak
_UNKNOWN unk_47A4A8; // weak
_UNKNOWN unk_47A4F0; // weak
_UNKNOWN unk_47A5C0; // weak
_UNKNOWN unk_47A678; // weak
_UNKNOWN unk_47A6E4; // weak
_UNKNOWN unk_47A708; // weak
_UNKNOWN unk_47A738; // weak
_UNKNOWN unk_47A790; // weak
_UNKNOWN unk_47A7E8; // weak
_UNKNOWN unk_47A838; // weak
_UNKNOWN unk_47A8B8; // weak
_UNKNOWN unk_47A960; // weak
_UNKNOWN unk_47A978; // weak
_UNKNOWN unk_47A9DC; // weak
_UNKNOWN unk_47AA14; // weak
_UNKNOWN unk_47AA44; // weak
_UNKNOWN unk_47AA78; // weak
_UNKNOWN unk_47AAA0; // weak
_UNKNOWN unk_47AAD4; // weak
_UNKNOWN unk_47AAF8; // weak
_UNKNOWN unk_47AB48; // weak
_UNKNOWN unk_47AB98; // weak
_UNKNOWN unk_47ABF0; // weak
_UNKNOWN unk_47AC28; // weak
_UNKNOWN unk_47ACC0; // weak
_UNKNOWN unk_47ACF8; // weak
_UNKNOWN unk_47AD20; // weak
_UNKNOWN unk_47AD68; // weak
_UNKNOWN unk_47AD98; // weak
_UNKNOWN unk_47ADEC; // weak
_UNKNOWN unk_47AE2C; // weak
_UNKNOWN unk_47AE6C; // weak
_UNKNOWN unk_47AE90; // weak
_UNKNOWN unk_47AEC4; // weak
_UNKNOWN unk_47AEF8; // weak
_UNKNOWN unk_47AF30; // weak
_UNKNOWN unk_47AF84; // weak
const char SubStr[] = { ':', ':' }; // idb
_UNKNOWN unk_47AFBC; // weak
_UNKNOWN unk_47AFF0; // weak
_UNKNOWN unk_47B000; // weak
_UNKNOWN unk_47B00C; // weak
_UNKNOWN unk_47B018; // weak
_UNKNOWN unk_47B054; // weak
_UNKNOWN unk_47B08C; // weak
int dword_47B090[28] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5
}; // weak
char byte_47B101[] = { '\0' }; // weak
char byte_47B102[] = { '\0' }; // weak
char byte_47B103[] = { '\0' }; // weak
char byte_47B104[20] =
{
  '\x10',
  '\x11',
  '\x12',
  '\0',
  '\b',
  '\a',
  '\t',
  '\x06',
  '\n',
  '\x05',
  '\v',
  '\x04',
  '\f',
  '\x03',
  '\r',
  '\x02',
  '\x0E',
  '\x01',
  '\x0F',
  '='
}; // weak
int dword_47B118[30] =
{
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13
}; // weak
_UNKNOWN unk_47B1E0; // weak
_UNKNOWN unk_47B660; // weak
char byte_47B6D8[256] =
{
  '\0',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x04',
  '\x05',
  '\x05',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\a',
  '\a',
  '\a',
  '\a',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F'
}; // weak
char byte_47B7D8[] = { '\0' }; // weak
char byte_47B8D8[256] =
{
  '\0',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\b',
  '\t',
  '\t',
  '\n',
  '\n',
  '\v',
  '\v',
  '\f',
  '\f',
  '\f',
  '\f',
  '\r',
  '\r',
  '\r',
  '\r',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x13',
  '\x13',
  '\x13',
  '\x13',
  '\x13',
  '\x13',
  '\x13',
  '\x13',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1C'
}; // weak
int dword_47B9D8[30] =
{
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  10,
  12,
  14,
  16,
  20,
  24,
  28,
  32,
  40,
  48,
  56,
  64,
  80,
  96,
  112,
  128,
  160,
  192,
  224,
  0,
  327687
}; // weak
int dword_47BA50[30] =
{
  0,
  1,
  2,
  3,
  4,
  6,
  8,
  12,
  16,
  24,
  32,
  48,
  64,
  96,
  128,
  192,
  256,
  384,
  512,
  768,
  1024,
  1536,
  2048,
  3072,
  4096,
  6144,
  8192,
  12288,
  16384,
  24576
}; // weak
__int16 word_47BAC8[] = { 0 }; // weak
__int16 word_47BACA[] = { 0 }; // weak
__int16 word_47BACC[] = { 0 }; // weak
__int16 word_47BACE[] = { 0 }; // weak
int (__cdecl *funcs_44B1F0[3])(int, int) =
{
  &sub_44B6D0,
  (int (__cdecl *)(int, int))0x40004,
  (int (__cdecl *)(int, int))0x40008
}; // weak
void *off_47BB40 = &aQ; // weak
void *off_47BBA8 = &byte_488AE8; // weak
int dword_47BC10[] = { -685199838 }; // weak
int dword_47BC14[] = { 1116352408 }; // weak
int dword_47BC18[] = { 602891725 }; // weak
int dword_47BC1C[] = { 1899447441 }; // weak
int dword_47BC20[] = { -330482897 }; // weak
int dword_47BC24[] = { -1245643825 }; // weak
int dword_47BC28[] = { -2121671748 }; // weak
int dword_47BC2C[] = { -373957723 }; // weak
int dword_47BC30[] = { -213338824 }; // weak
int dword_47BC34[] = { 961987163 }; // weak
int dword_47BC38[] = { -1241133031 }; // weak
int dword_47BC3C[] = { 1508970993 }; // weak
int dword_47BC40[] = { -1357295717 }; // weak
int dword_47BC44[] = { -1841331548 }; // weak
int dword_47BC48[] = { -630357736 }; // weak
int dword_47BC4C[] = { -1424204075 }; // weak
char xmlIsPubidChar_tab[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\x01',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
_DWORD xmlIsBaseCharGroup[2] = { 197, 0 }; // weak
_DWORD xmlIsCombiningGroup[2] = { 95, 0 }; // weak
_DWORD xmlIsDigitGroup[2] = { 14, 0 }; // weak
_DWORD xmlIsExtenderGroup[2] = { 10, 0 }; // weak
char byte_47C500[256] =
{
  '\0',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\n',
  '\v',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\x11',
  '\x12',
  '\x13',
  '\x14',
  '\x15',
  '\x16',
  '\x17',
  '\x18',
  '\x19',
  '\x1A',
  '\x1B',
  '\x1C',
  '\x1D',
  '\x1E',
  '\x1F',
  ' ',
  '!',
  '\"',
  '#',
  '$',
  '%',
  '&',
  '\'',
  '(',
  ')',
  '*',
  '+',
  ',',
  '-',
  '.',
  '/',
  '0',
  '1',
  '2',
  '3',
  '4',
  '5',
  '6',
  '7',
  '8',
  '9',
  ':',
  ';',
  '<',
  '=',
  '>',
  '?',
  '@',
  'a',
  'b',
  'c',
  'd',
  'e',
  'f',
  'g',
  'h',
  'i',
  'j',
  'k',
  'l',
  'm',
  'n',
  'o',
  'p',
  'q',
  'r',
  's',
  't',
  'u',
  'v',
  'w',
  'x',
  'y',
  'z',
  '{',
  '\\',
  ']',
  '^',
  '_',
  '`',
  'a',
  'b',
  'c',
  'd',
  'e',
  'f',
  'g',
  'h',
  'i',
  'j',
  'k',
  'l',
  'm',
  'n',
  'o',
  'p',
  'q',
  'r',
  's',
  't',
  'u',
  'v',
  'w',
  'x',
  'y',
  'z',
  '{',
  '|',
  '}',
  '~',
  '\x7F',
  '\x80',
  '\x81',
  '\x82',
  '\x83',
  '\x84',
  '\x85',
  '\x86',
  '\x87',
  '\x88',
  '\x89',
  '\x8A',
  '\x8B',
  '\x8C',
  '\x8D',
  '\x8E',
  '\x8F',
  '\x90',
  '\x91',
  '\x92',
  '\x93',
  '\x94',
  '\x95',
  '\x96',
  '\x97',
  '\x98',
  '\x99',
  '\x9A',
  '\x9B',
  '\x9C',
  '\x9D',
  '\x9E',
  '\x9F',
  '\xA0',
  '\xA1',
  '\xA2',
  '\xA3',
  '\xA4',
  '\xA5',
  '\xA6',
  '\xA7',
  '\xA8',
  '\xA9',
  '\xAA',
  '\xAB',
  '\xAC',
  '\xAD',
  '\xAE',
  '\xAF',
  '\xB0',
  '\xB1',
  '\xB2',
  '\xB3',
  '\xB4',
  '\xB5',
  '\xB6',
  '\xB7',
  '\xB8',
  '\xB9',
  '\xBA',
  '\xBB',
  '\xBC',
  '\xBD',
  '\xBE',
  '\xBF',
  '\xC0',
  '\xC1',
  '\xC2',
  '\xC3',
  '\xC4',
  '\xC5',
  '\xC6',
  '\xC7',
  '\xC8',
  '\xC9',
  '\xCA',
  '\xCB',
  '\xCC',
  '\xCD',
  '\xCE',
  '\xCF',
  '\xD0',
  '\xD1',
  '\xD2',
  '\xD3',
  '\xD4',
  '\xD5',
  '\xD6',
  '\xD7',
  '\xD8',
  '\xD9',
  '\xDA',
  '\xDB',
  '\xDC',
  '\xDD',
  '\xDE',
  '\xDF',
  '\xE0',
  '\xE1',
  '\xE2',
  '\xE3',
  '\xE4',
  '\xE5',
  '\xE6',
  '\xE7',
  '\xE8',
  '\xE9',
  '\xEA',
  '\xEB',
  '\xEC',
  '\xED',
  '\xEE',
  '\xEF',
  '\xF0',
  '\xF1',
  '\xF2',
  '\xF3',
  '\xF4',
  '\xF5',
  '\xF6',
  '\xF7',
  '\xF8',
  '\xF9',
  '\xFA',
  '\xFB',
  '\xFC',
  '\xFD',
  '\xFE',
  '\xFF'
}; // weak
char byte_47C600[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\t',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  ' ',
  '!',
  '\"',
  '#',
  '$',
  '%',
  '\0',
  '\'',
  '(',
  ')',
  '*',
  '+',
  ',',
  '-',
  '.',
  '/',
  '0',
  '1',
  '2',
  '3',
  '4',
  '5',
  '6',
  '7',
  '8',
  '9',
  ':',
  ';',
  '\0',
  '=',
  '>',
  '?',
  '@',
  'A',
  'B',
  'C',
  'D',
  'E',
  'F',
  'G',
  'H',
  'I',
  'J',
  'K',
  'L',
  'M',
  'N',
  'O',
  'P',
  'Q',
  'R',
  'S',
  'T',
  'U',
  'V',
  'W',
  'X',
  'Y',
  'Z',
  '[',
  '\\',
  '\0',
  '^',
  '_',
  '`',
  'a',
  'b',
  'c',
  'd',
  'e',
  'f',
  'g',
  'h',
  'i',
  'j',
  'k',
  'l',
  'm',
  'n',
  'o',
  'p',
  'q',
  'r',
  's',
  't',
  'u',
  'v',
  'w',
  'x',
  'y',
  'z',
  '{',
  '|',
  '}',
  '~',
  '\x7F',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
void *off_47C720 = &unk_482B38; // weak
int dword_47C770[512] =
{
  -966564955,
  -126059388,
  -294160487,
  -159679603,
  -855539,
  -697603139,
  -563122255,
  -1849309868,
  1613770832,
  33620227,
  -832084055,
  1445669757,
  -402719207,
  -1244145822,
  1303096294,
  -327780710,
  -1882535355,
  528646813,
  -1983264448,
  -92439161,
  -268764651,
  -1302767125,
  -1907931191,
  -68095989,
  1101901292,
  -1277897625,
  1604494077,
  1169141738,
  597466303,
  1403299063,
  -462261610,
  -1681866661,
  1974974402,
  -503448292,
  1033081774,
  1277568618,
  1815492186,
  2118074177,
  -168298750,
  -2083730353,
  1748251740,
  1369810420,
  -773462732,
  -101584632,
  -495881837,
  -1411852173,
  1647391059,
  706024767,
  134480908,
  -1782069422,
  1176707941,
  -1648114850,
  806885416,
  932615841,
  168101135,
  798661301,
  235341577,
  605164086,
  461406363,
  -538779075,
  -840176858,
  1311188841,
  2142417613,
  -361400929,
  302582043,
  495158174,
  1479289972,
  874125870,
  907746093,
  -596742478,
  -1269146898,
  1537253627,
  -1538108682,
  1983593293,
  -1210657183,
  2108928974,
  1378429307,
  -572267714,
  1580150641,
  327451799,
  -1504488459,
  -1177431704,
  0,
  -1041371860,
  1075847264,
  -469959649,
  2041688520,
  -1235526675,
  -731223362,
  -1916023994,
  1740553945,
  1916352843,
  -1807070498,
  -1739830060,
  -1336387352,
  -2049978550,
  -1143943061,
  -974131414,
  1336584933,
  -302253290,
  -2042412091,
  -1706209833,
  1714631509,
  293963156,
  -1975171633,
  -369493744,
  67240454,
  -25198719,
  -1605349136,
  2017213508,
  631218106,
  1269344483,
  -1571728909,
  1571005438,
  -2143272768,
  93294474,
  1066570413,
  563977660,
  1882732616,
  -235539196,
  1673313503,
  2008463041,
  -1344611723,
  1109467491,
  537923632,
  -436207846,
  -34344178,
  -1076702611,
  -2117218996,
  403442708,
  638784309,
  -1007883217,
  -1101045791,
  899127202,
  -2008791860,
  773265209,
  -1815821225,
  1437050866,
  -58818942,
  2050833735,
  -932944724,
  -1168286233,
  840505643,
  -428641387,
  -1067425632,
  427917720,
  -1638969391,
  -1545806721,
  1143087718,
  1412049534,
  999329963,
  193497219,
  -1941551414,
  -940642775,
  1807268051,
  672404540,
  -1478566279,
  -1134666014,
  369822493,
  -1378100362,
  -606019525,
  1681011286,
  1949973070,
  336202270,
  -1840690725,
  201721354,
  1210328172,
  -1201906460,
  -1614626211,
  -1110191250,
  1135389935,
  -1000185178,
  965841320,
  831886756,
  -739974089,
  -226920053,
  -706222286,
  -1949775805,
  1849112409,
  -630362697,
  26054028,
  -1311386268,
  -1672589614,
  1235855840,
  -663982924,
  -1403627782,
  -202050553,
  -806688219,
  -899324497,
  -193299826,
  1202630377,
  268961816,
  1874508501,
  -260540280,
  1243948399,
  1546530418,
  941366308,
  1470539505,
  1941222599,
  -1748580783,
  -873928669,
  -1579295364,
  -395021156,
  1042226977,
  -1773450275,
  1639824860,
  227249030,
  260737669,
  -529502064,
  2084453954,
  1907733956,
  -865704278,
  -1874310952,
  100860677,
  -134810111,
  470683154,
  -1033805405,
  1781871967,
  -1370007559,
  1773779408,
  394692241,
  -1715355304,
  974986535,
  664706745,
  -639508168,
  -336005101,
  731420851,
  571543859,
  -764843589,
  -1445340816,
  126783113,
  865375399,
  765172662,
  1008606754,
  361203602,
  -907417312,
  -2016489911,
  -1437248001,
  1344809080,
  -1512054918,
  59542671,
  1503764984,
  160008576,
  437062935,
  1707065306,
  -672733647,
  -2076032314,
  -798463816,
  -2109652541,
  697932208,
  1512910199,
  504303377,
  2075177163,
  -1470868228,
  1841019862,
  739644986,
  1667457891,
  2088533116,
  2004318071,
  2071690107,
  -218959118,
  1802201963,
  1869573999,
  -976894523,
  808464432,
  16843009,
  1734829927,
  724249387,
  -16843010,
  -673720361,
  -1414812757,
  1987475062,
  -892679478,
  -2105376126,
  -909522487,
  2105376125,
  -84215046,
  1499027801,
  1195853639,
  -252645136,
  -1381126739,
  -724249388,
  -1566399838,
  -1347440721,
  -1667457892,
  -1532713820,
  1920103026,
  -1061109568,
  -1212696649,
  -33686019,
  -1819044973,
  640034342,
  909522486,
  1061109567,
  -134744073,
  -858993460,
  875836468,
  -1515870811,
  -437918235,
  -235802127,
  1903260017,
  -656877352,
  825307441,
  353703189,
  67372036,
  -943208505,
  589505315,
  -1010580541,
  404232216,
  -1768515946,
  84215045,
  -1701143910,
  117901063,
  303174162,
  -2139062144,
  -488447262,
  -336860181,
  656877351,
  -1296911694,
  1970632053,
  151587081,
  -2088533117,
  741092396,
  437918234,
  454761243,
  1852730990,
  1515870810,
  -1600085856,
  1381126738,
  993737531,
  -690563370,
  -1280068685,
  690563369,
  -471604253,
  791621423,
  -2071690108,
  1397969747,
  -774778415,
  0,
  -303174163,
  538976288,
  -50529028,
  -1313754703,
  1532713819,
  1785358954,
  -875836469,
  -1094795586,
  960051513,
  1246382666,
  1280068684,
  1482184792,
  -808464433,
  -791621424,
  -269488145,
  -1431655766,
  -67372037,
  1128481603,
  1296911693,
  858993459,
  -2054847099,
  1162167621,
  -101058055,
  33686018,
  2139062143,
  1347440720,
  1010580540,
  -1616928865,
  -1465341784,
  1364283729,
  -1549556829,
  1077952576,
  -1886417009,
  -1835887982,
  -1650614883,
  943208504,
  -168430091,
  -1128481604,
  -1229539658,
  -623191334,
  555819297,
  269488144,
  -1,
  -202116109,
  -757935406,
  -842150451,
  202116108,
  320017171,
  -320017172,
  1600085855,
  -1751672937,
  1145324612,
  387389207,
  -993737532,
  -1482184793,
  2122219134,
  1027423549,
  1684300900,
  1566399837,
  421075225,
  1936946035,
  1616928864,
  -2122219135,
  1330597711,
  -589505316,
  572662306,
  707406378,
  -1869574000,
  -2004318072,
  1179010630,
  -286331154,
  -1195853640,
  336860180,
  -555819298,
  1583242846,
  185273099,
  -606348325,
  -522133280,
  842150450,
  976894522,
  168430090,
  1229539657,
  101058054,
  606348324,
  1549556828,
  -1027423550,
  -741092397,
  -1397969748,
  1650614882,
  -1852730991,
  -1785358955,
  -454761244,
  2038004089,
  -404232217,
  -926365496,
  926365495,
  1835887981,
  -1920103027,
  -707406379,
  1313754702,
  -1448498775,
  1819044972,
  1448498774,
  -185273100,
  -353703190,
  1701143909,
  2054847098,
  -1364283730,
  134744072,
  -1162167622,
  2021161080,
  623191333,
  774778414,
  471604252,
  -1499027802,
  -1263225676,
  -960051514,
  -387389208,
  -572662307,
  1953789044,
  522133279,
  1263225675,
  -1111638595,
  -1953789045,
  -1970632054,
  1886417008,
  1044266558,
  -1246382667,
  1717986918,
  1212696648,
  50529027,
  -151587082,
  235802126,
  1633771873,
  892679477,
  1465341783,
  -1179010631,
  -2038004090,
  -1044266559,
  488447261,
  -1633771874,
  -505290271,
  -117901064,
  -1734829928,
  286331153,
  1768515945,
  -640034343,
  -1903260018,
  -1802201964,
  -1684300901,
  505290270,
  -2021161081,
  -370546199,
  -825307442,
  1431655765,
  673720360,
  -538976289,
  -1936946036,
  -1583242847,
  -1987475063,
  218959117,
  -1077952577,
  -421075226,
  1111638594,
  1751672936,
  1094795585,
  -1717986919,
  757935405,
  252645135,
  -1330597712,
  1414812756,
  -1145324613,
  370546198
}; // weak
int dword_47CF70[256] =
{
  1374988112,
  2118214995,
  437757123,
  975658646,
  1001089995,
  530400753,
  -1392879445,
  1273168787,
  540080725,
  -1384747530,
  -1999866223,
  -184398811,
  1340463100,
  -987051049,
  641025152,
  -1251826801,
  -558802359,
  632953703,
  1172967064,
  1576976609,
  -1020300030,
  -2125664238,
  -1924753501,
  1809054150,
  59727847,
  361929877,
  -1083344149,
  -1789765158,
  -725712083,
  1484005843,
  1239443753,
  -1899378620,
  1975683434,
  -191989384,
  -1722270101,
  666464733,
  -1092530250,
  -259478249,
  -920605594,
  2110667444,
  1675577880,
  -451268222,
  -1756286112,
  1649639237,
  -1318815776,
  -1150570876,
  -25059300,
  -116905068,
  1883793496,
  -1891238631,
  -1797362553,
  1383856311,
  -1418472669,
  1917518562,
  -484470953,
  1716890410,
  -1293211641,
  800440835,
  -2033878118,
  -751368027,
  807962610,
  599762354,
  33778362,
  -317291940,
  -1966138325,
  -1485196142,
  -217582864,
  1315562145,
  1708848333,
  101039829,
  -785096161,
  -995688822,
  875451293,
  -1561111136,
  92987698,
  -1527321739,
  193195065,
  1080094634,
  1584504582,
  -1116860335,
  1042385657,
  -1763899843,
  -583137874,
  1306967366,
  -1856729675,
  1908694277,
  67556463,
  1615861247,
  429456164,
  -692196969,
  -1992277044,
  1742315127,
  -1326955843,
  126454664,
  -417768648,
  2043211483,
  -1585706425,
  2084704233,
  -125559095,
  0,
  159417987,
  841739592,
  504459436,
  1817866830,
  -49348613,
  260388950,
  1034867998,
  908933415,
  168810852,
  1750902305,
  -1688513327,
  607530554,
  202008497,
  -1822955761,
  -1259432238,
  463180190,
  -2134850225,
  1641816226,
  1517767529,
  470948374,
  -493635062,
  -1063245083,
  1008918595,
  303765277,
  235474187,
  -225720403,
  766945465,
  337553864,
  1475418501,
  -1351284916,
  -291906117,
  -1551933187,
  -150919521,
  1551037884,
  1147550661,
  1543208500,
  -1958532746,
  -886847780,
  -1225917336,
  -1192955549,
  -684598070,
  1113818384,
  328671808,
  -2067394272,
  -2058738563,
  -759480840,
  -1359400431,
  -953573011,
  496906059,
  -592301837,
  226906860,
  2009195472,
  733156972,
  -1452230247,
  294930682,
  1206477858,
  -1459843900,
  -1594867942,
  1451044056,
  573804783,
  -2025238841,
  -650587711,
  -1932877058,
  -1730933962,
  -1493859889,
  -1518674392,
  -625504730,
  1068351396,
  742039012,
  1350078989,
  1784663195,
  1417561698,
  -158526526,
  -1864845080,
  775550814,
  -2101104651,
  -1621262146,
  1775276924,
  1876241833,
  -819653965,
  -928212677,
  270040487,
  -392404114,
  -616842373,
  -853116919,
  1851332852,
  -325404927,
  -2091935064,
  -426414491,
  -1426069890,
  566021896,
  -283776794,
  -1159226407,
  1248802510,
  -358676012,
  699432150,
  832877231,
  708780849,
  -962227152,
  899835584,
  1951317047,
  -58537306,
  -527380304,
  866637845,
  -251357110,
  1106041591,
  2144161806,
  395441711,
  1984812685,
  1139781709,
  -861254316,
  -459930401,
  -1630423581,
  1282050075,
  -1054072904,
  1181045119,
  -1654724092,
  25965917,
  -91786125,
  -83148498,
  -1285087910,
  -1831087534,
  -384805325,
  1842759443,
  -1697160820,
  933301370,
  1509430414,
  -351060855,
  -827774994,
  -1218328267,
  -518199827,
  2051518780,
  -1663901863,
  1441952575,
  404016761,
  1942435775,
  1408749034,
  1610459739,
  -549621996,
  2017778566,
  -894438527,
  -1184316354,
  941896748,
  -1029488545,
  371049330,
  -1126030068,
  675039627,
  -15887039,
  967311729,
  135050206,
  -659233636,
  1683407248,
  2076935265,
  -718096784,
  1215061108,
  -793225406
}; // weak
int dword_47D370[256] =
{
  1381126738,
  151587081,
  1785358954,
  -707406379,
  808464432,
  909522486,
  -1515870811,
  943208504,
  -1077952577,
  1077952576,
  -1549556829,
  -1633771874,
  -2122219135,
  -202116109,
  -673720361,
  -67372037,
  2088533116,
  -471604253,
  960051513,
  -2105376126,
  -1684300901,
  791621423,
  -1,
  -2021161081,
  875836468,
  -1903260018,
  1128481603,
  1145324612,
  -993737532,
  -555819298,
  -370546199,
  -875836469,
  1414812756,
  2071690107,
  -1802201964,
  842150450,
  -1499027802,
  -1027423550,
  589505315,
  1027423549,
  -286331154,
  1280068684,
  -1785358955,
  185273099,
  1111638594,
  -84215046,
  -1010580541,
  1313754702,
  134744072,
  774778414,
  -1583242847,
  1717986918,
  673720360,
  -640034343,
  606348324,
  -1296911694,
  1987475062,
  1532713819,
  -1566399838,
  1229539657,
  1835887981,
  -1953789045,
  -774778415,
  623191333,
  1920103026,
  -117901064,
  -151587082,
  1684300900,
  -2038004090,
  1751672936,
  -1734829928,
  370546198,
  -724249388,
  -1532713820,
  1549556828,
  -858993460,
  1566399837,
  1701143909,
  -1229539658,
  -1835887982,
  1819044972,
  1886417008,
  1212696648,
  1347440720,
  -33686019,
  -303174163,
  -1179010631,
  -623191334,
  1583242846,
  353703189,
  1179010630,
  1465341783,
  -1482184793,
  -1920103027,
  -1650614883,
  -2071690108,
  -1869574000,
  -656877352,
  -1414812757,
  0,
  -1936946036,
  -1128481604,
  -741092397,
  168430090,
  -134744073,
  -454761244,
  1482184792,
  84215045,
  -1195853640,
  -1280068685,
  1162167621,
  101058054,
  -791621424,
  741092396,
  505290270,
  -1886417009,
  -892679478,
  1061109567,
  252645135,
  33686018,
  -1044266559,
  -1347440721,
  -1111638595,
  50529027,
  16843009,
  320017171,
  -1970632054,
  1802201963,
  976894522,
  -1852730991,
  286331153,
  1094795585,
  1330597711,
  1734829927,
  -589505316,
  -353703190,
  -1751672937,
  -218959118,
  -808464433,
  -825307442,
  -252645136,
  -1263225676,
  -421075226,
  1936946035,
  -1768515946,
  -1397969748,
  1953789044,
  572662306,
  -404232217,
  -1381126739,
  892679477,
  -2054847099,
  -488447262,
  -101058055,
  926365495,
  -387389208,
  471604252,
  1970632053,
  -538976289,
  1852730990,
  1195853639,
  -235802127,
  437918234,
  1903260017,
  488447261,
  690563369,
  -976894523,
  -1987475063,
  1869573999,
  -1212696649,
  1650614882,
  235802126,
  -1431655766,
  404232216,
  -1094795586,
  454761243,
  -50529028,
  1448498774,
  1044266558,
  1263225675,
  -960051514,
  -757935406,
  2038004089,
  538976288,
  -1701143910,
  -606348325,
  -1061109568,
  -16843010,
  2021161080,
  -842150451,
  1515870810,
  -185273100,
  522133279,
  -572662307,
  -1465341784,
  858993459,
  -2004318072,
  117901063,
  -943208505,
  825307441,
  -1313754703,
  303174162,
  269488144,
  1499027801,
  656877351,
  -2139062144,
  -320017172,
  1600085855,
  1616928864,
  1364283729,
  2139062143,
  -1448498775,
  421075225,
  -1246382667,
  1246382666,
  218959117,
  757935405,
  -437918235,
  2054847098,
  -1616928865,
  -1819044973,
  -909522487,
  -1667457892,
  -269488145,
  -1600085856,
  -522133280,
  993737531,
  1296911693,
  -1364283730,
  707406378,
  -168430091,
  -1330597712,
  -926365496,
  -336860181,
  -1145324613,
  1010580540,
  -2088533117,
  1397969747,
  -1717986919,
  1633771873,
  387389207,
  724249387,
  67372036,
  2122219134,
  -1162167622,
  2004318071,
  -690563370,
  640034342,
  -505290271,
  1768515945,
  336860180,
  1667457891,
  1431655765,
  555819297,
  202116108,
  2105376125
}; // weak
int dword_47D770[256] =
{
  -1513725085,
  -2064089988,
  -1712425097,
  -1913226373,
  234877682,
  -1110021269,
  -1310822545,
  1418839493,
  1348481072,
  50462977,
  -1446090905,
  2102799147,
  434634494,
  1656084439,
  -431117397,
  -1695779210,
  1167051466,
  -1658879358,
  1082771913,
  -2013627011,
  368048890,
  -340633255,
  -913422521,
  201060592,
  -331240019,
  1739838676,
  -44064094,
  -364531793,
  -1088185188,
  -145513308,
  -1763413390,
  1536934080,
  -1032472649,
  484572669,
  -1371696237,
  1783375398,
  1517041206,
  1098792767,
  49674231,
  1334037708,
  1550332980,
  -195975771,
  886171109,
  150598129,
  -1813876367,
  1940642008,
  1398944049,
  1059722517,
  201851908,
  1385547719,
  1699095331,
  1587397571,
  674240536,
  -1590192490,
  252314885,
  -1255171430,
  151914247,
  908333586,
  -1692696448,
  1038082786,
  651029483,
  1766729511,
  -847269198,
  -1612024459,
  454166793,
  -1642232957,
  1951935532,
  775166490,
  758520603,
  -1294176658,
  -290170278,
  -77881184,
  -157003182,
  1299594043,
  1639438038,
  -830622797,
  2068982057,
  1054729187,
  1901997871,
  -1760328572,
  -173649069,
  1757008337,
  0,
  750906861,
  1614815264,
  535035132,
  -931548751,
  -306816165,
  -1093375382,
  1183697867,
  -647512386,
  1265776953,
  -560706998,
  -728216500,
  -391096232,
  1250283471,
  1807470800,
  717615087,
  -447763798,
  384695291,
  -981056701,
  -677753523,
  1432761139,
  -1810791035,
  -813021883,
  283769337,
  100925954,
  -2114027649,
  -257929136,
  1148730428,
  -1171939425,
  -481580888,
  -207466159,
  -27417693,
  -1065336768,
  -1979347057,
  -1388342638,
  -1138647651,
  1215313976,
  82966005,
  -547111748,
  -1049119050,
  1974459098,
  1665278241,
  807407632,
  451280895,
  251524083,
  1841287890,
  1283575245,
  337120268,
  891687699,
  801369324,
  -507617441,
  -1573546089,
  -863484860,
  959321879,
  1469301956,
  -229267545,
  -2097381762,
  1199193405,
  -1396153244,
  -407216803,
  724703513,
  -1780059277,
  -1598005152,
  -1743158911,
  -778154161,
  2141445340,
  1715741218,
  2119445034,
  -1422159728,
  -2096396152,
  -896776634,
  700968686,
  -747915080,
  1009259540,
  2041044702,
  -490971554,
  487983883,
  1991105499,
  1004265696,
  1449407026,
  1316239930,
  504629770,
  -611169975,
  168560134,
  1816667172,
  -457679780,
  1570751170,
  1857934291,
  -280777556,
  -1497079198,
  -1472622191,
  -1540254315,
  936633572,
  -1947043463,
  852879335,
  1133234376,
  1500395319,
  -1210421907,
  -1946055283,
  1689376213,
  -761508274,
  -532043351,
  -1260884884,
  -89369002,
  133428468,
  634383082,
  -1345690267,
  -1896580486,
  -381178194,
  403703816,
  -714097990,
  -1997506440,
  1867130149,
  1918643758,
  607656988,
  -245913946,
  -948718412,
  1368901318,
  600565992,
  2090982877,
  -1662487436,
  557719327,
  -577352885,
  -597574211,
  -2045932661,
  -2062579062,
  -1864339344,
  1115438654,
  -999180875,
  -1429445018,
  -661632952,
  84280067,
  33027830,
  303828494,
  -1547542175,
  1600795957,
  -106014889,
  -798377543,
  -1860729210,
  1486471617,
  658119965,
  -1188585826,
  953803233,
  334231800,
  -1288988520,
  857870609,
  -1143838359,
  1890179545,
  -1995993458,
  -1489791852,
  -1238525029,
  574365214,
  -1844082809,
  550103529,
  1233637070,
  -5614251,
  2018519080,
  2057691103,
  -1895592820,
  -128343647,
  -2146858615,
  387583245,
  -630865985,
  836232934,
  -964410814,
  -1194301336,
  -1014873791,
  -1339450983,
  2002398509,
  287182607,
  -881086288,
  -56077228,
  -697451589,
  975967766
}; // weak
int dword_47DB70[256] =
{
  1671808611,
  2089089148,
  2006576759,
  2072901243,
  -233963534,
  1807603307,
  1873927791,
  -984313403,
  810573872,
  16974337,
  1739181671,
  729634347,
  -31856642,
  -681396777,
  -1410970197,
  1989864566,
  -901410870,
  -2103631998,
  -918517303,
  2106063485,
  -99225606,
  1508618841,
  1204391495,
  -267650064,
  -1377025619,
  -731401260,
  -1560453214,
  -1343601233,
  -1665195108,
  -1527295068,
  1922491506,
  -1067738176,
  -1211992649,
  -48438787,
  -1817297517,
  644500518,
  911895606,
  1061256767,
  -150800905,
  -867204148,
  878471220,
  -1510714971,
  -449523227,
  -251069967,
  1905517169,
  -663508008,
  827548209,
  356461077,
  67897348,
  -950889017,
  593839651,
  -1017209405,
  405286936,
  -1767819370,
  84871685,
  -1699401830,
  118033927,
  305538066,
  -2137318528,
  -499261470,
  -349778453,
  661212711,
  -1295155278,
  1973414517,
  152769033,
  -2086789757,
  745822252,
  439235610,
  455947803,
  1857215598,
  1525593178,
  -1594139744,
  1391895634,
  994932283,
  -698239018,
  -1278313037,
  695947817,
  -482419229,
  795958831,
  -2070473852,
  1408607827,
  -781665839,
  0,
  -315833875,
  543178784,
  -65018884,
  -1312261711,
  1542305371,
  1790891114,
  -884568629,
  -1093048386,
  961245753,
  1256100938,
  1289001036,
  1491644504,
  -817199665,
  -798245936,
  -282409489,
  -1427812438,
  -82383365,
  1137018435,
  1305975373,
  861234739,
  -2053893755,
  1171229253,
  -116332039,
  33948674,
  2139225727,
  1357946960,
  1011120188,
  -1615190625,
  -1461498968,
  1374921297,
  -1543610973,
  1086357568,
  -1886780017,
  -1834139758,
  -1648615011,
  944271416,
  -184225291,
  -1126210628,
  -1228834890,
  -629821478,
  560153121,
  271589392,
  -15014401,
  -217121293,
  -764559406,
  -850624051,
  202643468,
  322250259,
  -332413972,
  1608629855,
  -1750977129,
  1154254916,
  389623319,
  -1000893500,
  -1477290585,
  2122513534,
  1028094525,
  1689045092,
  1575467613,
  422261273,
  1939203699,
  1621147744,
  -2120738431,
  1339137615,
  -595614756,
  577127458,
  712922154,
  -1867826288,
  -2004677752,
  1187679302,
  -299251730,
  -1194103880,
  339486740,
  -562452514,
  1591917662,
  186455563,
  -612979237,
  -532948000,
  844522546,
  978220090,
  169743370,
  1239126601,
  101321734,
  611076132,
  1558493276,
  -1034051646,
  -747717165,
  -1393605716,
  1655096418,
  -1851246191,
  -1784401515,
  -466103324,
  2039214713,
  -416098841,
  -935097400,
  928607799,
  1840765549,
  -1920204403,
  -714821163,
  1322425422,
  -1444918871,
  1823791212,
  1459268694,
  -200805388,
  -366620694,
  1706019429,
  2056189050,
  -1360443474,
  135794696,
  -1160417350,
  2022240376,
  628050469,
  779246638,
  472135708,
  -1494132826,
  -1261997132,
  -967731258,
  -400307224,
  -579034659,
  1956440180,
  522272287,
  1272813131,
  -1109630531,
  -1954148981,
  -1970991222,
  1888542832,
  1044544574,
  -1245417035,
  1722469478,
  1222152264,
  50660867,
  -167643146,
  236067854,
  1638122081,
  895445557,
  1475980887,
  -1177523783,
  -2037311610,
  -1051158079,
  489110045,
  -1632032866,
  -516367903,
  -132912136,
  -1733088360,
  288563729,
  1773916777,
  -646927911,
  -1903622258,
  -1800981612,
  -1682559589,
  505560094,
  -2020469369,
  -383727127,
  -834041906,
  1442818645,
  678973480,
  -545610273,
  -1936784500,
  -1577559647,
  -1988097655,
  219617805,
  -1076206145,
  -432941082,
  1120306242,
  1756942440,
  1103331905,
  -1716508263,
  762796589,
  252780047,
  -1328841808,
  1425844308,
  -1143575109,
  372911126
}; // weak
int dword_47DF70[256] =
{
  1667474886,
  2088535288,
  2004326894,
  2071694838,
  -219017729,
  1802223062,
  1869591006,
  -976923503,
  808472672,
  16843522,
  1734846926,
  724270422,
  -16901657,
  -673750347,
  -1414797747,
  1987484396,
  -892713585,
  -2105369313,
  -909557623,
  2105378810,
  -84273681,
  1499065266,
  1195886990,
  -252703749,
  -1381110719,
  -724277325,
  -1566376609,
  -1347425723,
  -1667449053,
  -1532692653,
  1920112356,
  -1061135461,
  -1212693899,
  -33743647,
  -1819038147,
  640051788,
  909531756,
  1061110142,
  -134806795,
  -859025533,
  875846760,
  -1515850671,
  -437963567,
  -235861767,
  1903268834,
  -656903253,
  825316194,
  353713962,
  67374088,
  -943238507,
  589522246,
  -1010606435,
  404236336,
  -1768513225,
  84217610,
  -1701137105,
  117901582,
  303183396,
  -2139055333,
  -488489505,
  -336910643,
  656894286,
  -1296904833,
  1970642922,
  151591698,
  -2088526307,
  741110872,
  437923380,
  454765878,
  1852748508,
  1515908788,
  -1600062629,
  1381168804,
  993742198,
  -690593353,
  -1280061827,
  690584402,
  -471646499,
  791638366,
  -2071685357,
  1398011302,
  -774805319,
  0,
  -303223615,
  538992704,
  -50585629,
  -1313748871,
  1532751286,
  1785380564,
  -875870579,
  -1094788761,
  960056178,
  1246420628,
  1280103576,
  1482221744,
  -808498555,
  -791647301,
  -269538619,
  -1431640753,
  -67430675,
  1128514950,
  1296947098,
  859002214,
  -2054843375,
  1162203018,
  -101117719,
  33687044,
  2139062782,
  1347481760,
  1010582648,
  -1616922075,
  -1465326773,
  1364325282,
  -1549533603,
  1077985408,
  -1886418427,
  -1835881153,
  -1650607071,
  943212656,
  -168491791,
  -1128472733,
  -1229536905,
  -623217233,
  555836226,
  269496352,
  -58651,
  -202174723,
  -757961281,
  -842183551,
  202118168,
  320025894,
  -320065597,
  1600119230,
  -1751670219,
  1145359496,
  387397934,
  -993765485,
  -1482165675,
  2122220284,
  1027426170,
  1684319432,
  1566435258,
  421079858,
  1936954854,
  1616945344,
  -2122213351,
  1330631070,
  -589529181,
  572679748,
  707427924,
  -1869567173,
  -2004319477,
  1179044492,
  -286381625,
  -1195846805,
  336870440,
  -555845209,
  1583276732,
  185277718,
  -606374227,
  -522175525,
  842159716,
  976899700,
  168435220,
  1229577106,
  101059084,
  606366792,
  1549591736,
  -1027449441,
  -741118275,
  -1397952701,
  1650632388,
  -1852725191,
  -1785355215,
  -454805549,
  2038008818,
  -404278571,
  -926399605,
  926374254,
  1835907034,
  -1920103423,
  -707435343,
  1313788572,
  -1448484791,
  1819063512,
  1448540844,
  -185333773,
  -353753649,
  1701162954,
  2054852340,
  -1364268729,
  134748176,
  -1162160785,
  2021165296,
  623210314,
  774795868,
  471606328,
  -1499008681,
  -1263220877,
  -960081513,
  -387439669,
  -572687199,
  1953799400,
  522133822,
  1263263126,
  -1111630751,
  -1953790451,
  -1970633457,
  1886425312,
  1044267644,
  -1246378895,
  1718004428,
  1212733584,
  50529542,
  -151649801,
  235803164,
  1633788866,
  892690282,
  1465383342,
  -1179004823,
  -2038001385,
  -1044293479,
  488449850,
  -1633765081,
  -505333543,
  -117959701,
  -1734823125,
  286339874,
  1768537042,
  -640061271,
  -1903261433,
  -1802197197,
  -1684294099,
  505291324,
  -2021158379,
  -370597687,
  -825341561,
  1431699370,
  673740880,
  -539002203,
  -1936945405,
  -1583220647,
  -1987477495,
  218961690,
  -1077945755,
  -421121577,
  1111672452,
  1751693520,
  1094828930,
  -1717981143,
  757954394,
  252645662,
  -1330590853,
  1414855848,
  -1145317779,
  370555436
}; // weak
int dword_47E370[256] =
{
  99,
  124,
  119,
  123,
  242,
  107,
  111,
  197,
  48,
  1,
  103,
  43,
  254,
  215,
  171,
  118,
  202,
  130,
  201,
  125,
  250,
  89,
  71,
  240,
  173,
  212,
  162,
  175,
  156,
  164,
  114,
  192,
  183,
  253,
  147,
  38,
  54,
  63,
  247,
  204,
  52,
  165,
  229,
  241,
  113,
  216,
  49,
  21,
  4,
  199,
  35,
  195,
  24,
  150,
  5,
  154,
  7,
  18,
  128,
  226,
  235,
  39,
  178,
  117,
  9,
  131,
  44,
  26,
  27,
  110,
  90,
  160,
  82,
  59,
  214,
  179,
  41,
  227,
  47,
  132,
  83,
  209,
  0,
  237,
  32,
  252,
  177,
  91,
  106,
  203,
  190,
  57,
  74,
  76,
  88,
  207,
  208,
  239,
  170,
  251,
  67,
  77,
  51,
  133,
  69,
  249,
  2,
  127,
  80,
  60,
  159,
  168,
  81,
  163,
  64,
  143,
  146,
  157,
  56,
  245,
  188,
  182,
  218,
  33,
  16,
  255,
  243,
  210,
  205,
  12,
  19,
  236,
  95,
  151,
  68,
  23,
  196,
  167,
  126,
  61,
  100,
  93,
  25,
  115,
  96,
  129,
  79,
  220,
  34,
  42,
  144,
  136,
  70,
  238,
  184,
  20,
  222,
  94,
  11,
  219,
  224,
  50,
  58,
  10,
  73,
  6,
  36,
  92,
  194,
  211,
  172,
  98,
  145,
  149,
  228,
  121,
  231,
  200,
  55,
  109,
  141,
  213,
  78,
  169,
  108,
  86,
  244,
  234,
  101,
  122,
  174,
  8,
  186,
  120,
  37,
  46,
  28,
  166,
  180,
  198,
  232,
  221,
  116,
  31,
  75,
  189,
  139,
  138,
  112,
  62,
  181,
  102,
  72,
  3,
  246,
  14,
  97,
  53,
  87,
  185,
  134,
  193,
  29,
  158,
  225,
  248,
  152,
  17,
  105,
  217,
  142,
  148,
  155,
  30,
  135,
  233,
  206,
  85,
  40,
  223,
  140,
  161,
  137,
  13,
  191,
  230,
  66,
  104,
  65,
  153,
  45,
  15,
  176,
  84,
  187,
  22
}; // weak
int dword_47E770[256] =
{
  25344,
  31744,
  30464,
  31488,
  61952,
  27392,
  28416,
  50432,
  12288,
  256,
  26368,
  11008,
  65024,
  55040,
  43776,
  30208,
  51712,
  33280,
  51456,
  32000,
  64000,
  22784,
  18176,
  61440,
  44288,
  54272,
  41472,
  44800,
  39936,
  41984,
  29184,
  49152,
  46848,
  64768,
  37632,
  9728,
  13824,
  16128,
  63232,
  52224,
  13312,
  42240,
  58624,
  61696,
  28928,
  55296,
  12544,
  5376,
  1024,
  50944,
  8960,
  49920,
  6144,
  38400,
  1280,
  39424,
  1792,
  4608,
  32768,
  57856,
  60160,
  9984,
  45568,
  29952,
  2304,
  33536,
  11264,
  6656,
  6912,
  28160,
  23040,
  40960,
  20992,
  15104,
  54784,
  45824,
  10496,
  58112,
  12032,
  33792,
  21248,
  53504,
  0,
  60672,
  8192,
  64512,
  45312,
  23296,
  27136,
  51968,
  48640,
  14592,
  18944,
  19456,
  22528,
  52992,
  53248,
  61184,
  43520,
  64256,
  17152,
  19712,
  13056,
  34048,
  17664,
  63744,
  512,
  32512,
  20480,
  15360,
  40704,
  43008,
  20736,
  41728,
  16384,
  36608,
  37376,
  40192,
  14336,
  62720,
  48128,
  46592,
  55808,
  8448,
  4096,
  65280,
  62208,
  53760,
  52480,
  3072,
  4864,
  60416,
  24320,
  38656,
  17408,
  5888,
  50176,
  42752,
  32256,
  15616,
  25600,
  23808,
  6400,
  29440,
  24576,
  33024,
  20224,
  56320,
  8704,
  10752,
  36864,
  34816,
  17920,
  60928,
  47104,
  5120,
  56832,
  24064,
  2816,
  56064,
  57344,
  12800,
  14848,
  2560,
  18688,
  1536,
  9216,
  23552,
  49664,
  54016,
  44032,
  25088,
  37120,
  38144,
  58368,
  30976,
  59136,
  51200,
  14080,
  27904,
  36096,
  54528,
  19968,
  43264,
  27648,
  22016,
  62464,
  59904,
  25856,
  31232,
  44544,
  2048,
  47616,
  30720,
  9472,
  11776,
  7168,
  42496,
  46080,
  50688,
  59392,
  56576,
  29696,
  7936,
  19200,
  48384,
  35584,
  35328,
  28672,
  15872,
  46336,
  26112,
  18432,
  768,
  62976,
  3584,
  24832,
  13568,
  22272,
  47360,
  34304,
  49408,
  7424,
  40448,
  57600,
  63488,
  38912,
  4352,
  26880,
  55552,
  36352,
  37888,
  39680,
  7680,
  34560,
  59648,
  52736,
  21760,
  10240,
  57088,
  35840,
  41216,
  35072,
  3328,
  48896,
  58880,
  16896,
  26624,
  16640,
  39168,
  11520,
  3840,
  45056,
  21504,
  47872,
  5632
}; // weak
int dword_47EB70[256] =
{
  6488064,
  8126464,
  7798784,
  8060928,
  15859712,
  7012352,
  7274496,
  12910592,
  3145728,
  65536,
  6750208,
  2818048,
  16646144,
  14090240,
  11206656,
  7733248,
  13238272,
  8519680,
  13172736,
  8192000,
  16384000,
  5832704,
  4653056,
  15728640,
  11337728,
  13893632,
  10616832,
  11468800,
  10223616,
  10747904,
  7471104,
  12582912,
  11993088,
  16580608,
  9633792,
  2490368,
  3538944,
  4128768,
  16187392,
  13369344,
  3407872,
  10813440,
  15007744,
  15794176,
  7405568,
  14155776,
  3211264,
  1376256,
  262144,
  13041664,
  2293760,
  12779520,
  1572864,
  9830400,
  327680,
  10092544,
  458752,
  1179648,
  8388608,
  14811136,
  15400960,
  2555904,
  11665408,
  7667712,
  589824,
  8585216,
  2883584,
  1703936,
  1769472,
  7208960,
  5898240,
  10485760,
  5373952,
  3866624,
  14024704,
  11730944,
  2686976,
  14876672,
  3080192,
  8650752,
  5439488,
  13697024,
  0,
  15532032,
  2097152,
  16515072,
  11599872,
  5963776,
  6946816,
  13303808,
  12451840,
  3735552,
  4849664,
  4980736,
  5767168,
  13565952,
  13631488,
  15663104,
  11141120,
  16449536,
  4390912,
  5046272,
  3342336,
  8716288,
  4521984,
  16318464,
  131072,
  8323072,
  5242880,
  3932160,
  10420224,
  11010048,
  5308416,
  10682368,
  4194304,
  9371648,
  9568256,
  10289152,
  3670016,
  16056320,
  12320768,
  11927552,
  14286848,
  2162688,
  1048576,
  16711680,
  15925248,
  13762560,
  13434880,
  786432,
  1245184,
  15466496,
  6225920,
  9895936,
  4456448,
  1507328,
  12845056,
  10944512,
  8257536,
  3997696,
  6553600,
  6094848,
  1638400,
  7536640,
  6291456,
  8454144,
  5177344,
  14417920,
  2228224,
  2752512,
  9437184,
  8912896,
  4587520,
  15597568,
  12058624,
  1310720,
  14548992,
  6160384,
  720896,
  14352384,
  14680064,
  3276800,
  3801088,
  655360,
  4784128,
  393216,
  2359296,
  6029312,
  12713984,
  13828096,
  11272192,
  6422528,
  9502720,
  9764864,
  14942208,
  7929856,
  15138816,
  13107200,
  3604480,
  7143424,
  9240576,
  13959168,
  5111808,
  11075584,
  7077888,
  5636096,
  15990784,
  15335424,
  6619136,
  7995392,
  11403264,
  524288,
  12189696,
  7864320,
  2424832,
  3014656,
  1835008,
  10878976,
  11796480,
  12976128,
  15204352,
  14483456,
  7602176,
  2031616,
  4915200,
  12386304,
  9109504,
  9043968,
  7340032,
  4063232,
  11862016,
  6684672,
  4718592,
  196608,
  16121856,
  917504,
  6356992,
  3473408,
  5701632,
  12124160,
  8781824,
  12648448,
  1900544,
  10354688,
  14745600,
  16252928,
  9961472,
  1114112,
  6881280,
  14221312,
  9306112,
  9699328,
  10158080,
  1966080,
  8847360,
  15269888,
  13500416,
  5570560,
  2621440,
  14614528,
  9175040,
  10551296,
  8978432,
  851968,
  12517376,
  15073280,
  4325376,
  6815744,
  4259840,
  10027008,
  2949120,
  983040,
  11534336,
  5505024,
  12255232,
  1441792
}; // weak
int dword_47EF70[256] =
{
  1660944384,
  2080374784,
  1996488704,
  2063597568,
  -234881024,
  1795162112,
  1862270976,
  -989855744,
  805306368,
  16777216,
  1728053248,
  721420288,
  -33554432,
  -687865856,
  -1426063360,
  1979711488,
  -905969664,
  -2113929216,
  -922746880,
  2097152000,
  -100663296,
  1493172224,
  1191182336,
  -268435456,
  -1392508928,
  -738197504,
  -1577058304,
  -1358954496,
  -1677721600,
  -1543503872,
  1912602624,
  -1073741824,
  -1224736768,
  -50331648,
  -1828716544,
  637534208,
  905969664,
  1056964608,
  -150994944,
  -872415232,
  872415232,
  -1526726656,
  -452984832,
  -251658240,
  1895825408,
  -671088640,
  822083584,
  352321536,
  67108864,
  -956301312,
  587202560,
  -1023410176,
  402653184,
  -1778384896,
  83886080,
  -1711276032,
  117440512,
  301989888,
  2147483648,
  -503316480,
  -352321536,
  654311424,
  -1308622848,
  1962934272,
  150994944,
  -2097152000,
  738197504,
  436207616,
  452984832,
  1845493760,
  1509949440,
  -1610612736,
  1375731712,
  989855744,
  -704643072,
  -1291845632,
  687865856,
  -486539264,
  788529152,
  -2080374784,
  1392508928,
  -788529152,
  0,
  -318767104,
  536870912,
  -67108864,
  -1325400064,
  1526726656,
  1778384896,
  -889192448,
  -1107296256,
  956301312,
  1241513984,
  1275068416,
  1476395008,
  -822083584,
  -805306368,
  -285212672,
  -1442840576,
  -83886080,
  1124073472,
  1291845632,
  855638016,
  -2063597568,
  1157627904,
  -117440512,
  33554432,
  2130706432,
  1342177280,
  1006632960,
  -1627389952,
  -1476395008,
  1358954496,
  -1560281088,
  1073741824,
  -1895825408,
  -1845493760,
  -1660944384,
  939524096,
  -184549376,
  -1140850688,
  -1241513984,
  -637534208,
  553648128,
  268435456,
  -16777216,
  -218103808,
  -771751936,
  -855638016,
  201326592,
  318767104,
  -335544320,
  1593835520,
  -1761607680,
  1140850688,
  385875968,
  -1006632960,
  -1493172224,
  2113929216,
  1023410176,
  1677721600,
  1560281088,
  419430400,
  1929379840,
  1610612736,
  -2130706432,
  1325400064,
  -603979776,
  570425344,
  704643072,
  -1879048192,
  -2013265920,
  1174405120,
  -301989888,
  -1207959552,
  335544320,
  -570425344,
  1577058304,
  184549376,
  -620756992,
  -536870912,
  838860800,
  973078528,
  167772160,
  1224736768,
  100663296,
  603979776,
  1543503872,
  -1040187392,
  -754974720,
  -1409286144,
  1644167168,
  -1862270976,
  -1795162112,
  -469762048,
  2030043136,
  -419430400,
  -939524096,
  922746880,
  1828716544,
  -1929379840,
  -721420288,
  1308622848,
  -1459617792,
  1811939328,
  1442840576,
  -201326592,
  -369098752,
  1694498816,
  2046820352,
  -1375731712,
  134217728,
  -1174405120,
  2013265920,
  620756992,
  771751936,
  469762048,
  -1509949440,
  -1275068416,
  -973078528,
  -402653184,
  -587202560,
  1946157056,
  520093696,
  1258291200,
  -1124073472,
  -1962934272,
  -1979711488,
  1879048192,
  1040187392,
  -1258291200,
  1711276032,
  1207959552,
  50331648,
  -167772160,
  234881024,
  1627389952,
  889192448,
  1459617792,
  -1191182336,
  -2046820352,
  -1056964608,
  486539264,
  -1644167168,
  -520093696,
  -134217728,
  -1744830464,
  285212672,
  1761607680,
  -654311424,
  -1912602624,
  -1811939328,
  -1694498816,
  503316480,
  -2030043136,
  -385875968,
  -838860800,
  1426063360,
  671088640,
  -553648128,
  -1946157056,
  -1593835520,
  -1996488704,
  218103808,
  -1090519040,
  -436207616,
  1107296256,
  1744830464,
  1090519040,
  -1728053248,
  754974720,
  251658240,
  -1342177280,
  1409286144,
  -1157627904,
  369098752
}; // weak
int dword_47F370[256] =
{
  1347548327,
  1400783205,
  -1021700188,
  -1774573730,
  -885281941,
  -249586363,
  -1414727080,
  -1823743229,
  1428173050,
  -156404115,
  -1853305738,
  636813900,
  -61872681,
  -674944309,
  -2144979644,
  -1883938141,
  1239331162,
  1730525723,
  -1740248562,
  -513933632,
  46346101,
  310463728,
  -1551022441,
  -966011911,
  -419197089,
  -1793748324,
  -339776134,
  -627748263,
  768917123,
  -749177823,
  692707433,
  1150208456,
  1786102409,
  2029293177,
  1805211710,
  -584599183,
  -1229004465,
  401639597,
  1724457132,
  -1266823622,
  409198410,
  -2098914767,
  1620529459,
  1164071807,
  -525245321,
  -2068091986,
  486441376,
  -1795618773,
  1483753576,
  428819965,
  -2020286868,
  -1219331080,
  598438867,
  -495826174,
  1474502543,
  711349675,
  129166120,
  53458370,
  -1702443653,
  -1512884472,
  -231724921,
  -1306280027,
  -1174273174,
  1559041666,
  730517276,
  -1834518092,
  -252508174,
  -1588696606,
  -848962828,
  -721025602,
  533804130,
  -1966823682,
  -1657524653,
  -1599933611,
  839224033,
  1973745387,
  957055980,
  -1438621457,
  106852767,
  1371368976,
  -113368694,
  1033297158,
  -1361232379,
  1179510461,
  -1248766835,
  91341917,
  1862534868,
  -10465259,
  605657339,
  -1747534359,
  -863420349,
  2003294622,
  -1112479678,
  -2012771957,
  954669403,
  -612775698,
  1201765386,
  -377732593,
  -906460130,
  0,
  -2096529274,
  1211247597,
  -1407315600,
  1315723890,
  -67301633,
  1443857720,
  507358933,
  657861945,
  1678381017,
  560487590,
  -778347692,
  975451694,
  -1324610969,
  261314535,
  -759894378,
  -1642357871,
  1333838021,
  -1570644960,
  1767536459,
  370938394,
  182621114,
  -440360918,
  1128014560,
  487725847,
  185469197,
  -1376613433,
  -1188186456,
  -938205527,
  -2057834215,
  1286567175,
  -1141990947,
  -39616672,
  -1611202266,
  -1134791947,
  -985373125,
  878443390,
  1988838185,
  -590666810,
  1756818940,
  1673061617,
  -891866660,
  272786309,
  1075025698,
  545572369,
  2105887268,
  -120407235,
  296679730,
  1841768865,
  1260232239,
  -203640272,
  -334657966,
  -797457949,
  1814803222,
  -1716948807,
  -99511224,
  575138148,
  -995558260,
  446754879,
  -665420500,
  -282971248,
  -947435186,
  -1042728751,
  -24327518,
  915985419,
  -811141759,
  681933534,
  651868046,
  -1539330625,
  -466863459,
  223377554,
  -1687527476,
  1649704518,
  -1024029421,
  -393160520,
  1580087799,
  -175979601,
  -1096852096,
  2087309459,
  -1452288723,
  -1278270190,
  1003007129,
  -1492117379,
  1860738147,
  2077965243,
  164439672,
  -194094824,
  32283319,
  -1467789414,
  1709610350,
  2125135846,
  136428751,
  -420538904,
  -642062437,
  -833982666,
  -722821367,
  -701910916,
  -1355701070,
  824852259,
  818324884,
  -1070226842,
  930369212,
  -1493400886,
  -1327460144,
  355706840,
  1257309336,
  -146674470,
  243256656,
  790073846,
  -1921626666,
  1296297904,
  1422699085,
  -538667516,
  -476130891,
  457992840,
  -1195299809,
  2135319889,
  77422314,
  1560382517,
  1945798516,
  788204353,
  1521706781,
  1385356242,
  870912086,
  325965383,
  -1936009375,
  2050466060,
  -1906706412,
  -1981082820,
  -288446169,
  901210569,
  -304014107,
  1014646705,
  1503449823,
  1062597235,
  2031621326,
  -1082931401,
  -363595827,
  1533017514,
  350174575,
  -2038938405,
  -2117423117,
  1052338372,
  741876788,
  1606591296,
  1914052035,
  213705253,
  -1960297399,
  1107234197,
  1899603969,
  -569897805,
  -1663519516,
  -1872472383,
  1635502980,
  1893020342,
  1950903388,
  1120974935
}; // weak
int dword_47F770[256] =
{
  -1487908364,
  1699970625,
  -1530717673,
  1586903591,
  1808481195,
  1173430173,
  1487645946,
  59984867,
  -95084496,
  1844882806,
  1989249228,
  1277555970,
  -671330331,
  -875051734,
  1149249077,
  -1550863006,
  1514790577,
  459744698,
  244860394,
  -1058972162,
  1963115311,
  -267222708,
  -1750889146,
  -104436781,
  1608975247,
  -1667951214,
  2062270317,
  1507497298,
  -2094148418,
  567498868,
  1764313568,
  -935031095,
  -1989511742,
  2037970062,
  1047239000,
  1910319033,
  1337376481,
  -1390940024,
  -1402549984,
  984907214,
  1243112415,
  830661914,
  861968209,
  2135253587,
  2011214180,
  -1367032981,
  -1608712575,
  731183368,
  1750626376,
  -48656571,
  1820824798,
  -122203525,
  -752637069,
  48394827,
  -1890065633,
  -1423284651,
  671593195,
  -1039978571,
  2073724613,
  145085239,
  -2014171096,
  -1515052097,
  1790575107,
  -2107839210,
  472615631,
  -1265457287,
  -219090169,
  -492745111,
  -187865638,
  -1093335547,
  1646252340,
  -24460122,
  1402811438,
  1436590835,
  -516815478,
  -344611594,
  -331805821,
  -274055072,
  -1626972559,
  273792366,
  -1963377119,
  104699613,
  95345982,
  -1119466010,
  -1917480620,
  1560637892,
  -730921978,
  369057872,
  -81520232,
  -375925059,
  1137477952,
  -1636341799,
  1119727848,
  -1954019447,
  1530455833,
  -287606328,
  172466556,
  266959938,
  516552836,
  0,
  -2038232704,
  -314035669,
  1890328081,
  1917742170,
  -262898,
  945164165,
  -719438418,
  958871085,
  -647755249,
  -1507760036,
  1423022939,
  775562294,
  1739656202,
  -418409641,
  -1764576018,
  -1851909221,
  -984645440,
  547512796,
  1265195639,
  437656594,
  -1173691757,
  719700128,
  -532464606,
  387781147,
  218828297,
  -944901493,
  -1464259146,
  -1446505442,
  428169201,
  122466165,
  -574886247,
  1627235199,
  648017665,
  -172204942,
  1002783846,
  2117360635,
  695634755,
  -958608605,
  -60246291,
  -245122844,
  -590686415,
  -2062531997,
  574624663,
  287343814,
  612205898,
  1039717051,
  840019705,
  -1586641111,
  793451934,
  821288114,
  1391201670,
  -472877119,
  376187827,
  -1181111952,
  1224348052,
  1679968233,
  -1933268740,
  1058709744,
  752375421,
  -1863376333,
  1321699145,
  -775825096,
  -1560376118,
  188127444,
  -2117097739,
  -567761542,
  -1910056265,
  -1079754835,
  -1645990854,
  -1844621192,
  -862229921,
  1180849278,
  331544205,
  -1192718120,
  -144822727,
  -1342864701,
  -2134991011,
  -1820562992,
  766078933,
  313773861,
  -1724135252,
  2108100632,
  1668212892,
  -1149510853,
  2013908262,
  418672217,
  -1224610662,
  -1700232369,
  1852171925,
  -427906305,
  -821550660,
  -387518699,
  -1680229657,
  919489135,
  164948639,
  2094410160,
  -1297141340,
  590424639,
  -1808742747,
  1723872674,
  -1137216434,
  -895026046,
  -793714544,
  -669699161,
  -1739919100,
  -621329940,
  1343127501,
  -164685935,
  -695372211,
  -1337113617,
  1297403050,
  81781910,
  -1243373871,
  -2011476886,
  532201772,
  1367295589,
  -368796322,
  895287692,
  1953757831,
  1093597963,
  492483431,
  -766340389,
  1446242576,
  1192455638,
  1636604631,
  209336225,
  344873464,
  1015671571,
  669961897,
  -919226527,
  -437395172,
  -1321436601,
  -547775278,
  1933530610,
  -830924780,
  935293895,
  -840281097,
  -1436852227,
  1863638845,
  -611944380,
  -209597777,
  -1002522264,
  875313188,
  1080017571,
  -1015933411,
  621591778,
  1233856572,
  -1790836979,
  24197544,
  -1277294580,
  -459482956,
  -1047501738,
  -2073986101,
  -1234119374,
  1551124588,
  1463996600
}; // weak
int dword_47FB70[256] =
{
  -190361519,
  1097159550,
  396673818,
  660510266,
  -1418998981,
  -1656360673,
  -94852180,
  -486304949,
  821712160,
  1986918061,
  -864644728,
  38544885,
  -438830001,
  718002117,
  893681702,
  1654886325,
  -1319482914,
  -1172609243,
  -368142267,
  -20913827,
  796197571,
  1290801793,
  1184342925,
  -738605461,
  -1889540349,
  -1835231979,
  1836772287,
  1381620373,
  -1098699308,
  1948373848,
  -529979063,
  -909622130,
  -1031181707,
  -1904641804,
  1480485785,
  -1183720153,
  -514869570,
  -2001922064,
  548169417,
  -835013507,
  -548792221,
  439452389,
  1362321559,
  1400849762,
  1685577905,
  1806599355,
  -2120213250,
  137073913,
  1214797936,
  1174215055,
  -563312748,
  2079897426,
  1943217067,
  1258480242,
  529487843,
  1437280870,
  -349698126,
  -1245576401,
  -981755258,
  923313619,
  679998000,
  -1079659997,
  57326082,
  377642221,
  -820237430,
  2041877159,
  133361907,
  1776460110,
  -621490843,
  96392454,
  878845905,
  -1493267772,
  777231668,
  -212492126,
  -1964953083,
  -152341084,
  -2081670901,
  1626319424,
  1906247262,
  1846563261,
  562755902,
  -586793578,
  1040559837,
  -423803315,
  1418573201,
  -1000536719,
  114585348,
  1343618912,
  -1728371687,
  -1108764714,
  1078185097,
  -643926169,
  -398279248,
  -1987344377,
  425408743,
  -923870343,
  2081048481,
  1108339068,
  -2078357000,
  0,
  -2138668279,
  736970802,
  292596766,
  1517440620,
  251657213,
  -2059905521,
  -1361764803,
  758720310,
  265905162,
  1554391400,
  1532285339,
  908999204,
  174567692,
  1474760595,
  -292105548,
  -1684955621,
  -1060810880,
  -601841055,
  2001430874,
  303699484,
  -1816524062,
  -1607801408,
  585122620,
  454499602,
  151849742,
  -1949848078,
  -1230456531,
  514443284,
  -249985705,
  1963412655,
  -1713521682,
  2137062819,
  19308535,
  1928707164,
  1715193156,
  -75615141,
  1126790795,
  600235211,
  -302225226,
  -453942344,
  836553431,
  1669664834,
  -1759363053,
  -971956092,
  1243905413,
  -1153566510,
  -114159186,
  698445255,
  -1641067747,
  -1305414692,
  -2041385971,
  -1042034569,
  -1290376149,
  1891211689,
  -1807156719,
  -379313593,
  -57883480,
  -264299872,
  2100090966,
  865136418,
  1229899655,
  953270745,
  -895287668,
  -737462632,
  -176042074,
  2061379749,
  -1215420710,
  -1379949505,
  983426092,
  2022837584,
  1607244650,
  2118541908,
  -1928084746,
  -658970480,
  972512814,
  -1011878526,
  1568718495,
  -795640727,
  -718427793,
  621982671,
  -1399243832,
  410887952,
  -1671205144,
  1002142683,
  645401037,
  1494807662,
  -1699282452,
  1335535747,
  -1787927066,
  -1671510,
  -1127282655,
  367585007,
  -409216582,
  1865862730,
  -1626745622,
  -1333995991,
  -1531793615,
  1059270954,
  -1517014842,
  -1570324427,
  1320957812,
  -2100648196,
  -1865371424,
  -1479011021,
  77089521,
  -321194175,
  -850391425,
  -1846137065,
  1305906550,
  -273658557,
  -1437772596,
  -1778065436,
  -776608866,
  1787304780,
  740276417,
  1699839814,
  1592394909,
  -1942659839,
  -2022411270,
  188821243,
  1729977011,
  -606973294,
  274084841,
  -699985043,
  -681472870,
  -1593017801,
  -132870567,
  322734571,
  -1457000754,
  1640576439,
  484830689,
  1202797690,
  -757114468,
  -227328171,
  349075736,
  -952647821,
  -137500077,
  -39167137,
  1030690015,
  1155237496,
  -1342996022,
  1757691577,
  607398968,
  -1556062270,
  499347990,
  -500888388,
  1011452712,
  227885567,
  -1476300487,
  213114376,
  -1260086056,
  1455525988,
  -880516741,
  850817237,
  1817998408,
  -1202240816
}; // weak
int dword_47FF70[256] =
{
  0,
  235474187,
  470948374,
  303765277,
  941896748,
  908933415,
  607530554,
  708780849,
  1883793496,
  2118214995,
  1817866830,
  1649639237,
  1215061108,
  1181045119,
  1417561698,
  1517767529,
  -527380304,
  -291906117,
  -58537306,
  -225720403,
  -659233636,
  -692196969,
  -995688822,
  -894438527,
  -1864845080,
  -1630423581,
  -1932877058,
  -2101104651,
  -1459843900,
  -1493859889,
  -1259432238,
  -1159226407,
  -616842373,
  -718096784,
  -953573011,
  -920605594,
  -484470953,
  -317291940,
  -15887039,
  -251357110,
  -1418472669,
  -1518674392,
  -1218328267,
  -1184316354,
  -1822955761,
  -1654724092,
  -1891238631,
  -2125664238,
  1001089995,
  899835584,
  666464733,
  699432150,
  59727847,
  226906860,
  530400753,
  294930682,
  1273168787,
  1172967064,
  1475418501,
  1509430414,
  1942435775,
  2110667444,
  1876241833,
  1641816226,
  -1384747530,
  -1551933187,
  -1318815776,
  -1083344149,
  -1789765158,
  -1688513327,
  -1992277044,
  -2025238841,
  -583137874,
  -751368027,
  -1054072904,
  -819653965,
  -451268222,
  -351060855,
  -116905068,
  -150919521,
  1306967366,
  1139781709,
  1374988112,
  1610459739,
  1975683434,
  2076935265,
  1775276924,
  1742315127,
  1034867998,
  866637845,
  566021896,
  800440835,
  92987698,
  193195065,
  429456164,
  395441711,
  1984812685,
  2017778566,
  1784663195,
  1683407248,
  1315562145,
  1080094634,
  1383856311,
  1551037884,
  101039829,
  135050206,
  437757123,
  337553864,
  1042385657,
  807962610,
  573804783,
  742039012,
  -1763899843,
  -1730933962,
  -1966138325,
  -2067394272,
  -1359400431,
  -1594867942,
  -1293211641,
  -1126030068,
  -426414491,
  -392404114,
  -91786125,
  -191989384,
  -558802359,
  -793225406,
  -1029488545,
  -861254316,
  1106041591,
  1340463100,
  1576976609,
  1408749034,
  2043211483,
  2009195472,
  1708848333,
  1809054150,
  832877231,
  1068351396,
  766945465,
  599762354,
  159417987,
  126454664,
  361929877,
  463180190,
  -1585706425,
  -1351284916,
  -1116860335,
  -1285087910,
  -1722270101,
  -1756286112,
  -2058738563,
  -1958532746,
  -785096161,
  -549621996,
  -853116919,
  -1020300030,
  -384805325,
  -417768648,
  -184398811,
  -83148498,
  -1697160820,
  -1797362553,
  -2033878118,
  -1999866223,
  -1561111136,
  -1392879445,
  -1092530250,
  -1326955843,
  -358676012,
  -459930401,
  -158526526,
  -125559095,
  -759480840,
  -592301837,
  -827774994,
  -1063245083,
  2051518780,
  1951317047,
  1716890410,
  1750902305,
  1113818384,
  1282050075,
  1584504582,
  1350078989,
  168810852,
  67556463,
  371049330,
  404016761,
  841739592,
  1008918595,
  775550814,
  540080725,
  -325404927,
  -493635062,
  -259478249,
  -25059300,
  -725712083,
  -625504730,
  -928212677,
  -962227152,
  -1663901863,
  -1831087534,
  -2134850225,
  -1899378620,
  -1527321739,
  -1426069890,
  -1192955549,
  -1225917336,
  202008497,
  33778362,
  270040487,
  504459436,
  875451293,
  975658646,
  675039627,
  641025152,
  2084704233,
  1917518562,
  1615861247,
  1851332852,
  1147550661,
  1248802510,
  1484005843,
  1451044056,
  933301370,
  967311729,
  733156972,
  632953703,
  260388950,
  25965917,
  328671808,
  496906059,
  1206477858,
  1239443753,
  1543208500,
  1441952575,
  2144161806,
  1908694277,
  1675577880,
  1842759443,
  -684598070,
  -650587711,
  -886847780,
  -987051049,
  -283776794,
  -518199827,
  -217582864,
  -49348613,
  -1485196142,
  -1452230247,
  -1150570876,
  -1251826801,
  -1621262146,
  -1856729675,
  -2091935064,
  -1924753501
}; // weak
int dword_480370[256] =
{
  0,
  185469197,
  370938394,
  487725847,
  741876788,
  657861945,
  975451694,
  824852259,
  1483753576,
  1400783205,
  1315723890,
  1164071807,
  1950903388,
  2135319889,
  1649704518,
  1767536459,
  -1327460144,
  -1141990947,
  -1493400886,
  -1376613433,
  -1663519516,
  -1747534359,
  -1966823682,
  -2117423117,
  -393160520,
  -476130891,
  -24327518,
  -175979601,
  -995558260,
  -811141759,
  -759894378,
  -642062437,
  2077965243,
  1893020342,
  1841768865,
  1724457132,
  1474502543,
  1559041666,
  1107234197,
  1257309336,
  598438867,
  681933534,
  901210569,
  1052338372,
  261314535,
  77422314,
  428819965,
  310463728,
  -885281941,
  -1070226842,
  -584599183,
  -701910916,
  -419197089,
  -334657966,
  -249586363,
  -99511224,
  -1823743229,
  -1740248562,
  -2057834215,
  -1906706412,
  -1082931401,
  -1266823622,
  -1452288723,
  -1570644960,
  -156404115,
  -39616672,
  -525245321,
  -339776134,
  -627748263,
  -778347692,
  -863420349,
  -947435186,
  -1361232379,
  -1512884472,
  -1195299809,
  -1278270190,
  -2098914767,
  -1981082820,
  -1795618773,
  -1611202266,
  1179510461,
  1296297904,
  1347548327,
  1533017514,
  1786102409,
  1635502980,
  2087309459,
  2003294622,
  507358933,
  355706840,
  136428751,
  53458370,
  839224033,
  957055980,
  605657339,
  790073846,
  -1921626666,
  -2038938405,
  -1687527476,
  -1872472383,
  -1588696606,
  -1438621457,
  -1219331080,
  -1134791947,
  -721025602,
  -569897805,
  -1021700188,
  -938205527,
  -113368694,
  -231724921,
  -282971248,
  -466863459,
  1033297158,
  915985419,
  730517276,
  545572369,
  296679730,
  446754879,
  129166120,
  213705253,
  1709610350,
  1860738147,
  1945798516,
  2029293177,
  1239331162,
  1120974935,
  1606591296,
  1422699085,
  -146674470,
  -61872681,
  -513933632,
  -363595827,
  -612775698,
  -797457949,
  -848962828,
  -966011911,
  -1355701070,
  -1539330625,
  -1188186456,
  -1306280027,
  -2096529274,
  -2012771957,
  -1793748324,
  -1642357871,
  1201765386,
  1286567175,
  1371368976,
  1521706781,
  1805211710,
  1620529459,
  2105887268,
  1988838185,
  533804130,
  350174575,
  164439672,
  46346101,
  870912086,
  954669403,
  636813900,
  788204353,
  -1936009375,
  -2020286868,
  -1702443653,
  -1853305738,
  -1599933611,
  -1414727080,
  -1229004465,
  -1112479678,
  -722821367,
  -538667516,
  -1024029421,
  -906460130,
  -120407235,
  -203640272,
  -288446169,
  -440360918,
  1014646705,
  930369212,
  711349675,
  560487590,
  272786309,
  457992840,
  106852767,
  223377554,
  1678381017,
  1862534868,
  1914052035,
  2031621326,
  1211247597,
  1128014560,
  1580087799,
  1428173050,
  32283319,
  182621114,
  401639597,
  486441376,
  768917123,
  651868046,
  1003007129,
  818324884,
  1503449823,
  1385356242,
  1333838021,
  1150208456,
  1973745387,
  2125135846,
  1673061617,
  1756818940,
  -1324610969,
  -1174273174,
  -1492117379,
  -1407315600,
  -1657524653,
  -1774573730,
  -1960297399,
  -2144979644,
  -377732593,
  -495826174,
  -10465259,
  -194094824,
  -985373125,
  -833982666,
  -749177823,
  -665420500,
  2050466060,
  1899603969,
  1814803222,
  1730525723,
  1443857720,
  1560382517,
  1075025698,
  1260232239,
  575138148,
  692707433,
  878443390,
  1062597235,
  243256656,
  91341917,
  409198410,
  325965383,
  -891866660,
  -1042728751,
  -590666810,
  -674944309,
  -420538904,
  -304014107,
  -252508174,
  -67301633,
  -1834518092,
  -1716948807,
  -2068091986,
  -1883938141,
  -1096852096,
  -1248766835,
  -1467789414,
  -1551022441
}; // weak
int dword_480770[256] =
{
  0,
  218828297,
  437656594,
  387781147,
  875313188,
  958871085,
  775562294,
  590424639,
  1750626376,
  1699970625,
  1917742170,
  2135253587,
  1551124588,
  1367295589,
  1180849278,
  1265195639,
  -793714544,
  -574886247,
  -895026046,
  -944901493,
  -459482956,
  -375925059,
  -24460122,
  -209597777,
  -1192718120,
  -1243373871,
  -1560376118,
  -1342864701,
  -1933268740,
  -2117097739,
  -1764576018,
  -1680229657,
  -1149510853,
  -1234119374,
  -1586641111,
  -1402549984,
  -1890065633,
  -2107839210,
  -1790836979,
  -1739919100,
  -752637069,
  -567761542,
  -919226527,
  -1002522264,
  -418409641,
  -368796322,
  -48656571,
  -267222708,
  1808481195,
  1723872674,
  1910319033,
  2094410160,
  1608975247,
  1391201670,
  1173430173,
  1224348052,
  59984867,
  244860394,
  428169201,
  344873464,
  935293895,
  984907214,
  766078933,
  547512796,
  1844882806,
  1627235199,
  2011214180,
  2062270317,
  1507497298,
  1423022939,
  1137477952,
  1321699145,
  95345982,
  145085239,
  532201772,
  313773861,
  830661914,
  1015671571,
  731183368,
  648017665,
  -1119466010,
  -1337113617,
  -1487908364,
  -1436852227,
  -1989511742,
  -2073986101,
  -1820562992,
  -1636341799,
  -719438418,
  -669699161,
  -821550660,
  -1039978571,
  -516815478,
  -331805821,
  -81520232,
  -164685935,
  -695372211,
  -611944380,
  -862229921,
  -1047501738,
  -492745111,
  -274055072,
  -122203525,
  -172204942,
  -1093335547,
  -1277294580,
  -1530717673,
  -1446505442,
  -1963377119,
  -2014171096,
  -1863376333,
  -1645990854,
  104699613,
  188127444,
  472615631,
  287343814,
  840019705,
  1058709744,
  671593195,
  621591778,
  1852171925,
  1668212892,
  1953757831,
  2037970062,
  1514790577,
  1463996600,
  1080017571,
  1297403050,
  -621329940,
  -671330331,
  -1058972162,
  -840281097,
  -287606328,
  -472877119,
  -187865638,
  -104436781,
  -1297141340,
  -1079754835,
  -1464259146,
  -1515052097,
  -2038232704,
  -1954019447,
  -1667951214,
  -1851909221,
  172466556,
  122466165,
  273792366,
  492483431,
  1047239000,
  861968209,
  612205898,
  695634755,
  1646252340,
  1863638845,
  2013908262,
  1963115311,
  1446242576,
  1530455833,
  1277555970,
  1093597963,
  1636604631,
  1820824798,
  2073724613,
  1989249228,
  1436590835,
  1487645946,
  1337376481,
  1119727848,
  164948639,
  81781910,
  331544205,
  516552836,
  1039717051,
  821288114,
  669961897,
  719700128,
  -1321436601,
  -1137216434,
  -1423284651,
  -1507760036,
  -2062531997,
  -2011476886,
  -1626972559,
  -1844621192,
  -647755249,
  -730921978,
  -1015933411,
  -830924780,
  -314035669,
  -532464606,
  -144822727,
  -95084496,
  -1224610662,
  -1173691757,
  -1390940024,
  -1608712575,
  -2094148418,
  -1910056265,
  -1724135252,
  -1808742747,
  -547775278,
  -766340389,
  -984645440,
  -935031095,
  -344611594,
  -427906305,
  -245122844,
  -60246291,
  1739656202,
  1790575107,
  2108100632,
  1890328081,
  1402811438,
  1586903591,
  1233856572,
  1149249077,
  266959938,
  48394827,
  369057872,
  418672217,
  1002783846,
  919489135,
  567498868,
  752375421,
  209336225,
  24197544,
  376187827,
  459744698,
  945164165,
  895287692,
  574624663,
  793451934,
  1679968233,
  1764313568,
  2117360635,
  1933530610,
  1343127501,
  1560637892,
  1243112415,
  1192455638,
  -590686415,
  -775825096,
  -958608605,
  -875051734,
  -387518699,
  -437395172,
  -219090169,
  -262898,
  -1265457287,
  -1181111952,
  -1367032981,
  -1550863006,
  -2134991011,
  -1917480620,
  -1700232369,
  -1750889146
}; // weak
int dword_480B70[257] =
{
  0,
  151849742,
  303699484,
  454499602,
  607398968,
  758720310,
  908999204,
  1059270954,
  1214797936,
  1097159550,
  1517440620,
  1400849762,
  1817998408,
  1699839814,
  2118541908,
  2001430874,
  -1865371424,
  -1713521682,
  -2100648196,
  -1949848078,
  -1260086056,
  -1108764714,
  -1493267772,
  -1342996022,
  -658970480,
  -776608866,
  -895287668,
  -1011878526,
  -57883480,
  -176042074,
  -292105548,
  -409216582,
  1002142683,
  850817237,
  698445255,
  548169417,
  529487843,
  377642221,
  227885567,
  77089521,
  1943217067,
  2061379749,
  1640576439,
  1757691577,
  1474760595,
  1592394909,
  1174215055,
  1290801793,
  -1418998981,
  -1570324427,
  -1183720153,
  -1333995991,
  -1889540349,
  -2041385971,
  -1656360673,
  -1807156719,
  -486304949,
  -368142267,
  -249985705,
  -132870567,
  -952647821,
  -835013507,
  -718427793,
  -601841055,
  1986918061,
  2137062819,
  1685577905,
  1836772287,
  1381620373,
  1532285339,
  1078185097,
  1229899655,
  1040559837,
  923313619,
  740276417,
  621982671,
  439452389,
  322734571,
  137073913,
  19308535,
  -423803315,
  -273658557,
  -190361519,
  -39167137,
  -1031181707,
  -880516741,
  -795640727,
  -643926169,
  -1361764803,
  -1479011021,
  -1127282655,
  -1245576401,
  -1964953083,
  -2081670901,
  -1728371687,
  -1846137065,
  1305906550,
  1155237496,
  1607244650,
  1455525988,
  1776460110,
  1626319424,
  2079897426,
  1928707164,
  96392454,
  213114376,
  396673818,
  514443284,
  562755902,
  679998000,
  865136418,
  983426092,
  -586793578,
  -737462632,
  -820237430,
  -971956092,
  -114159186,
  -264299872,
  -349698126,
  -500888388,
  -1787927066,
  -1671205144,
  -2022411270,
  -1904641804,
  -1319482914,
  -1202240816,
  -1556062270,
  -1437772596,
  -321194175,
  -438830001,
  -20913827,
  -137500077,
  -923870343,
  -1042034569,
  -621490843,
  -738605461,
  -1531793615,
  -1379949505,
  -1230456531,
  -1079659997,
  -2138668279,
  -1987344377,
  -1835231979,
  -1684955621,
  2081048481,
  1963412655,
  1846563261,
  1729977011,
  1480485785,
  1362321559,
  1243905413,
  1126790795,
  878845905,
  1030690015,
  645401037,
  796197571,
  274084841,
  425408743,
  38544885,
  188821243,
  -681472870,
  -563312748,
  -981755258,
  -864644728,
  -212492126,
  -94852180,
  -514869570,
  -398279248,
  -1626745622,
  -1778065436,
  -1928084746,
  -2078357000,
  -1153566510,
  -1305414692,
  -1457000754,
  -1607801408,
  1202797690,
  1320957812,
  1437280870,
  1554391400,
  1669664834,
  1787304780,
  1906247262,
  2022837584,
  265905162,
  114585348,
  499347990,
  349075736,
  736970802,
  585122620,
  972512814,
  821712160,
  -1699282452,
  -1816524062,
  -2001922064,
  -2120213250,
  -1098699308,
  -1215420710,
  -1399243832,
  -1517014842,
  -757114468,
  -606973294,
  -1060810880,
  -909622130,
  -152341084,
  -1671510,
  -453942344,
  -302225226,
  174567692,
  57326082,
  410887952,
  292596766,
  777231668,
  660510266,
  1011452712,
  893681702,
  1108339068,
  1258480242,
  1343618912,
  1494807662,
  1715193156,
  1865862730,
  1948373848,
  2100090966,
  -1593017801,
  -1476300487,
  -1290376149,
  -1172609243,
  -2059905521,
  -1942659839,
  -1759363053,
  -1641067747,
  -379313593,
  -529979063,
  -75615141,
  -227328171,
  -850391425,
  -1000536719,
  -548792221,
  -699985043,
  836553431,
  953270745,
  600235211,
  718002117,
  367585007,
  484830689,
  133361907,
  251657213,
  2041877159,
  1891211689,
  1806599355,
  1654886325,
  1568718495,
  1418573201,
  1335535747,
  1184342925,
  16777216
}; // weak
_UNKNOWN unk_480F74; // weak
_UNKNOWN unk_480F8C; // weak
_UNKNOWN unk_480F90; // weak
void *off_480F98 = &byte_482B34; // weak
int dword_481010[] = { 608135816 }; // weak
_UNKNOWN unk_481058; // weak
char (*off_482058)[4] = &byte_482B2C; // weak
char byte_4820BC[52] =
{
  '%',
  'h',
  '\xD3',
  '\xC2',
  '(',
  '\xF2',
  'Y',
  '.',
  '\x94',
  '\xEE',
  '\xF2',
  '\x91',
  '\xAC',
  '\x13',
  '\x96',
  '\x95',
  'H',
  '\x17',
  '\xAE',
  '\x06',
  '\x91',
  '\xCC',
  's',
  ',',
  'l',
  'X',
  'K',
  'l',
  '+',
  '\x8B',
  '\xF3',
  'l',
  '}',
  '\xF0',
  '`',
  '\x17',
  '\x81',
  'J',
  '#',
  '\r',
  'i',
  'W',
  '!',
  'v',
  'u',
  '\xDD',
  '\xD1',
  '\xDE',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char byte_4820F0[264] =
{
  '\0',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\v',
  '\n',
  '\t',
  '\f',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\r',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x0E',
  '\x02',
  '\x0F',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b'
}; // weak
char byte_4821F8[36] =
{
  '\0',
  '\x10',
  '\x11',
  '\x11',
  '\x11',
  '\x12',
  '\x12',
  '\x12',
  '\x13',
  '\x13',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x15',
  '\x15',
  '\x16',
  '\x16',
  '\x17',
  '\x18',
  '\x18',
  '\x19',
  '\x19',
  '\x19',
  '\x1A',
  '\x1A',
  '\x1B',
  '\x1C',
  '\x1C',
  '\x1C',
  '\x1D',
  '\x1E',
  '\x1E',
  '\x1F',
  '\x1F'
}; // weak
char byte_48221C[36] =
{
  '\0',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x01',
  '\x03',
  '\x01',
  '\x02',
  '\x01',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x01',
  '\x03',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x03',
  '\x01',
  '\x03',
  '\x03',
  '\x01',
  '\x03',
  '\x02',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x03',
  '\x02',
  '\0',
  '\x01'
}; // weak
char byte_482240[] = { '\0' }; // weak
char byte_482268[32] =
{
  '\x17',
  '\v',
  '\f',
  '\x10',
  '\0',
  '\x1B',
  '\a',
  '\r',
  '\x0E',
  '\x1A',
  '!',
  '\0',
  '\0',
  ' ',
  '\0',
  '\0',
  '\xFF',
  '\x04',
  '\v',
  '\x13',
  '\f',
  '\r',
  '\x0E',
  '\x06',
  '\a',
  '\x10',
  '\x11',
  '\x1D',
  '\x1E',
  '\x12',
  '#',
  '$'
}; // weak
char byte_482288[40] =
{
  '\x12',
  '\xFA',
  '\x1C',
  '\x15',
  '\v',
  '\xE9',
  '\xE9',
  '\xFE',
  '\xE9',
  '\xE9',
  '\xE9',
  '\xE9',
  '\x0F',
  '\x14',
  '\x1D',
  '\x04',
  '\xE9',
  '\x06',
  '\xE9',
  '\xE9',
  '\x1D',
  '!',
  '\xE9',
  '\xFA',
  '\xFA',
  '\xFA',
  '\x1F',
  '\x15',
  '\xFA',
  '\xE9',
  '\"',
  ' ',
  '#',
  '\xFA',
  '\x05',
  '\xE9',
  '\xE9',
  '\xE9',
  '\xE9',
  '$'
}; // weak
char byte_4822B0[32] =
{
  '$',
  '\xE9',
  '\xE9',
  '\x0F',
  '\t',
  '!',
  '\xE9',
  '\xE9',
  '\xE9',
  '\xE9',
  '\xE9',
  '\0',
  '(',
  '\xE9',
  '\0',
  '\0',
  '\xE9',
  '\xE9',
  '\xE9',
  '\xE9',
  '\x16',
  '\xE9',
  ',',
  '\xEA',
  '\x01',
  '\xFF',
  '\x02',
  '\xE9',
  '\x1E',
  '\x11',
  '\xE9',
  '\x17'
}; // weak
char byte_4822D0[56] =
{
  '\b',
  '&',
  '\x05',
  '\x0F',
  '\x0F',
  '\x15',
  '2',
  '\x17',
  '\x18',
  '&',
  '\x19',
  '\x16',
  '\n',
  '\x1F',
  ' ',
  '5',
  '\x19',
  '!',
  '\x1F',
  '4',
  '\"',
  '\x01',
  '\x02',
  '\x03',
  '\x1A',
  '\'',
  '(',
  '\t',
  ',',
  '\x05',
  '-',
  '\x1B',
  '1',
  '\'',
  '\t',
  '\n',
  '\x05',
  ')',
  '/',
  '*',
  '\x05',
  '0',
  '\x1C',
  '\x05',
  '!',
  '\x17',
  '0',
  '\x14',
  '\"',
  '+',
  '%',
  '3',
  '\0',
  '.',
  '\0',
  '\0'
}; // weak
char byte_482308[112] =
{
  '\x01',
  '\x17',
  '\b',
  '\x02',
  '\x03',
  '\x03',
  '\x01',
  '\t',
  '\n',
  '\x1F',
  '\f',
  '\0',
  '\a',
  '\t',
  '\n',
  '\x0F',
  '\f',
  '\v',
  '\t',
  '\n',
  '\x0E',
  '\x03',
  '\x04',
  '\x05',
  '\t',
  '\x18',
  '\x19',
  '\x06',
  '\x1B',
  '\b',
  '\x1C',
  '\v',
  '!',
  ' ',
  '\x06',
  '\a',
  '\b',
  '\x06',
  '\x06',
  '\b',
  '\b',
  '\x06',
  '\r',
  '\b',
  '\v',
  '\t',
  '\x06',
  '\x03',
  '\x0E',
  '\x1B',
  '\x14',
  '\"',
  '\xFF',
  '\x1E',
  '\0',
  '\0',
  '\0',
  '\x03',
  '\x04',
  '\x05',
  '\x11',
  '\b',
  '\x17',
  '\x18',
  '\x19',
  '\x06',
  '\a',
  '\x12',
  '\x14',
  '\x15',
  '\x16',
  '\x18',
  '\x19',
  '\x1A',
  '\x1D',
  '\x13',
  '\x16',
  '\x1A',
  '\0',
  '\t',
  '\n',
  '\f',
  '\t',
  '\v',
  '\r',
  '\x1B',
  '\x1C',
  '\t',
  '\n',
  '\v',
  '\x0E',
  '\x1E',
  '\x1F',
  '\x1C',
  '\x17',
  '\x18',
  '\x18',
  '\x06',
  '\b',
  '\x14',
  '\x18',
  '\x1A',
  '\x1F',
  '\x06',
  '\x06',
  '\x19',
  '\x01',
  '\x1D',
  '\n',
  '\x0F',
  '\0',
  '\0'
}; // weak
_UNKNOWN unk_482378; // weak
_UNKNOWN unk_48239C; // weak
_UNKNOWN unk_4823C4; // weak
_UNKNOWN unk_4823E8; // weak
_UNKNOWN unk_482410; // weak
_UNKNOWN unk_482434; // weak
_UNKNOWN unk_48246C; // weak
_UNKNOWN unk_4824A0; // weak
_UNKNOWN unk_4825A4; // weak
_UNKNOWN unk_4825D0; // weak
_UNKNOWN unk_4825F4; // weak
_UNKNOWN unk_482618; // weak
_UNKNOWN unk_4826AC; // weak
_UNKNOWN unk_4826D0; // weak
_UNKNOWN unk_4826F0; // weak
_UNKNOWN unk_48270C; // weak
_UNKNOWN unk_482718; // weak
_UNKNOWN unk_482730; // weak
_UNKNOWN unk_482774; // weak
_UNKNOWN unk_482778; // weak
_UNKNOWN unk_482788; // weak
_UNKNOWN unk_4827B8; // weak
_UNKNOWN unk_4827E4; // weak
_UNKNOWN unk_482808; // weak
_UNKNOWN unk_482850; // weak
_UNKNOWN unk_4828B0; // weak
_UNKNOWN unk_4828D4; // weak
_UNKNOWN unk_4828EC; // weak
_UNKNOWN unk_4828F4; // weak
_UNKNOWN unk_482914; // weak
_UNKNOWN unk_48291C; // weak
_UNKNOWN unk_482928; // weak
_UNKNOWN unk_482948; // weak
_UNKNOWN unk_482964; // weak
_UNKNOWN unk_482978; // weak
_UNKNOWN unk_482998; // weak
_UNKNOWN unk_4829C8; // weak
_UNKNOWN unk_4829F8; // weak
_UNKNOWN unk_482A20; // weak
_UNKNOWN unk_482A44; // weak
_UNKNOWN unk_482A68; // weak
_UNKNOWN unk_482A84; // weak
_UNKNOWN unk_482AA0; // weak
_UNKNOWN unk_482ACC; // weak
_UNKNOWN unk_482AF0; // weak
char byte_482B2C[4] = { '\x02', '\0', '\0', '\0' }; // weak
char byte_482B30[4] = { '\x01', '\0', '\0', '\0' }; // weak
char byte_482B34[4] = { '\x03', '\0', '\0', '\0' }; // weak
_UNKNOWN unk_4872E0; // weak
_UNKNOWN unk_487314; // weak
_UNKNOWN unk_487348; // weak
_UNKNOWN unk_487384; // weak
_UNKNOWN unk_4873BC; // weak
_UNKNOWN unk_4873C8; // weak
_UNKNOWN unk_4873D4; // weak
_UNKNOWN unk_4873F0; // weak
_UNKNOWN unk_487410; // weak
_UNKNOWN unk_48741C; // weak
_UNKNOWN unk_487438; // weak
_UNKNOWN unk_4874F8; // weak
_UNKNOWN unk_4875A8; // weak
_UNKNOWN unk_4875D4; // weak
_UNKNOWN unk_48760C; // weak
_UNKNOWN unk_487624; // weak
_UNKNOWN unk_487660; // weak
_UNKNOWN unk_48767C; // weak
_UNKNOWN unk_48769C; // weak
_UNKNOWN unk_4876D0; // weak
_UNKNOWN unk_4876E8; // weak
_UNKNOWN unk_487710; // weak
_UNKNOWN unk_487720; // weak
_UNKNOWN unk_487728; // weak
_UNKNOWN unk_487748; // weak
_UNKNOWN unk_4877AC; // weak
_UNKNOWN unk_4877D4; // weak
_UNKNOWN unk_487810; // weak
_UNKNOWN unk_487848; // weak
_UNKNOWN unk_487884; // weak
_UNKNOWN unk_4878B4; // weak
_UNKNOWN unk_4878D4; // weak
_UNKNOWN unk_4878F8; // weak
_UNKNOWN unk_487928; // weak
_UNKNOWN unk_487954; // weak
_UNKNOWN unk_487984; // weak
_UNKNOWN unk_4879A8; // weak
_UNKNOWN unk_4879B4; // weak
_UNKNOWN unk_4879C0; // weak
_UNKNOWN unk_4879F4; // weak
_UNKNOWN unk_488898; // weak
_UNKNOWN unk_4888B0; // weak
_UNKNOWN unk_4888F8; // weak
_UNKNOWN unk_488908; // weak
_UNKNOWN unk_488910; // weak
_UNKNOWN unk_488930; // weak
_UNKNOWN unk_488948; // weak
_UNKNOWN unk_488950; // weak
_UNKNOWN unk_488958; // weak
_UNKNOWN unk_488964; // weak
_UNKNOWN unk_488990; // weak
_UNKNOWN unk_4889C4; // weak
_UNKNOWN unk_4889C8; // weak
_UNKNOWN unk_4889CC; // weak
_UNKNOWN unk_4889D4; // weak
_UNKNOWN unk_4889F8; // weak
_UNKNOWN unk_488A00; // weak
_UNKNOWN unk_488A20; // weak
_UNKNOWN unk_488A4C; // weak
_UNKNOWN unk_488A70; // weak
_UNKNOWN unk_488ABC; // weak
char byte_488AE8[8] = { '\xD9', '\xDB', '\xC7', '\xE8', '\0', '\0', '\0', '\0' }; // weak
_UNKNOWN unk_488AF0; // weak
_UNKNOWN unk_488B28; // weak
const char aQ[] = "Q"; // idb
_UNKNOWN unk_488B58; // weak
_UNKNOWN unk_488B84; // weak
_UNKNOWN unk_488B9C; // weak
_UNKNOWN unk_488BB4; // weak
_UNKNOWN unk_488BD0; // weak
_UNKNOWN unk_488BFC; // weak
_UNKNOWN unk_488C24; // weak
_UNKNOWN unk_488C4C; // weak
_UNKNOWN unk_488C64; // weak
_UNKNOWN unk_488C7C; // weak
_UNKNOWN unk_488C88; // weak
_UNKNOWN unk_488CAC; // weak
_UNKNOWN unk_488CB4; // weak
_UNKNOWN unk_488CD4; // weak
_UNKNOWN unk_488CE8; // weak
_UNKNOWN unk_488D08; // weak
_UNKNOWN unk_488D1C; // weak
_UNKNOWN unk_488D34; // weak
_UNKNOWN unk_488D3C; // weak
_UNKNOWN unk_488D44; // weak
_UNKNOWN unk_488D80; // weak
_UNKNOWN unk_488D84; // weak
_UNKNOWN unk_488D9C; // weak
_UNKNOWN unk_488DAC; // weak
_UNKNOWN unk_488DB8; // weak
_UNKNOWN unk_48B048; // weak
_UNKNOWN unk_48B070; // weak
_UNKNOWN unk_48B0A4; // weak
_UNKNOWN unk_48B0D8; // weak
_UNKNOWN unk_48B130; // weak
_UNKNOWN unk_48B188; // weak
_UNKNOWN unk_48B1CC; // weak
_UNKNOWN unk_48B1F8; // weak
_UNKNOWN unk_48B228; // weak
_UNKNOWN unk_48B284; // weak
_UNKNOWN unk_48B298; // weak
_UNKNOWN unk_48B2D4; // weak
_UNKNOWN unk_48B310; // weak
_UNKNOWN unk_48B3F0; // weak
void *off_4931F0 = &unk_4A9EA0; // weak
int dword_493F78 = 28800; // weak
int dword_493F7C = 1; // weak
int dword_493F80 = -3600; // weak
void *off_494008 = &unk_493F88; // weak
int dword_494300 = 1024; // weak
int dword_494304 = -1023; // weak
int dword_494308 = 53; // weak
int dword_49430C = 11; // weak
int dword_494310 = 64; // weak
int dword_494314 = 1023; // weak
int dword_494318 = 128; // weak
int dword_49431C = -127; // weak
int dword_494320 = 24; // weak
int dword_494324 = 8; // weak
int dword_494328 = 32; // weak
int dword_49432C = 127; // weak
void *off_494600 = &unk_47B1E0; // weak
void *off_494614 = &unk_47B660; // weak
char byte_494626[] = { '\0' }; // weak
_UNKNOWN unk_494628; // weak
_UNKNOWN unk_4946E0; // weak
_UNKNOWN unk_494708; // weak
void *off_494724 = &unk_495114; // weak
void *dword_494728 = NULL; // idb
_UNKNOWN unk_495088; // weak
_UNKNOWN unk_4950D0; // weak
char (*off_495190[5])[4] = { &byte_47627C, &byte_47627C, &byte_47627C, &byte_47627C, &byte_47627C }; // weak
__int16 word_4951F8[362] =
{
  0,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  48,
  134,
  2,
  132,
  47,
  31,
  135,
  129,
  130,
  45,
  42,
  8,
  43,
  44,
  46,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  26,
  131,
  36,
  13,
  38,
  25,
  59,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  60,
  2,
  136,
  30,
  2,
  133,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  127,
  29,
  128,
  49,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  1,
  3,
  4,
  5,
  6,
  7,
  9,
  10,
  11,
  12,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  27,
  28,
  32,
  33,
  34,
  35,
  37,
  39,
  40,
  41,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  61,
  62,
  63,
  64,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  73,
  74,
  75,
  76,
  77,
  78,
  79,
  80,
  81,
  82,
  83,
  84,
  85,
  86,
  87,
  88,
  89,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  103,
  104,
  105,
  106,
  107,
  108,
  109,
  110,
  111,
  112,
  113,
  114,
  115,
  116,
  117,
  118,
  119,
  120,
  121,
  122,
  123,
  124,
  125,
  126
}; // weak
char (*empty_string)[4] = &byte_47627C; // weak
void *off_4954D0 = &unk_488894; // idb
__int16 word_4958F0[348] =
{
  0,
  137,
  139,
  138,
  138,
  140,
  140,
  142,
  141,
  141,
  143,
  143,
  144,
  145,
  146,
  147,
  145,
  148,
  149,
  145,
  150,
  151,
  145,
  152,
  153,
  145,
  154,
  155,
  156,
  145,
  157,
  145,
  145,
  145,
  145,
  145,
  145,
  145,
  145,
  145,
  145,
  145,
  145,
  145,
  145,
  145,
  158,
  159,
  145,
  160,
  161,
  145,
  162,
  145,
  145,
  163,
  163,
  164,
  165,
  165,
  166,
  168,
  169,
  167,
  170,
  171,
  167,
  172,
  167,
  173,
  167,
  174,
  174,
  175,
  175,
  176,
  176,
  177,
  177,
  178,
  178,
  179,
  179,
  179,
  179,
  180,
  181,
  180,
  182,
  180,
  183,
  183,
  184,
  184,
  185,
  186,
  185,
  187,
  188,
  187,
  189,
  189,
  190,
  190,
  191,
  191,
  192,
  192,
  192,
  192,
  192,
  192,
  192,
  192,
  193,
  193,
  194,
  194,
  194,
  194,
  194,
  194,
  195,
  195,
  196,
  196,
  196,
  197,
  197,
  197,
  197,
  198,
  198,
  199,
  200,
  201,
  199,
  202,
  203,
  199,
  204,
  204,
  205,
  205,
  205,
  205,
  206,
  206,
  206,
  207,
  207,
  209,
  208,
  208,
  211,
  210,
  210,
  210,
  210,
  212,
  210,
  213,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  214,
  210,
  215,
  210,
  216,
  210,
  217,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  218,
  219,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  210,
  220,
  210,
  210,
  210,
  210,
  210,
  222,
  221,
  223,
  221,
  224,
  221,
  225,
  225,
  226,
  226,
  226,
  227,
  227,
  228,
  228,
  228,
  228,
  228,
  228,
  228,
  229,
  229,
  229,
  229,
  229,
  230,
  230,
  230,
  230,
  230,
  230,
  231,
  231,
  232,
  232,
  233,
  233,
  233,
  233,
  234,
  234,
  235,
  236,
  237,
  238,
  239,
  238,
  240,
  240,
  241,
  241,
  241,
  242,
  242,
  243,
  243,
  244,
  245,
  244,
  246,
  247,
  246,
  248,
  248,
  248,
  249,
  249,
  250,
  250,
  251,
  251,
  252,
  253,
  252,
  252,
  254,
  254,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  256,
  256,
  256,
  256,
  256,
  256,
  256,
  256,
  256,
  256,
  256,
  256,
  257,
  258,
  257,
  257,
  257,
  257,
  257,
  259,
  259,
  259,
  260,
  260,
  260,
  260,
  260,
  260,
  260,
  261,
  262,
  261,
  0
}; // weak
__int16 word_495BA8[348] =
{
  0,
  1,
  0,
  3,
  0,
  1,
  1,
  0,
  3,
  0,
  1,
  1,
  1,
  3,
  0,
  0,
  9,
  0,
  0,
  12,
  0,
  0,
  7,
  0,
  0,
  9,
  0,
  0,
  0,
  12,
  0,
  6,
  2,
  3,
  2,
  3,
  2,
  3,
  3,
  3,
  3,
  3,
  1,
  2,
  3,
  5,
  0,
  0,
  10,
  0,
  0,
  10,
  0,
  6,
  1,
  1,
  3,
  1,
  1,
  3,
  1,
  0,
  0,
  11,
  0,
  0,
  10,
  0,
  6,
  0,
  8,
  0,
  2,
  1,
  4,
  1,
  4,
  1,
  4,
  3,
  5,
  3,
  4,
  4,
  5,
  0,
  0,
  6,
  0,
  5,
  1,
  1,
  1,
  4,
  0,
  0,
  7,
  0,
  0,
  8,
  0,
  2,
  0,
  3,
  1,
  0,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  1,
  0,
  1,
  1,
  2,
  3,
  3,
  4,
  3,
  1,
  1,
  2,
  4,
  3,
  5,
  1,
  3,
  2,
  0,
  3,
  0,
  0,
  11,
  0,
  0,
  10,
  0,
  1,
  3,
  5,
  1,
  3,
  0,
  3,
  1,
  0,
  1,
  0,
  4,
  1,
  0,
  7,
  3,
  4,
  4,
  0,
  7,
  0,
  4,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  2,
  2,
  2,
  2,
  0,
  4,
  0,
  4,
  0,
  4,
  0,
  4,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  0,
  0,
  7,
  1,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  0,
  3,
  1,
  4,
  3,
  2,
  0,
  5,
  0,
  5,
  0,
  7,
  1,
  1,
  0,
  2,
  3,
  0,
  3,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  2,
  4,
  1,
  1,
  1,
  3,
  3,
  3,
  0,
  2,
  0,
  1,
  5,
  3,
  3,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  4,
  1,
  2,
  4,
  4,
  1,
  1,
  4,
  0,
  1,
  1,
  0,
  4,
  1,
  0,
  2,
  4,
  4,
  1,
  1,
  3,
  1,
  2,
  3,
  1,
  1,
  0,
  5,
  0,
  0,
  2,
  5,
  3,
  3,
  1,
  6,
  4,
  4,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  0,
  1,
  0,
  5,
  3,
  3,
  6,
  3,
  1,
  1,
  1,
  4,
  4,
  2,
  2,
  4,
  2,
  2,
  1,
  0,
  4,
  0
}; // weak
__int16 word_495E60[531] =
{
  4,
  2,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  224,
  0,
  238,
  0,
  243,
  244,
  255,
  256,
  282,
  42,
  245,
  146,
  23,
  0,
  0,
  0,
  52,
  0,
  0,
  0,
  64,
  61,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  248,
  249,
  246,
  247,
  326,
  9,
  0,
  54,
  297,
  326,
  326,
  326,
  3,
  5,
  12,
  6,
  60,
  270,
  214,
  257,
  226,
  0,
  269,
  0,
  271,
  274,
  277,
  281,
  0,
  215,
  339,
  340,
  0,
  342,
  343,
  229,
  198,
  199,
  200,
  201,
  175,
  273,
  177,
  216,
  217,
  218,
  219,
  220,
  221,
  222,
  0,
  236,
  161,
  237,
  271,
  0,
  223,
  0,
  0,
  230,
  0,
  148,
  0,
  20,
  149,
  0,
  0,
  0,
  32,
  0,
  34,
  0,
  140,
  140,
  36,
  270,
  0,
  271,
  58,
  0,
  0,
  124,
  0,
  0,
  123,
  129,
  0,
  0,
  0,
  0,
  67,
  154,
  305,
  0,
  7,
  0,
  0,
  0,
  0,
  0,
  182,
  0,
  184,
  211,
  178,
  180,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  43,
  174,
  176,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  232,
  275,
  284,
  0,
  298,
  278,
  0,
  225,
  241,
  239,
  0,
  0,
  0,
  115,
  0,
  41,
  0,
  0,
  0,
  150,
  153,
  270,
  0,
  271,
  0,
  0,
  33,
  35,
  141,
  0,
  0,
  37,
  38,
  0,
  44,
  0,
  125,
  0,
  39,
  0,
  0,
  40,
  0,
  55,
  57,
  344,
  0,
  0,
  0,
  0,
  304,
  0,
  310,
  0,
  263,
  321,
  316,
  327,
  317,
  319,
  320,
  318,
  325,
  260,
  0,
  0,
  323,
  324,
  322,
  315,
  13,
  0,
  210,
  0,
  228,
  258,
  259,
  0,
  186,
  0,
  0,
  0,
  0,
  187,
  189,
  188,
  204,
  205,
  202,
  203,
  206,
  207,
  208,
  209,
  196,
  197,
  191,
  192,
  190,
  193,
  194,
  195,
  0,
  156,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  115,
  0,
  285,
  0,
  0,
  341,
  115,
  162,
  240,
  14,
  234,
  0,
  0,
  114,
  270,
  271,
  147,
  0,
  0,
  26,
  151,
  49,
  46,
  0,
  0,
  30,
  65,
  62,
  59,
  0,
  122,
  0,
  0,
  251,
  0,
  250,
  130,
  127,
  0,
  0,
  345,
  337,
  338,
  69,
  132,
  0,
  301,
  0,
  300,
  314,
  272,
  0,
  227,
  264,
  306,
  328,
  0,
  256,
  0,
  0,
  8,
  10,
  11,
  283,
  183,
  185,
  0,
  179,
  181,
  0,
  0,
  158,
  157,
  272,
  0,
  295,
  0,
  290,
  276,
  286,
  289,
  294,
  279,
  280,
  0,
  17,
  0,
  115,
  118,
  231,
  0,
  24,
  21,
  149,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  105,
  0,
  126,
  252,
  253,
  261,
  0,
  56,
  45,
  0,
  0,
  0,
  302,
  304,
  0,
  0,
  309,
  0,
  308,
  0,
  330,
  0,
  331,
  333,
  212,
  159,
  233,
  0,
  291,
  287,
  284,
  0,
  242,
  9,
  15,
  0,
  0,
  270,
  271,
  0,
  0,
  0,
  152,
  71,
  71,
  79,
  0,
  9,
  77,
  53,
  85,
  85,
  31,
  0,
  106,
  0,
  0,
  104,
  105,
  268,
  0,
  263,
  128,
  346,
  132,
  137,
  134,
  0,
  68,
  131,
  304,
  299,
  0,
  313,
  312,
  0,
  334,
  336,
  335,
  0,
  0,
  0,
  241,
  296,
  0,
  0,
  0,
  7,
  94,
  235,
  121,
  0,
  9,
  92,
  22,
  27,
  0,
  0,
  0,
  0,
  7,
  85,
  0,
  85,
  0,
  107,
  0,
  108,
  9,
  0,
  0,
  0,
  254,
  264,
  262,
  0,
  140,
  140,
  144,
  0,
  0
}; // weak
__int16 word_496286[263] =
{
  155,
  0,
  307,
  329,
  0,
  213,
  160,
  288,
  292,
  293,
  97,
  100,
  0,
  7,
  149,
  72,
  50,
  47,
  80,
  0,
  0,
  0,
  0,
  0,
  0,
  81,
  109,
  7,
  0,
  110,
  0,
  0,
  267,
  266,
  70,
  0,
  0,
  0,
  0,
  133,
  303,
  311,
  332,
  102,
  0,
  0,
  16,
  25,
  0,
  0,
  0,
  0,
  78,
  0,
  83,
  0,
  90,
  91,
  88,
  82,
  0,
  111,
  0,
  112,
  9,
  0,
  138,
  135,
  145,
  142,
  0,
  0,
  0,
  0,
  101,
  93,
  28,
  9,
  75,
  51,
  48,
  84,
  86,
  9,
  66,
  113,
  7,
  265,
  105,
  0,
  0,
  0,
  9,
  0,
  0,
  0,
  7,
  9,
  7,
  63,
  0,
  105,
  143,
  0,
  7,
  19,
  95,
  9,
  73,
  29,
  0,
  7,
  9,
  0,
  0,
  0,
  7,
  76,
  7,
  0,
  98,
  96,
  0,
  0,
  9,
  9,
  74,
  139,
  7,
  7,
  136,
  0,
  0,
  0,
  0,
  0,
  0,
  662,
  1,
  2,
  66,
  148,
  265,
  369,
  609,
  68,
  395,
  498,
  443,
  541,
  211,
  450,
  116,
  449,
  402,
  545,
  626,
  409,
  405,
  582,
  404,
  581,
  120,
  236,
  237,
  134,
  69,
  70,
  127,
  411,
  126,
  410,
  243,
  420,
  507,
  640,
  610,
  459,
  333,
  462,
  512,
  628,
  614,
  589,
  504,
  542,
  646,
  574,
  656,
  577,
  603,
  466,
  467,
  321,
  322,
  137,
  138,
  140,
  421,
  479,
  527,
  620,
  526,
  619,
  223,
  529,
  114,
  212,
  213,
  403,
  71,
  244,
  492,
  202,
  275,
  276,
  271,
  273,
  274,
  491,
  104,
  72,
  207,
  309,
  396,
  106,
  110,
  316,
  73,
  345,
  74,
  470,
  363,
  471,
  75,
  76,
  216,
  77,
  78,
  310,
  79,
  80,
  81,
  312,
  387,
  494,
  388,
  438,
  389,
  390,
  82,
  356,
  357,
  480,
  247,
  248,
  147,
  263,
  429,
  489,
  83,
  240,
  419
}; // weak
int xmlFree = 4515260; // idb
__int16 word_496498[531] =
{
  32768,
  39,
  604,
  2039,
  2039,
  -83,
  2039,
  2039,
  2039,
  2039,
  2039,
  2039,
  2039,
  -16,
  -16,
  2039,
  2039,
  2039,
  2039,
  2039,
  2039,
  2039,
  32768,
  -20,
  -81,
  -76,
  32768,
  32768,
  -42,
  32768,
  32768,
  32768,
  32768,
  2039,
  32768,
  -72,
  -40,
  -9,
  32768,
  -4,
  1282,
  1314,
  32768,
  32768,
  1427,
  -23,
  11,
  34,
  8,
  23,
  76,
  58,
  83,
  91,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  2039,
  32768,
  3,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  2316,
  32768,
  159,
  731,
  46,
  -33,
  32768,
  12,
  32768,
  3385,
  3385,
  2039,
  3385,
  3385,
  3483,
  95,
  95,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  2039,
  32768,
  32768,
  32768,
  32768,
  1459,
  32768,
  2039,
  -20,
  32768,
  14,
  3385,
  1169,
  32768,
  2039,
  2039,
  101,
  2039,
  32768,
  2371,
  32768,
  2421,
  206,
  206,
  32768,
  124,
  3385,
  547,
  32768,
  163,
  138,
  32768,
  4,
  16,
  32768,
  257,
  18,
  -16,
  -16,
  -16,
  170,
  32768,
  1572,
  393,
  150,
  2476,
  2039,
  846,
  959,
  1072,
  32768,
  2039,
  32768,
  32768,
  32768,
  32768,
  2039,
  2039,
  2039,
  2039,
  2039,
  2039,
  2039,
  2039,
  2039,
  2039,
  2039,
  2039,
  2039,
  2039,
  2039,
  2039,
  2039,
  2039,
  2039,
  32768,
  32768,
  32768,
  1604,
  2039,
  2039,
  2039,
  2039,
  2039,
  2039,
  2039,
  2039,
  2039,
  2039,
  2039,
  32768,
  32768,
  2039,
  2039,
  3,
  -33,
  2526,
  32768,
  151,
  32768,
  2580,
  2630,
  165,
  1717,
  2039,
  32768,
  216,
  2039,
  171,
  293,
  3385,
  220,
  222,
  562,
  242,
  2684,
  32768,
  32768,
  32768,
  243,
  244,
  32768,
  32768,
  187,
  32768,
  2039,
  32768,
  11,
  32768,
  429,
  247,
  32768,
  26,
  32768,
  32768,
  32768,
  27,
  192,
  254,
  198,
  -15,
  -16,
  3248,
  194,
  318,
  32768,
  32768,
  25,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  2152,
  -16,
  32768,
  32768,
  32768,
  32768,
  32768,
  604,
  32768,
  2942,
  32768,
  32768,
  32768,
  2039,
  3460,
  2039,
  2039,
  2039,
  2039,
  3542,
  3559,
  593,
  2332,
  2332,
  2332,
  2332,
  246,
  246,
  246,
  246,
  286,
  286,
  95,
  95,
  95,
  32768,
  32768,
  32768,
  -19,
  3483,
  3483,
  3483,
  3483,
  3483,
  3483,
  3483,
  3483,
  3483,
  3483,
  3483,
  3483,
  1717,
  -24,
  3385,
  199,
  2996,
  32768,
  1717,
  32768,
  32768,
  310,
  32768,
  -16,
  207,
  330,
  69,
  50,
  3385,
  213,
  2734,
  32768,
  32768,
  32768,
  32768,
  331,
  70,
  32768,
  32768,
  32768,
  32768,
  3044,
  32768,
  429,
  429,
  32768,
  214,
  32768,
  32768,
  332,
  -16,
  217,
  32768,
  32768,
  32768,
  32768,
  32768,
  218,
  32768,
  71,
  32768,
  32768,
  32768,
  1749,
  32768,
  1862,
  32768,
  32768,
  280,
  290,
  3098,
  223,
  32768,
  32768,
  32768,
  32768,
  3423,
  3483,
  3341,
  3524,
  2146,
  -20,
  -42,
  32768,
  32768,
  226,
  228,
  32768,
  2039,
  32768,
  251,
  32768,
  -31,
  32768,
  32768,
  32768,
  231,
  32768,
  1169,
  1717,
  32768,
  32768,
  1894,
  32768,
  32768,
  2039,
  2039,
  -16,
  -16,
  429,
  283,
  717,
  -1,
  5,
  234,
  32768,
  32768,
  32768,
  429,
  429,
  32768,
  32768,
  -16,
  237,
  136,
  32768,
  -15,
  352,
  -16,
  3385,
  -16,
  3302,
  185,
  32768,
  2039,
  32768,
  32768,
  32768,
  32768,
  32768,
  3146,
  32768,
  32768,
  2039,
  2039,
  32768,
  32768,
  32768,
  239,
  -16,
  72,
  359,
  2039,
  830,
  240,
  3385,
  261,
  261,
  32768,
  375,
  32768,
  32768,
  32768,
  258,
  259,
  32768,
  321,
  382,
  326,
  269,
  396,
  5,
  298,
  278,
  404,
  32768,
  32768,
  32768,
  32768,
  32768,
  342,
  32768,
  32768,
  -15,
  32768,
  2039,
  32768,
  32768,
  2007,
  32768,
  32768,
  32768,
  279,
  2206,
  2039,
  151,
  32768,
  -24,
  281,
  3200,
  161,
  32768,
  32768,
  32768,
  2788,
  32768,
  32768,
  32768,
  32768,
  -16,
  291,
  292,
  429,
  329,
  32768,
  157,
  32768,
  1,
  32768,
  429,
  32768,
  32768,
  175,
  295,
  429,
  32768,
  429,
  32768,
  140,
  206,
  206,
  407,
  20,
  73
}; // weak
__int16 word_4968BE[263] =
{
  3483,
  -16,
  3385,
  32768,
  299,
  3504,
  32768,
  32768,
  32768,
  32768,
  32768,
  179,
  297,
  345,
  2039,
  32768,
  32768,
  32768,
  32768,
  301,
  208,
  303,
  2039,
  -3,
  131,
  32768,
  32768,
  300,
  364,
  410,
  365,
  311,
  32768,
  328,
  32768,
  373,
  374,
  429,
  376,
  32768,
  32768,
  32768,
  32768,
  197,
  315,
  1169,
  32768,
  32768,
  314,
  320,
  943,
  943,
  32768,
  323,
  32768,
  2266,
  32768,
  32768,
  32768,
  32768,
  324,
  32768,
  429,
  32768,
  32768,
  429,
  32768,
  32768,
  32768,
  438,
  334,
  431,
  392,
  2039,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  346,
  32768,
  5,
  341,
  429,
  2039,
  32768,
  344,
  2838,
  1056,
  388,
  32768,
  7,
  32768,
  348,
  5,
  32768,
  2892,
  394,
  32768,
  32768,
  32768,
  32768,
  32768,
  347,
  125,
  32768,
  349,
  433,
  1169,
  397,
  32768,
  353,
  357,
  32768,
  32768,
  355,
  361,
  32768,
  32768,
  32768,
  32768,
  362,
  201,
  32768,
  495,
  499,
  32768,
  0,
  0,
  0,
  32768,
  32768,
  32768,
  32768,
  -162,
  32768,
  32768,
  -2,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  153,
  32768,
  238,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  53,
  32768,
  -80,
  32768,
  32768,
  32768,
  -423,
  32768,
  32768,
  -82,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  -438,
  32768,
  -272,
  32768,
  32768,
  284,
  32768,
  35,
  32768,
  32768,
  32768,
  32768,
  32768,
  -126,
  32768,
  32768,
  -397,
  32768,
  32768,
  -12,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768,
  215,
  32768,
  32768,
  32768,
  -99,
  32768,
  30,
  -202,
  -182,
  32768,
  32768,
  41,
  32768,
  0,
  -21,
  -186,
  48,
  109,
  32768,
  -296,
  428,
  32768,
  79,
  32768,
  32768,
  29,
  32768,
  32768,
  32768,
  32768,
  44,
  102,
  32768,
  32768,
  32768,
  241,
  32768,
  32768,
  32768,
  32768,
  32768,
  32768
}; // weak
int (__cdecl *xmlMalloc)(_DWORD) = &malloc; // weak
__int16 word_496AD0[3608] =
{
  67,
  224,
  107,
  84,
  85,
  451,
  87,
  88,
  89,
  90,
  91,
  92,
  93,
  206,
  386,
  97,
  98,
  99,
  100,
  101,
  102,
  103,
  208,
  587,
  231,
  460,
  234,
  196,
  569,
  440,
  520,
  344,
  129,
  115,
  347,
  349,
  463,
  383,
  514,
  -1,
  123,
  125,
  378,
  393,
  130,
  384,
  86,
  30,
  109,
  105,
  379,
  30,
  30,
  111,
  132,
  30,
  30,
  117,
  -117,
  358,
  149,
  94,
  96,
  182,
  183,
  184,
  185,
  186,
  187,
  188,
  189,
  190,
  191,
  192,
  193,
  30,
  464,
  -116,
  407,
  423,
  -119,
  423,
  135,
  30,
  112,
  364,
  200,
  113,
  551,
  118,
  555,
  107,
  553,
  554,
  197,
  354,
  441,
  -89,
  -89,
  -89,
  -273,
  -273,
  465,
  385,
  201,
  139,
  133,
  215,
  62,
  204,
  381,
  205,
  62,
  62,
  210,
  230,
  62,
  62,
  214,
  130,
  119,
  219,
  95,
  95,
  445,
  121,
  461,
  144,
  588,
  556,
  150,
  229,
  108,
  365,
  397,
  -89,
  62,
  141,
  344,
  344,
  176,
  177,
  178,
  136,
  198,
  209,
  246,
  232,
  580,
  235,
  267,
  570,
  142,
  131,
  195,
  272,
  348,
  350,
  413,
  414,
  277,
  278,
  279,
  280,
  281,
  282,
  283,
  284,
  285,
  286,
  287,
  288,
  289,
  290,
  291,
  292,
  293,
  294,
  295,
  194,
  -117,
  631,
  297,
  298,
  299,
  300,
  301,
  302,
  303,
  304,
  305,
  306,
  307,
  308,
  644,
  323,
  311,
  313,
  386,
  -116,
  408,
  424,
  -119,
  571,
  344,
  143,
  559,
  130,
  325,
  180,
  181,
  327,
  145,
  344,
  344,
  -87,
  -87,
  -87,
  453,
  454,
  146,
  108,
  553,
  554,
  455,
  -18,
  -18,
  -18,
  217,
  338,
  218,
  475,
  476,
  469,
  472,
  475,
  476,
  222,
  477,
  483,
  227,
  484,
  477,
  575,
  576,
  108,
  560,
  552,
  553,
  554,
  238,
  239,
  241,
  -87,
  486,
  225,
  487,
  488,
  367,
  590,
  500,
  601,
  602,
  370,
  478,
  -99,
  -99,
  -99,
  565,
  228,
  233,
  373,
  561,
  374,
  375,
  376,
  377,
  242,
  264,
  435,
  315,
  497,
  32768,
  32768,
  32768,
  32768,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  319,
  510,
  326,
  323,
  584,
  553,
  554,
  329,
  328,
  323,
  151,
  152,
  153,
  344,
  330,
  130,
  331,
  332,
  335,
  336,
  344,
  130,
  324,
  337,
  346,
  344,
  546,
  344,
  351,
  352,
  361,
  353,
  362,
  549,
  173,
  174,
  175,
  176,
  177,
  178,
  557,
  391,
  394,
  398,
  399,
  563,
  544,
  564,
  400,
  415,
  406,
  416,
  572,
  422,
  418,
  430,
  431,
  433,
  456,
  355,
  359,
  194,
  558,
  107,
  436,
  439,
  426,
  442,
  428,
  468,
  474,
  482,
  344,
  -120,
  368,
  499,
  506,
  505,
  182,
  183,
  184,
  185,
  186,
  187,
  188,
  189,
  190,
  191,
  192,
  193,
  323,
  437,
  599,
  447,
  509,
  511,
  513,
  344,
  515,
  444,
  344,
  516,
  130,
  517,
  518,
  130,
  566,
  567,
  214,
  452,
  519,
  382,
  458,
  521,
  522,
  -273,
  -273,
  616,
  523,
  528,
  618,
  534,
  550,
  539,
  324,
  344,
  568,
  547,
  548,
  593,
  324,
  562,
  579,
  573,
  578,
  359,
  591,
  490,
  583,
  617,
  585,
  592,
  594,
  596,
  595,
  633,
  311,
  496,
  597,
  598,
  604,
  606,
  627,
  600,
  503,
  501,
  607,
  621,
  629,
  249,
  612,
  615,
  238,
  623,
  624,
  651,
  -103,
  635,
  250,
  622,
  251,
  252,
  642,
  253,
  254,
  255,
  632,
  340,
  341,
  641,
  630,
  636,
  647,
  643,
  648,
  650,
  653,
  649,
  531,
  654,
  655,
  533,
  657,
  108,
  194,
  -120,
  661,
  536,
  658,
  659,
  660,
  663,
  26,
  27,
  342,
  664,
  417,
  256,
  611,
  371,
  613,
  324,
  32,
  508,
  448,
  525,
  199,
  380,
  524,
  359,
  359,
  339,
  257,
  258,
  259,
  495,
  260,
  261,
  537,
  538,
  530,
  481,
  0,
  0,
  473,
  262,
  0,
  0,
  355,
  0,
  359,
  0,
  359,
  0,
  0,
  0,
  343,
  54,
  55,
  56,
  57,
  214,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  586,
  0,
  359,
  0,
  0,
  0,
  0,
  182,
  183,
  184,
  185,
  186,
  187,
  188,
  189,
  190,
  191,
  192,
  193,
  0,
  0,
  605,
  182,
  183,
  184,
  185,
  186,
  187,
  188,
  189,
  190,
  191,
  192,
  193,
  0,
  0,
  355,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  -273,
  -273,
  0,
  0,
  0,
  0,
  0,
  625,
  0,
  0,
  3,
  4,
  5,
  6,
  7,
  -273,
  -273,
  0,
  359,
  8,
  0,
  0,
  0,
  0,
  0,
  634,
  0,
  639,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  359,
  0,
  0,
  652,
  0,
  9,
  10,
  0,
  0,
  -272,
  0,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  0,
  23,
  24,
  25,
  0,
  0,
  0,
  26,
  27,
  28,
  29,
  30,
  194,
  31,
  226,
  0,
  0,
  32,
  33,
  34,
  35,
  0,
  36,
  0,
  37,
  0,
  38,
  194,
  0,
  39,
  0,
  0,
  0,
  40,
  41,
  42,
  43,
  0,
  44,
  45,
  46,
  47,
  0,
  48,
  49,
  50,
  51,
  0,
  0,
  0,
  52,
  53,
  54,
  55,
  56,
  57,
  3,
  4,
  5,
  6,
  7,
  0,
  58,
  0,
  0,
  8,
  0,
  59,
  0,
  60,
  0,
  61,
  62,
  63,
  64,
  65,
  0,
  0,
  0,
  457,
  182,
  183,
  184,
  185,
  186,
  187,
  188,
  189,
  190,
  191,
  192,
  193,
  0,
  0,
  0,
  9,
  10,
  0,
  0,
  0,
  0,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  0,
  23,
  24,
  25,
  -273,
  -273,
  0,
  26,
  27,
  28,
  29,
  30,
  0,
  31,
  0,
  0,
  0,
  32,
  33,
  34,
  35,
  0,
  36,
  0,
  37,
  0,
  38,
  0,
  0,
  39,
  0,
  0,
  0,
  40,
  41,
  0,
  0,
  0,
  44,
  45,
  46,
  47,
  0,
  48,
  49,
  50,
  0,
  0,
  0,
  0,
  52,
  53,
  54,
  55,
  56,
  57,
  3,
  4,
  5,
  6,
  7,
  0,
  58,
  0,
  0,
  8,
  0,
  59,
  0,
  60,
  0,
  61,
  62,
  63,
  64,
  65,
  0,
  0,
  0,
  502,
  0,
  0,
  0,
  194,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  9,
  10,
  0,
  0,
  0,
  0,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  0,
  23,
  24,
  25,
  0,
  0,
  0,
  26,
  27,
  28,
  29,
  30,
  0,
  31,
  0,
  0,
  249,
  32,
  33,
  34,
  35,
  0,
  36,
  0,
  37,
  250,
  38,
  251,
  252,
  39,
  253,
  254,
  255,
  40,
  41,
  0,
  0,
  0,
  44,
  45,
  46,
  47,
  0,
  48,
  49,
  50,
  0,
  0,
  0,
  0,
  52,
  53,
  54,
  55,
  56,
  57,
  3,
  4,
  5,
  6,
  7,
  0,
  58,
  0,
  256,
  8,
  0,
  59,
  0,
  60,
  0,
  61,
  62,
  63,
  64,
  65,
  0,
  0,
  0,
  608,
  258,
  259,
  0,
  260,
  261,
  0,
  0,
  0,
  0,
  268,
  0,
  0,
  262,
  0,
  0,
  9,
  10,
  0,
  0,
  0,
  0,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  0,
  23,
  24,
  25,
  0,
  0,
  0,
  26,
  27,
  28,
  29,
  30,
  0,
  31,
  0,
  0,
  249,
  32,
  33,
  34,
  35,
  0,
  36,
  0,
  37,
  250,
  38,
  251,
  252,
  39,
  253,
  254,
  255,
  40,
  41,
  0,
  0,
  0,
  44,
  45,
  46,
  47,
  0,
  48,
  49,
  50,
  0,
  0,
  0,
  0,
  52,
  53,
  54,
  55,
  56,
  57,
  3,
  4,
  5,
  6,
  7,
  0,
  58,
  0,
  256,
  8,
  0,
  59,
  0,
  60,
  0,
  61,
  62,
  63,
  64,
  65,
  0,
  0,
  0,
  638,
  258,
  259,
  0,
  260,
  261,
  0,
  0,
  0,
  0,
  0,
  269,
  0,
  262,
  0,
  0,
  9,
  10,
  0,
  0,
  0,
  0,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  0,
  23,
  24,
  25,
  0,
  0,
  0,
  26,
  27,
  28,
  29,
  30,
  0,
  31,
  0,
  0,
  249,
  32,
  33,
  34,
  35,
  0,
  36,
  0,
  37,
  250,
  38,
  251,
  252,
  39,
  253,
  254,
  255,
  40,
  41,
  0,
  0,
  0,
  44,
  45,
  46,
  47,
  0,
  48,
  49,
  50,
  0,
  0,
  0,
  0,
  52,
  53,
  54,
  55,
  56,
  57,
  3,
  4,
  5,
  6,
  7,
  0,
  58,
  0,
  256,
  8,
  0,
  59,
  0,
  60,
  0,
  61,
  62,
  63,
  64,
  65,
  0,
  0,
  0,
  0,
  258,
  259,
  0,
  260,
  261,
  0,
  0,
  0,
  0,
  0,
  0,
  270,
  262,
  0,
  0,
  9,
  10,
  0,
  0,
  0,
  0,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  0,
  23,
  24,
  25,
  0,
  0,
  0,
  26,
  27,
  28,
  29,
  30,
  0,
  31,
  0,
  0,
  0,
  32,
  33,
  34,
  35,
  0,
  36,
  0,
  37,
  0,
  38,
  0,
  0,
  39,
  0,
  0,
  0,
  40,
  41,
  0,
  0,
  0,
  44,
  45,
  46,
  47,
  0,
  48,
  49,
  50,
  0,
  0,
  0,
  0,
  52,
  53,
  54,
  55,
  56,
  57,
  3,
  4,
  5,
  6,
  7,
  0,
  58,
  0,
  0,
  8,
  0,
  59,
  0,
  60,
  0,
  61,
  62,
  63,
  64,
  65,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  3,
  4,
  5,
  6,
  7,
  0,
  0,
  9,
  10,
  8,
  0,
  0,
  0,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  0,
  23,
  24,
  0,
  0,
  0,
  0,
  26,
  27,
  28,
  29,
  30,
  0,
  0,
  9,
  10,
  0,
  32,
  0,
  0,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  0,
  23,
  24,
  0,
  0,
  0,
  0,
  26,
  27,
  28,
  29,
  30,
  49,
  50,
  0,
  0,
  0,
  32,
  52,
  53,
  54,
  55,
  56,
  57,
  0,
  0,
  0,
  0,
  0,
  0,
  58,
  0,
  0,
  0,
  0,
  0,
  0,
  60,
  0,
  122,
  62,
  63,
  64,
  65,
  49,
  50,
  0,
  0,
  0,
  0,
  52,
  53,
  54,
  55,
  56,
  57,
  3,
  4,
  5,
  6,
  7,
  0,
  58,
  0,
  0,
  8,
  0,
  0,
  0,
  60,
  0,
  124,
  62,
  63,
  64,
  65,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  3,
  4,
  5,
  6,
  7,
  0,
  0,
  9,
  10,
  8,
  0,
  0,
  0,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  0,
  23,
  24,
  0,
  0,
  0,
  0,
  26,
  27,
  28,
  29,
  30,
  0,
  0,
  9,
  10,
  0,
  32,
  0,
  0,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  0,
  23,
  24,
  0,
  0,
  0,
  0,
  26,
  27,
  28,
  29,
  30,
  49,
  50,
  0,
  0,
  0,
  32,
  52,
  53,
  54,
  55,
  56,
  57,
  0,
  0,
  0,
  0,
  0,
  0,
  58,
  0,
  0,
  0,
  0,
  0,
  0,
  60,
  0,
  128,
  62,
  63,
  64,
  65,
  49,
  50,
  0,
  0,
  0,
  0,
  52,
  53,
  54,
  55,
  56,
  57,
  3,
  4,
  5,
  6,
  7,
  0,
  58,
  0,
  0,
  8,
  0,
  0,
  0,
  60,
  203,
  0,
  62,
  63,
  64,
  65,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  245,
  0,
  0,
  0,
  3,
  4,
  5,
  6,
  7,
  0,
  0,
  9,
  10,
  8,
  0,
  0,
  0,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  0,
  23,
  24,
  296,
  0,
  0,
  0,
  26,
  27,
  28,
  29,
  30,
  0,
  0,
  9,
  10,
  0,
  32,
  0,
  0,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  0,
  23,
  24,
  0,
  0,
  0,
  0,
  26,
  27,
  28,
  29,
  30,
  49,
  50,
  0,
  0,
  0,
  32,
  52,
  53,
  54,
  55,
  56,
  57,
  0,
  0,
  0,
  0,
  0,
  0,
  58,
  0,
  0,
  0,
  0,
  0,
  0,
  60,
  0,
  0,
  62,
  63,
  64,
  65,
  49,
  50,
  0,
  0,
  0,
  0,
  52,
  53,
  54,
  55,
  56,
  57,
  3,
  4,
  5,
  6,
  7,
  0,
  58,
  0,
  0,
  8,
  0,
  0,
  0,
  60,
  0,
  0,
  62,
  63,
  64,
  65,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  320,
  0,
  0,
  0,
  3,
  4,
  5,
  6,
  7,
  0,
  0,
  9,
  10,
  8,
  0,
  0,
  0,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  0,
  23,
  24,
  425,
  0,
  0,
  0,
  26,
  27,
  28,
  29,
  30,
  0,
  0,
  9,
  10,
  0,
  32,
  0,
  0,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  0,
  23,
  24,
  0,
  0,
  0,
  0,
  26,
  27,
  28,
  29,
  30,
  49,
  50,
  0,
  0,
  0,
  32,
  52,
  53,
  54,
  55,
  56,
  57,
  0,
  0,
  0,
  0,
  0,
  0,
  58,
  0,
  0,
  0,
  0,
  0,
  0,
  60,
  0,
  0,
  62,
  63,
  64,
  65,
  49,
  50,
  0,
  0,
  0,
  0,
  52,
  53,
  54,
  55,
  56,
  57,
  3,
  4,
  5,
  6,
  7,
  0,
  58,
  0,
  0,
  8,
  0,
  0,
  0,
  60,
  0,
  0,
  62,
  63,
  64,
  65,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  427,
  0,
  0,
  0,
  3,
  4,
  5,
  6,
  7,
  0,
  0,
  9,
  10,
  8,
  0,
  0,
  0,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  0,
  23,
  24,
  446,
  0,
  0,
  0,
  26,
  27,
  28,
  29,
  30,
  0,
  0,
  9,
  10,
  0,
  32,
  0,
  0,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  0,
  23,
  24,
  0,
  0,
  0,
  0,
  26,
  27,
  28,
  29,
  30,
  49,
  50,
  0,
  0,
  0,
  32,
  52,
  53,
  54,
  55,
  56,
  57,
  0,
  0,
  0,
  0,
  0,
  0,
  58,
  0,
  0,
  0,
  0,
  0,
  0,
  60,
  0,
  0,
  62,
  63,
  64,
  65,
  49,
  50,
  0,
  0,
  0,
  0,
  52,
  53,
  54,
  55,
  56,
  57,
  3,
  4,
  5,
  6,
  7,
  0,
  58,
  0,
  0,
  8,
  0,
  0,
  0,
  60,
  0,
  0,
  62,
  63,
  64,
  65,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  532,
  0,
  0,
  0,
  3,
  4,
  5,
  6,
  7,
  0,
  0,
  9,
  10,
  8,
  0,
  0,
  0,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  0,
  23,
  24,
  0,
  0,
  0,
  0,
  26,
  27,
  28,
  29,
  30,
  0,
  0,
  9,
  10,
  0,
  32,
  0,
  0,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  0,
  23,
  24,
  0,
  0,
  0,
  0,
  26,
  27,
  28,
  29,
  30,
  49,
  50,
  0,
  0,
  0,
  32,
  52,
  53,
  54,
  55,
  56,
  57,
  0,
  0,
  0,
  0,
  0,
  0,
  58,
  0,
  0,
  0,
  0,
  0,
  0,
  60,
  0,
  0,
  62,
  63,
  64,
  65,
  49,
  50,
  0,
  0,
  0,
  0,
  52,
  53,
  54,
  55,
  56,
  57,
  3,
  4,
  5,
  6,
  7,
  0,
  58,
  0,
  0,
  8,
  0,
  0,
  0,
  60,
  0,
  0,
  62,
  63,
  64,
  65,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  9,
  10,
  0,
  0,
  0,
  0,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  0,
  23,
  24,
  154,
  155,
  156,
  0,
  26,
  27,
  28,
  366,
  30,
  0,
  0,
  0,
  0,
  0,
  32,
  0,
  157,
  0,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  0,
  0,
  49,
  50,
  0,
  0,
  0,
  0,
  52,
  53,
  54,
  55,
  56,
  57,
  0,
  0,
  0,
  0,
  0,
  0,
  58,
  154,
  155,
  156,
  0,
  0,
  0,
  60,
  0,
  0,
  62,
  63,
  64,
  65,
  0,
  0,
  0,
  157,
  587,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  154,
  155,
  156,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  157,
  535,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  32768,
  32768,
  32768,
  32768,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  154,
  155,
  156,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  157,
  588,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  154,
  155,
  156,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  157,
  179,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  154,
  155,
  156,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  157,
  220,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  154,
  155,
  156,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  157,
  221,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  154,
  155,
  156,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  157,
  266,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  154,
  155,
  156,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  157,
  314,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  154,
  155,
  156,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  157,
  317,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  154,
  155,
  156,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  157,
  318,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  154,
  155,
  156,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  157,
  334,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  154,
  155,
  156,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  157,
  401,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  154,
  155,
  156,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  157,
  543,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  154,
  155,
  156,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  157,
  637,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  154,
  155,
  156,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  157,
  645,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  154,
  155,
  156,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  157,
  372,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  154,
  155,
  156,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  157,
  392,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  154,
  155,
  156,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  157,
  412,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  154,
  155,
  156,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  157,
  432,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  154,
  155,
  156,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  157,
  493,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  154,
  155,
  156,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  157,
  540,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  154,
  155,
  156,
  0,
  0,
  0,
  0,
  360,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  157,
  434,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  0,
  0,
  0,
  0,
  0,
  154,
  155,
  156,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  157,
  485,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  155,
  156,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  157,
  0,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  156,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  157,
  0,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  157,
  0,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  0
}; // weak
__int16 word_498700[3608] =
{
  2,
  127,
  23,
  3,
  4,
  402,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  112,
  310,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  8,
  26,
  8,
  26,
  8,
  60,
  8,
  60,
  468,
  233,
  44,
  33,
  8,
  8,
  31,
  309,
  461,
  0,
  40,
  41,
  61,
  315,
  44,
  69,
  129,
  71,
  129,
  69,
  69,
  71,
  71,
  129,
  77,
  71,
  71,
  129,
  8,
  245,
  60,
  13,
  14,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  71,
  71,
  8,
  8,
  8,
  8,
  8,
  71,
  71,
  126,
  60,
  86,
  129,
  511,
  129,
  513,
  112,
  91,
  92,
  127,
  110,
  127,
  90,
  91,
  92,
  50,
  51,
  97,
  127,
  104,
  71,
  129,
  119,
  132,
  109,
  296,
  111,
  132,
  132,
  116,
  136,
  132,
  132,
  118,
  119,
  129,
  121,
  13,
  14,
  396,
  129,
  127,
  69,
  131,
  128,
  127,
  127,
  23,
  108,
  320,
  128,
  132,
  129,
  340,
  341,
  45,
  46,
  47,
  132,
  132,
  131,
  146,
  131,
  545,
  131,
  150,
  131,
  129,
  44,
  108,
  155,
  130,
  130,
  340,
  341,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  129,
  130,
  619,
  182,
  183,
  184,
  185,
  186,
  187,
  188,
  189,
  190,
  191,
  192,
  193,
  632,
  207,
  196,
  197,
  494,
  130,
  130,
  130,
  130,
  130,
  406,
  129,
  31,
  207,
  208,
  50,
  51,
  211,
  129,
  415,
  416,
  90,
  91,
  92,
  404,
  405,
  129,
  112,
  91,
  92,
  406,
  64,
  65,
  66,
  119,
  229,
  129,
  95,
  96,
  415,
  416,
  95,
  96,
  31,
  102,
  425,
  77,
  427,
  102,
  64,
  65,
  136,
  71,
  90,
  91,
  92,
  141,
  142,
  143,
  128,
  69,
  131,
  71,
  72,
  258,
  128,
  446,
  64,
  65,
  265,
  128,
  64,
  65,
  66,
  128,
  131,
  13,
  271,
  97,
  273,
  274,
  275,
  276,
  107,
  128,
  378,
  129,
  443,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  129,
  457,
  80,
  309,
  90,
  91,
  92,
  8,
  131,
  315,
  63,
  64,
  65,
  509,
  88,
  309,
  88,
  69,
  69,
  69,
  516,
  315,
  207,
  130,
  71,
  521,
  506,
  523,
  130,
  69,
  130,
  127,
  8,
  509,
  42,
  43,
  44,
  45,
  46,
  47,
  516,
  136,
  26,
  130,
  8,
  521,
  502,
  523,
  129,
  129,
  13,
  13,
  532,
  129,
  131,
  69,
  60,
  128,
  69,
  244,
  245,
  129,
  518,
  378,
  130,
  108,
  360,
  130,
  362,
  129,
  127,
  13,
  568,
  8,
  259,
  130,
  109,
  131,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  396,
  385,
  568,
  399,
  13,
  131,
  131,
  593,
  71,
  395,
  596,
  13,
  396,
  71,
  129,
  399,
  526,
  527,
  402,
  403,
  8,
  296,
  408,
  109,
  130,
  50,
  51,
  593,
  8,
  71,
  596,
  136,
  87,
  136,
  309,
  621,
  13,
  130,
  130,
  13,
  315,
  130,
  81,
  128,
  131,
  320,
  130,
  431,
  131,
  595,
  131,
  71,
  71,
  109,
  127,
  621,
  440,
  441,
  69,
  69,
  129,
  131,
  608,
  71,
  450,
  449,
  130,
  13,
  614,
  60,
  131,
  131,
  347,
  26,
  66,
  26,
  66,
  623,
  69,
  129,
  71,
  72,
  628,
  74,
  75,
  76,
  129,
  42,
  43,
  85,
  128,
  131,
  638,
  129,
  131,
  130,
  83,
  643,
  482,
  130,
  127,
  485,
  131,
  378,
  129,
  130,
  128,
  491,
  131,
  655,
  656,
  0,
  67,
  68,
  69,
  0,
  347,
  108,
  582,
  265,
  586,
  396,
  77,
  454,
  399,
  474,
  82,
  296,
  471,
  404,
  405,
  231,
  123,
  124,
  125,
  440,
  127,
  128,
  492,
  494,
  480,
  423,
  -1,
  -1,
  419,
  136,
  -1,
  -1,
  423,
  -1,
  425,
  -1,
  427,
  -1,
  -1,
  -1,
  111,
  112,
  113,
  114,
  115,
  545,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  553,
  -1,
  446,
  -1,
  -1,
  -1,
  -1,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  -1,
  -1,
  576,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  -1,
  -1,
  480,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  50,
  51,
  -1,
  -1,
  -1,
  -1,
  -1,
  604,
  -1,
  -1,
  3,
  4,
  5,
  6,
  7,
  50,
  51,
  -1,
  506,
  12,
  -1,
  -1,
  -1,
  -1,
  -1,
  622,
  -1,
  626,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  532,
  -1,
  -1,
  646,
  -1,
  42,
  43,
  -1,
  -1,
  88,
  -1,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  -1,
  61,
  62,
  63,
  -1,
  -1,
  -1,
  67,
  68,
  69,
  70,
  71,
  129,
  73,
  131,
  -1,
  -1,
  77,
  78,
  79,
  80,
  -1,
  82,
  -1,
  84,
  -1,
  86,
  129,
  -1,
  89,
  -1,
  -1,
  -1,
  93,
  94,
  95,
  96,
  -1,
  98,
  99,
  100,
  101,
  -1,
  103,
  104,
  105,
  106,
  -1,
  -1,
  -1,
  110,
  111,
  112,
  113,
  114,
  115,
  3,
  4,
  5,
  6,
  7,
  -1,
  122,
  -1,
  -1,
  12,
  -1,
  127,
  -1,
  129,
  -1,
  131,
  132,
  133,
  134,
  135,
  -1,
  -1,
  -1,
  26,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  -1,
  -1,
  -1,
  42,
  43,
  -1,
  -1,
  -1,
  -1,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  -1,
  61,
  62,
  63,
  50,
  51,
  -1,
  67,
  68,
  69,
  70,
  71,
  -1,
  73,
  -1,
  -1,
  -1,
  77,
  78,
  79,
  80,
  -1,
  82,
  -1,
  84,
  -1,
  86,
  -1,
  -1,
  89,
  -1,
  -1,
  -1,
  93,
  94,
  -1,
  -1,
  -1,
  98,
  99,
  100,
  101,
  -1,
  103,
  104,
  105,
  -1,
  -1,
  -1,
  -1,
  110,
  111,
  112,
  113,
  114,
  115,
  3,
  4,
  5,
  6,
  7,
  -1,
  122,
  -1,
  -1,
  12,
  -1,
  127,
  -1,
  129,
  -1,
  131,
  132,
  133,
  134,
  135,
  -1,
  -1,
  -1,
  26,
  -1,
  -1,
  -1,
  129,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  42,
  43,
  -1,
  -1,
  -1,
  -1,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  -1,
  61,
  62,
  63,
  -1,
  -1,
  -1,
  67,
  68,
  69,
  70,
  71,
  -1,
  73,
  -1,
  -1,
  60,
  77,
  78,
  79,
  80,
  -1,
  82,
  -1,
  84,
  69,
  86,
  71,
  72,
  89,
  74,
  75,
  76,
  93,
  94,
  -1,
  -1,
  -1,
  98,
  99,
  100,
  101,
  -1,
  103,
  104,
  105,
  -1,
  -1,
  -1,
  -1,
  110,
  111,
  112,
  113,
  114,
  115,
  3,
  4,
  5,
  6,
  7,
  -1,
  122,
  -1,
  108,
  12,
  -1,
  127,
  -1,
  129,
  -1,
  131,
  132,
  133,
  134,
  135,
  -1,
  -1,
  -1,
  26,
  124,
  125,
  -1,
  127,
  128,
  -1,
  -1,
  -1,
  -1,
  133,
  -1,
  -1,
  136,
  -1,
  -1,
  42,
  43,
  -1,
  -1,
  -1,
  -1,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  -1,
  61,
  62,
  63,
  -1,
  -1,
  -1,
  67,
  68,
  69,
  70,
  71,
  -1,
  73,
  -1,
  -1,
  60,
  77,
  78,
  79,
  80,
  -1,
  82,
  -1,
  84,
  69,
  86,
  71,
  72,
  89,
  74,
  75,
  76,
  93,
  94,
  -1,
  -1,
  -1,
  98,
  99,
  100,
  101,
  -1,
  103,
  104,
  105,
  -1,
  -1,
  -1,
  -1,
  110,
  111,
  112,
  113,
  114,
  115,
  3,
  4,
  5,
  6,
  7,
  -1,
  122,
  -1,
  108,
  12,
  -1,
  127,
  -1,
  129,
  -1,
  131,
  132,
  133,
  134,
  135,
  -1,
  -1,
  -1,
  26,
  124,
  125,
  -1,
  127,
  128,
  -1,
  -1,
  -1,
  -1,
  -1,
  134,
  -1,
  136,
  -1,
  -1,
  42,
  43,
  -1,
  -1,
  -1,
  -1,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  -1,
  61,
  62,
  63,
  -1,
  -1,
  -1,
  67,
  68,
  69,
  70,
  71,
  -1,
  73,
  -1,
  -1,
  60,
  77,
  78,
  79,
  80,
  -1,
  82,
  -1,
  84,
  69,
  86,
  71,
  72,
  89,
  74,
  75,
  76,
  93,
  94,
  -1,
  -1,
  -1,
  98,
  99,
  100,
  101,
  -1,
  103,
  104,
  105,
  -1,
  -1,
  -1,
  -1,
  110,
  111,
  112,
  113,
  114,
  115,
  3,
  4,
  5,
  6,
  7,
  -1,
  122,
  -1,
  108,
  12,
  -1,
  127,
  -1,
  129,
  -1,
  131,
  132,
  133,
  134,
  135,
  -1,
  -1,
  -1,
  -1,
  124,
  125,
  -1,
  127,
  128,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  135,
  136,
  -1,
  -1,
  42,
  43,
  -1,
  -1,
  -1,
  -1,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  -1,
  61,
  62,
  63,
  -1,
  -1,
  -1,
  67,
  68,
  69,
  70,
  71,
  -1,
  73,
  -1,
  -1,
  -1,
  77,
  78,
  79,
  80,
  -1,
  82,
  -1,
  84,
  -1,
  86,
  -1,
  -1,
  89,
  -1,
  -1,
  -1,
  93,
  94,
  -1,
  -1,
  -1,
  98,
  99,
  100,
  101,
  -1,
  103,
  104,
  105,
  -1,
  -1,
  -1,
  -1,
  110,
  111,
  112,
  113,
  114,
  115,
  3,
  4,
  5,
  6,
  7,
  -1,
  122,
  -1,
  -1,
  12,
  -1,
  127,
  -1,
  129,
  -1,
  131,
  132,
  133,
  134,
  135,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3,
  4,
  5,
  6,
  7,
  -1,
  -1,
  42,
  43,
  12,
  -1,
  -1,
  -1,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  -1,
  61,
  62,
  -1,
  -1,
  -1,
  -1,
  67,
  68,
  69,
  70,
  71,
  -1,
  -1,
  42,
  43,
  -1,
  77,
  -1,
  -1,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  -1,
  61,
  62,
  -1,
  -1,
  -1,
  -1,
  67,
  68,
  69,
  70,
  71,
  104,
  105,
  -1,
  -1,
  -1,
  77,
  110,
  111,
  112,
  113,
  114,
  115,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  122,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  129,
  -1,
  131,
  132,
  133,
  134,
  135,
  104,
  105,
  -1,
  -1,
  -1,
  -1,
  110,
  111,
  112,
  113,
  114,
  115,
  3,
  4,
  5,
  6,
  7,
  -1,
  122,
  -1,
  -1,
  12,
  -1,
  -1,
  -1,
  129,
  -1,
  131,
  132,
  133,
  134,
  135,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3,
  4,
  5,
  6,
  7,
  -1,
  -1,
  42,
  43,
  12,
  -1,
  -1,
  -1,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  -1,
  61,
  62,
  -1,
  -1,
  -1,
  -1,
  67,
  68,
  69,
  70,
  71,
  -1,
  -1,
  42,
  43,
  -1,
  77,
  -1,
  -1,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  -1,
  61,
  62,
  -1,
  -1,
  -1,
  -1,
  67,
  68,
  69,
  70,
  71,
  104,
  105,
  -1,
  -1,
  -1,
  77,
  110,
  111,
  112,
  113,
  114,
  115,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  122,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  129,
  -1,
  131,
  132,
  133,
  134,
  135,
  104,
  105,
  -1,
  -1,
  -1,
  -1,
  110,
  111,
  112,
  113,
  114,
  115,
  3,
  4,
  5,
  6,
  7,
  -1,
  122,
  -1,
  -1,
  12,
  -1,
  -1,
  -1,
  129,
  130,
  -1,
  132,
  133,
  134,
  135,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  31,
  -1,
  -1,
  -1,
  3,
  4,
  5,
  6,
  7,
  -1,
  -1,
  42,
  43,
  12,
  -1,
  -1,
  -1,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  -1,
  61,
  62,
  31,
  -1,
  -1,
  -1,
  67,
  68,
  69,
  70,
  71,
  -1,
  -1,
  42,
  43,
  -1,
  77,
  -1,
  -1,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  -1,
  61,
  62,
  -1,
  -1,
  -1,
  -1,
  67,
  68,
  69,
  70,
  71,
  104,
  105,
  -1,
  -1,
  -1,
  77,
  110,
  111,
  112,
  113,
  114,
  115,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  122,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  129,
  -1,
  -1,
  132,
  133,
  134,
  135,
  104,
  105,
  -1,
  -1,
  -1,
  -1,
  110,
  111,
  112,
  113,
  114,
  115,
  3,
  4,
  5,
  6,
  7,
  -1,
  122,
  -1,
  -1,
  12,
  -1,
  -1,
  -1,
  129,
  -1,
  -1,
  132,
  133,
  134,
  135,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  31,
  -1,
  -1,
  -1,
  3,
  4,
  5,
  6,
  7,
  -1,
  -1,
  42,
  43,
  12,
  -1,
  -1,
  -1,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  -1,
  61,
  62,
  31,
  -1,
  -1,
  -1,
  67,
  68,
  69,
  70,
  71,
  -1,
  -1,
  42,
  43,
  -1,
  77,
  -1,
  -1,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  -1,
  61,
  62,
  -1,
  -1,
  -1,
  -1,
  67,
  68,
  69,
  70,
  71,
  104,
  105,
  -1,
  -1,
  -1,
  77,
  110,
  111,
  112,
  113,
  114,
  115,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  122,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  129,
  -1,
  -1,
  132,
  133,
  134,
  135,
  104,
  105,
  -1,
  -1,
  -1,
  -1,
  110,
  111,
  112,
  113,
  114,
  115,
  3,
  4,
  5,
  6,
  7,
  -1,
  122,
  -1,
  -1,
  12,
  -1,
  -1,
  -1,
  129,
  -1,
  -1,
  132,
  133,
  134,
  135,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  31,
  -1,
  -1,
  -1,
  3,
  4,
  5,
  6,
  7,
  -1,
  -1,
  42,
  43,
  12,
  -1,
  -1,
  -1,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  -1,
  61,
  62,
  31,
  -1,
  -1,
  -1,
  67,
  68,
  69,
  70,
  71,
  -1,
  -1,
  42,
  43,
  -1,
  77,
  -1,
  -1,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  -1,
  61,
  62,
  -1,
  -1,
  -1,
  -1,
  67,
  68,
  69,
  70,
  71,
  104,
  105,
  -1,
  -1,
  -1,
  77,
  110,
  111,
  112,
  113,
  114,
  115,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  122,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  129,
  -1,
  -1,
  132,
  133,
  134,
  135,
  104,
  105,
  -1,
  -1,
  -1,
  -1,
  110,
  111,
  112,
  113,
  114,
  115,
  3,
  4,
  5,
  6,
  7,
  -1,
  122,
  -1,
  -1,
  12,
  -1,
  -1,
  -1,
  129,
  -1,
  -1,
  132,
  133,
  134,
  135,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  31,
  -1,
  -1,
  -1,
  3,
  4,
  5,
  6,
  7,
  -1,
  -1,
  42,
  43,
  12,
  -1,
  -1,
  -1,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  -1,
  61,
  62,
  -1,
  -1,
  -1,
  -1,
  67,
  68,
  69,
  70,
  71,
  -1,
  -1,
  42,
  43,
  -1,
  77,
  -1,
  -1,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  -1,
  61,
  62,
  -1,
  -1,
  -1,
  -1,
  67,
  68,
  69,
  70,
  71,
  104,
  105,
  -1,
  -1,
  -1,
  77,
  110,
  111,
  112,
  113,
  114,
  115,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  122,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  129,
  -1,
  -1,
  132,
  133,
  134,
  135,
  104,
  105,
  -1,
  -1,
  -1,
  -1,
  110,
  111,
  112,
  113,
  114,
  115,
  3,
  4,
  5,
  6,
  7,
  -1,
  122,
  -1,
  -1,
  12,
  -1,
  -1,
  -1,
  129,
  -1,
  -1,
  132,
  133,
  134,
  135,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  42,
  43,
  -1,
  -1,
  -1,
  -1,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  -1,
  61,
  62,
  9,
  10,
  11,
  -1,
  67,
  68,
  69,
  70,
  71,
  -1,
  -1,
  -1,
  -1,
  -1,
  77,
  -1,
  25,
  -1,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  -1,
  -1,
  104,
  105,
  -1,
  -1,
  -1,
  -1,
  110,
  111,
  112,
  113,
  114,
  115,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  122,
  9,
  10,
  11,
  -1,
  -1,
  -1,
  129,
  -1,
  -1,
  132,
  133,
  134,
  135,
  -1,
  -1,
  -1,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  10,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  25,
  136,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  9,
  10,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  25,
  131,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  10,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  25,
  131,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  10,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  25,
  131,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  10,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  25,
  131,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  10,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  25,
  130,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  10,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  25,
  130,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  10,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  25,
  130,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  10,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  25,
  130,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  10,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  25,
  130,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  10,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  25,
  130,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  10,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  25,
  130,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  10,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  25,
  130,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  10,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  25,
  130,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  10,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  25,
  128,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  10,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  25,
  128,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  10,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  25,
  128,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  10,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  25,
  128,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  10,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  25,
  128,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  10,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  25,
  128,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  9,
  10,
  11,
  -1,
  -1,
  -1,
  -1,
  109,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  10,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  25,
  109,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  10,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  25,
  -1,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  25,
  -1,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  25,
  -1,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  0
}; // weak
__int16 word_49A330[1352] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  146,
  98,
  98,
  144,
  107,
  84,
  121,
  108,
  84,
  84,
  84,
  124,
  84,
  84,
  84,
  84,
  84,
  84,
  84,
  90,
  90,
  84,
  84,
  84,
  84,
  84,
  84,
  105,
  123,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  85,
  84,
  87,
  126,
  141,
  131,
  126,
  92,
  92,
  131,
  144,
  106,
  128,
  131,
  127,
  143,
  144,
  129,
  144,
  142,
  140,
  126,
  144,
  106,
  33,
  32,
  89,
  88,
  114,
  116,
  110,
  111,
  111,
  109,
  109,
  109,
  98,
  0,
  98,
  101,
  99,
  98,
  107,
  63,
  0,
  119,
  0,
  104,
  71,
  118,
  78,
  74,
  0,
  120,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  68,
  58,
  66,
  59,
  67,
  31,
  93,
  70,
  113,
  108,
  69,
  93,
  90,
  0,
  0,
  34,
  0,
  82,
  64,
  63,
  62,
  55,
  65,
  83,
  117,
  76,
  105,
  105,
  105,
  105,
  20,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  13,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  7,
  105,
  105,
  105,
  105,
  105,
  79,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  75,
  77,
  126,
  130,
  86,
  31,
  92,
  0,
  139,
  135,
  137,
  139,
  106,
  128,
  132,
  127,
  0,
  133,
  134,
  129,
  136,
  140,
  126,
  125,
  125,
  106,
  0,
  32,
  88,
  114,
  115,
  110,
  111,
  112,
  98,
  0,
  100,
  0,
  0,
  61,
  104,
  118,
  118,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  93,
  0,
  93,
  91,
  0,
  0,
  72,
  60,
  73,
  117,
  117,
  105,
  105,
  105,
  80,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  2,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  14,
  105,
  105,
  105,
  105,
  105,
  35,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  49,
  36,
  105,
  81,
  92,
  137,
  138,
  98,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  105,
  105,
  105,
  105,
  105,
  105,
  23,
  105,
  105,
  105,
  105,
  105,
  105,
  27,
  10,
  105,
  105,
  105,
  105,
  105,
  105,
  44,
  1,
  105,
  105,
  105,
  105,
  105,
  105,
  56,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  137,
  138,
  98,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  37,
  0,
  0,
  0,
  0,
  0,
  0,
  122,
  122,
  0,
  105,
  105,
  105,
  105,
  57,
  25,
  105,
  29,
  5,
  105,
  105,
  105,
  105,
  52,
  105,
  105,
  9,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  51,
  105,
  28,
  105,
  105,
  105,
  105,
  54,
  11,
  98,
  0,
  102,
  102,
  0,
  0,
  0,
  0,
  42,
  0,
  0,
  0,
  0,
  0,
  38,
  0,
  0,
  0,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  8,
  105,
  15,
  105,
  105,
  105,
  105,
  105,
  50,
  105,
  105,
  105,
  6,
  53,
  21,
  98,
  0,
  0,
  0,
  0,
  40,
  0,
  0,
  0,
  0,
  0,
  43,
  0,
  105,
  105,
  105,
  105,
  105,
  105,
  18,
  24,
  105,
  105,
  105,
  105,
  30,
  16,
  105,
  45,
  105,
  47,
  98,
  0,
  0,
  0,
  0,
  0,
  0,
  41,
  0,
  39,
  0,
  105,
  97,
  105,
  96,
  105,
  26,
  105,
  105,
  105,
  12,
  4,
  105,
  105,
  105,
  98,
  0,
  0,
  0,
  0,
  94,
  105,
  105,
  105,
  22,
  105,
  105,
  105,
  98,
  0,
  0,
  0,
  105,
  19,
  17,
  105,
  105,
  105,
  98,
  0,
  0,
  0,
  105,
  105,
  105,
  105,
  98,
  0,
  0,
  0,
  95,
  46,
  3,
  48,
  98,
  0,
  0,
  0,
  98,
  0,
  0,
  0,
  98,
  0,
  0,
  0,
  98,
  0,
  0,
  0,
  98,
  0,
  0,
  0,
  0,
  98,
  0,
  103,
  0,
  0,
  0,
  0,
  98,
  0,
  103,
  103,
  0,
  0,
  0,
  98,
  0,
  0,
  0,
  0,
  98,
  0,
  0,
  0,
  0,
  99,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  98,
  0,
  0,
  0
}; // weak
char byte_49ADC0[] = { '\0' }; // weak
char byte_49B1C0[] = { '\0' }; // weak
int (__cdecl *xmlMallocAtomic)(size_t Size) = &malloc; // weak
__int16 word_49B2C0[1772] =
{
  0,
  7910,
  7909,
  0,
  0,
  62,
  0,
  114,
  115,
  121,
  122,
  123,
  151,
  210,
  0,
  272,
  0,
  7919,
  7918,
  132,
  139,
  7931,
  7905,
  121,
  7936,
  129,
  7903,
  131,
  7936,
  0,
  112,
  137,
  135,
  333,
  7936,
  7902,
  143,
  151,
  150,
  322,
  322,
  331,
  7904,
  320,
  148,
  153,
  7899,
  7899,
  7892,
  7936,
  303,
  7872,
  332,
  340,
  347,
  308,
  7877,
  0,
  351,
  7879,
  7882,
  312,
  7868,
  7880,
  305,
  312,
  7883,
  7875,
  7867,
  7936,
  312,
  7936,
  0,
  7936,
  404,
  7887,
  447,
  375,
  7936,
  464,
  0,
  7880,
  7904,
  7881,
  7936,
  460,
  7904,
  453,
  7936,
  466,
  469,
  458,
  479,
  7936,
  0,
  7936,
  0,
  0,
  7890,
  0,
  7936,
  7905,
  7880,
  7936,
  7879,
  7880,
  467,
  7879,
  7877,
  350,
  7866,
  485,
  7875,
  134,
  7936,
  383,
  0,
  7936,
  397,
  7936,
  7936,
  470,
  7936,
  7897,
  0,
  7848,
  7850,
  7849,
  7851,
  7848,
  7859,
  7855,
  7839,
  7844,
  7936,
  7936,
  7936,
  7936,
  7936,
  7936,
  476,
  7936,
  7936,
  7936,
  7936,
  485,
  491,
  505,
  496,
  7936,
  7838,
  468,
  7936,
  7936,
  7863,
  7936,
  7936,
  7862,
  533,
  7936,
  0,
  502,
  7850,
  7835,
  0,
  7847,
  7832,
  7829,
  7848,
  7834,
  503,
  7842,
  0,
  7838,
  7826,
  7828,
  7839,
  7841,
  498,
  7823,
  7826,
  7824,
  0,
  7835,
  7818,
  7817,
  7812,
  7830,
  0,
  7824,
  493,
  7831,
  7822,
  7811,
  7824,
  7810,
  7818,
  7808,
  7936,
  7936,
  0,
  7936,
  7936,
  0,
  528,
  532,
  7936,
  7936,
  524,
  538,
  0,
  7825,
  7936,
  7827,
  7826,
  7936,
  7936,
  7849,
  7936,
  550,
  551,
  7936,
  7851,
  561,
  575,
  0,
  0,
  0,
  7936,
  0,
  7936,
  7936,
  7828,
  571,
  7936,
  7811,
  7800,
  7936,
  0,
  7936,
  7847,
  7798,
  7800,
  7793,
  7798,
  7792,
  7801,
  7809,
  7791,
  7789,
  566,
  569,
  572,
  580,
  7804,
  7837,
  7936,
  7936,
  7936,
  7936,
  7835,
  7792,
  553,
  7794,
  0,
  7801,
  7800,
  7795,
  7785,
  7779,
  529,
  7785,
  7795,
  0,
  7780,
  7789,
  7773,
  569,
  7780,
  7771,
  7785,
  7784,
  7785,
  7785,
  7774,
  7780,
  7764,
  0,
  7784,
  7768,
  7760,
  7759,
  7759,
  7758,
  7772,
  0,
  0,
  7764,
  0,
  606,
  577,
  612,
  7783,
  611,
  7758,
  7764,
  7771,
  7759,
  7768,
  7768,
  622,
  7763,
  7755,
  7757,
  7760,
  3005,
  3053,
  606,
  3019,
  3007,
  3004,
  3003,
  2991,
  2990,
  0,
  2997,
  2980,
  2978,
  2988,
  2995,
  2974,
  0,
  2985,
  2968,
  2973,
  2962,
  2951,
  2931,
  2939,
  0,
  0,
  2924,
  2936,
  2914,
  2932,
  2909,
  2907,
  0,
  2920,
  2905,
  2915,
  2905,
  2907,
  2905,
  2887,
  2886,
  7936,
  7936,
  2895,
  628,
  627,
  2866,
  2856,
  652,
  2848,
  2834,
  653,
  7936,
  2775,
  2777,
  655,
  2765,
  2758,
  2766,
  7936,
  2804,
  609,
  2754,
  2767,
  2767,
  2764,
  0,
  0,
  2748,
  0,
  0,
  2753,
  2747,
  2752,
  2757,
  0,
  2759,
  2743,
  0,
  2751,
  2749,
  2751,
  2748,
  2736,
  2731,
  2728,
  0,
  2709,
  0,
  2711,
  2713,
  2722,
  2712,
  0,
  0,
  2726,
  649,
  7936,
  2746,
  2695,
  2677,
  659,
  660,
  7936,
  2689,
  2682,
  2681,
  2665,
  662,
  7936,
  2677,
  665,
  2665,
  2661,
  2676,
  2650,
  2660,
  2641,
  2626,
  2640,
  2624,
  0,
  2629,
  2635,
  2610,
  2615,
  2605,
  2602,
  2592,
  0,
  2600,
  2590,
  2596,
  0,
  0,
  0,
  2600,
  660,
  2572,
  679,
  674,
  7936,
  2575,
  2569,
  682,
  684,
  687,
  7936,
  2550,
  2568,
  2565,
  2552,
  2558,
  2539,
  2547,
  0,
  0,
  2549,
  2546,
  2532,
  2519,
  0,
  0,
  2508,
  2522,
  2516,
  2518,
  2520,
  682,
  2509,
  690,
  696,
  700,
  701,
  7936,
  702,
  7936,
  714,
  2509,
  0,
  2492,
  0,
  2475,
  0,
  2464,
  2476,
  2470,
  0,
  0,
  2462,
  2456,
  2458,
  2480,
  696,
  2464,
  2461,
  723,
  0,
  2437,
  2437,
  2431,
  0,
  2423,
  2427,
  2419,
  2440,
  711,
  2411,
  2405,
  2417,
  0,
  0,
  2399,
  2384,
  2394,
  2404,
  719,
  2394,
  2377,
  2383,
  2376,
  2365,
  2357,
  2367,
  721,
  2334,
  2332,
  0,
  0,
  0,
  0,
  2357,
  728,
  2345,
  2343,
  2350,
  729,
  2321,
  2320,
  2324,
  733,
  2295,
  2308,
  2319,
  734,
  2314,
  729,
  2312,
  742,
  2308,
  762,
  772,
  2308,
  759,
  667,
  787,
  2283,
  2265,
  2266,
  2279,
  787,
  7936,
  2300,
  2261,
  2260,
  2249,
  2272,
  788,
  2243,
  2238,
  797,
  2251,
  794,
  2261,
  2253,
  802,
  7936,
  2237,
  798,
  2236,
  800,
  2233,
  805,
  2232,
  809,
  2222,
  823,
  2219,
  834,
  2216,
  835,
  2202,
  840,
  2199,
  844,
  2197,
  845,
  2196,
  846,
  2193,
  855,
  2184,
  857,
  2182,
  875,
  2181,
  880,
  2179,
  885,
  2162,
  886,
  2159,
  890,
  2156,
  892,
  2153,
  897,
  2149,
  903,
  2146,
  915,
  2144,
  920,
  2142,
  925,
  2139,
  926,
  2127,
  932,
  2116,
  937,
  2114,
  938,
  2113,
  943,
  2111,
  955,
  2109,
  960,
  2104,
  966,
  2102,
  972,
  2100,
  973,
  2099,
  977,
  2081,
  978,
  2074,
  983,
  2071,
  995,
  2070,
  1006,
  2069,
  1008,
  2068,
  1012,
  2065,
  1013,
  2064,
  1017,
  2059,
  1018,
  2054,
  1023,
  2043,
  1043,
  2034,
  1048,
  2031,
  1052,
  2029,
  1053,
  2028,
  1054,
  2025,
  1058,
  2024,
  1063,
  2014,
  1065,
  2011,
  1083,
  2008,
  1088,
  1994,
  1093,
  1991,
  1094,
  1989,
  1098,
  1988,
  1100,
  1985,
  1105,
  1976,
  1111,
  1974,
  1123,
  1973,
  1128,
  1971,
  1133,
  1954,
  1134,
  1951,
  1140,
  1948,
  1145,
  1945,
  1146,
  1941,
  1151,
  1938,
  1163,
  1936,
  1168,
  1934,
  1174,
  1931,
  1180,
  1919,
  1181,
  1908,
  1185,
  1906,
  1186,
  1905,
  1191,
  1903,
  1203,
  1901,
  1214,
  1896,
  1216,
  1894,
  1220,
  1892,
  1221,
  1891,
  1225,
  1873,
  1226,
  1866,
  1231,
  1863,
  1251,
  1862,
  1256,
  1861,
  1260,
  1860,
  1261,
  1857,
  1262,
  1856,
  1266,
  1851,
  1271,
  1846,
  1273,
  1835,
  1291,
  1826,
  1296,
  1823,
  1301,
  1821,
  1302,
  1820,
  1306,
  1817,
  1308,
  1816,
  1313,
  1806,
  1319,
  1803,
  1331,
  1800,
  1336,
  1786,
  1341,
  1783,
  1342,
  1781,
  1348,
  1780,
  1353,
  1777,
  1354,
  1768,
  1359,
  1766,
  1371,
  1765,
  1376,
  1763,
  1382,
  1746,
  1388,
  1743,
  1389,
  1740,
  1393,
  1737,
  1394,
  1733,
  1399,
  1730,
  1411,
  1728,
  1422,
  1726,
  1424,
  1723,
  1428,
  1711,
  1429,
  1700,
  1433,
  1698,
  1434,
  1697,
  1439,
  1695,
  1459,
  1693,
  1464,
  1688,
  1468,
  1686,
  1469,
  1684,
  1470,
  1683,
  1474,
  1665,
  1479,
  1658,
  1481,
  1655,
  1499,
  1654,
  1504,
  1653,
  1509,
  1652,
  1510,
  1649,
  1514,
  1648,
  1516,
  1643,
  1521,
  1638,
  1527,
  1627,
  1539,
  1618,
  1544,
  1615,
  1549,
  1613,
  1550,
  1612,
  1556,
  1609,
  1561,
  1608,
  1562,
  1598,
  1567,
  1595,
  1579,
  1592,
  1584,
  1578,
  1590,
  1575,
  1596,
  1573,
  1597,
  1572,
  1601,
  1569,
  1602,
  1560,
  1607,
  1558,
  1619,
  1557,
  1630,
  1555,
  1632,
  1538,
  1636,
  1535,
  1637,
  1532,
  1641,
  1529,
  1642,
  1525,
  1647,
  1522,
  1667,
  1520,
  1672,
  1518,
  1676,
  1515,
  1677,
  1503,
  1678,
  1492,
  1682,
  1490,
  1687,
  1489,
  1689,
  1487,
  1707,
  1485,
  1712,
  1480,
  1717,
  1478,
  1718,
  1476,
  1722,
  1475,
  1724,
  1457,
  1729,
  125,
  1735,
  157,
  1747,
  312,
  1752,
  340,
  1757,
  349,
  1758,
  364,
  1764,
  466,
  1769,
  476,
  1770,
  483,
  1775,
  499,
  1787,
  503,
  1792,
  530,
  1798,
  538,
  1804,
  578,
  1805,
  580,
  1809,
  597,
  1810,
  613,
  1815,
  627,
  1827,
  654,
  1838,
  671,
  1840,
  674,
  1844,
  681,
  1845,
  683,
  1849,
  686,
  1850,
  694,
  1855,
  697,
  1875,
  698,
  1880,
  704,
  1884,
  715,
  1885,
  720,
  1886,
  727,
  1890,
  735,
  1895,
  744,
  1897,
  747,
  1915,
  752,
  1920,
  754,
  1925,
  757,
  1926,
  767,
  1930,
  770,
  1932,
  777,
  1937,
  783,
  1943,
  785,
  1955,
  792,
  1960,
  795,
  1965,
  802,
  1966,
  806,
  1972,
  810,
  1977,
  813,
  1978,
  816,
  1983,
  817,
  1995,
  820,
  2000,
  822,
  2006,
  831,
  2012,
  833,
  2013,
  842,
  2017,
  851,
  2018,
  852,
  2023,
  853,
  2035,
  854,
  2046,
  856,
  2048,
  863,
  2052,
  865,
  2053,
  866,
  2057,
  868,
  2058,
  877,
  2063,
  879,
  2083,
  891,
  2088,
  894,
  2092,
  896,
  2093,
  898,
  2094,
  901,
  2098,
  905,
  2103,
  908,
  2105,
  911,
  2123,
  914,
  2128,
  931,
  2133,
  933,
  2134,
  934,
  2138,
  936,
  2140,
  945,
  2145,
  948,
  2151,
  949,
  2163,
  951,
  2168,
  954,
  2173,
  968,
  2174,
  971,
  2180,
  974,
  2185,
  984,
  2186,
  985,
  2191,
  988,
  2203,
  989,
  2208,
  991,
  2214,
  994,
  2220,
  1003,
  2221,
  1014,
  2225,
  1019,
  2226,
  1024,
  2231,
  1025,
  2243,
  1028,
  2254,
  1029,
  2256,
  1030,
  2260,
  1031,
  2261,
  1034,
  2265,
  1041,
  2266,
  1059,
  2271,
  1060,
  2291,
  1062,
  2296,
  1064,
  2300,
  1069,
  2301,
  1071,
  2302,
  1073,
  2306,
  1074,
  2311,
  1076,
  2313,
  1087,
  2331,
  1099,
  2336,
  1102,
  2341,
  1104,
  2342,
  1106,
  2346,
  1109,
  2348,
  1113,
  2353,
  1116,
  2359,
  1119,
  2371,
  1122,
  2376,
  1139,
  2381,
  1141,
  2382,
  1142,
  2388,
  1144,
  2393,
  1153,
  2394,
  1156,
  2399,
  1157,
  2411,
  1159,
  2416,
  1162,
  2422,
  1176,
  2428,
  1179,
  2429,
  1182,
  2433,
  1192,
  2434,
  1193,
  2439,
  1196,
  2451,
  1197,
  2462,
  1199,
  2464,
  1202,
  2468,
  1211,
  2469,
  1222,
  2473,
  1227,
  2474,
  1232,
  2479,
  1233,
  2499,
  1236,
  2504,
  1237,
  2508,
  1238,
  2509,
  1239,
  2510,
  1242,
  2514,
  1249,
  2519,
  1267,
  2521,
  1268,
  2539,
  1270,
  2544,
  1272,
  2549,
  1277,
  2550,
  1279,
  2554,
  1281,
  2556,
  1282,
  2561,
  1284,
  2567,
  1295,
  2579,
  1307,
  2584,
  1310,
  2589,
  1312,
  2590,
  1314,
  2596,
  1317,
  2601,
  1321,
  2602,
  1324,
  2607,
  1327,
  2619,
  1330,
  2624,
  1347,
  2630,
  1349,
  2636,
  1350,
  2637,
  1352,
  2641,
  1361,
  2642,
  1364,
  2647,
  1365,
  2659,
  1367,
  2670,
  1370,
  2672,
  1384,
  2676,
  1387,
  2677,
  1390,
  2681,
  1400,
  2682,
  1401,
  2687,
  1404,
  2707,
  1405,
  2712,
  1407,
  2716,
  1410,
  2717,
  1419,
  2718,
  1430,
  2722,
  1435,
  2727,
  1440,
  2729,
  1441,
  2747,
  1444,
  2752,
  1445,
  2757,
  1446,
  2758,
  1447,
  2762,
  7936,
  2764,
  7936,
  2816,
  2828,
  2840,
  2852,
  2864,
  2876,
  2888,
  1463,
  2900,
  2904,
  2915,
  2926,
  2930,
  2942,
  2952,
  2956,
  2960,
  2972,
  2984,
  2996,
  3000,
  3012,
  3023,
  3035,
  3045,
  3057,
  3069,
  3081,
  3093,
  3105,
  3117,
  3129,
  3141,
  3153,
  3165,
  3177,
  3189,
  3201,
  3213,
  3225,
  3237,
  3249,
  3261,
  3273,
  3285,
  3297,
  3309,
  3321,
  3333,
  3345,
  3357,
  3369,
  3381,
  3393,
  3405,
  3417,
  3429,
  3441,
  3453,
  3465,
  3477,
  3489,
  3501,
  3513,
  3525,
  3537,
  3549,
  3561,
  3573,
  3585,
  3597,
  3609,
  3621,
  3633,
  3645,
  3657,
  3669,
  3681,
  3693,
  3705,
  3717,
  3729,
  3741,
  3753,
  3765,
  3777,
  3789,
  3801,
  3813,
  3825,
  3837,
  3849,
  3861,
  3873,
  3885,
  3897,
  3909,
  3921,
  3933,
  3945,
  3957,
  3969,
  3981,
  3993,
  4005,
  4017,
  4029,
  4041,
  4053,
  4065,
  4077,
  4089,
  4101,
  4113,
  4125,
  4137,
  4149,
  4161,
  4173,
  4185,
  4197,
  4209,
  4221,
  4233,
  4245,
  4257,
  4269,
  4281,
  4293,
  4305,
  4317,
  4329,
  4341,
  4353,
  4365,
  4377,
  4389,
  4401,
  4413,
  4425,
  4437,
  4449,
  4461,
  4473,
  4485,
  4497,
  4509,
  4521,
  4533,
  4545,
  4557,
  4569,
  4581,
  4593,
  4605,
  4617,
  4629,
  4641,
  4653,
  4665,
  4677,
  4689,
  4701,
  4713,
  4725,
  4737,
  4749,
  4761,
  4773,
  4785,
  4797,
  4809,
  4821,
  4833,
  4845,
  4857,
  4869,
  4881,
  4893,
  4905,
  4917,
  4929,
  4941,
  4953,
  4965,
  4977,
  4989,
  5001,
  5013,
  5025,
  5037,
  5049,
  5061,
  5073,
  5085,
  5097,
  5109,
  5121,
  5133,
  5145,
  5157,
  5169,
  5181,
  5193,
  5205,
  5217,
  5229,
  5241,
  5253,
  5265,
  5277,
  5289,
  5301,
  5313,
  5325,
  5337,
  5349,
  5361,
  5373,
  5385,
  5397,
  5409,
  5421,
  5433,
  5445,
  5457,
  5469,
  5481,
  5493,
  5505,
  5517,
  5529,
  5541,
  5553,
  5565,
  5577,
  5589,
  5601,
  5613,
  5625,
  5637,
  5649,
  5661,
  5673,
  5685,
  5697,
  5709,
  5721,
  5733,
  5745,
  5757,
  5769,
  5781,
  5793,
  5805,
  5817,
  5829,
  5841,
  5853,
  5865,
  5877,
  5889,
  5901,
  5913,
  5925,
  5937,
  5949,
  5961,
  5973,
  5985,
  5997,
  6009,
  6021,
  6033,
  6045,
  6057,
  6069,
  6081,
  6093,
  6105,
  6117,
  6129,
  6141,
  6153,
  6165,
  6177,
  6189,
  6201,
  6213,
  6225,
  6237,
  6249,
  6261,
  6273,
  6285,
  6297,
  6309,
  6321,
  6333,
  6345,
  6357,
  6369,
  6381,
  6393,
  6405,
  6417,
  6429,
  6441,
  6453,
  6465,
  6477,
  6489,
  6501,
  6513,
  6525,
  6537,
  6549,
  6561,
  6573,
  6585,
  6597,
  6609,
  6621,
  6633,
  6645,
  6657,
  6669,
  6681,
  6693,
  6705,
  6717,
  6729,
  6741,
  6753,
  6765,
  6777,
  6789,
  6801,
  6813,
  6825,
  6837,
  6849,
  6861,
  6873,
  6885,
  6897,
  6909,
  6921,
  6933,
  6945,
  6957,
  6969,
  6981,
  6993,
  7005,
  7017,
  7029,
  7041,
  7053,
  7065,
  7077,
  7089,
  7101,
  7113,
  7125,
  7137,
  7149,
  7161,
  7173,
  7185,
  7197,
  7209,
  7221,
  7233,
  7245,
  7257,
  7269,
  7281,
  7293,
  7305,
  7317,
  7329,
  7341,
  7353,
  7365,
  7377,
  7389,
  7401,
  7413,
  7425,
  7437,
  7449,
  7461,
  7473,
  7485,
  7497,
  7509,
  7521,
  7533,
  7545,
  7557,
  7569,
  7581,
  7593,
  7605,
  7617,
  7629,
  7641,
  7653,
  7665,
  7677,
  7689,
  7701,
  7713,
  7725,
  7737,
  7749,
  7761,
  7773,
  7785,
  0
}; // weak
__int16 word_49C098[] = { 0 }; // weak
__int16 word_49CE70[8000] =
{
  0,
  24,
  25,
  25,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  34,
  37,
  38,
  39,
  40,
  41,
  41,
  42,
  34,
  43,
  44,
  45,
  46,
  34,
  24,
  47,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  57,
  57,
  59,
  57,
  60,
  61,
  62,
  57,
  63,
  64,
  57,
  65,
  66,
  67,
  68,
  57,
  57,
  69,
  70,
  71,
  24,
  72,
  72,
  72,
  72,
  73,
  72,
  74,
  72,
  72,
  72,
  72,
  72,
  72,
  72,
  72,
  75,
  72,
  72,
  76,
  77,
  77,
  72,
  72,
  72,
  72,
  72,
  72,
  78,
  79,
  72,
  80,
  81,
  80,
  80,
  80,
  80,
  80,
  80,
  80,
  80,
  80,
  80,
  80,
  80,
  80,
  80,
  80,
  80,
  80,
  80,
  80,
  80,
  80,
  80,
  80,
  80,
  80,
  80,
  82,
  72,
  78,
  84,
  84,
  86,
  86,
  89,
  108,
  111,
  111,
  111,
  90,
  100,
  101,
  114,
  117,
  118,
  114,
  102,
  100,
  101,
  85,
  85,
  122,
  119,
  102,
  109,
  955,
  87,
  87,
  91,
  88,
  88,
  89,
  89,
  135,
  103,
  104,
  115,
  90,
  120,
  115,
  123,
  103,
  104,
  137,
  136,
  140,
  140,
  140,
  110,
  154,
  155,
  141,
  138,
  139,
  156,
  157,
  91,
  957,
  92,
  89,
  92,
  92,
  92,
  92,
  92,
  92,
  92,
  92,
  92,
  92,
  92,
  92,
  92,
  92,
  92,
  92,
  92,
  92,
  92,
  92,
  92,
  92,
  92,
  92,
  92,
  92,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  94,
  93,
  94,
  94,
  94,
  94,
  94,
  94,
  94,
  94,
  94,
  94,
  94,
  94,
  94,
  94,
  94,
  94,
  94,
  94,
  94,
  94,
  94,
  94,
  94,
  94,
  94,
  94,
  93,
  93,
  93,
  95,
  95,
  95,
  95,
  95,
  95,
  95,
  95,
  95,
  95,
  95,
  95,
  95,
  95,
  95,
  95,
  95,
  95,
  95,
  95,
  95,
  95,
  95,
  95,
  95,
  95,
  95,
  95,
  95,
  95,
  95,
  96,
  95,
  96,
  96,
  96,
  96,
  96,
  96,
  96,
  96,
  96,
  96,
  96,
  96,
  96,
  96,
  96,
  96,
  96,
  96,
  96,
  96,
  96,
  96,
  96,
  96,
  96,
  96,
  95,
  95,
  95,
  124,
  142,
  959,
  198,
  150,
  145,
  143,
  146,
  146,
  146,
  151,
  152,
  153,
  144,
  145,
  162,
  146,
  146,
  146,
  163,
  164,
  179,
  187,
  191,
  193,
  147,
  192,
  180,
  188,
  194,
  961,
  166,
  125,
  126,
  147,
  127,
  167,
  128,
  199,
  963,
  129,
  234,
  168,
  170,
  148,
  169,
  130,
  171,
  173,
  131,
  132,
  1350,
  133,
  172,
  965,
  182,
  113,
  174,
  175,
  176,
  204,
  204,
  204,
  183,
  235,
  239,
  240,
  177,
  184,
  178,
  201,
  201,
  201,
  201,
  201,
  201,
  201,
  201,
  201,
  201,
  201,
  201,
  201,
  201,
  201,
  201,
  201,
  201,
  201,
  201,
  201,
  201,
  201,
  201,
  201,
  201,
  201,
  201,
  201,
  201,
  201,
  116,
  201,
  116,
  116,
  116,
  116,
  116,
  116,
  116,
  116,
  116,
  116,
  116,
  116,
  116,
  116,
  116,
  116,
  116,
  116,
  116,
  116,
  116,
  116,
  116,
  116,
  116,
  116,
  202,
  201,
  201,
  204,
  204,
  204,
  207,
  215,
  219,
  208,
  208,
  219,
  1350,
  219,
  208,
  208,
  220,
  122,
  221,
  222,
  208,
  208,
  218,
  111,
  111,
  111,
  216,
  967,
  1350,
  255,
  256,
  1350,
  140,
  140,
  140,
  219,
  123,
  969,
  219,
  224,
  205,
  250,
  250,
  250,
  971,
  145,
  209,
  146,
  146,
  146,
  147,
  209,
  253,
  253,
  253,
  1350,
  251,
  209,
  251,
  147,
  973,
  252,
  252,
  252,
  975,
  147,
  253,
  253,
  253,
  253,
  253,
  253,
  259,
  260,
  261,
  271,
  279,
  262,
  272,
  290,
  300,
  300,
  291,
  263,
  204,
  204,
  204,
  280,
  299,
  299,
  299,
  977,
  219,
  219,
  301,
  301,
  301,
  219,
  220,
  979,
  221,
  222,
  299,
  299,
  299,
  299,
  299,
  299,
  301,
  301,
  301,
  301,
  301,
  301,
  221,
  222,
  1350,
  327,
  328,
  219,
  219,
  224,
  250,
  250,
  250,
  252,
  252,
  252,
  252,
  252,
  252,
  319,
  1350,
  356,
  356,
  1350,
  253,
  253,
  253,
  981,
  147,
  983,
  334,
  320,
  335,
  374,
  375,
  336,
  374,
  375,
  253,
  253,
  253,
  253,
  253,
  253,
  1350,
  337,
  985,
  1350,
  366,
  338,
  299,
  299,
  299,
  412,
  412,
  413,
  357,
  357,
  357,
  367,
  1350,
  1350,
  987,
  1350,
  299,
  299,
  299,
  299,
  299,
  299,
  357,
  357,
  357,
  357,
  357,
  357,
  989,
  1350,
  417,
  366,
  1350,
  423,
  1350,
  414,
  368,
  455,
  417,
  1350,
  423,
  418,
  367,
  461,
  424,
  1350,
  576,
  577,
  456,
  418,
  1350,
  424,
  455,
  1350,
  462,
  991,
  1350,
  485,
  485,
  485,
  488,
  1350,
  490,
  456,
  1350,
  461,
  419,
  1350,
  485,
  485,
  485,
  489,
  993,
  491,
  417,
  995,
  462,
  1350,
  366,
  488,
  490,
  1350,
  997,
  1350,
  999,
  418,
  1350,
  1001,
  1350,
  367,
  489,
  491,
  511,
  511,
  511,
  1003,
  1350,
  1350,
  1005,
  1007,
  1350,
  511,
  511,
  511,
  1350,
  1009,
  1350,
  565,
  565,
  565,
  1350,
  510,
  1350,
  1350,
  1350,
  1350,
  1011,
  158,
  1350,
  1350,
  1350,
  1013,
  1350,
  1350,
  1350,
  1350,
  158,
  1350,
  1015,
  1350,
  1350,
  566,
  1350,
  1350,
  1350,
  1350,
  1017,
  1350,
  1350,
  1350,
  565,
  565,
  565,
  1350,
  1350,
  1019,
  1350,
  1350,
  1021,
  1350,
  570,
  570,
  570,
  1023,
  571,
  1025,
  1350,
  1350,
  1027,
  572,
  1350,
  1350,
  1350,
  1350,
  566,
  570,
  570,
  570,
  1029,
  571,
  1350,
  1031,
  1350,
  1350,
  572,
  590,
  590,
  590,
  1033,
  1350,
  590,
  590,
  590,
  1350,
  1035,
  1350,
  1037,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1039,
  1350,
  1350,
  1041,
  573,
  1350,
  1350,
  591,
  1350,
  1350,
  1043,
  1350,
  591,
  1350,
  1045,
  1350,
  1350,
  1350,
  1047,
  573,
  1350,
  1049,
  1350,
  1350,
  1051,
  1053,
  1350,
  1350,
  1055,
  1350,
  1057,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1059,
  1350,
  1061,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1063,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1065,
  1067,
  1069,
  1071,
  1350,
  1073,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1075,
  1350,
  1077,
  1079,
  1350,
  1081,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1083,
  1350,
  1085,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1087,
  1350,
  1350,
  1089,
  1350,
  1091,
  1350,
  1093,
  1350,
  1350,
  1095,
  1350,
  1350,
  1350,
  1097,
  1350,
  1350,
  1099,
  1350,
  1350,
  1101,
  1350,
  1350,
  1103,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1105,
  1350,
  1107,
  1109,
  1350,
  1111,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1113,
  1350,
  1350,
  1115,
  1117,
  1350,
  1119,
  1350,
  1350,
  1121,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1123,
  1350,
  1350,
  1125,
  1350,
  1350,
  1127,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1129,
  1131,
  1350,
  1350,
  1133,
  1135,
  1350,
  1137,
  1350,
  1350,
  1139,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1141,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1143,
  1350,
  1350,
  1350,
  1350,
  1145,
  1350,
  1350,
  1350,
  1350,
  1147,
  1149,
  1350,
  1350,
  1151,
  1153,
  1155,
  1157,
  1350,
  1350,
  1159,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1161,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1163,
  1165,
  1350,
  1167,
  1350,
  1169,
  1350,
  1350,
  1350,
  1350,
  1171,
  1350,
  1173,
  1350,
  1175,
  1177,
  1350,
  1179,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1181,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1183,
  1350,
  1350,
  1185,
  1350,
  1187,
  1350,
  1189,
  1350,
  1350,
  1191,
  1350,
  1350,
  1350,
  1193,
  1350,
  1350,
  1195,
  1350,
  1350,
  1197,
  1350,
  1350,
  1199,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1201,
  1350,
  1203,
  1205,
  1350,
  1207,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1209,
  1350,
  1350,
  1211,
  1213,
  1350,
  1215,
  1350,
  1350,
  1217,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1219,
  1350,
  1350,
  1221,
  1350,
  1350,
  1223,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1225,
  1227,
  1350,
  1350,
  1229,
  1231,
  1350,
  1233,
  1350,
  1350,
  1235,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1237,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1239,
  1350,
  1350,
  1350,
  1350,
  1241,
  1350,
  1350,
  1350,
  1350,
  1243,
  1245,
  1350,
  1350,
  1247,
  1249,
  1251,
  1253,
  1350,
  1350,
  1255,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1257,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1259,
  1261,
  1350,
  1263,
  1350,
  1265,
  1350,
  1350,
  1350,
  1350,
  1267,
  1350,
  1269,
  1350,
  1271,
  1273,
  1350,
  1275,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1277,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1279,
  1350,
  1350,
  1281,
  1350,
  1283,
  1350,
  1285,
  1350,
  1350,
  1287,
  1350,
  1350,
  1350,
  1289,
  1350,
  1350,
  1291,
  1350,
  1350,
  1293,
  1350,
  1350,
  1295,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1297,
  1350,
  1299,
  1301,
  1350,
  1303,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1305,
  1350,
  1350,
  1307,
  1309,
  1350,
  1311,
  1350,
  1350,
  1313,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1315,
  1350,
  1350,
  1317,
  1350,
  1350,
  1319,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1321,
  1323,
  1350,
  1350,
  1325,
  1327,
  1350,
  1329,
  1350,
  1350,
  1331,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1333,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1335,
  1350,
  1350,
  1350,
  1350,
  1337,
  1350,
  1350,
  1350,
  1350,
  1339,
  1341,
  1350,
  1350,
  1343,
  1345,
  1347,
  1349,
  1350,
  1350,
  116,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  953,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  951,
  949,
  1350,
  947,
  1350,
  945,
  1350,
  1350,
  1350,
  1350,
  943,
  1350,
  941,
  1350,
  939,
  937,
  1350,
  935,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  933,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  931,
  1350,
  1350,
  929,
  1350,
  927,
  1350,
  925,
  1350,
  1350,
  923,
  1350,
  1350,
  1350,
  921,
  1350,
  1350,
  919,
  1350,
  1350,
  917,
  1350,
  1350,
  915,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  913,
  1350,
  911,
  909,
  1350,
  907,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  905,
  1350,
  1350,
  903,
  901,
  1350,
  899,
  1350,
  1350,
  897,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  895,
  1350,
  1350,
  893,
  1350,
  1350,
  891,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  889,
  887,
  1350,
  1350,
  885,
  883,
  1350,
  881,
  1350,
  1350,
  879,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  877,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  875,
  1350,
  1350,
  1350,
  1350,
  873,
  1350,
  1350,
  1350,
  1350,
  871,
  869,
  1350,
  1350,
  867,
  865,
  863,
  861,
  1350,
  1350,
  859,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  857,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  855,
  853,
  1350,
  851,
  1350,
  849,
  1350,
  1350,
  1350,
  1350,
  847,
  1350,
  845,
  1350,
  843,
  841,
  1350,
  839,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  837,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  835,
  1350,
  1350,
  833,
  1350,
  831,
  1350,
  829,
  1350,
  1350,
  827,
  1350,
  1350,
  1350,
  825,
  1350,
  1350,
  823,
  1350,
  1350,
  821,
  1350,
  1350,
  819,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  817,
  1350,
  815,
  813,
  1350,
  811,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  809,
  1350,
  1350,
  807,
  805,
  1350,
  803,
  1350,
  1350,
  801,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  799,
  1350,
  1350,
  797,
  1350,
  1350,
  795,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  793,
  791,
  1350,
  1350,
  789,
  787,
  1350,
  785,
  1350,
  1350,
  783,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  781,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  779,
  1350,
  1350,
  1350,
  1350,
  777,
  1350,
  1350,
  1350,
  1350,
  775,
  773,
  1350,
  1350,
  771,
  769,
  767,
  765,
  1350,
  1350,
  763,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  761,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  759,
  757,
  1350,
  755,
  1350,
  753,
  1350,
  1350,
  1350,
  1350,
  751,
  1350,
  749,
  1350,
  747,
  745,
  1350,
  743,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  741,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  739,
  1350,
  1350,
  737,
  1350,
  735,
  1350,
  733,
  1350,
  1350,
  731,
  1350,
  1350,
  1350,
  729,
  1350,
  1350,
  727,
  1350,
  1350,
  725,
  1350,
  1350,
  723,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  721,
  1350,
  719,
  717,
  1350,
  715,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  713,
  1350,
  1350,
  711,
  709,
  1350,
  707,
  1350,
  1350,
  705,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  703,
  1350,
  1350,
  701,
  1350,
  1350,
  699,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  697,
  695,
  1350,
  1350,
  693,
  691,
  1350,
  689,
  1350,
  1350,
  687,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  685,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  683,
  1350,
  1350,
  1350,
  1350,
  681,
  1350,
  1350,
  1350,
  1350,
  679,
  677,
  1350,
  1350,
  675,
  673,
  671,
  669,
  1350,
  1350,
  667,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  665,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  663,
  661,
  1350,
  659,
  1350,
  657,
  1350,
  1350,
  1350,
  1350,
  655,
  1350,
  653,
  1350,
  651,
  649,
  1350,
  647,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  645,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  643,
  1350,
  1350,
  641,
  1350,
  639,
  1350,
  637,
  1350,
  1350,
  635,
  1350,
  1350,
  1350,
  633,
  1350,
  1350,
  631,
  1350,
  1350,
  629,
  1350,
  1350,
  627,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  625,
  1350,
  623,
  621,
  1350,
  619,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  617,
  1350,
  1350,
  615,
  613,
  1350,
  611,
  1350,
  1350,
  609,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  607,
  1350,
  1350,
  605,
  1350,
  1350,
  603,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  601,
  599,
  1350,
  1350,
  597,
  595,
  1350,
  585,
  1350,
  1350,
  585,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  593,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  589,
  1350,
  1350,
  1350,
  1350,
  588,
  1350,
  1350,
  1350,
  1350,
  587,
  585,
  1350,
  1350,
  584,
  583,
  576,
  582,
  1350,
  1350,
  580,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  579,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  578,
  575,
  1350,
  569,
  1350,
  568,
  1350,
  1350,
  1350,
  1350,
  564,
  1350,
  563,
  1350,
  561,
  560,
  1350,
  559,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  557,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  556,
  1350,
  1350,
  555,
  1350,
  553,
  1350,
  552,
  1350,
  1350,
  551,
  1350,
  1350,
  1350,
  549,
  1350,
  1350,
  548,
  1350,
  1350,
  547,
  1350,
  1350,
  545,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  544,
  1350,
  543,
  542,
  1350,
  541,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  540,
  1350,
  1350,
  539,
  537,
  1350,
  536,
  1350,
  1350,
  535,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  534,
  1350,
  1350,
  533,
  1350,
  1350,
  532,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  531,
  529,
  1350,
  1350,
  528,
  527,
  1350,
  526,
  1350,
  1350,
  525,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  524,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  523,
  1350,
  1350,
  1350,
  1350,
  522,
  1350,
  1350,
  1350,
  1350,
  521,
  519,
  1350,
  1350,
  518,
  517,
  516,
  515,
  1350,
  1350,
  514,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  503,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  513,
  512,
  1350,
  509,
  1350,
  508,
  1350,
  1350,
  1350,
  1350,
  506,
  1350,
  505,
  1350,
  504,
  503,
  1350,
  502,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  501,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  500,
  1350,
  1350,
  499,
  1350,
  498,
  1350,
  497,
  1350,
  1350,
  496,
  1350,
  1350,
  1350,
  495,
  1350,
  1350,
  494,
  1350,
  1350,
  493,
  1350,
  1350,
  492,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  487,
  1350,
  486,
  484,
  1350,
  483,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  481,
  1350,
  1350,
  480,
  479,
  1350,
  478,
  1350,
  1350,
  477,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  476,
  1350,
  1350,
  475,
  1350,
  1350,
  474,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  473,
  472,
  1350,
  1350,
  471,
  470,
  1350,
  469,
  1350,
  1350,
  468,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  467,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  466,
  1350,
  1350,
  1350,
  1350,
  465,
  1350,
  1350,
  1350,
  1350,
  464,
  463,
  1350,
  1350,
  460,
  459,
  458,
  370,
  1350,
  1350,
  457,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  454,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  453,
  412,
  1350,
  452,
  1350,
  450,
  1350,
  1350,
  1350,
  1350,
  449,
  1350,
  448,
  1350,
  447,
  446,
  1350,
  445,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  444,
  1350,
  443,
  1350,
  1350,
  1350,
  1350,
  1350,
  442,
  1350,
  1350,
  1350,
  441,
  1350,
  1350,
  440,
  1350,
  439,
  438,
  437,
  436,
  435,
  434,
  1350,
  433,
  432,
  431,
  430,
  1350,
  429,
  428,
  374,
  427,
  1350,
  1350,
  426,
  425,
  422,
  1350,
  421,
  1350,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  83,
  83,
  83,
  83,
  83,
  83,
  83,
  83,
  83,
  83,
  83,
  83,
  97,
  97,
  97,
  97,
  97,
  97,
  97,
  97,
  97,
  97,
  97,
  97,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  105,
  107,
  107,
  107,
  107,
  107,
  107,
  107,
  107,
  107,
  107,
  370,
  107,
  113,
  113,
  113,
  113,
  420,
  113,
  113,
  113,
  113,
  113,
  113,
  113,
  121,
  121,
  121,
  121,
  121,
  121,
  121,
  121,
  121,
  121,
  121,
  121,
  160,
  416,
  415,
  160,
  200,
  200,
  200,
  411,
  200,
  200,
  200,
  409,
  200,
  200,
  206,
  206,
  206,
  206,
  206,
  206,
  206,
  206,
  206,
  206,
  206,
  206,
  210,
  408,
  407,
  210,
  213,
  213,
  213,
  213,
  213,
  213,
  406,
  213,
  213,
  213,
  213,
  213,
  223,
  405,
  404,
  403,
  402,
  401,
  223,
  223,
  400,
  223,
  225,
  399,
  398,
  225,
  226,
  397,
  396,
  226,
  227,
  227,
  227,
  227,
  227,
  227,
  227,
  395,
  227,
  227,
  227,
  227,
  229,
  229,
  394,
  229,
  229,
  393,
  229,
  229,
  229,
  229,
  229,
  229,
  232,
  232,
  232,
  232,
  232,
  232,
  232,
  232,
  232,
  232,
  232,
  232,
  238,
  392,
  391,
  238,
  302,
  302,
  302,
  302,
  302,
  302,
  302,
  302,
  302,
  302,
  302,
  302,
  317,
  390,
  389,
  388,
  387,
  386,
  385,
  384,
  383,
  382,
  317,
  358,
  358,
  358,
  358,
  358,
  358,
  358,
  358,
  358,
  358,
  358,
  358,
  376,
  381,
  380,
  379,
  378,
  377,
  376,
  316,
  373,
  376,
  410,
  410,
  410,
  410,
  410,
  410,
  410,
  410,
  410,
  410,
  410,
  410,
  451,
  451,
  451,
  451,
  451,
  451,
  451,
  451,
  451,
  451,
  451,
  451,
  482,
  482,
  482,
  482,
  482,
  482,
  482,
  482,
  482,
  482,
  482,
  482,
  507,
  507,
  507,
  507,
  507,
  507,
  507,
  507,
  507,
  507,
  507,
  507,
  520,
  520,
  520,
  520,
  520,
  520,
  520,
  520,
  520,
  520,
  520,
  520,
  530,
  530,
  530,
  530,
  530,
  530,
  530,
  530,
  530,
  530,
  530,
  530,
  538,
  538,
  538,
  538,
  538,
  538,
  538,
  538,
  538,
  538,
  538,
  538,
  546,
  546,
  546,
  546,
  546,
  546,
  546,
  546,
  546,
  546,
  546,
  546,
  550,
  550,
  550,
  550,
  550,
  550,
  550,
  550,
  550,
  550,
  550,
  550,
  554,
  554,
  554,
  554,
  554,
  554,
  554,
  554,
  554,
  554,
  554,
  554,
  558,
  558,
  558,
  558,
  558,
  558,
  558,
  558,
  558,
  558,
  558,
  558,
  562,
  562,
  562,
  562,
  562,
  562,
  562,
  562,
  562,
  562,
  562,
  562,
  567,
  567,
  567,
  567,
  567,
  567,
  567,
  567,
  567,
  567,
  567,
  567,
  574,
  574,
  574,
  574,
  574,
  574,
  574,
  574,
  574,
  574,
  574,
  574,
  581,
  581,
  581,
  581,
  581,
  581,
  581,
  581,
  581,
  581,
  581,
  581,
  586,
  586,
  586,
  586,
  586,
  586,
  586,
  586,
  586,
  586,
  586,
  586,
  592,
  592,
  592,
  592,
  592,
  592,
  592,
  592,
  592,
  592,
  592,
  592,
  594,
  594,
  594,
  594,
  594,
  594,
  594,
  594,
  594,
  594,
  594,
  594,
  596,
  596,
  596,
  596,
  596,
  596,
  596,
  596,
  596,
  596,
  596,
  596,
  598,
  598,
  598,
  598,
  598,
  598,
  598,
  598,
  598,
  598,
  598,
  598,
  600,
  600,
  600,
  600,
  600,
  600,
  600,
  600,
  600,
  600,
  600,
  600,
  602,
  602,
  602,
  602,
  602,
  602,
  602,
  602,
  602,
  602,
  602,
  602,
  604,
  604,
  604,
  604,
  604,
  604,
  604,
  604,
  604,
  604,
  604,
  604,
  606,
  606,
  606,
  606,
  606,
  606,
  606,
  606,
  606,
  606,
  606,
  606,
  608,
  608,
  608,
  608,
  608,
  608,
  608,
  608,
  608,
  608,
  608,
  608,
  610,
  610,
  610,
  610,
  610,
  610,
  610,
  610,
  610,
  610,
  610,
  610,
  612,
  612,
  612,
  612,
  612,
  612,
  612,
  612,
  612,
  612,
  612,
  612,
  614,
  614,
  614,
  614,
  614,
  614,
  614,
  614,
  614,
  614,
  614,
  614,
  616,
  616,
  616,
  616,
  616,
  616,
  616,
  616,
  616,
  616,
  616,
  616,
  618,
  618,
  618,
  618,
  618,
  618,
  618,
  618,
  618,
  618,
  618,
  618,
  620,
  620,
  620,
  620,
  620,
  620,
  620,
  620,
  620,
  620,
  620,
  620,
  622,
  622,
  622,
  622,
  622,
  622,
  622,
  622,
  622,
  622,
  622,
  622,
  624,
  624,
  624,
  624,
  624,
  624,
  624,
  624,
  624,
  624,
  624,
  624,
  626,
  626,
  626,
  626,
  626,
  626,
  626,
  626,
  626,
  626,
  626,
  626,
  628,
  628,
  628,
  628,
  628,
  628,
  628,
  628,
  628,
  628,
  628,
  628,
  630,
  630,
  630,
  630,
  630,
  630,
  630,
  630,
  630,
  630,
  630,
  630,
  632,
  632,
  632,
  632,
  632,
  632,
  632,
  632,
  632,
  632,
  632,
  632,
  634,
  634,
  634,
  634,
  634,
  634,
  634,
  634,
  634,
  634,
  634,
  634,
  636,
  636,
  636,
  636,
  636,
  636,
  636,
  636,
  636,
  636,
  636,
  636,
  638,
  638,
  638,
  638,
  638,
  638,
  638,
  638,
  638,
  638,
  638,
  638,
  640,
  640,
  640,
  640,
  640,
  640,
  640,
  640,
  640,
  640,
  640,
  640,
  642,
  642,
  642,
  642,
  642,
  642,
  642,
  642,
  642,
  642,
  642,
  642,
  644,
  644,
  644,
  644,
  644,
  644,
  644,
  644,
  644,
  644,
  644,
  644,
  646,
  646,
  646,
  646,
  646,
  646,
  646,
  646,
  646,
  646,
  646,
  646,
  648,
  648,
  648,
  648,
  648,
  648,
  648,
  648,
  648,
  648,
  648,
  648,
  650,
  650,
  650,
  650,
  650,
  650,
  650,
  650,
  650,
  650,
  650,
  650,
  652,
  652,
  652,
  652,
  652,
  652,
  652,
  652,
  652,
  652,
  652,
  652,
  654,
  654,
  654,
  654,
  654,
  654,
  654,
  654,
  654,
  654,
  654,
  654,
  656,
  656,
  656,
  656,
  656,
  656,
  656,
  656,
  656,
  656,
  656,
  656,
  658,
  658,
  658,
  658,
  658,
  658,
  658,
  658,
  658,
  658,
  658,
  658,
  660,
  660,
  660,
  660,
  660,
  660,
  660,
  660,
  660,
  660,
  660,
  660,
  662,
  662,
  662,
  662,
  662,
  662,
  662,
  662,
  662,
  662,
  662,
  662,
  664,
  664,
  664,
  664,
  664,
  664,
  664,
  664,
  664,
  664,
  664,
  664,
  666,
  666,
  666,
  666,
  666,
  666,
  666,
  666,
  666,
  666,
  666,
  666,
  668,
  668,
  668,
  668,
  668,
  668,
  668,
  668,
  668,
  668,
  668,
  668,
  670,
  670,
  670,
  670,
  670,
  670,
  670,
  670,
  670,
  670,
  670,
  670,
  672,
  672,
  672,
  672,
  672,
  672,
  672,
  672,
  672,
  672,
  672,
  672,
  674,
  674,
  674,
  674,
  674,
  674,
  674,
  674,
  674,
  674,
  674,
  674,
  676,
  676,
  676,
  676,
  676,
  676,
  676,
  676,
  676,
  676,
  676,
  676,
  678,
  678,
  678,
  678,
  678,
  678,
  678,
  678,
  678,
  678,
  678,
  678,
  680,
  680,
  680,
  680,
  680,
  680,
  680,
  680,
  680,
  680,
  680,
  680,
  682,
  682,
  682,
  682,
  682,
  682,
  682,
  682,
  682,
  682,
  682,
  682,
  684,
  684,
  684,
  684,
  684,
  684,
  684,
  684,
  684,
  684,
  684,
  684,
  686,
  686,
  686,
  686,
  686,
  686,
  686,
  686,
  686,
  686,
  686,
  686,
  688,
  688,
  688,
  688,
  688,
  688,
  688,
  688,
  688,
  688,
  688,
  688,
  690,
  690,
  690,
  690,
  690,
  690,
  690,
  690,
  690,
  690,
  690,
  690,
  692,
  692,
  692,
  692,
  692,
  692,
  692,
  692,
  692,
  692,
  692,
  692,
  694,
  694,
  694,
  694,
  694,
  694,
  694,
  694,
  694,
  694,
  694,
  694,
  696,
  696,
  696,
  696,
  696,
  696,
  696,
  696,
  696,
  696,
  696,
  696,
  698,
  698,
  698,
  698,
  698,
  698,
  698,
  698,
  698,
  698,
  698,
  698,
  700,
  700,
  700,
  700,
  700,
  700,
  700,
  700,
  700,
  700,
  700,
  700,
  702,
  702,
  702,
  702,
  702,
  702,
  702,
  702,
  702,
  702,
  702,
  702,
  704,
  704,
  704,
  704,
  704,
  704,
  704,
  704,
  704,
  704,
  704,
  704,
  706,
  706,
  706,
  706,
  706,
  706,
  706,
  706,
  706,
  706,
  706,
  706,
  708,
  708,
  708,
  708,
  708,
  708,
  708,
  708,
  708,
  708,
  708,
  708,
  710,
  710,
  710,
  710,
  710,
  710,
  710,
  710,
  710,
  710,
  710,
  710,
  712,
  712,
  712,
  712,
  712,
  712,
  712,
  712,
  712,
  712,
  712,
  712,
  714,
  714,
  714,
  714,
  714,
  714,
  714,
  714,
  714,
  714,
  714,
  714,
  716,
  716,
  716,
  716,
  716,
  716,
  716,
  716,
  716,
  716,
  716,
  716,
  718,
  718,
  718,
  718,
  718,
  718,
  718,
  718,
  718,
  718,
  718,
  718,
  720,
  720,
  720,
  720,
  720,
  720,
  720,
  720,
  720,
  720,
  720,
  720,
  722,
  722,
  722,
  722,
  722,
  722,
  722,
  722,
  722,
  722,
  722,
  722,
  724,
  724,
  724,
  724,
  724,
  724,
  724,
  724,
  724,
  724,
  724,
  724,
  726,
  726,
  726,
  726,
  726,
  726,
  726,
  726,
  726,
  726,
  726,
  726,
  728,
  728,
  728,
  728,
  728,
  728,
  728,
  728,
  728,
  728,
  728,
  728,
  730,
  730,
  730,
  730,
  730,
  730,
  730,
  730,
  730,
  730,
  730,
  730,
  732,
  732,
  732,
  732,
  732,
  732,
  732,
  732,
  732,
  732,
  732,
  732,
  734,
  734,
  734,
  734,
  734,
  734,
  734,
  734,
  734,
  734,
  734,
  734,
  736,
  736,
  736,
  736,
  736,
  736,
  736,
  736,
  736,
  736,
  736,
  736,
  738,
  738,
  738,
  738,
  738,
  738,
  738,
  738,
  738,
  738,
  738,
  738,
  740,
  740,
  740,
  740,
  740,
  740,
  740,
  740,
  740,
  740,
  740,
  740,
  742,
  742,
  742,
  742,
  742,
  742,
  742,
  742,
  742,
  742,
  742,
  742,
  744,
  744,
  744,
  744,
  744,
  744,
  744,
  744,
  744,
  744,
  744,
  744,
  746,
  746,
  746,
  746,
  746,
  746,
  746,
  746,
  746,
  746,
  746,
  746,
  748,
  748,
  748,
  748,
  748,
  748,
  748,
  748,
  748,
  748,
  748,
  748,
  750,
  750,
  750,
  750,
  750,
  750,
  750,
  750,
  750,
  750,
  750,
  750,
  752,
  752,
  752,
  752,
  752,
  752,
  752,
  752,
  752,
  752,
  752,
  752,
  754,
  754,
  754,
  754,
  754,
  754,
  754,
  754,
  754,
  754,
  754,
  754,
  756,
  756,
  756,
  756,
  756,
  756,
  756,
  756,
  756,
  756,
  756,
  756,
  758,
  758,
  758,
  758,
  758,
  758,
  758,
  758,
  758,
  758,
  758,
  758,
  760,
  760,
  760,
  760,
  760,
  760,
  760,
  760,
  760,
  760,
  760,
  760,
  762,
  762,
  762,
  762,
  762,
  762,
  762,
  762,
  762,
  762,
  762,
  762,
  764,
  764,
  764,
  764,
  764,
  764,
  764,
  764,
  764,
  764,
  764,
  764,
  766,
  766,
  766,
  766,
  766,
  766,
  766,
  766,
  766,
  766,
  766,
  766,
  768,
  768,
  768,
  768,
  768,
  768,
  768,
  768,
  768,
  768,
  768,
  768,
  770,
  770,
  770,
  770,
  770,
  770,
  770,
  770,
  770,
  770,
  770,
  770,
  772,
  772,
  772,
  772,
  772,
  772,
  772,
  772,
  772,
  772,
  772,
  772,
  774,
  774,
  774,
  774,
  774,
  774,
  774,
  774,
  774,
  774,
  774,
  774,
  776,
  776,
  776,
  776,
  776,
  776,
  776,
  776,
  776,
  776,
  776,
  776,
  778,
  778,
  778,
  778,
  778,
  778,
  778,
  778,
  778,
  778,
  778,
  778,
  780,
  780,
  780,
  780,
  780,
  780,
  780,
  780,
  780,
  780,
  780,
  780,
  782,
  782,
  782,
  782,
  782,
  782,
  782,
  782,
  782,
  782,
  782,
  782,
  784,
  784,
  784,
  784,
  784,
  784,
  784,
  784,
  784,
  784,
  784,
  784,
  786,
  786,
  786,
  786,
  786,
  786,
  786,
  786,
  786,
  786,
  786,
  786,
  788,
  788,
  788,
  788,
  788,
  788,
  788,
  788,
  788,
  788,
  788,
  788,
  790,
  790,
  790,
  790,
  790,
  790,
  790,
  790,
  790,
  790,
  790,
  790,
  792,
  792,
  792,
  792,
  792,
  792,
  792,
  792,
  792,
  792,
  792,
  792,
  794,
  794,
  794,
  794,
  794,
  794,
  794,
  794,
  794,
  794,
  794,
  794,
  796,
  796,
  796,
  796,
  796,
  796,
  796,
  796,
  796,
  796,
  796,
  796,
  798,
  798,
  798,
  798,
  798,
  798,
  798,
  798,
  798,
  798,
  798,
  798,
  800,
  800,
  800,
  800,
  800,
  800,
  800,
  800,
  800,
  800,
  800,
  800,
  802,
  802,
  802,
  802,
  802,
  802,
  802,
  802,
  802,
  802,
  802,
  802,
  804,
  804,
  804,
  804,
  804,
  804,
  804,
  804,
  804,
  804,
  804,
  804,
  806,
  806,
  806,
  806,
  806,
  806,
  806,
  806,
  806,
  806,
  806,
  806,
  808,
  808,
  808,
  808,
  808,
  808,
  808,
  808,
  808,
  808,
  808,
  808,
  810,
  810,
  810,
  810,
  810,
  810,
  810,
  810,
  810,
  810,
  810,
  810,
  812,
  812,
  812,
  812,
  812,
  812,
  812,
  812,
  812,
  812,
  812,
  812,
  814,
  814,
  814,
  814,
  814,
  814,
  814,
  814,
  814,
  814,
  814,
  814,
  816,
  816,
  816,
  816,
  816,
  816,
  816,
  816,
  816,
  816,
  816,
  816,
  818,
  818,
  818,
  818,
  818,
  818,
  818,
  818,
  818,
  818,
  818,
  818,
  820,
  820,
  820,
  820,
  820,
  820,
  820,
  820,
  820,
  820,
  820,
  820,
  822,
  822,
  822,
  822,
  822,
  822,
  822,
  822,
  822,
  822,
  822,
  822,
  824,
  824,
  824,
  824,
  824,
  824,
  824,
  824,
  824,
  824,
  824,
  824,
  826,
  826,
  826,
  826,
  826,
  826,
  826,
  826,
  826,
  826,
  826,
  826,
  828,
  828,
  828,
  828,
  828,
  828,
  828,
  828,
  828,
  828,
  828,
  828,
  830,
  830,
  830,
  830,
  830,
  830,
  830,
  830,
  830,
  830,
  830,
  830,
  832,
  832,
  832,
  832,
  832,
  832,
  832,
  832,
  832,
  832,
  832,
  832,
  834,
  834,
  834,
  834,
  834,
  834,
  834,
  834,
  834,
  834,
  834,
  834,
  836,
  836,
  836,
  836,
  836,
  836,
  836,
  836,
  836,
  836,
  836,
  836,
  838,
  838,
  838,
  838,
  838,
  838,
  838,
  838,
  838,
  838,
  838,
  838,
  840,
  840,
  840,
  840,
  840,
  840,
  840,
  840,
  840,
  840,
  840,
  840,
  842,
  842,
  842,
  842,
  842,
  842,
  842,
  842,
  842,
  842,
  842,
  842,
  844,
  844,
  844,
  844,
  844,
  844,
  844,
  844,
  844,
  844,
  844,
  844,
  846,
  846,
  846,
  846,
  846,
  846,
  846,
  846,
  846,
  846,
  846,
  846,
  848,
  848,
  848,
  848,
  848,
  848,
  848,
  848,
  848,
  848,
  848,
  848,
  850,
  850,
  850,
  850,
  850,
  850,
  850,
  850,
  850,
  850,
  850,
  850,
  852,
  852,
  852,
  852,
  852,
  852,
  852,
  852,
  852,
  852,
  852,
  852,
  854,
  854,
  854,
  854,
  854,
  854,
  854,
  854,
  854,
  854,
  854,
  854,
  856,
  856,
  856,
  856,
  856,
  856,
  856,
  856,
  856,
  856,
  856,
  856,
  858,
  858,
  858,
  858,
  858,
  858,
  858,
  858,
  858,
  858,
  858,
  858,
  860,
  860,
  860,
  860,
  860,
  860,
  860,
  860,
  860,
  860,
  860,
  860,
  862,
  862,
  862,
  862,
  862,
  862,
  862,
  862,
  862,
  862,
  862,
  862,
  864,
  864,
  864,
  864,
  864,
  864,
  864,
  864,
  864,
  864,
  864,
  864,
  866,
  866,
  866,
  866,
  866,
  866,
  866,
  866,
  866,
  866,
  866,
  866,
  868,
  868,
  868,
  868,
  868,
  868,
  868,
  868,
  868,
  868,
  868,
  868,
  870,
  870,
  870,
  870,
  870,
  870,
  870,
  870,
  870,
  870,
  870,
  870,
  872,
  872,
  872,
  872,
  872,
  872,
  872,
  872,
  872,
  872,
  872,
  872,
  874,
  874,
  874,
  874,
  874,
  874,
  874,
  874,
  874,
  874,
  874,
  874,
  876,
  876,
  876,
  876,
  876,
  876,
  876,
  876,
  876,
  876,
  876,
  876,
  878,
  878,
  878,
  878,
  878,
  878,
  878,
  878,
  878,
  878,
  878,
  878,
  880,
  880,
  880,
  880,
  880,
  880,
  880,
  880,
  880,
  880,
  880,
  880,
  882,
  882,
  882,
  882,
  882,
  882,
  882,
  882,
  882,
  882,
  882,
  882,
  884,
  884,
  884,
  884,
  884,
  884,
  884,
  884,
  884,
  884,
  884,
  884,
  886,
  886,
  886,
  886,
  886,
  886,
  886,
  886,
  886,
  886,
  886,
  886,
  888,
  888,
  888,
  888,
  888,
  888,
  888,
  888,
  888,
  888,
  888,
  888,
  890,
  890,
  890,
  890,
  890,
  890,
  890,
  890,
  890,
  890,
  890,
  890,
  892,
  892,
  892,
  892,
  892,
  892,
  892,
  892,
  892,
  892,
  892,
  892,
  894,
  894,
  894,
  894,
  894,
  894,
  894,
  894,
  894,
  894,
  894,
  894,
  896,
  896,
  896,
  896,
  896,
  896,
  896,
  896,
  896,
  896,
  896,
  896,
  898,
  898,
  898,
  898,
  898,
  898,
  898,
  898,
  898,
  898,
  898,
  898,
  900,
  900,
  900,
  900,
  900,
  900,
  900,
  900,
  900,
  900,
  900,
  900,
  902,
  902,
  902,
  902,
  902,
  902,
  902,
  902,
  902,
  902,
  902,
  902,
  904,
  904,
  904,
  904,
  904,
  904,
  904,
  904,
  904,
  904,
  904,
  904,
  906,
  906,
  906,
  906,
  906,
  906,
  906,
  906,
  906,
  906,
  906,
  906,
  908,
  908,
  908,
  908,
  908,
  908,
  908,
  908,
  908,
  908,
  908,
  908,
  910,
  910,
  910,
  910,
  910,
  910,
  910,
  910,
  910,
  910,
  910,
  910,
  912,
  912,
  912,
  912,
  912,
  912,
  912,
  912,
  912,
  912,
  912,
  912,
  914,
  914,
  914,
  914,
  914,
  914,
  914,
  914,
  914,
  914,
  914,
  914,
  916,
  916,
  916,
  916,
  916,
  916,
  916,
  916,
  916,
  916,
  916,
  916,
  918,
  918,
  918,
  918,
  918,
  918,
  918,
  918,
  918,
  918,
  918,
  918,
  920,
  920,
  920,
  920,
  920,
  920,
  920,
  920,
  920,
  920,
  920,
  920,
  922,
  922,
  922,
  922,
  922,
  922,
  922,
  922,
  922,
  922,
  922,
  922,
  924,
  924,
  924,
  924,
  924,
  924,
  924,
  924,
  924,
  924,
  924,
  924,
  926,
  926,
  926,
  926,
  926,
  926,
  926,
  926,
  926,
  926,
  926,
  926,
  928,
  928,
  928,
  928,
  928,
  928,
  928,
  928,
  928,
  928,
  928,
  928,
  930,
  930,
  930,
  930,
  930,
  930,
  930,
  930,
  930,
  930,
  930,
  930,
  932,
  932,
  932,
  932,
  932,
  932,
  932,
  932,
  932,
  932,
  932,
  932,
  934,
  934,
  934,
  934,
  934,
  934,
  934,
  934,
  934,
  934,
  934,
  934,
  936,
  936,
  936,
  936,
  936,
  936,
  936,
  936,
  936,
  936,
  936,
  936,
  938,
  938,
  938,
  938,
  938,
  938,
  938,
  938,
  938,
  938,
  938,
  938,
  940,
  940,
  940,
  940,
  940,
  940,
  940,
  940,
  940,
  940,
  940,
  940,
  942,
  942,
  942,
  942,
  942,
  942,
  942,
  942,
  942,
  942,
  942,
  942,
  944,
  944,
  944,
  944,
  944,
  944,
  944,
  944,
  944,
  944,
  944,
  944,
  946,
  946,
  946,
  946,
  946,
  946,
  946,
  946,
  946,
  946,
  946,
  946,
  948,
  948,
  948,
  948,
  948,
  948,
  948,
  948,
  948,
  948,
  948,
  948,
  950,
  950,
  950,
  950,
  950,
  950,
  950,
  950,
  950,
  950,
  950,
  950,
  952,
  952,
  952,
  952,
  952,
  952,
  952,
  952,
  952,
  952,
  952,
  952,
  954,
  954,
  954,
  954,
  954,
  954,
  954,
  954,
  954,
  954,
  954,
  954,
  956,
  956,
  956,
  956,
  956,
  956,
  956,
  956,
  956,
  956,
  956,
  956,
  958,
  958,
  958,
  958,
  958,
  958,
  958,
  958,
  958,
  958,
  958,
  958,
  960,
  960,
  960,
  960,
  960,
  960,
  960,
  960,
  960,
  960,
  960,
  960,
  962,
  962,
  962,
  962,
  962,
  962,
  962,
  962,
  962,
  962,
  962,
  962,
  964,
  964,
  964,
  964,
  964,
  964,
  964,
  964,
  964,
  964,
  964,
  964,
  966,
  966,
  966,
  966,
  966,
  966,
  966,
  966,
  966,
  966,
  966,
  966,
  968,
  968,
  968,
  968,
  968,
  968,
  968,
  968,
  968,
  968,
  968,
  968,
  970,
  970,
  970,
  970,
  970,
  970,
  970,
  970,
  970,
  970,
  970,
  970,
  972,
  972,
  972,
  972,
  972,
  972,
  972,
  972,
  972,
  972,
  972,
  972,
  974,
  974,
  974,
  974,
  974,
  974,
  974,
  974,
  974,
  974,
  974,
  974,
  976,
  976,
  976,
  976,
  976,
  976,
  976,
  976,
  976,
  976,
  976,
  976,
  978,
  978,
  978,
  978,
  978,
  978,
  978,
  978,
  978,
  978,
  978,
  978,
  980,
  980,
  980,
  980,
  980,
  980,
  980,
  980,
  980,
  980,
  980,
  980,
  982,
  982,
  982,
  982,
  982,
  982,
  982,
  982,
  982,
  982,
  982,
  982,
  984,
  984,
  984,
  984,
  984,
  984,
  984,
  984,
  984,
  984,
  984,
  984,
  986,
  986,
  986,
  986,
  986,
  986,
  986,
  986,
  986,
  986,
  986,
  986,
  988,
  988,
  988,
  988,
  988,
  988,
  988,
  988,
  988,
  988,
  988,
  988,
  990,
  990,
  990,
  990,
  990,
  990,
  990,
  990,
  990,
  990,
  990,
  990,
  992,
  992,
  992,
  992,
  992,
  992,
  992,
  992,
  992,
  992,
  992,
  992,
  994,
  994,
  994,
  994,
  994,
  994,
  994,
  994,
  994,
  994,
  994,
  994,
  996,
  996,
  996,
  996,
  996,
  996,
  996,
  996,
  996,
  996,
  996,
  996,
  998,
  998,
  998,
  998,
  998,
  998,
  998,
  998,
  998,
  998,
  998,
  998,
  1000,
  1000,
  1000,
  1000,
  1000,
  1000,
  1000,
  1000,
  1000,
  1000,
  1000,
  1000,
  1002,
  1002,
  1002,
  1002,
  1002,
  1002,
  1002,
  1002,
  1002,
  1002,
  1002,
  1002,
  1004,
  1004,
  1004,
  1004,
  1004,
  1004,
  1004,
  1004,
  1004,
  1004,
  1004,
  1004,
  1006,
  1006,
  1006,
  1006,
  1006,
  1006,
  1006,
  1006,
  1006,
  1006,
  1006,
  1006,
  1008,
  1008,
  1008,
  1008,
  1008,
  1008,
  1008,
  1008,
  1008,
  1008,
  1008,
  1008,
  1010,
  1010,
  1010,
  1010,
  1010,
  1010,
  1010,
  1010,
  1010,
  1010,
  1010,
  1010,
  1012,
  1012,
  1012,
  1012,
  1012,
  1012,
  1012,
  1012,
  1012,
  1012,
  1012,
  1012,
  1014,
  1014,
  1014,
  1014,
  1014,
  1014,
  1014,
  1014,
  1014,
  1014,
  1014,
  1014,
  1016,
  1016,
  1016,
  1016,
  1016,
  1016,
  1016,
  1016,
  1016,
  1016,
  1016,
  1016,
  1018,
  1018,
  1018,
  1018,
  1018,
  1018,
  1018,
  1018,
  1018,
  1018,
  1018,
  1018,
  1020,
  1020,
  1020,
  1020,
  1020,
  1020,
  1020,
  1020,
  1020,
  1020,
  1020,
  1020,
  1022,
  1022,
  1022,
  1022,
  1022,
  1022,
  1022,
  1022,
  1022,
  1022,
  1022,
  1022,
  1024,
  1024,
  1024,
  1024,
  1024,
  1024,
  1024,
  1024,
  1024,
  1024,
  1024,
  1024,
  1026,
  1026,
  1026,
  1026,
  1026,
  1026,
  1026,
  1026,
  1026,
  1026,
  1026,
  1026,
  1028,
  1028,
  1028,
  1028,
  1028,
  1028,
  1028,
  1028,
  1028,
  1028,
  1028,
  1028,
  1030,
  1030,
  1030,
  1030,
  1030,
  1030,
  1030,
  1030,
  1030,
  1030,
  1030,
  1030,
  1032,
  1032,
  1032,
  1032,
  1032,
  1032,
  1032,
  1032,
  1032,
  1032,
  1032,
  1032,
  1034,
  1034,
  1034,
  1034,
  1034,
  1034,
  1034,
  1034,
  1034,
  1034,
  1034,
  1034,
  1036,
  1036,
  1036,
  1036,
  1036,
  1036,
  1036,
  1036,
  1036,
  1036,
  1036,
  1036,
  1038,
  1038,
  1038,
  1038,
  1038,
  1038,
  1038,
  1038,
  1038,
  1038,
  1038,
  1038,
  1040,
  1040,
  1040,
  1040,
  1040,
  1040,
  1040,
  1040,
  1040,
  1040,
  1040,
  1040,
  1042,
  1042,
  1042,
  1042,
  1042,
  1042,
  1042,
  1042,
  1042,
  1042,
  1042,
  1042,
  1044,
  1044,
  1044,
  1044,
  1044,
  1044,
  1044,
  1044,
  1044,
  1044,
  1044,
  1044,
  1046,
  1046,
  1046,
  1046,
  1046,
  1046,
  1046,
  1046,
  1046,
  1046,
  1046,
  1046,
  1048,
  1048,
  1048,
  1048,
  1048,
  1048,
  1048,
  1048,
  1048,
  1048,
  1048,
  1048,
  1050,
  1050,
  1050,
  1050,
  1050,
  1050,
  1050,
  1050,
  1050,
  1050,
  1050,
  1050,
  1052,
  1052,
  1052,
  1052,
  1052,
  1052,
  1052,
  1052,
  1052,
  1052,
  1052,
  1052,
  1054,
  1054,
  1054,
  1054,
  1054,
  1054,
  1054,
  1054,
  1054,
  1054,
  1054,
  1054,
  1056,
  1056,
  1056,
  1056,
  1056,
  1056,
  1056,
  1056,
  1056,
  1056,
  1056,
  1056,
  1058,
  1058,
  1058,
  1058,
  1058,
  1058,
  1058,
  1058,
  1058,
  1058,
  1058,
  1058,
  1060,
  1060,
  1060,
  1060,
  1060,
  1060,
  1060,
  1060,
  1060,
  1060,
  1060,
  1060,
  1062,
  1062,
  1062,
  1062,
  1062,
  1062,
  1062,
  1062,
  1062,
  1062,
  1062,
  1062,
  1064,
  1064,
  1064,
  1064,
  1064,
  1064,
  1064,
  1064,
  1064,
  1064,
  1064,
  1064,
  1066,
  1066,
  1066,
  1066,
  1066,
  1066,
  1066,
  1066,
  1066,
  1066,
  1066,
  1066,
  1068,
  1068,
  1068,
  1068,
  1068,
  1068,
  1068,
  1068,
  1068,
  1068,
  1068,
  1068,
  1070,
  1070,
  1070,
  1070,
  1070,
  1070,
  1070,
  1070,
  1070,
  1070,
  1070,
  1070,
  1072,
  1072,
  1072,
  1072,
  1072,
  1072,
  1072,
  1072,
  1072,
  1072,
  1072,
  1072,
  1074,
  1074,
  1074,
  1074,
  1074,
  1074,
  1074,
  1074,
  1074,
  1074,
  1074,
  1074,
  1076,
  1076,
  1076,
  1076,
  1076,
  1076,
  1076,
  1076,
  1076,
  1076,
  1076,
  1076,
  1078,
  1078,
  1078,
  1078,
  1078,
  1078,
  1078,
  1078,
  1078,
  1078,
  1078,
  1078,
  1080,
  1080,
  1080,
  1080,
  1080,
  1080,
  1080,
  1080,
  1080,
  1080,
  1080,
  1080,
  1082,
  1082,
  1082,
  1082,
  1082,
  1082,
  1082,
  1082,
  1082,
  1082,
  1082,
  1082,
  1084,
  1084,
  1084,
  1084,
  1084,
  1084,
  1084,
  1084,
  1084,
  1084,
  1084,
  1084,
  1086,
  1086,
  1086,
  1086,
  1086,
  1086,
  1086,
  1086,
  1086,
  1086,
  1086,
  1086,
  1088,
  1088,
  1088,
  1088,
  1088,
  1088,
  1088,
  1088,
  1088,
  1088,
  1088,
  1088,
  1090,
  1090,
  1090,
  1090,
  1090,
  1090,
  1090,
  1090,
  1090,
  1090,
  1090,
  1090,
  1092,
  1092,
  1092,
  1092,
  1092,
  1092,
  1092,
  1092,
  1092,
  1092,
  1092,
  1092,
  1094,
  1094,
  1094,
  1094,
  1094,
  1094,
  1094,
  1094,
  1094,
  1094,
  1094,
  1094,
  1096,
  1096,
  1096,
  1096,
  1096,
  1096,
  1096,
  1096,
  1096,
  1096,
  1096,
  1096,
  1098,
  1098,
  1098,
  1098,
  1098,
  1098,
  1098,
  1098,
  1098,
  1098,
  1098,
  1098,
  1100,
  1100,
  1100,
  1100,
  1100,
  1100,
  1100,
  1100,
  1100,
  1100,
  1100,
  1100,
  1102,
  1102,
  1102,
  1102,
  1102,
  1102,
  1102,
  1102,
  1102,
  1102,
  1102,
  1102,
  1104,
  1104,
  1104,
  1104,
  1104,
  1104,
  1104,
  1104,
  1104,
  1104,
  1104,
  1104,
  1106,
  1106,
  1106,
  1106,
  1106,
  1106,
  1106,
  1106,
  1106,
  1106,
  1106,
  1106,
  1108,
  1108,
  1108,
  1108,
  1108,
  1108,
  1108,
  1108,
  1108,
  1108,
  1108,
  1108,
  1110,
  1110,
  1110,
  1110,
  1110,
  1110,
  1110,
  1110,
  1110,
  1110,
  1110,
  1110,
  1112,
  1112,
  1112,
  1112,
  1112,
  1112,
  1112,
  1112,
  1112,
  1112,
  1112,
  1112,
  1114,
  1114,
  1114,
  1114,
  1114,
  1114,
  1114,
  1114,
  1114,
  1114,
  1114,
  1114,
  1116,
  1116,
  1116,
  1116,
  1116,
  1116,
  1116,
  1116,
  1116,
  1116,
  1116,
  1116,
  1118,
  1118,
  1118,
  1118,
  1118,
  1118,
  1118,
  1118,
  1118,
  1118,
  1118,
  1118,
  1120,
  1120,
  1120,
  1120,
  1120,
  1120,
  1120,
  1120,
  1120,
  1120,
  1120,
  1120,
  1122,
  1122,
  1122,
  1122,
  1122,
  1122,
  1122,
  1122,
  1122,
  1122,
  1122,
  1122,
  1124,
  1124,
  1124,
  1124,
  1124,
  1124,
  1124,
  1124,
  1124,
  1124,
  1124,
  1124,
  1126,
  1126,
  1126,
  1126,
  1126,
  1126,
  1126,
  1126,
  1126,
  1126,
  1126,
  1126,
  1128,
  1128,
  1128,
  1128,
  1128,
  1128,
  1128,
  1128,
  1128,
  1128,
  1128,
  1128,
  1130,
  1130,
  1130,
  1130,
  1130,
  1130,
  1130,
  1130,
  1130,
  1130,
  1130,
  1130,
  1132,
  1132,
  1132,
  1132,
  1132,
  1132,
  1132,
  1132,
  1132,
  1132,
  1132,
  1132,
  1134,
  1134,
  1134,
  1134,
  1134,
  1134,
  1134,
  1134,
  1134,
  1134,
  1134,
  1134,
  1136,
  1136,
  1136,
  1136,
  1136,
  1136,
  1136,
  1136,
  1136,
  1136,
  1136,
  1136,
  1138,
  1138,
  1138,
  1138,
  1138,
  1138,
  1138,
  1138,
  1138,
  1138,
  1138,
  1138,
  1140,
  1140,
  1140,
  1140,
  1140,
  1140,
  1140,
  1140,
  1140,
  1140,
  1140,
  1140,
  1142,
  1142,
  1142,
  1142,
  1142,
  1142,
  1142,
  1142,
  1142,
  1142,
  1142,
  1142,
  1144,
  1144,
  1144,
  1144,
  1144,
  1144,
  1144,
  1144,
  1144,
  1144,
  1144,
  1144,
  1146,
  1146,
  1146,
  1146,
  1146,
  1146,
  1146,
  1146,
  1146,
  1146,
  1146,
  1146,
  1148,
  1148,
  1148,
  1148,
  1148,
  1148,
  1148,
  1148,
  1148,
  1148,
  1148,
  1148,
  1150,
  1150,
  1150,
  1150,
  1150,
  1150,
  1150,
  1150,
  1150,
  1150,
  1150,
  1150,
  1152,
  1152,
  1152,
  1152,
  1152,
  1152,
  1152,
  1152,
  1152,
  1152,
  1152,
  1152,
  1154,
  1154,
  1154,
  1154,
  1154,
  1154,
  1154,
  1154,
  1154,
  1154,
  1154,
  1154,
  1156,
  1156,
  1156,
  1156,
  1156,
  1156,
  1156,
  1156,
  1156,
  1156,
  1156,
  1156,
  1158,
  1158,
  1158,
  1158,
  1158,
  1158,
  1158,
  1158,
  1158,
  1158,
  1158,
  1158,
  1160,
  1160,
  1160,
  1160,
  1160,
  1160,
  1160,
  1160,
  1160,
  1160,
  1160,
  1160,
  1162,
  1162,
  1162,
  1162,
  1162,
  1162,
  1162,
  1162,
  1162,
  1162,
  1162,
  1162,
  1164,
  1164,
  1164,
  1164,
  1164,
  1164,
  1164,
  1164,
  1164,
  1164,
  1164,
  1164,
  1166,
  1166,
  1166,
  1166,
  1166,
  1166,
  1166,
  1166,
  1166,
  1166,
  1166,
  1166,
  1168,
  1168,
  1168,
  1168,
  1168,
  1168,
  1168,
  1168,
  1168,
  1168,
  1168,
  1168,
  1170,
  1170,
  1170,
  1170,
  1170,
  1170,
  1170,
  1170,
  1170,
  1170,
  1170,
  1170,
  1172,
  1172,
  1172,
  1172,
  1172,
  1172,
  1172,
  1172,
  1172,
  1172,
  1172,
  1172,
  1174,
  1174,
  1174,
  1174,
  1174,
  1174,
  1174,
  1174,
  1174,
  1174,
  1174,
  1174,
  1176,
  1176,
  1176,
  1176,
  1176,
  1176,
  1176,
  1176,
  1176,
  1176,
  1176,
  1176,
  1178,
  1178,
  1178,
  1178,
  1178,
  1178,
  1178,
  1178,
  1178,
  1178,
  1178,
  1178,
  1180,
  1180,
  1180,
  1180,
  1180,
  1180,
  1180,
  1180,
  1180,
  1180,
  1180,
  1180,
  1182,
  1182,
  1182,
  1182,
  1182,
  1182,
  1182,
  1182,
  1182,
  1182,
  1182,
  1182,
  1184,
  1184,
  1184,
  1184,
  1184,
  1184,
  1184,
  1184,
  1184,
  1184,
  1184,
  1184,
  1186,
  1186,
  1186,
  1186,
  1186,
  1186,
  1186,
  1186,
  1186,
  1186,
  1186,
  1186,
  1188,
  1188,
  1188,
  1188,
  1188,
  1188,
  1188,
  1188,
  1188,
  1188,
  1188,
  1188,
  1190,
  1190,
  1190,
  1190,
  1190,
  1190,
  1190,
  1190,
  1190,
  1190,
  1190,
  1190,
  1192,
  1192,
  1192,
  1192,
  1192,
  1192,
  1192,
  1192,
  1192,
  1192,
  1192,
  1192,
  1194,
  1194,
  1194,
  1194,
  1194,
  1194,
  1194,
  1194,
  1194,
  1194,
  1194,
  1194,
  1196,
  1196,
  1196,
  1196,
  1196,
  1196,
  1196,
  1196,
  1196,
  1196,
  1196,
  1196,
  1198,
  1198,
  1198,
  1198,
  1198,
  1198,
  1198,
  1198,
  1198,
  1198,
  1198,
  1198,
  1200,
  1200,
  1200,
  1200,
  1200,
  1200,
  1200,
  1200,
  1200,
  1200,
  1200,
  1200,
  1202,
  1202,
  1202,
  1202,
  1202,
  1202,
  1202,
  1202,
  1202,
  1202,
  1202,
  1202,
  1204,
  1204,
  1204,
  1204,
  1204,
  1204,
  1204,
  1204,
  1204,
  1204,
  1204,
  1204,
  1206,
  1206,
  1206,
  1206,
  1206,
  1206,
  1206,
  1206,
  1206,
  1206,
  1206,
  1206,
  1208,
  1208,
  1208,
  1208,
  1208,
  1208,
  1208,
  1208,
  1208,
  1208,
  1208,
  1208,
  1210,
  1210,
  1210,
  1210,
  1210,
  1210,
  1210,
  1210,
  1210,
  1210,
  1210,
  1210,
  1212,
  1212,
  1212,
  1212,
  1212,
  1212,
  1212,
  1212,
  1212,
  1212,
  1212,
  1212,
  1214,
  1214,
  1214,
  1214,
  1214,
  1214,
  1214,
  1214,
  1214,
  1214,
  1214,
  1214,
  1216,
  1216,
  1216,
  1216,
  1216,
  1216,
  1216,
  1216,
  1216,
  1216,
  1216,
  1216,
  1218,
  1218,
  1218,
  1218,
  1218,
  1218,
  1218,
  1218,
  1218,
  1218,
  1218,
  1218,
  1220,
  1220,
  1220,
  1220,
  1220,
  1220,
  1220,
  1220,
  1220,
  1220,
  1220,
  1220,
  1222,
  1222,
  1222,
  1222,
  1222,
  1222,
  1222,
  1222,
  1222,
  1222,
  1222,
  1222,
  1224,
  1224,
  1224,
  1224,
  1224,
  1224,
  1224,
  1224,
  1224,
  1224,
  1224,
  1224,
  1226,
  1226,
  1226,
  1226,
  1226,
  1226,
  1226,
  1226,
  1226,
  1226,
  1226,
  1226,
  1228,
  1228,
  1228,
  1228,
  1228,
  1228,
  1228,
  1228,
  1228,
  1228,
  1228,
  1228,
  1230,
  1230,
  1230,
  1230,
  1230,
  1230,
  1230,
  1230,
  1230,
  1230,
  1230,
  1230,
  1232,
  1232,
  1232,
  1232,
  1232,
  1232,
  1232,
  1232,
  1232,
  1232,
  1232,
  1232,
  1234,
  1234,
  1234,
  1234,
  1234,
  1234,
  1234,
  1234,
  1234,
  1234,
  1234,
  1234,
  1236,
  1236,
  1236,
  1236,
  1236,
  1236,
  1236,
  1236,
  1236,
  1236,
  1236,
  1236,
  1238,
  1238,
  1238,
  1238,
  1238,
  1238,
  1238,
  1238,
  1238,
  1238,
  1238,
  1238,
  1240,
  1240,
  1240,
  1240,
  1240,
  1240,
  1240,
  1240,
  1240,
  1240,
  1240,
  1240,
  1242,
  1242,
  1242,
  1242,
  1242,
  1242,
  1242,
  1242,
  1242,
  1242,
  1242,
  1242,
  1244,
  1244,
  1244,
  1244,
  1244,
  1244,
  1244,
  1244,
  1244,
  1244,
  1244,
  1244,
  1246,
  1246,
  1246,
  1246,
  1246,
  1246,
  1246,
  1246,
  1246,
  1246,
  1246,
  1246,
  1248,
  1248,
  1248,
  1248,
  1248,
  1248,
  1248,
  1248,
  1248,
  1248,
  1248,
  1248,
  1250,
  1250,
  1250,
  1250,
  1250,
  1250,
  1250,
  1250,
  1250,
  1250,
  1250,
  1250,
  1252,
  1252,
  1252,
  1252,
  1252,
  1252,
  1252,
  1252,
  1252,
  1252,
  1252,
  1252,
  1254,
  1254,
  1254,
  1254,
  1254,
  1254,
  1254,
  1254,
  1254,
  1254,
  1254,
  1254,
  1256,
  1256,
  1256,
  1256,
  1256,
  1256,
  1256,
  1256,
  1256,
  1256,
  1256,
  1256,
  1258,
  1258,
  1258,
  1258,
  1258,
  1258,
  1258,
  1258,
  1258,
  1258,
  1258,
  1258,
  1260,
  1260,
  1260,
  1260,
  1260,
  1260,
  1260,
  1260,
  1260,
  1260,
  1260,
  1260,
  1262,
  1262,
  1262,
  1262,
  1262,
  1262,
  1262,
  1262,
  1262,
  1262,
  1262,
  1262,
  1264,
  1264,
  1264,
  1264,
  1264,
  1264,
  1264,
  1264,
  1264,
  1264,
  1264,
  1264,
  1266,
  1266,
  1266,
  1266,
  1266,
  1266,
  1266,
  1266,
  1266,
  1266,
  1266,
  1266,
  1268,
  1268,
  1268,
  1268,
  1268,
  1268,
  1268,
  1268,
  1268,
  1268,
  1268,
  1268,
  1270,
  1270,
  1270,
  1270,
  1270,
  1270,
  1270,
  1270,
  1270,
  1270,
  1270,
  1270,
  1272,
  1272,
  1272,
  1272,
  1272,
  1272,
  1272,
  1272,
  1272,
  1272,
  1272,
  1272,
  1274,
  1274,
  1274,
  1274,
  1274,
  1274,
  1274,
  1274,
  1274,
  1274,
  1274,
  1274,
  1276,
  1276,
  1276,
  1276,
  1276,
  1276,
  1276,
  1276,
  1276,
  1276,
  1276,
  1276,
  1278,
  1278,
  1278,
  1278,
  1278,
  1278,
  1278,
  1278,
  1278,
  1278,
  1278,
  1278,
  1280,
  1280,
  1280,
  1280,
  1280,
  1280,
  1280,
  1280,
  1280,
  1280,
  1280,
  1280,
  1282,
  1282,
  1282,
  1282,
  1282,
  1282,
  1282,
  1282,
  1282,
  1282,
  1282,
  1282,
  1284,
  1284,
  1284,
  1284,
  1284,
  1284,
  1284,
  1284,
  1284,
  1284,
  1284,
  1284,
  1286,
  1286,
  1286,
  1286,
  1286,
  1286,
  1286,
  1286,
  1286,
  1286,
  1286,
  1286,
  1288,
  1288,
  1288,
  1288,
  1288,
  1288,
  1288,
  1288,
  1288,
  1288,
  1288,
  1288,
  1290,
  1290,
  1290,
  1290,
  1290,
  1290,
  1290,
  1290,
  1290,
  1290,
  1290,
  1290,
  1292,
  1292,
  1292,
  1292,
  1292,
  1292,
  1292,
  1292,
  1292,
  1292,
  1292,
  1292,
  1294,
  1294,
  1294,
  1294,
  1294,
  1294,
  1294,
  1294,
  1294,
  1294,
  1294,
  1294,
  1296,
  1296,
  1296,
  1296,
  1296,
  1296,
  1296,
  1296,
  1296,
  1296,
  1296,
  1296,
  1298,
  1298,
  1298,
  1298,
  1298,
  1298,
  1298,
  1298,
  1298,
  1298,
  1298,
  1298,
  1300,
  1300,
  1300,
  1300,
  1300,
  1300,
  1300,
  1300,
  1300,
  1300,
  1300,
  1300,
  1302,
  1302,
  1302,
  1302,
  1302,
  1302,
  1302,
  1302,
  1302,
  1302,
  1302,
  1302,
  1304,
  1304,
  1304,
  1304,
  1304,
  1304,
  1304,
  1304,
  1304,
  1304,
  1304,
  1304,
  1306,
  1306,
  1306,
  1306,
  1306,
  1306,
  1306,
  1306,
  1306,
  1306,
  1306,
  1306,
  1308,
  1308,
  1308,
  1308,
  1308,
  1308,
  1308,
  1308,
  1308,
  1308,
  1308,
  1308,
  1310,
  1310,
  1310,
  1310,
  1310,
  1310,
  1310,
  1310,
  1310,
  1310,
  1310,
  1310,
  1312,
  1312,
  1312,
  1312,
  1312,
  1312,
  1312,
  1312,
  1312,
  1312,
  1312,
  1312,
  1314,
  1314,
  1314,
  1314,
  1314,
  1314,
  1314,
  1314,
  1314,
  1314,
  1314,
  1314,
  1316,
  1316,
  1316,
  1316,
  1316,
  1316,
  1316,
  1316,
  1316,
  1316,
  1316,
  1316,
  1318,
  1318,
  1318,
  1318,
  1318,
  1318,
  1318,
  1318,
  1318,
  1318,
  1318,
  1318,
  1320,
  1320,
  1320,
  1320,
  1320,
  1320,
  1320,
  1320,
  1320,
  1320,
  1320,
  1320,
  1322,
  1322,
  1322,
  1322,
  1322,
  1322,
  1322,
  1322,
  1322,
  1322,
  1322,
  1322,
  1324,
  1324,
  1324,
  1324,
  1324,
  1324,
  1324,
  1324,
  1324,
  1324,
  1324,
  1324,
  1326,
  1326,
  1326,
  1326,
  1326,
  1326,
  1326,
  1326,
  1326,
  1326,
  1326,
  1326,
  1328,
  1328,
  1328,
  1328,
  1328,
  1328,
  1328,
  1328,
  1328,
  1328,
  1328,
  1328,
  1330,
  1330,
  1330,
  1330,
  1330,
  1330,
  1330,
  1330,
  1330,
  1330,
  1330,
  1330,
  1332,
  1332,
  1332,
  1332,
  1332,
  1332,
  1332,
  1332,
  1332,
  1332,
  1332,
  1332,
  1334,
  1334,
  1334,
  1334,
  1334,
  1334,
  1334,
  1334,
  1334,
  1334,
  1334,
  1334,
  1336,
  1336,
  1336,
  1336,
  1336,
  1336,
  1336,
  1336,
  1336,
  1336,
  1336,
  1336,
  1338,
  1338,
  1338,
  1338,
  1338,
  1338,
  1338,
  1338,
  1338,
  1338,
  1338,
  1338,
  1340,
  1340,
  1340,
  1340,
  1340,
  1340,
  1340,
  1340,
  1340,
  1340,
  1340,
  1340,
  1342,
  1342,
  1342,
  1342,
  1342,
  1342,
  1342,
  1342,
  1342,
  1342,
  1342,
  1342,
  1344,
  1344,
  1344,
  1344,
  1344,
  1344,
  1344,
  1344,
  1344,
  1344,
  1344,
  1344,
  1346,
  1346,
  1346,
  1346,
  1346,
  1346,
  1346,
  1346,
  1346,
  1346,
  1346,
  1346,
  1348,
  1348,
  1348,
  1348,
  1348,
  1348,
  1348,
  1348,
  1348,
  1348,
  1348,
  1348,
  372,
  371,
  370,
  369,
  365,
  364,
  363,
  362,
  361,
  360,
  359,
  355,
  354,
  353,
  352,
  351,
  350,
  349,
  348,
  347,
  346,
  345,
  344,
  343,
  342,
  341,
  340,
  339,
  333,
  332,
  331,
  330,
  329,
  326,
  325,
  324,
  323,
  322,
  321,
  318,
  259,
  316,
  315,
  314,
  313,
  312,
  311,
  310,
  309,
  308,
  307,
  306,
  239,
  305,
  304,
  303,
  221,
  217,
  1350,
  214,
  211,
  298,
  297,
  296,
  295,
  294,
  293,
  292,
  289,
  288,
  287,
  286,
  285,
  284,
  283,
  282,
  281,
  278,
  277,
  276,
  275,
  274,
  273,
  270,
  269,
  268,
  267,
  266,
  265,
  264,
  258,
  257,
  254,
  249,
  248,
  247,
  246,
  245,
  244,
  243,
  242,
  241,
  1350,
  237,
  236,
  234,
  106,
  233,
  231,
  231,
  230,
  228,
  217,
  214,
  212,
  211,
  203,
  197,
  196,
  195,
  190,
  189,
  186,
  185,
  181,
  165,
  161,
  159,
  158,
  149,
  134,
  112,
  106,
  1350,
  98,
  98,
  23,
  23,
  21,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  0
}; // weak
__int16 word_4A0CF0[] = { 0 }; // weak
__int16 word_4A0CF2[7999] =
{
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  7,
  8,
  9,
  10,
  11,
  23,
  25,
  25,
  25,
  11,
  19,
  19,
  27,
  30,
  30,
  113,
  19,
  20,
  20,
  7,
  8,
  32,
  31,
  20,
  23,
  952,
  9,
  10,
  11,
  9,
  10,
  11,
  12,
  36,
  19,
  19,
  27,
  12,
  31,
  113,
  32,
  20,
  20,
  37,
  36,
  38,
  38,
  38,
  23,
  44,
  44,
  38,
  37,
  37,
  45,
  45,
  12,
  954,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  33,
  39,
  956,
  70,
  43,
  40,
  39,
  40,
  40,
  40,
  43,
  43,
  43,
  39,
  41,
  50,
  41,
  41,
  41,
  50,
  50,
  55,
  61,
  64,
  65,
  40,
  64,
  55,
  61,
  65,
  958,
  52,
  33,
  33,
  41,
  33,
  52,
  33,
  70,
  960,
  33,
  109,
  52,
  53,
  40,
  52,
  33,
  53,
  54,
  33,
  33,
  115,
  33,
  53,
  962,
  58,
  115,
  54,
  54,
  54,
  77,
  77,
  77,
  58,
  109,
  118,
  118,
  54,
  58,
  54,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  74,
  76,
  76,
  76,
  79,
  85,
  89,
  87,
  87,
  90,
  106,
  89,
  91,
  91,
  90,
  121,
  92,
  92,
  79,
  79,
  87,
  111,
  111,
  111,
  85,
  964,
  106,
  151,
  151,
  106,
  140,
  140,
  140,
  89,
  121,
  966,
  90,
  92,
  76,
  145,
  145,
  145,
  968,
  146,
  87,
  146,
  146,
  146,
  140,
  91,
  148,
  148,
  148,
  106,
  147,
  79,
  147,
  145,
  970,
  147,
  147,
  147,
  972,
  146,
  148,
  148,
  148,
  148,
  148,
  148,
  158,
  158,
  161,
  170,
  178,
  161,
  170,
  190,
  208,
  208,
  190,
  161,
  204,
  204,
  204,
  178,
  205,
  205,
  205,
  974,
  219,
  220,
  209,
  209,
  209,
  219,
  220,
  976,
  223,
  223,
  205,
  205,
  205,
  205,
  205,
  205,
  209,
  209,
  209,
  209,
  209,
  209,
  224,
  224,
  233,
  270,
  270,
  219,
  220,
  223,
  250,
  250,
  250,
  251,
  251,
  251,
  252,
  252,
  252,
  262,
  233,
  300,
  300,
  233,
  253,
  253,
  253,
  978,
  250,
  980,
  277,
  262,
  277,
  317,
  317,
  277,
  376,
  376,
  253,
  253,
  253,
  253,
  253,
  253,
  303,
  277,
  982,
  233,
  310,
  277,
  299,
  299,
  299,
  360,
  360,
  360,
  301,
  301,
  301,
  310,
  303,
  359,
  984,
  303,
  299,
  299,
  299,
  299,
  299,
  299,
  301,
  301,
  301,
  301,
  301,
  301,
  986,
  359,
  363,
  366,
  359,
  370,
  411,
  360,
  310,
  416,
  417,
  303,
  423,
  363,
  366,
  426,
  370,
  452,
  569,
  569,
  416,
  417,
  411,
  423,
  455,
  411,
  426,
  988,
  359,
  454,
  454,
  454,
  459,
  452,
  460,
  455,
  452,
  461,
  363,
  483,
  485,
  485,
  485,
  459,
  990,
  460,
  486,
  992,
  461,
  411,
  487,
  488,
  490,
  508,
  994,
  483,
  996,
  486,
  483,
  998,
  452,
  487,
  488,
  490,
  492,
  492,
  492,
  1000,
  521,
  508,
  1002,
  1004,
  508,
  511,
  511,
  511,
  531,
  1006,
  539,
  561,
  561,
  561,
  483,
  485,
  521,
  547,
  551,
  521,
  1008,
  492,
  555,
  559,
  531,
  1010,
  539,
  531,
  508,
  539,
  511,
  563,
  1012,
  547,
  551,
  561,
  547,
  551,
  555,
  559,
  1014,
  555,
  559,
  521,
  565,
  565,
  565,
  563,
  568,
  1016,
  563,
  531,
  1018,
  539,
  566,
  566,
  566,
  1020,
  566,
  1022,
  547,
  551,
  1024,
  566,
  568,
  555,
  559,
  568,
  565,
  570,
  570,
  570,
  1026,
  570,
  563,
  1028,
  575,
  582,
  570,
  585,
  585,
  585,
  1030,
  587,
  590,
  590,
  590,
  593,
  1032,
  595,
  1034,
  568,
  575,
  582,
  597,
  575,
  582,
  1036,
  599,
  587,
  1038,
  566,
  587,
  593,
  585,
  595,
  593,
  1040,
  595,
  590,
  597,
  1042,
  601,
  597,
  599,
  1044,
  570,
  599,
  1046,
  575,
  582,
  1048,
  1050,
  603,
  605,
  1052,
  587,
  1054,
  601,
  607,
  593,
  601,
  595,
  609,
  611,
  613,
  1056,
  597,
  1058,
  603,
  605,
  599,
  603,
  605,
  615,
  607,
  617,
  1060,
  607,
  609,
  611,
  613,
  609,
  611,
  613,
  601,
  1062,
  1064,
  1066,
  1068,
  615,
  1070,
  617,
  615,
  619,
  617,
  603,
  605,
  1072,
  621,
  1074,
  1076,
  607,
  1078,
  623,
  625,
  609,
  611,
  613,
  627,
  619,
  629,
  1080,
  619,
  1082,
  621,
  631,
  615,
  621,
  617,
  623,
  625,
  633,
  623,
  625,
  627,
  1084,
  629,
  627,
  1086,
  629,
  1088,
  631,
  1090,
  635,
  631,
  1092,
  619,
  633,
  637,
  1094,
  633,
  621,
  1096,
  639,
  641,
  1098,
  623,
  625,
  1100,
  635,
  643,
  627,
  635,
  629,
  637,
  645,
  647,
  637,
  631,
  639,
  641,
  649,
  639,
  641,
  633,
  1102,
  643,
  1104,
  1106,
  643,
  1108,
  645,
  647,
  651,
  645,
  647,
  635,
  649,
  653,
  1110,
  649,
  637,
  1112,
  1114,
  655,
  1116,
  639,
  641,
  1118,
  651,
  657,
  659,
  651,
  643,
  653,
  661,
  663,
  653,
  645,
  647,
  655,
  665,
  1120,
  655,
  649,
  1122,
  657,
  659,
  1124,
  657,
  659,
  661,
  663,
  667,
  661,
  663,
  651,
  665,
  1126,
  1128,
  665,
  653,
  1130,
  1132,
  669,
  1134,
  671,
  655,
  1136,
  667,
  673,
  675,
  667,
  657,
  659,
  677,
  679,
  1138,
  661,
  663,
  669,
  681,
  671,
  669,
  665,
  671,
  673,
  675,
  1140,
  673,
  675,
  677,
  679,
  1142,
  677,
  679,
  667,
  681,
  1144,
  1146,
  681,
  683,
  1148,
  1150,
  1152,
  1154,
  685,
  669,
  1156,
  671,
  687,
  689,
  691,
  673,
  675,
  1158,
  693,
  683,
  677,
  679,
  683,
  695,
  685,
  697,
  681,
  685,
  687,
  689,
  691,
  687,
  689,
  691,
  693,
  1160,
  1162,
  693,
  1164,
  695,
  1166,
  697,
  695,
  699,
  697,
  1168,
  683,
  1170,
  701,
  1172,
  1174,
  685,
  1176,
  703,
  705,
  687,
  689,
  691,
  707,
  699,
  709,
  693,
  699,
  1178,
  701,
  711,
  695,
  701,
  697,
  703,
  705,
  713,
  703,
  705,
  707,
  1180,
  709,
  707,
  1182,
  709,
  1184,
  711,
  1186,
  715,
  711,
  1188,
  699,
  713,
  717,
  1190,
  713,
  701,
  1192,
  719,
  721,
  1194,
  703,
  705,
  1196,
  715,
  723,
  707,
  715,
  709,
  717,
  725,
  727,
  717,
  711,
  719,
  721,
  729,
  719,
  721,
  713,
  1198,
  723,
  1200,
  1202,
  723,
  1204,
  725,
  727,
  731,
  725,
  727,
  715,
  729,
  733,
  1206,
  729,
  717,
  1208,
  1210,
  735,
  1212,
  719,
  721,
  1214,
  731,
  737,
  739,
  731,
  723,
  733,
  741,
  743,
  733,
  725,
  727,
  735,
  745,
  1216,
  735,
  729,
  1218,
  737,
  739,
  1220,
  737,
  739,
  741,
  743,
  747,
  741,
  743,
  731,
  745,
  1222,
  1224,
  745,
  733,
  1226,
  1228,
  749,
  1230,
  751,
  735,
  1232,
  747,
  753,
  755,
  747,
  737,
  739,
  757,
  759,
  1234,
  741,
  743,
  749,
  761,
  751,
  749,
  745,
  751,
  753,
  755,
  1236,
  753,
  755,
  757,
  759,
  1238,
  757,
  759,
  747,
  761,
  1240,
  1242,
  761,
  763,
  1244,
  1246,
  1248,
  1250,
  765,
  749,
  1252,
  751,
  767,
  769,
  771,
  753,
  755,
  1254,
  773,
  763,
  757,
  759,
  763,
  775,
  765,
  777,
  761,
  765,
  767,
  769,
  771,
  767,
  769,
  771,
  773,
  1256,
  1258,
  773,
  1260,
  775,
  1262,
  777,
  775,
  779,
  777,
  1264,
  763,
  1266,
  781,
  1268,
  1270,
  765,
  1272,
  783,
  785,
  767,
  769,
  771,
  787,
  779,
  789,
  773,
  779,
  1274,
  781,
  791,
  775,
  781,
  777,
  783,
  785,
  793,
  783,
  785,
  787,
  1276,
  789,
  787,
  1278,
  789,
  1280,
  791,
  1282,
  795,
  791,
  1284,
  779,
  793,
  797,
  1286,
  793,
  781,
  1288,
  799,
  801,
  1290,
  783,
  785,
  1292,
  795,
  803,
  787,
  795,
  789,
  797,
  805,
  807,
  797,
  791,
  799,
  801,
  809,
  799,
  801,
  793,
  1294,
  803,
  1296,
  1298,
  803,
  1300,
  805,
  807,
  811,
  805,
  807,
  795,
  809,
  813,
  1302,
  809,
  797,
  1304,
  1306,
  815,
  1308,
  799,
  801,
  1310,
  811,
  817,
  819,
  811,
  803,
  813,
  821,
  823,
  813,
  805,
  807,
  815,
  825,
  1312,
  815,
  809,
  1314,
  817,
  819,
  1316,
  817,
  819,
  821,
  823,
  827,
  821,
  823,
  811,
  825,
  1318,
  1320,
  825,
  813,
  1322,
  1324,
  829,
  1326,
  831,
  815,
  1328,
  827,
  833,
  835,
  827,
  817,
  819,
  837,
  839,
  1330,
  821,
  823,
  829,
  841,
  831,
  829,
  825,
  831,
  833,
  835,
  1332,
  833,
  835,
  837,
  839,
  1334,
  837,
  839,
  827,
  841,
  1336,
  1338,
  841,
  843,
  1340,
  1342,
  1344,
  1346,
  845,
  829,
  1358,
  831,
  847,
  849,
  851,
  833,
  835,
  950,
  853,
  843,
  837,
  839,
  843,
  855,
  845,
  857,
  841,
  845,
  847,
  849,
  851,
  847,
  849,
  851,
  853,
  948,
  946,
  853,
  944,
  855,
  942,
  857,
  855,
  859,
  857,
  940,
  843,
  938,
  861,
  936,
  934,
  845,
  932,
  863,
  865,
  847,
  849,
  851,
  867,
  859,
  869,
  853,
  859,
  930,
  861,
  871,
  855,
  861,
  857,
  863,
  865,
  873,
  863,
  865,
  867,
  928,
  869,
  867,
  926,
  869,
  924,
  871,
  922,
  875,
  871,
  920,
  859,
  873,
  877,
  918,
  873,
  861,
  916,
  879,
  881,
  914,
  863,
  865,
  912,
  875,
  883,
  867,
  875,
  869,
  877,
  885,
  887,
  877,
  871,
  879,
  881,
  889,
  879,
  881,
  873,
  910,
  883,
  908,
  906,
  883,
  904,
  885,
  887,
  891,
  885,
  887,
  875,
  889,
  893,
  902,
  889,
  877,
  900,
  898,
  895,
  896,
  879,
  881,
  894,
  891,
  897,
  899,
  891,
  883,
  893,
  901,
  903,
  893,
  885,
  887,
  895,
  905,
  892,
  895,
  889,
  890,
  897,
  899,
  888,
  897,
  899,
  901,
  903,
  907,
  901,
  903,
  891,
  905,
  886,
  884,
  905,
  893,
  882,
  880,
  909,
  878,
  911,
  895,
  876,
  907,
  913,
  915,
  907,
  897,
  899,
  917,
  919,
  874,
  901,
  903,
  909,
  921,
  911,
  909,
  905,
  911,
  913,
  915,
  872,
  913,
  915,
  917,
  919,
  870,
  917,
  919,
  907,
  921,
  868,
  866,
  921,
  923,
  864,
  862,
  860,
  858,
  925,
  909,
  856,
  911,
  927,
  929,
  931,
  913,
  915,
  854,
  933,
  923,
  917,
  919,
  923,
  935,
  925,
  937,
  921,
  925,
  927,
  929,
  931,
  927,
  929,
  931,
  933,
  852,
  850,
  933,
  848,
  935,
  846,
  937,
  935,
  939,
  937,
  844,
  923,
  842,
  941,
  840,
  838,
  925,
  836,
  943,
  945,
  927,
  929,
  931,
  947,
  939,
  949,
  933,
  939,
  834,
  941,
  951,
  935,
  941,
  937,
  943,
  945,
  953,
  943,
  945,
  947,
  832,
  949,
  947,
  830,
  949,
  828,
  951,
  826,
  955,
  951,
  824,
  939,
  953,
  957,
  822,
  953,
  941,
  820,
  959,
  961,
  818,
  943,
  945,
  816,
  955,
  963,
  947,
  955,
  949,
  957,
  965,
  967,
  957,
  951,
  959,
  961,
  969,
  959,
  961,
  953,
  814,
  963,
  812,
  810,
  963,
  808,
  965,
  967,
  971,
  965,
  967,
  955,
  969,
  973,
  806,
  969,
  957,
  804,
  802,
  975,
  800,
  959,
  961,
  798,
  971,
  977,
  979,
  971,
  963,
  973,
  981,
  983,
  973,
  965,
  967,
  975,
  985,
  796,
  975,
  969,
  794,
  977,
  979,
  792,
  977,
  979,
  981,
  983,
  987,
  981,
  983,
  971,
  985,
  790,
  788,
  985,
  973,
  786,
  784,
  989,
  782,
  991,
  975,
  780,
  987,
  993,
  995,
  987,
  977,
  979,
  997,
  999,
  778,
  981,
  983,
  989,
  1001,
  991,
  989,
  985,
  991,
  993,
  995,
  776,
  993,
  995,
  997,
  999,
  774,
  997,
  999,
  987,
  1001,
  772,
  770,
  1001,
  1003,
  768,
  766,
  764,
  762,
  1005,
  989,
  760,
  991,
  1007,
  1009,
  1011,
  993,
  995,
  758,
  1013,
  1003,
  997,
  999,
  1003,
  1015,
  1005,
  1017,
  1001,
  1005,
  1007,
  1009,
  1011,
  1007,
  1009,
  1011,
  1013,
  756,
  754,
  1013,
  752,
  1015,
  750,
  1017,
  1015,
  1019,
  1017,
  748,
  1003,
  746,
  1021,
  744,
  742,
  1005,
  740,
  1023,
  1025,
  1007,
  1009,
  1011,
  1027,
  1019,
  1029,
  1013,
  1019,
  738,
  1021,
  1031,
  1015,
  1021,
  1017,
  1023,
  1025,
  1033,
  1023,
  1025,
  1027,
  736,
  1029,
  1027,
  734,
  1029,
  732,
  1031,
  730,
  1035,
  1031,
  728,
  1019,
  1033,
  1037,
  726,
  1033,
  1021,
  724,
  1039,
  1041,
  722,
  1023,
  1025,
  720,
  1035,
  1043,
  1027,
  1035,
  1029,
  1037,
  1045,
  1047,
  1037,
  1031,
  1039,
  1041,
  1049,
  1039,
  1041,
  1033,
  718,
  1043,
  716,
  714,
  1043,
  712,
  1045,
  1047,
  1051,
  1045,
  1047,
  1035,
  1049,
  1053,
  710,
  1049,
  1037,
  708,
  706,
  1055,
  704,
  1039,
  1041,
  702,
  1051,
  1057,
  1059,
  1051,
  1043,
  1053,
  1061,
  1063,
  1053,
  1045,
  1047,
  1055,
  1065,
  700,
  1055,
  1049,
  698,
  1057,
  1059,
  696,
  1057,
  1059,
  1061,
  1063,
  1067,
  1061,
  1063,
  1051,
  1065,
  694,
  692,
  1065,
  1053,
  690,
  688,
  1069,
  686,
  1071,
  1055,
  684,
  1067,
  1073,
  1075,
  1067,
  1057,
  1059,
  1077,
  1079,
  682,
  1061,
  1063,
  1069,
  1081,
  1071,
  1069,
  1065,
  1071,
  1073,
  1075,
  680,
  1073,
  1075,
  1077,
  1079,
  678,
  1077,
  1079,
  1067,
  1081,
  676,
  674,
  1081,
  1083,
  672,
  670,
  668,
  666,
  1085,
  1069,
  664,
  1071,
  1087,
  1089,
  1091,
  1073,
  1075,
  662,
  1093,
  1083,
  1077,
  1079,
  1083,
  1095,
  1085,
  1097,
  1081,
  1085,
  1087,
  1089,
  1091,
  1087,
  1089,
  1091,
  1093,
  660,
  658,
  1093,
  656,
  1095,
  654,
  1097,
  1095,
  1099,
  1097,
  652,
  1083,
  650,
  1101,
  648,
  646,
  1085,
  644,
  1103,
  1105,
  1087,
  1089,
  1091,
  1107,
  1099,
  1109,
  1093,
  1099,
  642,
  1101,
  1111,
  1095,
  1101,
  1097,
  1103,
  1105,
  1113,
  1103,
  1105,
  1107,
  640,
  1109,
  1107,
  638,
  1109,
  636,
  1111,
  634,
  1115,
  1111,
  632,
  1099,
  1113,
  1117,
  630,
  1113,
  1101,
  628,
  1119,
  1121,
  626,
  1103,
  1105,
  624,
  1115,
  1123,
  1107,
  1115,
  1109,
  1117,
  1125,
  1127,
  1117,
  1111,
  1119,
  1121,
  1129,
  1119,
  1121,
  1113,
  622,
  1123,
  620,
  618,
  1123,
  616,
  1125,
  1127,
  1131,
  1125,
  1127,
  1115,
  1129,
  1133,
  614,
  1129,
  1117,
  612,
  610,
  1135,
  608,
  1119,
  1121,
  606,
  1131,
  1137,
  1139,
  1131,
  1123,
  1133,
  1141,
  1143,
  1133,
  1125,
  1127,
  1135,
  1145,
  604,
  1135,
  1129,
  602,
  1137,
  1139,
  600,
  1137,
  1139,
  1141,
  1143,
  1147,
  1141,
  1143,
  1131,
  1145,
  598,
  596,
  1145,
  1133,
  594,
  592,
  1149,
  589,
  1151,
  1135,
  588,
  1147,
  1153,
  1155,
  1147,
  1137,
  1139,
  1157,
  1159,
  586,
  1141,
  1143,
  1149,
  1161,
  1151,
  1149,
  1145,
  1151,
  1153,
  1155,
  584,
  1153,
  1155,
  1157,
  1159,
  583,
  1157,
  1159,
  1147,
  1161,
  581,
  580,
  1161,
  1163,
  579,
  578,
  577,
  574,
  1165,
  1149,
  573,
  1151,
  1167,
  1169,
  1171,
  1153,
  1155,
  572,
  1173,
  1163,
  1157,
  1159,
  1163,
  1175,
  1165,
  1177,
  1161,
  1165,
  1167,
  1169,
  1171,
  1167,
  1169,
  1171,
  1173,
  571,
  567,
  1173,
  564,
  1175,
  562,
  1177,
  1175,
  1179,
  1177,
  560,
  1163,
  558,
  1181,
  557,
  556,
  1165,
  554,
  1183,
  1185,
  1167,
  1169,
  1171,
  1187,
  1179,
  1189,
  1173,
  1179,
  553,
  1181,
  1191,
  1175,
  1181,
  1177,
  1183,
  1185,
  1193,
  1183,
  1185,
  1187,
  552,
  1189,
  1187,
  550,
  1189,
  549,
  1191,
  548,
  1195,
  1191,
  546,
  1179,
  1193,
  1197,
  541,
  1193,
  1181,
  540,
  1199,
  1201,
  538,
  1183,
  1185,
  537,
  1195,
  1203,
  1187,
  1195,
  1189,
  1197,
  1205,
  1207,
  1197,
  1191,
  1199,
  1201,
  1209,
  1199,
  1201,
  1193,
  536,
  1203,
  535,
  534,
  1203,
  533,
  1205,
  1207,
  1211,
  1205,
  1207,
  1195,
  1209,
  1213,
  532,
  1209,
  1197,
  530,
  529,
  1215,
  528,
  1199,
  1201,
  527,
  1211,
  1217,
  1219,
  1211,
  1203,
  1213,
  1221,
  1223,
  1213,
  1205,
  1207,
  1215,
  1225,
  524,
  1215,
  1209,
  523,
  1217,
  1219,
  522,
  1217,
  1219,
  1221,
  1223,
  1227,
  1221,
  1223,
  1211,
  1225,
  520,
  519,
  1225,
  1213,
  518,
  517,
  1229,
  515,
  1231,
  1215,
  514,
  1227,
  1233,
  1235,
  1227,
  1217,
  1219,
  1237,
  1239,
  513,
  1221,
  1223,
  1229,
  1241,
  1231,
  1229,
  1225,
  1231,
  1233,
  1235,
  510,
  1233,
  1235,
  1237,
  1239,
  509,
  1237,
  1239,
  1227,
  1241,
  507,
  506,
  1241,
  1243,
  505,
  504,
  501,
  500,
  1245,
  1229,
  499,
  1231,
  1247,
  1249,
  1251,
  1233,
  1235,
  497,
  1253,
  1243,
  1237,
  1239,
  1243,
  1255,
  1245,
  1257,
  1241,
  1245,
  1247,
  1249,
  1251,
  1247,
  1249,
  1251,
  1253,
  495,
  493,
  1253,
  484,
  1255,
  482,
  1257,
  1255,
  1259,
  1257,
  481,
  1243,
  480,
  1261,
  479,
  478,
  1245,
  475,
  1263,
  1265,
  1247,
  1249,
  1251,
  1267,
  1259,
  1269,
  1253,
  1259,
  474,
  1261,
  1271,
  1255,
  1261,
  1257,
  1263,
  1265,
  1273,
  1263,
  1265,
  1267,
  473,
  1269,
  1267,
  472,
  1269,
  469,
  1271,
  468,
  1275,
  1271,
  467,
  1259,
  1273,
  1277,
  466,
  1273,
  1261,
  465,
  1279,
  1281,
  464,
  1263,
  1265,
  463,
  1275,
  1283,
  1267,
  1275,
  1269,
  1277,
  1285,
  1287,
  1277,
  1271,
  1279,
  1281,
  1289,
  1279,
  1281,
  1273,
  458,
  1283,
  457,
  453,
  1283,
  451,
  1285,
  1287,
  1291,
  1285,
  1287,
  1275,
  1289,
  1293,
  447,
  1289,
  1277,
  446,
  445,
  1295,
  443,
  1279,
  1281,
  442,
  1291,
  1297,
  1299,
  1291,
  1283,
  1293,
  1301,
  1303,
  1293,
  1285,
  1287,
  1295,
  1305,
  441,
  1295,
  1289,
  440,
  1297,
  1299,
  439,
  1297,
  1299,
  1301,
  1303,
  1307,
  1301,
  1303,
  1291,
  1305,
  438,
  437,
  1305,
  1293,
  435,
  434,
  1309,
  433,
  1311,
  1295,
  432,
  1307,
  1313,
  1315,
  1307,
  1297,
  1299,
  1317,
  1319,
  431,
  1301,
  1303,
  1309,
  1321,
  1311,
  1309,
  1305,
  1311,
  1313,
  1315,
  430,
  1313,
  1315,
  1317,
  1319,
  429,
  1317,
  1319,
  1307,
  1321,
  428,
  427,
  1321,
  1323,
  425,
  422,
  421,
  420,
  1325,
  1309,
  419,
  1311,
  1327,
  1329,
  1331,
  1313,
  1315,
  415,
  1333,
  1323,
  1317,
  1319,
  1323,
  1335,
  1325,
  1337,
  1321,
  1325,
  1327,
  1329,
  1331,
  1327,
  1329,
  1331,
  1333,
  414,
  413,
  1333,
  410,
  1335,
  407,
  1337,
  1335,
  1339,
  1337,
  406,
  1323,
  405,
  1341,
  404,
  402,
  1325,
  400,
  1343,
  1345,
  1327,
  1329,
  1331,
  1347,
  1339,
  1349,
  1333,
  1339,
  399,
  1341,
  398,
  1335,
  1341,
  1337,
  1343,
  1345,
  397,
  1343,
  1345,
  1347,
  396,
  1349,
  1347,
  395,
  1349,
  394,
  392,
  391,
  389,
  388,
  387,
  1339,
  386,
  383,
  380,
  379,
  1341,
  378,
  377,
  375,
  373,
  1343,
  1345,
  372,
  371,
  369,
  1347,
  368,
  1349,
  1351,
  1351,
  1351,
  1351,
  1351,
  1351,
  1351,
  1351,
  1351,
  1351,
  1351,
  1351,
  1352,
  1352,
  1352,
  1352,
  1352,
  1352,
  1352,
  1352,
  1352,
  1352,
  1352,
  1352,
  1353,
  1353,
  1353,
  1353,
  1353,
  1353,
  1353,
  1353,
  1353,
  1353,
  1353,
  1353,
  1354,
  1354,
  1354,
  1354,
  1354,
  1354,
  1354,
  1354,
  1354,
  1354,
  1354,
  1354,
  1355,
  1355,
  1355,
  1355,
  1355,
  1355,
  1355,
  1355,
  1355,
  1355,
  1355,
  1355,
  1356,
  1356,
  1356,
  1356,
  1356,
  1356,
  1356,
  1356,
  1356,
  1356,
  365,
  1356,
  1357,
  1357,
  1357,
  1357,
  364,
  1357,
  1357,
  1357,
  1357,
  1357,
  1357,
  1357,
  1359,
  1359,
  1359,
  1359,
  1359,
  1359,
  1359,
  1359,
  1359,
  1359,
  1359,
  1359,
  1360,
  362,
  361,
  1360,
  1361,
  1361,
  1361,
  358,
  1361,
  1361,
  1361,
  355,
  1361,
  1361,
  1362,
  1362,
  1362,
  1362,
  1362,
  1362,
  1362,
  1362,
  1362,
  1362,
  1362,
  1362,
  1363,
  354,
  353,
  1363,
  1364,
  1364,
  1364,
  1364,
  1364,
  1364,
  352,
  1364,
  1364,
  1364,
  1364,
  1364,
  1365,
  351,
  350,
  349,
  348,
  346,
  1365,
  1365,
  345,
  1365,
  1366,
  344,
  343,
  1366,
  1367,
  342,
  341,
  1367,
  1368,
  1368,
  1368,
  1368,
  1368,
  1368,
  1368,
  338,
  1368,
  1368,
  1368,
  1368,
  1369,
  1369,
  337,
  1369,
  1369,
  336,
  1369,
  1369,
  1369,
  1369,
  1369,
  1369,
  1370,
  1370,
  1370,
  1370,
  1370,
  1370,
  1370,
  1370,
  1370,
  1370,
  1370,
  1370,
  1371,
  335,
  334,
  1371,
  1372,
  1372,
  1372,
  1372,
  1372,
  1372,
  1372,
  1372,
  1372,
  1372,
  1372,
  1372,
  1373,
  333,
  332,
  330,
  329,
  328,
  327,
  326,
  325,
  323,
  1373,
  1374,
  1374,
  1374,
  1374,
  1374,
  1374,
  1374,
  1374,
  1374,
  1374,
  1374,
  1374,
  1375,
  322,
  321,
  320,
  319,
  318,
  1375,
  316,
  315,
  1375,
  1376,
  1376,
  1376,
  1376,
  1376,
  1376,
  1376,
  1376,
  1376,
  1376,
  1376,
  1376,
  1377,
  1377,
  1377,
  1377,
  1377,
  1377,
  1377,
  1377,
  1377,
  1377,
  1377,
  1377,
  1378,
  1378,
  1378,
  1378,
  1378,
  1378,
  1378,
  1378,
  1378,
  1378,
  1378,
  1378,
  1379,
  1379,
  1379,
  1379,
  1379,
  1379,
  1379,
  1379,
  1379,
  1379,
  1379,
  1379,
  1380,
  1380,
  1380,
  1380,
  1380,
  1380,
  1380,
  1380,
  1380,
  1380,
  1380,
  1380,
  1381,
  1381,
  1381,
  1381,
  1381,
  1381,
  1381,
  1381,
  1381,
  1381,
  1381,
  1381,
  1382,
  1382,
  1382,
  1382,
  1382,
  1382,
  1382,
  1382,
  1382,
  1382,
  1382,
  1382,
  1383,
  1383,
  1383,
  1383,
  1383,
  1383,
  1383,
  1383,
  1383,
  1383,
  1383,
  1383,
  1384,
  1384,
  1384,
  1384,
  1384,
  1384,
  1384,
  1384,
  1384,
  1384,
  1384,
  1384,
  1385,
  1385,
  1385,
  1385,
  1385,
  1385,
  1385,
  1385,
  1385,
  1385,
  1385,
  1385,
  1386,
  1386,
  1386,
  1386,
  1386,
  1386,
  1386,
  1386,
  1386,
  1386,
  1386,
  1386,
  1387,
  1387,
  1387,
  1387,
  1387,
  1387,
  1387,
  1387,
  1387,
  1387,
  1387,
  1387,
  1388,
  1388,
  1388,
  1388,
  1388,
  1388,
  1388,
  1388,
  1388,
  1388,
  1388,
  1388,
  1389,
  1389,
  1389,
  1389,
  1389,
  1389,
  1389,
  1389,
  1389,
  1389,
  1389,
  1389,
  1390,
  1390,
  1390,
  1390,
  1390,
  1390,
  1390,
  1390,
  1390,
  1390,
  1390,
  1390,
  1391,
  1391,
  1391,
  1391,
  1391,
  1391,
  1391,
  1391,
  1391,
  1391,
  1391,
  1391,
  1392,
  1392,
  1392,
  1392,
  1392,
  1392,
  1392,
  1392,
  1392,
  1392,
  1392,
  1392,
  1393,
  1393,
  1393,
  1393,
  1393,
  1393,
  1393,
  1393,
  1393,
  1393,
  1393,
  1393,
  1394,
  1394,
  1394,
  1394,
  1394,
  1394,
  1394,
  1394,
  1394,
  1394,
  1394,
  1394,
  1395,
  1395,
  1395,
  1395,
  1395,
  1395,
  1395,
  1395,
  1395,
  1395,
  1395,
  1395,
  1396,
  1396,
  1396,
  1396,
  1396,
  1396,
  1396,
  1396,
  1396,
  1396,
  1396,
  1396,
  1397,
  1397,
  1397,
  1397,
  1397,
  1397,
  1397,
  1397,
  1397,
  1397,
  1397,
  1397,
  1398,
  1398,
  1398,
  1398,
  1398,
  1398,
  1398,
  1398,
  1398,
  1398,
  1398,
  1398,
  1399,
  1399,
  1399,
  1399,
  1399,
  1399,
  1399,
  1399,
  1399,
  1399,
  1399,
  1399,
  1400,
  1400,
  1400,
  1400,
  1400,
  1400,
  1400,
  1400,
  1400,
  1400,
  1400,
  1400,
  1401,
  1401,
  1401,
  1401,
  1401,
  1401,
  1401,
  1401,
  1401,
  1401,
  1401,
  1401,
  1402,
  1402,
  1402,
  1402,
  1402,
  1402,
  1402,
  1402,
  1402,
  1402,
  1402,
  1402,
  1403,
  1403,
  1403,
  1403,
  1403,
  1403,
  1403,
  1403,
  1403,
  1403,
  1403,
  1403,
  1404,
  1404,
  1404,
  1404,
  1404,
  1404,
  1404,
  1404,
  1404,
  1404,
  1404,
  1404,
  1405,
  1405,
  1405,
  1405,
  1405,
  1405,
  1405,
  1405,
  1405,
  1405,
  1405,
  1405,
  1406,
  1406,
  1406,
  1406,
  1406,
  1406,
  1406,
  1406,
  1406,
  1406,
  1406,
  1406,
  1407,
  1407,
  1407,
  1407,
  1407,
  1407,
  1407,
  1407,
  1407,
  1407,
  1407,
  1407,
  1408,
  1408,
  1408,
  1408,
  1408,
  1408,
  1408,
  1408,
  1408,
  1408,
  1408,
  1408,
  1409,
  1409,
  1409,
  1409,
  1409,
  1409,
  1409,
  1409,
  1409,
  1409,
  1409,
  1409,
  1410,
  1410,
  1410,
  1410,
  1410,
  1410,
  1410,
  1410,
  1410,
  1410,
  1410,
  1410,
  1411,
  1411,
  1411,
  1411,
  1411,
  1411,
  1411,
  1411,
  1411,
  1411,
  1411,
  1411,
  1412,
  1412,
  1412,
  1412,
  1412,
  1412,
  1412,
  1412,
  1412,
  1412,
  1412,
  1412,
  1413,
  1413,
  1413,
  1413,
  1413,
  1413,
  1413,
  1413,
  1413,
  1413,
  1413,
  1413,
  1414,
  1414,
  1414,
  1414,
  1414,
  1414,
  1414,
  1414,
  1414,
  1414,
  1414,
  1414,
  1415,
  1415,
  1415,
  1415,
  1415,
  1415,
  1415,
  1415,
  1415,
  1415,
  1415,
  1415,
  1416,
  1416,
  1416,
  1416,
  1416,
  1416,
  1416,
  1416,
  1416,
  1416,
  1416,
  1416,
  1417,
  1417,
  1417,
  1417,
  1417,
  1417,
  1417,
  1417,
  1417,
  1417,
  1417,
  1417,
  1418,
  1418,
  1418,
  1418,
  1418,
  1418,
  1418,
  1418,
  1418,
  1418,
  1418,
  1418,
  1419,
  1419,
  1419,
  1419,
  1419,
  1419,
  1419,
  1419,
  1419,
  1419,
  1419,
  1419,
  1420,
  1420,
  1420,
  1420,
  1420,
  1420,
  1420,
  1420,
  1420,
  1420,
  1420,
  1420,
  1421,
  1421,
  1421,
  1421,
  1421,
  1421,
  1421,
  1421,
  1421,
  1421,
  1421,
  1421,
  1422,
  1422,
  1422,
  1422,
  1422,
  1422,
  1422,
  1422,
  1422,
  1422,
  1422,
  1422,
  1423,
  1423,
  1423,
  1423,
  1423,
  1423,
  1423,
  1423,
  1423,
  1423,
  1423,
  1423,
  1424,
  1424,
  1424,
  1424,
  1424,
  1424,
  1424,
  1424,
  1424,
  1424,
  1424,
  1424,
  1425,
  1425,
  1425,
  1425,
  1425,
  1425,
  1425,
  1425,
  1425,
  1425,
  1425,
  1425,
  1426,
  1426,
  1426,
  1426,
  1426,
  1426,
  1426,
  1426,
  1426,
  1426,
  1426,
  1426,
  1427,
  1427,
  1427,
  1427,
  1427,
  1427,
  1427,
  1427,
  1427,
  1427,
  1427,
  1427,
  1428,
  1428,
  1428,
  1428,
  1428,
  1428,
  1428,
  1428,
  1428,
  1428,
  1428,
  1428,
  1429,
  1429,
  1429,
  1429,
  1429,
  1429,
  1429,
  1429,
  1429,
  1429,
  1429,
  1429,
  1430,
  1430,
  1430,
  1430,
  1430,
  1430,
  1430,
  1430,
  1430,
  1430,
  1430,
  1430,
  1431,
  1431,
  1431,
  1431,
  1431,
  1431,
  1431,
  1431,
  1431,
  1431,
  1431,
  1431,
  1432,
  1432,
  1432,
  1432,
  1432,
  1432,
  1432,
  1432,
  1432,
  1432,
  1432,
  1432,
  1433,
  1433,
  1433,
  1433,
  1433,
  1433,
  1433,
  1433,
  1433,
  1433,
  1433,
  1433,
  1434,
  1434,
  1434,
  1434,
  1434,
  1434,
  1434,
  1434,
  1434,
  1434,
  1434,
  1434,
  1435,
  1435,
  1435,
  1435,
  1435,
  1435,
  1435,
  1435,
  1435,
  1435,
  1435,
  1435,
  1436,
  1436,
  1436,
  1436,
  1436,
  1436,
  1436,
  1436,
  1436,
  1436,
  1436,
  1436,
  1437,
  1437,
  1437,
  1437,
  1437,
  1437,
  1437,
  1437,
  1437,
  1437,
  1437,
  1437,
  1438,
  1438,
  1438,
  1438,
  1438,
  1438,
  1438,
  1438,
  1438,
  1438,
  1438,
  1438,
  1439,
  1439,
  1439,
  1439,
  1439,
  1439,
  1439,
  1439,
  1439,
  1439,
  1439,
  1439,
  1440,
  1440,
  1440,
  1440,
  1440,
  1440,
  1440,
  1440,
  1440,
  1440,
  1440,
  1440,
  1441,
  1441,
  1441,
  1441,
  1441,
  1441,
  1441,
  1441,
  1441,
  1441,
  1441,
  1441,
  1442,
  1442,
  1442,
  1442,
  1442,
  1442,
  1442,
  1442,
  1442,
  1442,
  1442,
  1442,
  1443,
  1443,
  1443,
  1443,
  1443,
  1443,
  1443,
  1443,
  1443,
  1443,
  1443,
  1443,
  1444,
  1444,
  1444,
  1444,
  1444,
  1444,
  1444,
  1444,
  1444,
  1444,
  1444,
  1444,
  1445,
  1445,
  1445,
  1445,
  1445,
  1445,
  1445,
  1445,
  1445,
  1445,
  1445,
  1445,
  1446,
  1446,
  1446,
  1446,
  1446,
  1446,
  1446,
  1446,
  1446,
  1446,
  1446,
  1446,
  1447,
  1447,
  1447,
  1447,
  1447,
  1447,
  1447,
  1447,
  1447,
  1447,
  1447,
  1447,
  1448,
  1448,
  1448,
  1448,
  1448,
  1448,
  1448,
  1448,
  1448,
  1448,
  1448,
  1448,
  1449,
  1449,
  1449,
  1449,
  1449,
  1449,
  1449,
  1449,
  1449,
  1449,
  1449,
  1449,
  1450,
  1450,
  1450,
  1450,
  1450,
  1450,
  1450,
  1450,
  1450,
  1450,
  1450,
  1450,
  1451,
  1451,
  1451,
  1451,
  1451,
  1451,
  1451,
  1451,
  1451,
  1451,
  1451,
  1451,
  1452,
  1452,
  1452,
  1452,
  1452,
  1452,
  1452,
  1452,
  1452,
  1452,
  1452,
  1452,
  1453,
  1453,
  1453,
  1453,
  1453,
  1453,
  1453,
  1453,
  1453,
  1453,
  1453,
  1453,
  1454,
  1454,
  1454,
  1454,
  1454,
  1454,
  1454,
  1454,
  1454,
  1454,
  1454,
  1454,
  1455,
  1455,
  1455,
  1455,
  1455,
  1455,
  1455,
  1455,
  1455,
  1455,
  1455,
  1455,
  1456,
  1456,
  1456,
  1456,
  1456,
  1456,
  1456,
  1456,
  1456,
  1456,
  1456,
  1456,
  1457,
  1457,
  1457,
  1457,
  1457,
  1457,
  1457,
  1457,
  1457,
  1457,
  1457,
  1457,
  1458,
  1458,
  1458,
  1458,
  1458,
  1458,
  1458,
  1458,
  1458,
  1458,
  1458,
  1458,
  1459,
  1459,
  1459,
  1459,
  1459,
  1459,
  1459,
  1459,
  1459,
  1459,
  1459,
  1459,
  1460,
  1460,
  1460,
  1460,
  1460,
  1460,
  1460,
  1460,
  1460,
  1460,
  1460,
  1460,
  1461,
  1461,
  1461,
  1461,
  1461,
  1461,
  1461,
  1461,
  1461,
  1461,
  1461,
  1461,
  1462,
  1462,
  1462,
  1462,
  1462,
  1462,
  1462,
  1462,
  1462,
  1462,
  1462,
  1462,
  1463,
  1463,
  1463,
  1463,
  1463,
  1463,
  1463,
  1463,
  1463,
  1463,
  1463,
  1463,
  1464,
  1464,
  1464,
  1464,
  1464,
  1464,
  1464,
  1464,
  1464,
  1464,
  1464,
  1464,
  1465,
  1465,
  1465,
  1465,
  1465,
  1465,
  1465,
  1465,
  1465,
  1465,
  1465,
  1465,
  1466,
  1466,
  1466,
  1466,
  1466,
  1466,
  1466,
  1466,
  1466,
  1466,
  1466,
  1466,
  1467,
  1467,
  1467,
  1467,
  1467,
  1467,
  1467,
  1467,
  1467,
  1467,
  1467,
  1467,
  1468,
  1468,
  1468,
  1468,
  1468,
  1468,
  1468,
  1468,
  1468,
  1468,
  1468,
  1468,
  1469,
  1469,
  1469,
  1469,
  1469,
  1469,
  1469,
  1469,
  1469,
  1469,
  1469,
  1469,
  1470,
  1470,
  1470,
  1470,
  1470,
  1470,
  1470,
  1470,
  1470,
  1470,
  1470,
  1470,
  1471,
  1471,
  1471,
  1471,
  1471,
  1471,
  1471,
  1471,
  1471,
  1471,
  1471,
  1471,
  1472,
  1472,
  1472,
  1472,
  1472,
  1472,
  1472,
  1472,
  1472,
  1472,
  1472,
  1472,
  1473,
  1473,
  1473,
  1473,
  1473,
  1473,
  1473,
  1473,
  1473,
  1473,
  1473,
  1473,
  1474,
  1474,
  1474,
  1474,
  1474,
  1474,
  1474,
  1474,
  1474,
  1474,
  1474,
  1474,
  1475,
  1475,
  1475,
  1475,
  1475,
  1475,
  1475,
  1475,
  1475,
  1475,
  1475,
  1475,
  1476,
  1476,
  1476,
  1476,
  1476,
  1476,
  1476,
  1476,
  1476,
  1476,
  1476,
  1476,
  1477,
  1477,
  1477,
  1477,
  1477,
  1477,
  1477,
  1477,
  1477,
  1477,
  1477,
  1477,
  1478,
  1478,
  1478,
  1478,
  1478,
  1478,
  1478,
  1478,
  1478,
  1478,
  1478,
  1478,
  1479,
  1479,
  1479,
  1479,
  1479,
  1479,
  1479,
  1479,
  1479,
  1479,
  1479,
  1479,
  1480,
  1480,
  1480,
  1480,
  1480,
  1480,
  1480,
  1480,
  1480,
  1480,
  1480,
  1480,
  1481,
  1481,
  1481,
  1481,
  1481,
  1481,
  1481,
  1481,
  1481,
  1481,
  1481,
  1481,
  1482,
  1482,
  1482,
  1482,
  1482,
  1482,
  1482,
  1482,
  1482,
  1482,
  1482,
  1482,
  1483,
  1483,
  1483,
  1483,
  1483,
  1483,
  1483,
  1483,
  1483,
  1483,
  1483,
  1483,
  1484,
  1484,
  1484,
  1484,
  1484,
  1484,
  1484,
  1484,
  1484,
  1484,
  1484,
  1484,
  1485,
  1485,
  1485,
  1485,
  1485,
  1485,
  1485,
  1485,
  1485,
  1485,
  1485,
  1485,
  1486,
  1486,
  1486,
  1486,
  1486,
  1486,
  1486,
  1486,
  1486,
  1486,
  1486,
  1486,
  1487,
  1487,
  1487,
  1487,
  1487,
  1487,
  1487,
  1487,
  1487,
  1487,
  1487,
  1487,
  1488,
  1488,
  1488,
  1488,
  1488,
  1488,
  1488,
  1488,
  1488,
  1488,
  1488,
  1488,
  1489,
  1489,
  1489,
  1489,
  1489,
  1489,
  1489,
  1489,
  1489,
  1489,
  1489,
  1489,
  1490,
  1490,
  1490,
  1490,
  1490,
  1490,
  1490,
  1490,
  1490,
  1490,
  1490,
  1490,
  1491,
  1491,
  1491,
  1491,
  1491,
  1491,
  1491,
  1491,
  1491,
  1491,
  1491,
  1491,
  1492,
  1492,
  1492,
  1492,
  1492,
  1492,
  1492,
  1492,
  1492,
  1492,
  1492,
  1492,
  1493,
  1493,
  1493,
  1493,
  1493,
  1493,
  1493,
  1493,
  1493,
  1493,
  1493,
  1493,
  1494,
  1494,
  1494,
  1494,
  1494,
  1494,
  1494,
  1494,
  1494,
  1494,
  1494,
  1494,
  1495,
  1495,
  1495,
  1495,
  1495,
  1495,
  1495,
  1495,
  1495,
  1495,
  1495,
  1495,
  1496,
  1496,
  1496,
  1496,
  1496,
  1496,
  1496,
  1496,
  1496,
  1496,
  1496,
  1496,
  1497,
  1497,
  1497,
  1497,
  1497,
  1497,
  1497,
  1497,
  1497,
  1497,
  1497,
  1497,
  1498,
  1498,
  1498,
  1498,
  1498,
  1498,
  1498,
  1498,
  1498,
  1498,
  1498,
  1498,
  1499,
  1499,
  1499,
  1499,
  1499,
  1499,
  1499,
  1499,
  1499,
  1499,
  1499,
  1499,
  1500,
  1500,
  1500,
  1500,
  1500,
  1500,
  1500,
  1500,
  1500,
  1500,
  1500,
  1500,
  1501,
  1501,
  1501,
  1501,
  1501,
  1501,
  1501,
  1501,
  1501,
  1501,
  1501,
  1501,
  1502,
  1502,
  1502,
  1502,
  1502,
  1502,
  1502,
  1502,
  1502,
  1502,
  1502,
  1502,
  1503,
  1503,
  1503,
  1503,
  1503,
  1503,
  1503,
  1503,
  1503,
  1503,
  1503,
  1503,
  1504,
  1504,
  1504,
  1504,
  1504,
  1504,
  1504,
  1504,
  1504,
  1504,
  1504,
  1504,
  1505,
  1505,
  1505,
  1505,
  1505,
  1505,
  1505,
  1505,
  1505,
  1505,
  1505,
  1505,
  1506,
  1506,
  1506,
  1506,
  1506,
  1506,
  1506,
  1506,
  1506,
  1506,
  1506,
  1506,
  1507,
  1507,
  1507,
  1507,
  1507,
  1507,
  1507,
  1507,
  1507,
  1507,
  1507,
  1507,
  1508,
  1508,
  1508,
  1508,
  1508,
  1508,
  1508,
  1508,
  1508,
  1508,
  1508,
  1508,
  1509,
  1509,
  1509,
  1509,
  1509,
  1509,
  1509,
  1509,
  1509,
  1509,
  1509,
  1509,
  1510,
  1510,
  1510,
  1510,
  1510,
  1510,
  1510,
  1510,
  1510,
  1510,
  1510,
  1510,
  1511,
  1511,
  1511,
  1511,
  1511,
  1511,
  1511,
  1511,
  1511,
  1511,
  1511,
  1511,
  1512,
  1512,
  1512,
  1512,
  1512,
  1512,
  1512,
  1512,
  1512,
  1512,
  1512,
  1512,
  1513,
  1513,
  1513,
  1513,
  1513,
  1513,
  1513,
  1513,
  1513,
  1513,
  1513,
  1513,
  1514,
  1514,
  1514,
  1514,
  1514,
  1514,
  1514,
  1514,
  1514,
  1514,
  1514,
  1514,
  1515,
  1515,
  1515,
  1515,
  1515,
  1515,
  1515,
  1515,
  1515,
  1515,
  1515,
  1515,
  1516,
  1516,
  1516,
  1516,
  1516,
  1516,
  1516,
  1516,
  1516,
  1516,
  1516,
  1516,
  1517,
  1517,
  1517,
  1517,
  1517,
  1517,
  1517,
  1517,
  1517,
  1517,
  1517,
  1517,
  1518,
  1518,
  1518,
  1518,
  1518,
  1518,
  1518,
  1518,
  1518,
  1518,
  1518,
  1518,
  1519,
  1519,
  1519,
  1519,
  1519,
  1519,
  1519,
  1519,
  1519,
  1519,
  1519,
  1519,
  1520,
  1520,
  1520,
  1520,
  1520,
  1520,
  1520,
  1520,
  1520,
  1520,
  1520,
  1520,
  1521,
  1521,
  1521,
  1521,
  1521,
  1521,
  1521,
  1521,
  1521,
  1521,
  1521,
  1521,
  1522,
  1522,
  1522,
  1522,
  1522,
  1522,
  1522,
  1522,
  1522,
  1522,
  1522,
  1522,
  1523,
  1523,
  1523,
  1523,
  1523,
  1523,
  1523,
  1523,
  1523,
  1523,
  1523,
  1523,
  1524,
  1524,
  1524,
  1524,
  1524,
  1524,
  1524,
  1524,
  1524,
  1524,
  1524,
  1524,
  1525,
  1525,
  1525,
  1525,
  1525,
  1525,
  1525,
  1525,
  1525,
  1525,
  1525,
  1525,
  1526,
  1526,
  1526,
  1526,
  1526,
  1526,
  1526,
  1526,
  1526,
  1526,
  1526,
  1526,
  1527,
  1527,
  1527,
  1527,
  1527,
  1527,
  1527,
  1527,
  1527,
  1527,
  1527,
  1527,
  1528,
  1528,
  1528,
  1528,
  1528,
  1528,
  1528,
  1528,
  1528,
  1528,
  1528,
  1528,
  1529,
  1529,
  1529,
  1529,
  1529,
  1529,
  1529,
  1529,
  1529,
  1529,
  1529,
  1529,
  1530,
  1530,
  1530,
  1530,
  1530,
  1530,
  1530,
  1530,
  1530,
  1530,
  1530,
  1530,
  1531,
  1531,
  1531,
  1531,
  1531,
  1531,
  1531,
  1531,
  1531,
  1531,
  1531,
  1531,
  1532,
  1532,
  1532,
  1532,
  1532,
  1532,
  1532,
  1532,
  1532,
  1532,
  1532,
  1532,
  1533,
  1533,
  1533,
  1533,
  1533,
  1533,
  1533,
  1533,
  1533,
  1533,
  1533,
  1533,
  1534,
  1534,
  1534,
  1534,
  1534,
  1534,
  1534,
  1534,
  1534,
  1534,
  1534,
  1534,
  1535,
  1535,
  1535,
  1535,
  1535,
  1535,
  1535,
  1535,
  1535,
  1535,
  1535,
  1535,
  1536,
  1536,
  1536,
  1536,
  1536,
  1536,
  1536,
  1536,
  1536,
  1536,
  1536,
  1536,
  1537,
  1537,
  1537,
  1537,
  1537,
  1537,
  1537,
  1537,
  1537,
  1537,
  1537,
  1537,
  1538,
  1538,
  1538,
  1538,
  1538,
  1538,
  1538,
  1538,
  1538,
  1538,
  1538,
  1538,
  1539,
  1539,
  1539,
  1539,
  1539,
  1539,
  1539,
  1539,
  1539,
  1539,
  1539,
  1539,
  1540,
  1540,
  1540,
  1540,
  1540,
  1540,
  1540,
  1540,
  1540,
  1540,
  1540,
  1540,
  1541,
  1541,
  1541,
  1541,
  1541,
  1541,
  1541,
  1541,
  1541,
  1541,
  1541,
  1541,
  1542,
  1542,
  1542,
  1542,
  1542,
  1542,
  1542,
  1542,
  1542,
  1542,
  1542,
  1542,
  1543,
  1543,
  1543,
  1543,
  1543,
  1543,
  1543,
  1543,
  1543,
  1543,
  1543,
  1543,
  1544,
  1544,
  1544,
  1544,
  1544,
  1544,
  1544,
  1544,
  1544,
  1544,
  1544,
  1544,
  1545,
  1545,
  1545,
  1545,
  1545,
  1545,
  1545,
  1545,
  1545,
  1545,
  1545,
  1545,
  1546,
  1546,
  1546,
  1546,
  1546,
  1546,
  1546,
  1546,
  1546,
  1546,
  1546,
  1546,
  1547,
  1547,
  1547,
  1547,
  1547,
  1547,
  1547,
  1547,
  1547,
  1547,
  1547,
  1547,
  1548,
  1548,
  1548,
  1548,
  1548,
  1548,
  1548,
  1548,
  1548,
  1548,
  1548,
  1548,
  1549,
  1549,
  1549,
  1549,
  1549,
  1549,
  1549,
  1549,
  1549,
  1549,
  1549,
  1549,
  1550,
  1550,
  1550,
  1550,
  1550,
  1550,
  1550,
  1550,
  1550,
  1550,
  1550,
  1550,
  1551,
  1551,
  1551,
  1551,
  1551,
  1551,
  1551,
  1551,
  1551,
  1551,
  1551,
  1551,
  1552,
  1552,
  1552,
  1552,
  1552,
  1552,
  1552,
  1552,
  1552,
  1552,
  1552,
  1552,
  1553,
  1553,
  1553,
  1553,
  1553,
  1553,
  1553,
  1553,
  1553,
  1553,
  1553,
  1553,
  1554,
  1554,
  1554,
  1554,
  1554,
  1554,
  1554,
  1554,
  1554,
  1554,
  1554,
  1554,
  1555,
  1555,
  1555,
  1555,
  1555,
  1555,
  1555,
  1555,
  1555,
  1555,
  1555,
  1555,
  1556,
  1556,
  1556,
  1556,
  1556,
  1556,
  1556,
  1556,
  1556,
  1556,
  1556,
  1556,
  1557,
  1557,
  1557,
  1557,
  1557,
  1557,
  1557,
  1557,
  1557,
  1557,
  1557,
  1557,
  1558,
  1558,
  1558,
  1558,
  1558,
  1558,
  1558,
  1558,
  1558,
  1558,
  1558,
  1558,
  1559,
  1559,
  1559,
  1559,
  1559,
  1559,
  1559,
  1559,
  1559,
  1559,
  1559,
  1559,
  1560,
  1560,
  1560,
  1560,
  1560,
  1560,
  1560,
  1560,
  1560,
  1560,
  1560,
  1560,
  1561,
  1561,
  1561,
  1561,
  1561,
  1561,
  1561,
  1561,
  1561,
  1561,
  1561,
  1561,
  1562,
  1562,
  1562,
  1562,
  1562,
  1562,
  1562,
  1562,
  1562,
  1562,
  1562,
  1562,
  1563,
  1563,
  1563,
  1563,
  1563,
  1563,
  1563,
  1563,
  1563,
  1563,
  1563,
  1563,
  1564,
  1564,
  1564,
  1564,
  1564,
  1564,
  1564,
  1564,
  1564,
  1564,
  1564,
  1564,
  1565,
  1565,
  1565,
  1565,
  1565,
  1565,
  1565,
  1565,
  1565,
  1565,
  1565,
  1565,
  1566,
  1566,
  1566,
  1566,
  1566,
  1566,
  1566,
  1566,
  1566,
  1566,
  1566,
  1566,
  1567,
  1567,
  1567,
  1567,
  1567,
  1567,
  1567,
  1567,
  1567,
  1567,
  1567,
  1567,
  1568,
  1568,
  1568,
  1568,
  1568,
  1568,
  1568,
  1568,
  1568,
  1568,
  1568,
  1568,
  1569,
  1569,
  1569,
  1569,
  1569,
  1569,
  1569,
  1569,
  1569,
  1569,
  1569,
  1569,
  1570,
  1570,
  1570,
  1570,
  1570,
  1570,
  1570,
  1570,
  1570,
  1570,
  1570,
  1570,
  1571,
  1571,
  1571,
  1571,
  1571,
  1571,
  1571,
  1571,
  1571,
  1571,
  1571,
  1571,
  1572,
  1572,
  1572,
  1572,
  1572,
  1572,
  1572,
  1572,
  1572,
  1572,
  1572,
  1572,
  1573,
  1573,
  1573,
  1573,
  1573,
  1573,
  1573,
  1573,
  1573,
  1573,
  1573,
  1573,
  1574,
  1574,
  1574,
  1574,
  1574,
  1574,
  1574,
  1574,
  1574,
  1574,
  1574,
  1574,
  1575,
  1575,
  1575,
  1575,
  1575,
  1575,
  1575,
  1575,
  1575,
  1575,
  1575,
  1575,
  1576,
  1576,
  1576,
  1576,
  1576,
  1576,
  1576,
  1576,
  1576,
  1576,
  1576,
  1576,
  1577,
  1577,
  1577,
  1577,
  1577,
  1577,
  1577,
  1577,
  1577,
  1577,
  1577,
  1577,
  1578,
  1578,
  1578,
  1578,
  1578,
  1578,
  1578,
  1578,
  1578,
  1578,
  1578,
  1578,
  1579,
  1579,
  1579,
  1579,
  1579,
  1579,
  1579,
  1579,
  1579,
  1579,
  1579,
  1579,
  1580,
  1580,
  1580,
  1580,
  1580,
  1580,
  1580,
  1580,
  1580,
  1580,
  1580,
  1580,
  1581,
  1581,
  1581,
  1581,
  1581,
  1581,
  1581,
  1581,
  1581,
  1581,
  1581,
  1581,
  1582,
  1582,
  1582,
  1582,
  1582,
  1582,
  1582,
  1582,
  1582,
  1582,
  1582,
  1582,
  1583,
  1583,
  1583,
  1583,
  1583,
  1583,
  1583,
  1583,
  1583,
  1583,
  1583,
  1583,
  1584,
  1584,
  1584,
  1584,
  1584,
  1584,
  1584,
  1584,
  1584,
  1584,
  1584,
  1584,
  1585,
  1585,
  1585,
  1585,
  1585,
  1585,
  1585,
  1585,
  1585,
  1585,
  1585,
  1585,
  1586,
  1586,
  1586,
  1586,
  1586,
  1586,
  1586,
  1586,
  1586,
  1586,
  1586,
  1586,
  1587,
  1587,
  1587,
  1587,
  1587,
  1587,
  1587,
  1587,
  1587,
  1587,
  1587,
  1587,
  1588,
  1588,
  1588,
  1588,
  1588,
  1588,
  1588,
  1588,
  1588,
  1588,
  1588,
  1588,
  1589,
  1589,
  1589,
  1589,
  1589,
  1589,
  1589,
  1589,
  1589,
  1589,
  1589,
  1589,
  1590,
  1590,
  1590,
  1590,
  1590,
  1590,
  1590,
  1590,
  1590,
  1590,
  1590,
  1590,
  1591,
  1591,
  1591,
  1591,
  1591,
  1591,
  1591,
  1591,
  1591,
  1591,
  1591,
  1591,
  1592,
  1592,
  1592,
  1592,
  1592,
  1592,
  1592,
  1592,
  1592,
  1592,
  1592,
  1592,
  1593,
  1593,
  1593,
  1593,
  1593,
  1593,
  1593,
  1593,
  1593,
  1593,
  1593,
  1593,
  1594,
  1594,
  1594,
  1594,
  1594,
  1594,
  1594,
  1594,
  1594,
  1594,
  1594,
  1594,
  1595,
  1595,
  1595,
  1595,
  1595,
  1595,
  1595,
  1595,
  1595,
  1595,
  1595,
  1595,
  1596,
  1596,
  1596,
  1596,
  1596,
  1596,
  1596,
  1596,
  1596,
  1596,
  1596,
  1596,
  1597,
  1597,
  1597,
  1597,
  1597,
  1597,
  1597,
  1597,
  1597,
  1597,
  1597,
  1597,
  1598,
  1598,
  1598,
  1598,
  1598,
  1598,
  1598,
  1598,
  1598,
  1598,
  1598,
  1598,
  1599,
  1599,
  1599,
  1599,
  1599,
  1599,
  1599,
  1599,
  1599,
  1599,
  1599,
  1599,
  1600,
  1600,
  1600,
  1600,
  1600,
  1600,
  1600,
  1600,
  1600,
  1600,
  1600,
  1600,
  1601,
  1601,
  1601,
  1601,
  1601,
  1601,
  1601,
  1601,
  1601,
  1601,
  1601,
  1601,
  1602,
  1602,
  1602,
  1602,
  1602,
  1602,
  1602,
  1602,
  1602,
  1602,
  1602,
  1602,
  1603,
  1603,
  1603,
  1603,
  1603,
  1603,
  1603,
  1603,
  1603,
  1603,
  1603,
  1603,
  1604,
  1604,
  1604,
  1604,
  1604,
  1604,
  1604,
  1604,
  1604,
  1604,
  1604,
  1604,
  1605,
  1605,
  1605,
  1605,
  1605,
  1605,
  1605,
  1605,
  1605,
  1605,
  1605,
  1605,
  1606,
  1606,
  1606,
  1606,
  1606,
  1606,
  1606,
  1606,
  1606,
  1606,
  1606,
  1606,
  1607,
  1607,
  1607,
  1607,
  1607,
  1607,
  1607,
  1607,
  1607,
  1607,
  1607,
  1607,
  1608,
  1608,
  1608,
  1608,
  1608,
  1608,
  1608,
  1608,
  1608,
  1608,
  1608,
  1608,
  1609,
  1609,
  1609,
  1609,
  1609,
  1609,
  1609,
  1609,
  1609,
  1609,
  1609,
  1609,
  1610,
  1610,
  1610,
  1610,
  1610,
  1610,
  1610,
  1610,
  1610,
  1610,
  1610,
  1610,
  1611,
  1611,
  1611,
  1611,
  1611,
  1611,
  1611,
  1611,
  1611,
  1611,
  1611,
  1611,
  1612,
  1612,
  1612,
  1612,
  1612,
  1612,
  1612,
  1612,
  1612,
  1612,
  1612,
  1612,
  1613,
  1613,
  1613,
  1613,
  1613,
  1613,
  1613,
  1613,
  1613,
  1613,
  1613,
  1613,
  1614,
  1614,
  1614,
  1614,
  1614,
  1614,
  1614,
  1614,
  1614,
  1614,
  1614,
  1614,
  1615,
  1615,
  1615,
  1615,
  1615,
  1615,
  1615,
  1615,
  1615,
  1615,
  1615,
  1615,
  1616,
  1616,
  1616,
  1616,
  1616,
  1616,
  1616,
  1616,
  1616,
  1616,
  1616,
  1616,
  1617,
  1617,
  1617,
  1617,
  1617,
  1617,
  1617,
  1617,
  1617,
  1617,
  1617,
  1617,
  1618,
  1618,
  1618,
  1618,
  1618,
  1618,
  1618,
  1618,
  1618,
  1618,
  1618,
  1618,
  1619,
  1619,
  1619,
  1619,
  1619,
  1619,
  1619,
  1619,
  1619,
  1619,
  1619,
  1619,
  1620,
  1620,
  1620,
  1620,
  1620,
  1620,
  1620,
  1620,
  1620,
  1620,
  1620,
  1620,
  1621,
  1621,
  1621,
  1621,
  1621,
  1621,
  1621,
  1621,
  1621,
  1621,
  1621,
  1621,
  1622,
  1622,
  1622,
  1622,
  1622,
  1622,
  1622,
  1622,
  1622,
  1622,
  1622,
  1622,
  1623,
  1623,
  1623,
  1623,
  1623,
  1623,
  1623,
  1623,
  1623,
  1623,
  1623,
  1623,
  1624,
  1624,
  1624,
  1624,
  1624,
  1624,
  1624,
  1624,
  1624,
  1624,
  1624,
  1624,
  1625,
  1625,
  1625,
  1625,
  1625,
  1625,
  1625,
  1625,
  1625,
  1625,
  1625,
  1625,
  1626,
  1626,
  1626,
  1626,
  1626,
  1626,
  1626,
  1626,
  1626,
  1626,
  1626,
  1626,
  1627,
  1627,
  1627,
  1627,
  1627,
  1627,
  1627,
  1627,
  1627,
  1627,
  1627,
  1627,
  1628,
  1628,
  1628,
  1628,
  1628,
  1628,
  1628,
  1628,
  1628,
  1628,
  1628,
  1628,
  1629,
  1629,
  1629,
  1629,
  1629,
  1629,
  1629,
  1629,
  1629,
  1629,
  1629,
  1629,
  1630,
  1630,
  1630,
  1630,
  1630,
  1630,
  1630,
  1630,
  1630,
  1630,
  1630,
  1630,
  1631,
  1631,
  1631,
  1631,
  1631,
  1631,
  1631,
  1631,
  1631,
  1631,
  1631,
  1631,
  1632,
  1632,
  1632,
  1632,
  1632,
  1632,
  1632,
  1632,
  1632,
  1632,
  1632,
  1632,
  1633,
  1633,
  1633,
  1633,
  1633,
  1633,
  1633,
  1633,
  1633,
  1633,
  1633,
  1633,
  1634,
  1634,
  1634,
  1634,
  1634,
  1634,
  1634,
  1634,
  1634,
  1634,
  1634,
  1634,
  1635,
  1635,
  1635,
  1635,
  1635,
  1635,
  1635,
  1635,
  1635,
  1635,
  1635,
  1635,
  1636,
  1636,
  1636,
  1636,
  1636,
  1636,
  1636,
  1636,
  1636,
  1636,
  1636,
  1636,
  1637,
  1637,
  1637,
  1637,
  1637,
  1637,
  1637,
  1637,
  1637,
  1637,
  1637,
  1637,
  1638,
  1638,
  1638,
  1638,
  1638,
  1638,
  1638,
  1638,
  1638,
  1638,
  1638,
  1638,
  1639,
  1639,
  1639,
  1639,
  1639,
  1639,
  1639,
  1639,
  1639,
  1639,
  1639,
  1639,
  1640,
  1640,
  1640,
  1640,
  1640,
  1640,
  1640,
  1640,
  1640,
  1640,
  1640,
  1640,
  1641,
  1641,
  1641,
  1641,
  1641,
  1641,
  1641,
  1641,
  1641,
  1641,
  1641,
  1641,
  1642,
  1642,
  1642,
  1642,
  1642,
  1642,
  1642,
  1642,
  1642,
  1642,
  1642,
  1642,
  1643,
  1643,
  1643,
  1643,
  1643,
  1643,
  1643,
  1643,
  1643,
  1643,
  1643,
  1643,
  1644,
  1644,
  1644,
  1644,
  1644,
  1644,
  1644,
  1644,
  1644,
  1644,
  1644,
  1644,
  1645,
  1645,
  1645,
  1645,
  1645,
  1645,
  1645,
  1645,
  1645,
  1645,
  1645,
  1645,
  1646,
  1646,
  1646,
  1646,
  1646,
  1646,
  1646,
  1646,
  1646,
  1646,
  1646,
  1646,
  1647,
  1647,
  1647,
  1647,
  1647,
  1647,
  1647,
  1647,
  1647,
  1647,
  1647,
  1647,
  1648,
  1648,
  1648,
  1648,
  1648,
  1648,
  1648,
  1648,
  1648,
  1648,
  1648,
  1648,
  1649,
  1649,
  1649,
  1649,
  1649,
  1649,
  1649,
  1649,
  1649,
  1649,
  1649,
  1649,
  1650,
  1650,
  1650,
  1650,
  1650,
  1650,
  1650,
  1650,
  1650,
  1650,
  1650,
  1650,
  1651,
  1651,
  1651,
  1651,
  1651,
  1651,
  1651,
  1651,
  1651,
  1651,
  1651,
  1651,
  1652,
  1652,
  1652,
  1652,
  1652,
  1652,
  1652,
  1652,
  1652,
  1652,
  1652,
  1652,
  1653,
  1653,
  1653,
  1653,
  1653,
  1653,
  1653,
  1653,
  1653,
  1653,
  1653,
  1653,
  1654,
  1654,
  1654,
  1654,
  1654,
  1654,
  1654,
  1654,
  1654,
  1654,
  1654,
  1654,
  1655,
  1655,
  1655,
  1655,
  1655,
  1655,
  1655,
  1655,
  1655,
  1655,
  1655,
  1655,
  1656,
  1656,
  1656,
  1656,
  1656,
  1656,
  1656,
  1656,
  1656,
  1656,
  1656,
  1656,
  1657,
  1657,
  1657,
  1657,
  1657,
  1657,
  1657,
  1657,
  1657,
  1657,
  1657,
  1657,
  1658,
  1658,
  1658,
  1658,
  1658,
  1658,
  1658,
  1658,
  1658,
  1658,
  1658,
  1658,
  1659,
  1659,
  1659,
  1659,
  1659,
  1659,
  1659,
  1659,
  1659,
  1659,
  1659,
  1659,
  1660,
  1660,
  1660,
  1660,
  1660,
  1660,
  1660,
  1660,
  1660,
  1660,
  1660,
  1660,
  1661,
  1661,
  1661,
  1661,
  1661,
  1661,
  1661,
  1661,
  1661,
  1661,
  1661,
  1661,
  1662,
  1662,
  1662,
  1662,
  1662,
  1662,
  1662,
  1662,
  1662,
  1662,
  1662,
  1662,
  1663,
  1663,
  1663,
  1663,
  1663,
  1663,
  1663,
  1663,
  1663,
  1663,
  1663,
  1663,
  1664,
  1664,
  1664,
  1664,
  1664,
  1664,
  1664,
  1664,
  1664,
  1664,
  1664,
  1664,
  1665,
  1665,
  1665,
  1665,
  1665,
  1665,
  1665,
  1665,
  1665,
  1665,
  1665,
  1665,
  1666,
  1666,
  1666,
  1666,
  1666,
  1666,
  1666,
  1666,
  1666,
  1666,
  1666,
  1666,
  1667,
  1667,
  1667,
  1667,
  1667,
  1667,
  1667,
  1667,
  1667,
  1667,
  1667,
  1667,
  1668,
  1668,
  1668,
  1668,
  1668,
  1668,
  1668,
  1668,
  1668,
  1668,
  1668,
  1668,
  1669,
  1669,
  1669,
  1669,
  1669,
  1669,
  1669,
  1669,
  1669,
  1669,
  1669,
  1669,
  1670,
  1670,
  1670,
  1670,
  1670,
  1670,
  1670,
  1670,
  1670,
  1670,
  1670,
  1670,
  1671,
  1671,
  1671,
  1671,
  1671,
  1671,
  1671,
  1671,
  1671,
  1671,
  1671,
  1671,
  1672,
  1672,
  1672,
  1672,
  1672,
  1672,
  1672,
  1672,
  1672,
  1672,
  1672,
  1672,
  1673,
  1673,
  1673,
  1673,
  1673,
  1673,
  1673,
  1673,
  1673,
  1673,
  1673,
  1673,
  1674,
  1674,
  1674,
  1674,
  1674,
  1674,
  1674,
  1674,
  1674,
  1674,
  1674,
  1674,
  1675,
  1675,
  1675,
  1675,
  1675,
  1675,
  1675,
  1675,
  1675,
  1675,
  1675,
  1675,
  1676,
  1676,
  1676,
  1676,
  1676,
  1676,
  1676,
  1676,
  1676,
  1676,
  1676,
  1676,
  1677,
  1677,
  1677,
  1677,
  1677,
  1677,
  1677,
  1677,
  1677,
  1677,
  1677,
  1677,
  1678,
  1678,
  1678,
  1678,
  1678,
  1678,
  1678,
  1678,
  1678,
  1678,
  1678,
  1678,
  1679,
  1679,
  1679,
  1679,
  1679,
  1679,
  1679,
  1679,
  1679,
  1679,
  1679,
  1679,
  1680,
  1680,
  1680,
  1680,
  1680,
  1680,
  1680,
  1680,
  1680,
  1680,
  1680,
  1680,
  1681,
  1681,
  1681,
  1681,
  1681,
  1681,
  1681,
  1681,
  1681,
  1681,
  1681,
  1681,
  1682,
  1682,
  1682,
  1682,
  1682,
  1682,
  1682,
  1682,
  1682,
  1682,
  1682,
  1682,
  1683,
  1683,
  1683,
  1683,
  1683,
  1683,
  1683,
  1683,
  1683,
  1683,
  1683,
  1683,
  1684,
  1684,
  1684,
  1684,
  1684,
  1684,
  1684,
  1684,
  1684,
  1684,
  1684,
  1684,
  1685,
  1685,
  1685,
  1685,
  1685,
  1685,
  1685,
  1685,
  1685,
  1685,
  1685,
  1685,
  1686,
  1686,
  1686,
  1686,
  1686,
  1686,
  1686,
  1686,
  1686,
  1686,
  1686,
  1686,
  1687,
  1687,
  1687,
  1687,
  1687,
  1687,
  1687,
  1687,
  1687,
  1687,
  1687,
  1687,
  1688,
  1688,
  1688,
  1688,
  1688,
  1688,
  1688,
  1688,
  1688,
  1688,
  1688,
  1688,
  1689,
  1689,
  1689,
  1689,
  1689,
  1689,
  1689,
  1689,
  1689,
  1689,
  1689,
  1689,
  1690,
  1690,
  1690,
  1690,
  1690,
  1690,
  1690,
  1690,
  1690,
  1690,
  1690,
  1690,
  1691,
  1691,
  1691,
  1691,
  1691,
  1691,
  1691,
  1691,
  1691,
  1691,
  1691,
  1691,
  1692,
  1692,
  1692,
  1692,
  1692,
  1692,
  1692,
  1692,
  1692,
  1692,
  1692,
  1692,
  1693,
  1693,
  1693,
  1693,
  1693,
  1693,
  1693,
  1693,
  1693,
  1693,
  1693,
  1693,
  1694,
  1694,
  1694,
  1694,
  1694,
  1694,
  1694,
  1694,
  1694,
  1694,
  1694,
  1694,
  1695,
  1695,
  1695,
  1695,
  1695,
  1695,
  1695,
  1695,
  1695,
  1695,
  1695,
  1695,
  1696,
  1696,
  1696,
  1696,
  1696,
  1696,
  1696,
  1696,
  1696,
  1696,
  1696,
  1696,
  1697,
  1697,
  1697,
  1697,
  1697,
  1697,
  1697,
  1697,
  1697,
  1697,
  1697,
  1697,
  1698,
  1698,
  1698,
  1698,
  1698,
  1698,
  1698,
  1698,
  1698,
  1698,
  1698,
  1698,
  1699,
  1699,
  1699,
  1699,
  1699,
  1699,
  1699,
  1699,
  1699,
  1699,
  1699,
  1699,
  1700,
  1700,
  1700,
  1700,
  1700,
  1700,
  1700,
  1700,
  1700,
  1700,
  1700,
  1700,
  1701,
  1701,
  1701,
  1701,
  1701,
  1701,
  1701,
  1701,
  1701,
  1701,
  1701,
  1701,
  1702,
  1702,
  1702,
  1702,
  1702,
  1702,
  1702,
  1702,
  1702,
  1702,
  1702,
  1702,
  1703,
  1703,
  1703,
  1703,
  1703,
  1703,
  1703,
  1703,
  1703,
  1703,
  1703,
  1703,
  1704,
  1704,
  1704,
  1704,
  1704,
  1704,
  1704,
  1704,
  1704,
  1704,
  1704,
  1704,
  1705,
  1705,
  1705,
  1705,
  1705,
  1705,
  1705,
  1705,
  1705,
  1705,
  1705,
  1705,
  1706,
  1706,
  1706,
  1706,
  1706,
  1706,
  1706,
  1706,
  1706,
  1706,
  1706,
  1706,
  1707,
  1707,
  1707,
  1707,
  1707,
  1707,
  1707,
  1707,
  1707,
  1707,
  1707,
  1707,
  1708,
  1708,
  1708,
  1708,
  1708,
  1708,
  1708,
  1708,
  1708,
  1708,
  1708,
  1708,
  1709,
  1709,
  1709,
  1709,
  1709,
  1709,
  1709,
  1709,
  1709,
  1709,
  1709,
  1709,
  1710,
  1710,
  1710,
  1710,
  1710,
  1710,
  1710,
  1710,
  1710,
  1710,
  1710,
  1710,
  1711,
  1711,
  1711,
  1711,
  1711,
  1711,
  1711,
  1711,
  1711,
  1711,
  1711,
  1711,
  1712,
  1712,
  1712,
  1712,
  1712,
  1712,
  1712,
  1712,
  1712,
  1712,
  1712,
  1712,
  1713,
  1713,
  1713,
  1713,
  1713,
  1713,
  1713,
  1713,
  1713,
  1713,
  1713,
  1713,
  1714,
  1714,
  1714,
  1714,
  1714,
  1714,
  1714,
  1714,
  1714,
  1714,
  1714,
  1714,
  1715,
  1715,
  1715,
  1715,
  1715,
  1715,
  1715,
  1715,
  1715,
  1715,
  1715,
  1715,
  1716,
  1716,
  1716,
  1716,
  1716,
  1716,
  1716,
  1716,
  1716,
  1716,
  1716,
  1716,
  1717,
  1717,
  1717,
  1717,
  1717,
  1717,
  1717,
  1717,
  1717,
  1717,
  1717,
  1717,
  1718,
  1718,
  1718,
  1718,
  1718,
  1718,
  1718,
  1718,
  1718,
  1718,
  1718,
  1718,
  1719,
  1719,
  1719,
  1719,
  1719,
  1719,
  1719,
  1719,
  1719,
  1719,
  1719,
  1719,
  1720,
  1720,
  1720,
  1720,
  1720,
  1720,
  1720,
  1720,
  1720,
  1720,
  1720,
  1720,
  1721,
  1721,
  1721,
  1721,
  1721,
  1721,
  1721,
  1721,
  1721,
  1721,
  1721,
  1721,
  1722,
  1722,
  1722,
  1722,
  1722,
  1722,
  1722,
  1722,
  1722,
  1722,
  1722,
  1722,
  1723,
  1723,
  1723,
  1723,
  1723,
  1723,
  1723,
  1723,
  1723,
  1723,
  1723,
  1723,
  1724,
  1724,
  1724,
  1724,
  1724,
  1724,
  1724,
  1724,
  1724,
  1724,
  1724,
  1724,
  1725,
  1725,
  1725,
  1725,
  1725,
  1725,
  1725,
  1725,
  1725,
  1725,
  1725,
  1725,
  1726,
  1726,
  1726,
  1726,
  1726,
  1726,
  1726,
  1726,
  1726,
  1726,
  1726,
  1726,
  1727,
  1727,
  1727,
  1727,
  1727,
  1727,
  1727,
  1727,
  1727,
  1727,
  1727,
  1727,
  1728,
  1728,
  1728,
  1728,
  1728,
  1728,
  1728,
  1728,
  1728,
  1728,
  1728,
  1728,
  1729,
  1729,
  1729,
  1729,
  1729,
  1729,
  1729,
  1729,
  1729,
  1729,
  1729,
  1729,
  1730,
  1730,
  1730,
  1730,
  1730,
  1730,
  1730,
  1730,
  1730,
  1730,
  1730,
  1730,
  1731,
  1731,
  1731,
  1731,
  1731,
  1731,
  1731,
  1731,
  1731,
  1731,
  1731,
  1731,
  1732,
  1732,
  1732,
  1732,
  1732,
  1732,
  1732,
  1732,
  1732,
  1732,
  1732,
  1732,
  1733,
  1733,
  1733,
  1733,
  1733,
  1733,
  1733,
  1733,
  1733,
  1733,
  1733,
  1733,
  1734,
  1734,
  1734,
  1734,
  1734,
  1734,
  1734,
  1734,
  1734,
  1734,
  1734,
  1734,
  1735,
  1735,
  1735,
  1735,
  1735,
  1735,
  1735,
  1735,
  1735,
  1735,
  1735,
  1735,
  1736,
  1736,
  1736,
  1736,
  1736,
  1736,
  1736,
  1736,
  1736,
  1736,
  1736,
  1736,
  1737,
  1737,
  1737,
  1737,
  1737,
  1737,
  1737,
  1737,
  1737,
  1737,
  1737,
  1737,
  1738,
  1738,
  1738,
  1738,
  1738,
  1738,
  1738,
  1738,
  1738,
  1738,
  1738,
  1738,
  1739,
  1739,
  1739,
  1739,
  1739,
  1739,
  1739,
  1739,
  1739,
  1739,
  1739,
  1739,
  1740,
  1740,
  1740,
  1740,
  1740,
  1740,
  1740,
  1740,
  1740,
  1740,
  1740,
  1740,
  1741,
  1741,
  1741,
  1741,
  1741,
  1741,
  1741,
  1741,
  1741,
  1741,
  1741,
  1741,
  1742,
  1742,
  1742,
  1742,
  1742,
  1742,
  1742,
  1742,
  1742,
  1742,
  1742,
  1742,
  1743,
  1743,
  1743,
  1743,
  1743,
  1743,
  1743,
  1743,
  1743,
  1743,
  1743,
  1743,
  1744,
  1744,
  1744,
  1744,
  1744,
  1744,
  1744,
  1744,
  1744,
  1744,
  1744,
  1744,
  1745,
  1745,
  1745,
  1745,
  1745,
  1745,
  1745,
  1745,
  1745,
  1745,
  1745,
  1745,
  1746,
  1746,
  1746,
  1746,
  1746,
  1746,
  1746,
  1746,
  1746,
  1746,
  1746,
  1746,
  1747,
  1747,
  1747,
  1747,
  1747,
  1747,
  1747,
  1747,
  1747,
  1747,
  1747,
  1747,
  1748,
  1748,
  1748,
  1748,
  1748,
  1748,
  1748,
  1748,
  1748,
  1748,
  1748,
  1748,
  1749,
  1749,
  1749,
  1749,
  1749,
  1749,
  1749,
  1749,
  1749,
  1749,
  1749,
  1749,
  1750,
  1750,
  1750,
  1750,
  1750,
  1750,
  1750,
  1750,
  1750,
  1750,
  1750,
  1750,
  1751,
  1751,
  1751,
  1751,
  1751,
  1751,
  1751,
  1751,
  1751,
  1751,
  1751,
  1751,
  1752,
  1752,
  1752,
  1752,
  1752,
  1752,
  1752,
  1752,
  1752,
  1752,
  1752,
  1752,
  1753,
  1753,
  1753,
  1753,
  1753,
  1753,
  1753,
  1753,
  1753,
  1753,
  1753,
  1753,
  1754,
  1754,
  1754,
  1754,
  1754,
  1754,
  1754,
  1754,
  1754,
  1754,
  1754,
  1754,
  1755,
  1755,
  1755,
  1755,
  1755,
  1755,
  1755,
  1755,
  1755,
  1755,
  1755,
  1755,
  1756,
  1756,
  1756,
  1756,
  1756,
  1756,
  1756,
  1756,
  1756,
  1756,
  1756,
  1756,
  1757,
  1757,
  1757,
  1757,
  1757,
  1757,
  1757,
  1757,
  1757,
  1757,
  1757,
  1757,
  1758,
  1758,
  1758,
  1758,
  1758,
  1758,
  1758,
  1758,
  1758,
  1758,
  1758,
  1758,
  1759,
  1759,
  1759,
  1759,
  1759,
  1759,
  1759,
  1759,
  1759,
  1759,
  1759,
  1759,
  1760,
  1760,
  1760,
  1760,
  1760,
  1760,
  1760,
  1760,
  1760,
  1760,
  1760,
  1760,
  1761,
  1761,
  1761,
  1761,
  1761,
  1761,
  1761,
  1761,
  1761,
  1761,
  1761,
  1761,
  1762,
  1762,
  1762,
  1762,
  1762,
  1762,
  1762,
  1762,
  1762,
  1762,
  1762,
  1762,
  1763,
  1763,
  1763,
  1763,
  1763,
  1763,
  1763,
  1763,
  1763,
  1763,
  1763,
  1763,
  1764,
  1764,
  1764,
  1764,
  1764,
  1764,
  1764,
  1764,
  1764,
  1764,
  1764,
  1764,
  1765,
  1765,
  1765,
  1765,
  1765,
  1765,
  1765,
  1765,
  1765,
  1765,
  1765,
  1765,
  1766,
  1766,
  1766,
  1766,
  1766,
  1766,
  1766,
  1766,
  1766,
  1766,
  1766,
  1766,
  1767,
  1767,
  1767,
  1767,
  1767,
  1767,
  1767,
  1767,
  1767,
  1767,
  1767,
  1767,
  1768,
  1768,
  1768,
  1768,
  1768,
  1768,
  1768,
  1768,
  1768,
  1768,
  1768,
  1768,
  1769,
  1769,
  1769,
  1769,
  1769,
  1769,
  1769,
  1769,
  1769,
  1769,
  1769,
  1769,
  1770,
  1770,
  1770,
  1770,
  1770,
  1770,
  1770,
  1770,
  1770,
  1770,
  1770,
  1770,
  314,
  313,
  312,
  311,
  309,
  308,
  307,
  306,
  305,
  304,
  302,
  297,
  294,
  293,
  292,
  291,
  290,
  289,
  288,
  286,
  285,
  284,
  283,
  282,
  281,
  280,
  279,
  278,
  276,
  275,
  274,
  272,
  271,
  269,
  268,
  267,
  266,
  265,
  263,
  261,
  260,
  255,
  254,
  249,
  248,
  247,
  246,
  245,
  244,
  243,
  242,
  241,
  240,
  236,
  235,
  232,
  222,
  217,
  214,
  213,
  211,
  197,
  196,
  195,
  194,
  193,
  192,
  191,
  189,
  187,
  186,
  185,
  184,
  183,
  181,
  180,
  179,
  177,
  176,
  175,
  174,
  173,
  171,
  169,
  168,
  167,
  166,
  165,
  163,
  162,
  157,
  154,
  150,
  133,
  132,
  131,
  130,
  129,
  128,
  127,
  126,
  125,
  123,
  112,
  110,
  108,
  107,
  105,
  104,
  102,
  101,
  98,
  86,
  83,
  82,
  81,
  75,
  68,
  67,
  66,
  63,
  62,
  60,
  59,
  56,
  51,
  48,
  47,
  46,
  42,
  35,
  26,
  22,
  21,
  18,
  17,
  2,
  1,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  1350,
  0
}; // weak
int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes) = &realloc; // weak
int (__cdecl *xmlMemStrdup)(void *Src) = &xmlStrdup; // weak
char *xmlParserVersion = "20800"; // weak
int xmlBufferAllocScheme = 1; // weak
int dword_4A4B80 = 1; // weak
int xmlDefaultBufferSize = 4096; // weak
int dword_4A4B88 = 4096; // weak
int xmlGetWarningsDefaultValue = 1; // weak
int dword_4A4B90 = 1; // weak
int xmlKeepBlanksDefaultValue = 1; // weak
int dword_4A4B98 = 1; // weak
int (*xmlGenericError)(_DWORD, const char *, ...) = &sub_431949; // weak
int (__cdecl *off_4A4BA0)(int, char *Format, char ArgList) = &sub_431949; // weak
int xmlIndentTreeOutput = 1; // weak
int dword_4A4BA8 = 1; // weak
void *xmlTreeIndentString = &asc_487260; // idb
char *off_4A4BB0 = "  "; // weak
int dword_4A4BB4 = 2; // weak
int (__cdecl *xmlDefaultSAXHandler)(int, int, int, int) = &xmlSAX2InternalSubset; // weak
int (*xmlDefaultSAXLocator)() = &xmlSAX2GetPublicId; // weak
char *off_4A4C38[57] =
{
  "Unknown IO error",
  "Permission denied",
  "Resource temporarily unavailable",
  "Bad file descriptor",
  "Bad message",
  "Resource busy",
  "Operation canceled",
  "No child processes",
  "Resource deadlock avoided",
  "Domain error",
  "File exists",
  "Bad address",
  "File too large",
  "Operation in progress",
  "Interrupted function call",
  "Invalid argument",
  "Input/output error",
  "Is a directory",
  "Too many open files",
  "Too many links",
  "Inappropriate message buffer length",
  "Filename too long",
  "Too many open files in system",
  "No such device",
  "No such file or directory",
  "Exec format error",
  "No locks available",
  "Not enough space",
  "No space left on device",
  "Function not implemented",
  "Not a directory",
  "Directory not empty",
  "Not supported",
  "Inappropriate I/O control operation",
  "No such device or address",
  "Operation not permitted",
  "Broken pipe",
  "Result too large",
  "Read-only file system",
  "Invalid seek",
  "No such process",
  "Operation timed out",
  "Improper link",
  "Attempt to load network entity %s",
  "encoder error",
  "flush error",
  "write error",
  "no input",
  "buffer full",
  "loading error",
  "not a socket",
  "already connected",
  "connection refused",
  "unreachable network",
  "adddress in use",
  "already in use",
  "unknown address familly"
}; // weak
char *off_4A4CE4[14] =
{
  "Attempt to load network entity %s",
  "encoder error",
  "flush error",
  "write error",
  "no input",
  "buffer full",
  "loading error",
  "not a socket",
  "already connected",
  "connection refused",
  "unreachable network",
  "adddress in use",
  "already in use",
  "unknown address familly"
}; // weak
char *off_4A4CE8[13] =
{
  "encoder error",
  "flush error",
  "write error",
  "no input",
  "buffer full",
  "loading error",
  "not a socket",
  "already connected",
  "connection refused",
  "unreachable network",
  "adddress in use",
  "already in use",
  "unknown address familly"
}; // weak
char *off_4A4CEC[12] =
{
  "flush error",
  "write error",
  "no input",
  "buffer full",
  "loading error",
  "not a socket",
  "already connected",
  "connection refused",
  "unreachable network",
  "adddress in use",
  "already in use",
  "unknown address familly"
}; // weak
char *off_4A4CF0[11] =
{
  "write error",
  "no input",
  "buffer full",
  "loading error",
  "not a socket",
  "already connected",
  "connection refused",
  "unreachable network",
  "adddress in use",
  "already in use",
  "unknown address familly"
}; // weak
char *off_4A4CF4[10] =
{
  "no input",
  "buffer full",
  "loading error",
  "not a socket",
  "already connected",
  "connection refused",
  "unreachable network",
  "adddress in use",
  "already in use",
  "unknown address familly"
}; // weak
char *off_4A4CF8[9] =
{
  "buffer full",
  "loading error",
  "not a socket",
  "already connected",
  "connection refused",
  "unreachable network",
  "adddress in use",
  "already in use",
  "unknown address familly"
}; // weak
int (__cdecl *off_4A4D1C)(_DWORD, _DWORD) = &j___stat32; // weak
int (__cdecl *off_4A4D20)(char *FileName, int) = &sub_43BC8E; // weak
int (__cdecl *off_4A4D24)(char ArgList, int, int) = &sub_43D119; // weak
int dword_4A4D28 = 1; // weak
int xmlParserMaxDepth = 256; // weak
_UNKNOWN unk_4A4D30; // weak
char *off_4A4D7C[2] = { "xml-stylesheet", "xml-model" }; // weak
char *off_4A4D80 = "xml-model"; // weak
_UNKNOWN unk_4A4D88; // weak
_UNKNOWN unk_4A4DD8; // weak
int dword_4A4E24 = 1; // weak
_UNKNOWN unk_4A4E28; // weak
_UNKNOWN unk_4A4E78; // weak
int dword_4A4EC4 = 63; // weak
char aTcp[4] = "tcp"; // idb
_UNKNOWN unk_4A4ECC; // weak
_UNKNOWN unk_4A4F08; // weak
_UNKNOWN unk_4A4F1C; // weak
_UNKNOWN unk_4A4F34; // weak
int dword_4A4F44 = 3552306; // weak
_UNKNOWN unk_4A4F48; // weak
_UNKNOWN unk_4A4F88; // weak
int (__cdecl *off_4A4FE4)(_DWORD) = &malloc; // weak
int (__cdecl *off_4A4FE8)(_DWORD, _DWORD) = &realloc; // weak
int (__cdecl *off_4A4FEC)(_DWORD) = &free; // weak
_UNKNOWN unk_4A4FF0; // weak
__int16 word_4A5288 = 4; // weak
int dword_4A52F4 = 40; // weak
int dword_4A52F8 = 3225; // weak
int dword_4A52FC = 600; // weak
int dword_4A5300 = 1; // weak
_UNKNOWN unk_4A5304; // weak
char byte_4A5307[13] =
{
  '\0',
  '\x1F',
  '\x1D',
  '\x1F',
  '\x1E',
  '\x1F',
  '\x1E',
  '\x1F',
  '\x1F',
  '\x1E',
  '\x1F',
  '\x1E',
  '\x1F'
}; // weak
void *off_4A5318 = &unk_475F68; // weak
_UNKNOWN unk_4A58E8; // weak
void *off_4A58EC = &unk_475878; // weak
void *off_4A5968 = &unk_475F4C; // weak
char byte_4A5B7C[1160] =
{
  '\r',
  'q',
  '\xE3',
  '\xE6',
  'M',
  '\x01',
  '\xA0',
  '\xA3',
  'E',
  '\x9D',
  '7',
  'E',
  '\xF1',
  '\x97',
  '\xF2',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  
}; // weak
int dword_4A67EC; // weak
int dword_4A6844; // weak
int dword_4A6928; // weak
int dword_4A6934; // weak
int dword_4A6940; // weak
int dword_4A6944; // weak
int dword_4A6A54; // weak
int dword_4A6A58; // weak
int dword_4A6A5C; // weak
int dword_4A6A60; // weak
int dword_4A6A64; // weak
int dword_4A6A70; // weak
int dword_4A6A80; // weak
int dword_4A6A84; // weak
CHAR pszPath[512]; // weak
CHAR pszBuf[512]; // idb
char byte_4A6E88[]; // weak
char byte_4A6E89[504]; // weak
char byte_4A7081[]; // weak
char byte_4A7082[]; // weak
char byte_4A7083[]; // weak
char byte_4A7084[]; // weak
char byte_4A7085[]; // weak
char byte_4A7086[]; // weak
char byte_4A7087[]; // weak
char byte_4A7088; // idb
char byte_4A7089[]; // weak
char byte_4A708A[509]; // idb
char byte_4A7287; // weak
int dword_4A7288; // weak
char *dword_4A728C; // idb
int dword_4A7290; // weak
_UNKNOWN unk_4A7294; // weak
char byte_4A7297[]; // weak
char byte_4A7298[512]; // weak
char byte_4A7498[511]; // idb
char byte_4A7697[]; // weak
char byte_4A7698[800]; // weak
int dword_4A79B8; // weak
int dword_4A79BC; // weak
int dword_4A79C0; // weak
int dword_4A79C4; // weak
char *dword_4A79C8; // idb
int dword_4A79CC; // weak
int dword_4A79D0[]; // weak
int dword_4A79D4[]; // weak
int dword_4A79D8[]; // weak
int dword_4A79DC[57]; // weak
int dword_4A7AC0[]; // weak
int dword_4A7AC4[]; // weak
int dword_4A7AC8[]; // weak
int dword_4A7ACC[57]; // weak
int dword_4A7BB0; // weak
int (*dword_4A7BB4)(void); // weak
int (*dword_4A7BB8)(void); // weak
int dword_4A7BBC; // weak
int dword_4A7BC0; // weak
int dword_4A7BC4; // weak
int dword_4A7BC8; // weak
int (__cdecl *dword_4A7BCC)(_DWORD, _DWORD); // weak
int dword_4A7BD0; // weak
int dword_4A7BD4; // weak
int dword_4A7BD8; // weak
int dword_4A7BDC; // weak
int dword_4A7BE0; // weak
int dword_4A7BE4; // weak
int dword_4A7BE8; // weak
int dword_4A7BEC; // weak
_UNKNOWN unk_4A7BF0; // weak
int dword_4A7CC8[]; // weak
int dword_4A7CCC[255]; // weak
int dword_4A80C8; // weak
int dword_4A80CC; // weak
int dword_4A80D0; // weak
int dword_4A80D4; // weak
int dword_4A80D8; // weak
int dword_4A80DC; // weak
char *dword_4A80E0; // idb
int dword_4A80E4; // weak
void *DstBuf; // idb
int dword_4A80EC; // weak
int dword_4A80F0; // weak
int dword_4A80F4; // weak
int dword_4A80F8; // weak
void *dword_4A80FC; // idb
char byte_4A8101[3]; // idb
FILE *Stream; // idb
int dword_4A8108[]; // weak
_UNKNOWN unk_4A810C; // weak
int dword_4A8118[]; // weak
int dword_4A8120[]; // weak
int dword_4A8124[]; // weak
int dword_4A8130[]; // weak
int dword_4A8134[]; // weak
int dword_4A8148[592]; // weak
int dword_4A8A88[]; // weak
_UNKNOWN unk_4A8A8C; // weak
int dword_4A8A90[]; // weak
int dword_4A8ADC[]; // weak
int dword_4A8AE0[]; // weak
int dword_4A8AE4[777]; // weak
int dword_4A9708[]; // weak
int dword_4A9710[]; // weak
int dword_4A9714[]; // weak
int dword_4A9718[316]; // weak
int dword_4A9C08; // weak
int dword_4A9C0C; // weak
int dword_4A9C10; // weak
int dword_4A9C14; // weak
int dword_4A9C18; // weak
int dword_4A9C1C; // weak
int dword_4A9C20; // weak
int dword_4A9C24; // weak
void *dword_4A9C28; // idb
int dword_4A9C2C; // weak
int dword_4A9C30; // weak
void *dword_4A9C34; // idb
int dword_4A9C38; // weak
int dword_4A9C3C; // weak
int dword_4A9C40; // weak
int dword_4A9C44; // weak
int dword_4A9C48; // weak
int dword_4A9C4C; // weak
int dword_4A9C50; // weak
int dword_4A9C54; // weak
int dword_4A9C58; // weak
int dword_4A9C5C; // weak
int dword_4A9C60; // weak
int dword_4A9C64; // weak
int dword_4A9C68; // weak
char dword_4A9C6C[]; // idb
char dword_4A9C70[]; // idb
int dword_4A9C74; // weak
_UNKNOWN oldXMLWDcompatibility; // weak
int xmlParserDebugEntities; // weak
int dword_4A9C80; // weak
int xmlDoValidityCheckingDefaultValue; // weak
int dword_4A9C88; // weak
int xmlLoadExtDtdDefaultValue; // weak
int dword_4A9C90; // weak
int xmlPedanticParserDefaultValue; // weak
int dword_4A9C98; // weak
int xmlLineNumbersDefaultValue; // weak
int dword_4A9CA0; // weak
int xmlSubstituteEntitiesDefaultValue; // weak
int dword_4A9CA8; // weak
int (__cdecl *xmlRegisterNodeDefaultValue)(_DWORD); // weak
int dword_4A9CB0; // weak
int (__cdecl *xmlDeregisterNodeDefaultValue)(_DWORD); // weak
int dword_4A9CB8; // weak
int (__cdecl *xmlParserInputBufferCreateFilenameValue)(_DWORD, _DWORD); // weak
int dword_4A9CC0; // weak
int (*xmlOutputBufferCreateFilenameValue)(void); // weak
int dword_4A9CC8; // weak
int xmlStructuredError; // weak
int dword_4A9CD0; // weak
FILE *xmlGenericErrorContext; // idb
int dword_4A9CD8; // weak
int xmlStructuredErrorContext; // weak
int dword_4A9CE0; // weak
int xmlSaveNoEmptyTags; // weak
int dword_4A9CE8; // weak
int dword_4A9CF0; // weak
int dword_4A9CF4; // weak
void *dword_4A9CF8; // idb
int dword_4A9CFC; // weak
int dword_4A9D00; // weak
int dword_4A9D04; // weak
int dword_4A9D08; // weak
char *dword_4A9D0C; // idb
void *Block; // idb
int dword_4A9D14; // weak
int dword_4A9D18; // weak
void *dword_4A9D1C; // idb
void *dword_4A9D20; // idb
size_t NumOfElements; // idb
int dword_4A9D28; // weak
int dword_4A9D2C; // weak
int dword_4A9D30; // weak
char *dword_4A9D34; // idb
int dword_4A9D38; // weak
int dword_4A9D3C; // weak
int dword_4AAEA4; // weak
__time32_t dword_4AAEA8; // idb
int dword_4AAEAC; // weak
int (__cdecl *zend_printf)(_DWORD); // weak
int zend_ticks_function; // weak
int (*zend_unblock_interruptions)(void); // weak
int (__cdecl *zend_error_cb)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int zval_used_for_init; // weak
int dword_4AAED4; // weak
int dword_4AAED8; // weak
int dword_4AAEDC; // weak
int (__cdecl *zend_fopen)(_DWORD, _DWORD); // weak
int (__cdecl *zend_write)(_DWORD, _DWORD); // weak
char zend_standard_class_def; // weak
int dword_4AAF04; // weak
int dword_4AAF08; // weak
int dword_4AAF0C; // weak
int dword_4AAF10; // weak
_UNKNOWN unk_4AAF18; // weak
_UNKNOWN unk_4AAF40; // weak
int dword_4AAF6C; // weak
int dword_4AAF70; // weak
int dword_4AAF74; // weak
int (__thiscall *zend_block_interruptions)(_DWORD); // weak
FILE *language_scanner_globals; // idb
int dword_4AAF84; // weak
size_t dword_4AAF88; // idb
char *String; // idb
int dword_4AAF90; // weak
int dword_4AAF94; // weak
int dword_4AAF98; // weak
int dword_4AAF9C; // weak
char byte_4AAFA0; // weak
int dword_4AAFA4; // weak
int dword_4AAFA8; // weak
int dword_4AAFAC; // weak
int dword_4AAFB0; // weak
int dword_4AAFB4; // weak
int dword_4AAFB8; // weak
int (__cdecl *zend_compile_file)(_DWORD, _DWORD); // weak
int executor_globals; // weak
int dword_4AAFD8; // weak
int dword_4AB098; // weak
_UNKNOWN unk_4AB09C; // weak
_UNKNOWN unk_4AB0C4; // weak
jmp_buf Buf; // idb
int dword_4AB12C; // weak
int dword_4AB138; // weak
int dword_4AB148; // weak
char byte_4AB150; // weak
char byte_4AB151; // weak
_DWORD dword_4AB158[31]; // weak
int dword_4AB1D4; // weak
_DWORD compiler_globals[3]; // weak
_DWORD dword_4AB24C[3]; // weak
_DWORD dword_4AB258[3]; // weak
_DWORD dword_4AB264[3]; // weak
_DWORD dword_4AB270[3]; // weak
char byte_4AB27C; // weak
void *Src; // idb
size_t Size; // idb
int dword_4AB288; // weak
int dword_4AB28C; // weak
char byte_4AB290; // weak
_UNKNOWN unk_4AB294; // weak
_UNKNOWN unk_4AB2BC; // weak
int dword_4AB2E8; // weak
int dword_4AB2EC; // weak
int dword_4AB2F0; // weak
int dword_4AB2F4; // weak
void *dword_4AB2F8; // idb
size_t dword_4AB2FC; // idb
int dword_4AB308; // weak
_UNKNOWN unk_4AB324; // weak
int dword_4AB328; // weak
_DWORD dword_4AB340[3]; // weak
_DWORD dword_4AB34C[3]; // weak
int dword_4AB358; // weak
int dword_4AB35C; // weak
char dword_4AB360[]; // idb
int dword_4AB364; // weak
int dword_4AB368; // weak
int dword_4AB36C; // weak
int dword_4AB370; // idb
int dword_4AB374; // idb
_UNKNOWN unk_4AB378; // weak
int dword_4AB3A0; // idb
char byte_4AB3A4; // weak
char byte_4AB3A5; // weak
char byte_4AB3A6; // weak
char byte_4AB3A7; // weak
int dword_4AB3A8; // weak
int dword_4AB3AC; // weak
int dword_4AB3B0; // weak
int dword_4AB3B4; // weak
char byte_4AB3B8; // weak
char byte_4AB3B9; // weak
char byte_4AB3BA; // weak
_UNKNOWN unk_4AB3BC; // weak
int dword_4AB3DC; // weak
char byte_4AB3E0; // weak
LPVOID alloc_globals; // idb
int dword_4AB404[256]; // weak
_UNKNOWN unk_4AB804; // weak
int dword_4AE004[]; // weak
_UNKNOWN unk_4AE008; // weak
HANDLE dword_4AE040; // idb
_DWORD xmlLastError; // weak
int dword_4AE064; // weak
int dword_4AE094; // weak
char *ArgList; // idb
_DWORD ini_scanner_globals[16]; // weak
_UNKNOWN zend_extensions; // weak
int (__cdecl *zend_execute)(_DWORD); // weak
int dword_4AE100; // weak
__time32_t Time; // idb
int dword_4AE124; // weak
int dword_4AE128; // weak
int dword_4AE12C; // weak
int dword_4AE130; // weak
int dword_4AE134; // weak
int dword_4AE138; // weak
int dword_4AE13C; // weak
_UNKNOWN unk_4AE148; // weak
char name[64]; // idb
char Buffer[192]; // idb
int dword_4AE288; // weak
int dword_4AE290; // weak
int dword_4AE294; // weak
int dword_4AE298; // weak
int dword_4AE29C; // weak
int dword_4AE2A0; // weak
int dword_4AE2A4; // weak
char Destination[56]; // idb
int dword_4AE2E0; // weak
int dword_4AE2E4; // weak
int dword_4AE2E8; // weak
int dword_4AE2EC; // weak
int dword_4AE2F0; // weak
int dword_4AE2F4; // weak
int dword_4AE2F8; // weak
int dword_4AE2FC; // weak


//----- (00401000) --------------------------------------------------------
int __usercall sub_401000@<eax>(int *a1@<eax>, _DWORD *a2)
{
  int v2; // ebx
  int v3; // esi
  int v4; // edi
  int v5; // ecx
  int v6; // edx
  int v7; // esi
  int v8; // edi
  int v9; // ebx
  int v10; // ecx
  int v11; // edx
  int v12; // esi
  int v13; // edi
  int v14; // ebx
  int v15; // ebp
  int v16; // edx
  int v17; // esi
  int v18; // edi
  int v19; // ebx
  int v20; // ecx
  int v21; // ebp
  int v22; // esi
  int v23; // edi
  int v24; // ecx
  int v25; // ebp
  int v26; // esi
  int v27; // edi
  int v28; // ecx
  int v29; // eax
  int v30; // edx
  int v31; // edi
  int v32; // ecx
  int v33; // eax
  int v34; // edx
  int v35; // edi
  int v36; // ecx
  int v37; // eax
  int v38; // edx
  int v39; // edi
  int v40; // ecx
  int v41; // eax
  int v42; // edx
  int v43; // esi
  int v44; // edi
  int v45; // eax
  int v46; // ecx
  int v47; // esi
  int v48; // edi
  int v49; // eax
  int v50; // edx
  int v51; // esi
  int v52; // edi
  int v53; // edx
  int result; // eax
  int v55; // [esp+14h] [ebp-40h]
  int v56; // [esp+18h] [ebp-3Ch]
  int v57; // [esp+1Ch] [ebp-38h]
  int v58; // [esp+20h] [ebp-34h]
  int v59; // [esp+24h] [ebp-30h]
  int v60; // [esp+28h] [ebp-2Ch]
  int v61; // [esp+2Ch] [ebp-28h]
  int v62; // [esp+30h] [ebp-24h]
  int v63; // [esp+34h] [ebp-20h]
  int v64; // [esp+3Ch] [ebp-18h]
  int v65; // [esp+40h] [ebp-14h]
  int v66; // [esp+44h] [ebp-10h]
  int v67; // [esp+48h] [ebp-Ch]
  int v68; // [esp+4Ch] [ebp-8h]
  int v69; // [esp+50h] [ebp-4h]

  v2 = a2[1];
  v3 = a2[3];
  v4 = a2[2];
  v55 = *a1;
  v5 = __ROL4__(*a2 + *a1 + (v2 & v4 | v3 & ~v2), 3);
  v57 = a1[1];
  v6 = __ROL4__(v3 + v57 + (v5 & v2 | v4 & ~v5), 7);
  v56 = a1[2];
  v7 = __ROL4__(v4 + v56 + (v5 & v6 | v2 & ~v6), 11);
  v58 = a1[3];
  v8 = __ROR4__(v2 + v58 + (v7 & v6 | v5 & ~v7), 13);
  v9 = __ROL4__(v5 + a1[4] + (v8 & v7 | v6 & ~v8), 3);
  v60 = a1[4];
  v10 = __ROL4__(v6 + a1[5] + (v9 & v8 | v7 & ~v9), 7);
  v65 = a1[5];
  v11 = __ROL4__(v7 + a1[6] + (v9 & v10 | v8 & ~v10), 11);
  v63 = a1[6];
  v12 = __ROR4__(v8 + a1[7] + (v11 & v10 | v9 & ~v11), 13);
  v68 = a1[7];
  v13 = __ROL4__(v9 + a1[8] + (v12 & v11 | v10 & ~v12), 3);
  v59 = a1[8];
  v14 = __ROL4__(v10 + a1[9] + (v13 & v12 | v11 & ~v13), 7);
  v64 = a1[9];
  v15 = __ROL4__(v11 + a1[10] + (v13 & v14 | v12 & ~v14), 11);
  v62 = a1[10];
  v16 = __ROR4__(v12 + a1[11] + (v15 & v14 | v13 & ~v15), 13);
  v67 = a1[11];
  v17 = __ROL4__(v13 + a1[12] + (v16 & v15 | v14 & ~v16), 3);
  v61 = a1[12];
  v66 = a1[13];
  v18 = __ROL4__(v14 + v66 + (v17 & v16 | v15 & ~v17), 7);
  v19 = a1[14];
  v20 = __ROL4__(v15 + v19 + (v17 & v18 | v16 & ~v18), 11);
  v69 = a1[15];
  v21 = __ROR4__(v16 + v69 + (v20 & v18 | v17 & ~v20), 13);
  v22 = __ROL4__(*a1 + (v21 & v20 | v18 & (v21 | v20)) + v17 + 1518500249, 3);
  v23 = __ROL4__(v60 + (v22 & v21 | v20 & (v22 | v21)) + v18 + 1518500249, 5);
  v24 = __ROL4__(v59 + (v22 & v21 | v23 & (v22 | v21)) + v20 + 1518500249, 9);
  v25 = __ROL4__(v61 + (v22 & v24 | v23 & (v22 | v24)) + v21 + 1518500249, 13);
  v26 = __ROL4__(v57 + (v25 & v24 | v23 & (v25 | v24)) + v22 + 1518500249, 3);
  v27 = __ROL4__(v65 + (v26 & v25 | v24 & (v26 | v25)) + v23 + 1518500249, 5);
  v28 = __ROL4__(v64 + (v26 & v25 | v27 & (v26 | v25)) + v24 + 1518500249, 9);
  v29 = __ROL4__(v66 + (v26 & v28 | v27 & (v26 | v28)) + v25 + 1518500249, 13);
  v30 = __ROL4__(v56 + (v29 & v28 | v27 & (v29 | v28)) + v26 + 1518500249, 3);
  v31 = __ROL4__(v27 + v63 + (v30 & v29 | v28 & (v30 | v29)) + 1518500249, 5);
  v32 = __ROL4__(v62 + (v30 & v29 | v31 & (v30 | v29)) + v28 + 1518500249, 9);
  v33 = __ROL4__(v19 + (v30 & v32 | v31 & (v30 | v32)) + v29 + 1518500249, 13);
  v34 = __ROL4__(v58 + (v33 & v32 | v31 & (v33 | v32)) + v30 + 1518500249, 3);
  v35 = __ROL4__(v31 + v68 + (v34 & v33 | v32 & (v34 | v33)) + 1518500249, 5);
  v36 = __ROL4__(v67 + (v34 & v33 | v35 & (v34 | v33)) + v32 + 1518500249, 9);
  v37 = __ROL4__(v69 + (v34 & v36 | v35 & (v34 | v36)) + v33 + 1518500249, 13);
  v38 = __ROL4__(v55 + (v37 ^ v36 ^ v35) + v34 + 1859775393, 3);
  v39 = __ROL4__(v59 + (v38 ^ v37 ^ v36) + v35 + 1859775393, 9);
  v40 = __ROL4__(v60 + (v38 ^ v37 ^ v39) + v36 + 1859775393, 11);
  v41 = __ROL4__(v37 + v61 + (v38 ^ v40 ^ v39) + 1859775393, 15);
  v42 = __ROL4__(v56 + (v41 ^ v40 ^ v39) + v38 + 1859775393, 3);
  v43 = __ROL4__(v62 + (v42 ^ v41 ^ v40) + v39 + 1859775393, 9);
  v44 = __ROL4__(v63 + (v42 ^ v41 ^ v43) + v40 + 1859775393, 11);
  v45 = __ROL4__(v41 + v19 + (v42 ^ v44 ^ v43) + 1859775393, 15);
  v46 = __ROL4__(v57 + (v45 ^ v44 ^ v43) + v42 + 1859775393, 3);
  v47 = __ROL4__(v64 + (v46 ^ v45 ^ v44) + v43 + 1859775393, 9);
  v48 = __ROL4__(v65 + (v46 ^ v45 ^ v47) + v44 + 1859775393, 11);
  v49 = __ROL4__(v45 + v66 + (v46 ^ v48 ^ v47) + 1859775393, 15);
  v50 = __ROL4__(v58 + (v49 ^ v48 ^ v47) + v46 + 1859775393, 3);
  v51 = __ROL4__(v67 + (v50 ^ v49 ^ v48) + v47 + 1859775393, 9);
  v52 = __ROL4__(v68 + (v50 ^ v49 ^ v51) + v48 + 1859775393, 11);
  *a2 += v50;
  v53 = a2[1] + __ROL4__(v49 + v69 + (v50 ^ v52 ^ v51) + 1859775393, 15);
  a2[2] += v52;
  result = v51 + a2[3];
  a2[1] = v53;
  a2[3] = result;
  return result;
}

//----- (004014B0) --------------------------------------------------------
int __usercall sub_4014B0@<eax>(int *a1@<edx>, int a2@<edi>)
{
  int v2; // eax
  _BYTE *v3; // esi
  unsigned int v4; // eax
  int v5; // eax
  int v6; // edx
  char v7; // cl
  int result; // eax
  int v9[6]; // [esp+8h] [ebp-44h] BYREF
  int v10; // [esp+20h] [ebp-2Ch]
  int v11; // [esp+24h] [ebp-28h]
  int v12; // [esp+28h] [ebp-24h]
  int v13; // [esp+2Ch] [ebp-20h]
  int v14; // [esp+30h] [ebp-1Ch]
  int v15; // [esp+34h] [ebp-18h]
  int v16; // [esp+38h] [ebp-14h]
  int v17; // [esp+3Ch] [ebp-10h]
  int v18; // [esp+40h] [ebp-Ch]
  int v19; // [esp+44h] [ebp-8h]

  v2 = 192;
  v3 = (_BYTE *)(a2 + 16);
  do
  {
    v4 = (unsigned __int8)*v3 + v2;
    *v3 = v4;
    v2 = v4 >> 8;
    ++v3;
  }
  while ( v2 );
  v9[0] = *a1;
  v9[1] = a1[1];
  v9[2] = a1[2];
  v9[3] = a1[3];
  v5 = a1[4];
  v6 = a1[5];
  v9[4] = v5;
  v18 = 0;
  v19 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  LOBYTE(v18) = *(_BYTE *)(a2 + 16);
  LOBYTE(v5) = *(_BYTE *)(a2 + 18);
  v9[5] = v6;
  LOBYTE(v6) = *(_BYTE *)(a2 + 17);
  BYTE2(v18) = v5;
  LOBYTE(v5) = *(_BYTE *)(a2 + 20);
  BYTE1(v18) = v6;
  LOBYTE(v6) = *(_BYTE *)(a2 + 19);
  LOBYTE(v19) = v5;
  LOBYTE(v5) = *(_BYTE *)(a2 + 22);
  HIBYTE(v18) = v6;
  LOBYTE(v6) = *(_BYTE *)(a2 + 21);
  v7 = *(_BYTE *)(a2 + 23);
  BYTE2(v19) = v5;
  LOBYTE(v10) = 0x80;
  BYTE1(v19) = v6;
  HIBYTE(v19) = v7;
  result = sub_401000(v9, (_DWORD *)a2);
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

//----- (004015A0) --------------------------------------------------------
int sub_4015A0()
{
  char *v0; // ecx
  unsigned int i; // eax
  char v2; // dl
  int v3; // esi
  unsigned int v4; // eax
  int v5; // edi
  int v6; // edx
  int v7; // ecx
  int v8; // ebx
  int v9; // ebx
  int v10; // ebp
  int v11; // esi
  unsigned int v12; // edi
  _DWORD *v13; // eax
  _DWORD *j; // ecx
  int v16; // [esp+10h] [ebp-3Ch] BYREF
  int v17; // [esp+14h] [ebp-38h]
  unsigned __int8 v18; // [esp+18h] [ebp-34h]
  unsigned __int8 v19; // [esp+19h] [ebp-33h]
  unsigned __int8 v20; // [esp+1Ah] [ebp-32h]
  unsigned __int8 v21; // [esp+1Bh] [ebp-31h]
  unsigned __int8 v22; // [esp+1Ch] [ebp-30h]
  unsigned __int8 v23; // [esp+1Dh] [ebp-2Fh]
  unsigned __int8 v24; // [esp+1Eh] [ebp-2Eh]
  unsigned __int8 v25; // [esp+1Fh] [ebp-2Dh]
  char v26[8]; // [esp+20h] [ebp-2Ch]
  int v27[7]; // [esp+28h] [ebp-24h] BYREF

  v0 = (char *)&unk_4756C4;
  for ( i = 0; i < 0x10; ++i )
  {
    v2 = *v0;
    v0 += 2;
    *((_BYTE *)&v16 + i) = v2;
    if ( i < 8 )
      v26[i] = byte_4A5B7C[i];
  }
  v27[0] = 1732584193;
  v27[1] = -271733879;
  v27[2] = -1732584194;
  v27[3] = 271733878;
  memset(&v27[4], 0, 12);
  sub_4014B0(&v16, (int)v27);
  v16 += 383941958;
  v17 += 383941958;
  v3 = ((unsigned __int8)((8 * v25) | (v25 >> 5)) ^ 0x49)
     + ((unsigned __int8)((8 * v24) | (v24 >> 5)) ^ 0x49)
     + ((unsigned __int8)((8 * v23) | (v23 >> 5)) ^ 0x49)
     + ((unsigned __int8)((8 * v22) | (v22 >> 5)) ^ 0x49)
     + ((unsigned __int8)((8 * v21) | (v21 >> 5)) ^ 0x49)
     + ((unsigned __int8)((8 * v20) | (v20 >> 5)) ^ 0x49)
     + ((unsigned __int8)((8 * v19) | (v19 >> 5)) ^ 0x49)
     + ((unsigned __int8)((8 * v18) | (v18 >> 5)) ^ 0x49);
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  do
  {
    v3 += LOBYTE(v27[v4]) ^ (unsigned __int8)byte_4756E8[v4 * 4];
    v7 += BYTE1(v27[v4]) ^ (unsigned __int8)byte_4756E9[v4 * 4];
    v6 += BYTE2(v27[v4]) ^ (unsigned __int8)byte_4756EA[v4 * 4];
    v8 = HIBYTE(v27[v4]) ^ (unsigned __int8)byte_4756EB[v4 * 4];
    ++v4;
    v5 += v8;
  }
  while ( v4 < 4 );
  v9 = v16;
  v10 = v17;
  v11 = v7 + v6 + v5 + v3;
  dword_4A80C8 = v16;
  dword_4A80CC = v17;
  v12 = 16;
  v13 = (_DWORD *)sub_473493((int)&unk_4756FC);
  for ( j = &unk_4756C4; *j == *v13; ++j )
  {
    v12 -= 4;
    ++v13;
    if ( v12 < 4 )
      return 52;
  }
  if ( dword_4AE100 + 86400 < v9 )
    return -93;
  if ( dword_4AE100 <= v10 )
    return v11 != 0 ? 0x84 : 0;
  return 142;
}
// 4A80C8: using guessed type int dword_4A80C8;
// 4A80CC: using guessed type int dword_4A80CC;
// 4AE100: using guessed type int dword_4AE100;
// 4015A0: using guessed type char var_2C[8];

//----- (00401830) --------------------------------------------------------
void __noreturn sub_401830(const char *a1, ...)
{
  char *v1; // ebx
  char *v2; // eax
  char *v3; // edx
  char v4; // cl
  va_list va; // [esp+14h] [ebp+8h] BYREF

  va_start(va, a1);
  v1 = (char *)malloc(strlen(a1) + 32);
  v2 = (char *)sub_473493((int)&unk_475F74);
  v3 = v1;
  do
  {
    v4 = *v2;
    *v3++ = *v2++;
  }
  while ( v4 );
  strcat(v1, a1);
  sub_407880(va, v1);
}

//----- (004018B0) --------------------------------------------------------
int sub_4018B0()
{
  char *v0; // ebx
  int v1; // ebp
  int v2; // edi
  char *v3; // esi
  int v4; // ecx
  int v5; // ecx
  int v6; // edx
  const char *v7; // eax

  v0 = ArgList;
  v1 = 1;
  v2 = 0;
  v3 = ArgList;
  if ( isspace(*ArgList) )
  {
    do
      v4 = *++v3;
    while ( isspace(v4) );
  }
  if ( !isdigit(*v3) )
    goto LABEL_15;
  do
  {
    v5 = *v3;
    v6 = *++v3;
    v2 = v5 + 10 * v2 - 48;
  }
  while ( isdigit(v6) );
  if ( *v3 )
  {
    switch ( tolower(*v3) )
    {
      case 'd':
        v2 *= 86400;
        break;
      case 'h':
        v2 *= 3600;
        break;
      case 'm':
        v2 *= 60;
        break;
      case 's':
        break;
      case 'w':
        v2 *= 604800;
        break;
      default:
        v1 = 0;
        break;
    }
    if ( *v3 && v3[1] || !v1 )
    {
LABEL_15:
      v7 = (const char *)sub_473493((int)&unk_475F9C);
      sub_401830(v7, v0);
    }
  }
  return v2;
}

//----- (004019C0) --------------------------------------------------------
int sub_4019C0()
{
  const char *v0; // edi
  const char *v1; // eax
  const char *v2; // eax
  struct tm *v3; // eax
  __time32_t v4; // esi
  struct tm *v5; // eax
  int v6; // esi
  int result; // eax
  const char *v8; // eax
  __time32_t Time; // [esp+8h] [ebp-34h] BYREF
  int v10; // [esp+Ch] [ebp-30h] BYREF
  int v11; // [esp+10h] [ebp-2Ch] BYREF
  int v12; // [esp+14h] [ebp-28h] BYREF
  struct tm Tm; // [esp+18h] [ebp-24h] BYREF

  v0 = ArgList;
  v1 = (const char *)sub_473493((int)&unk_475FB4);
  if ( sscanf(v0, v1, &v10, &v11, &v12) != 3 )
  {
    v2 = (const char *)sub_473493((int)&unk_475FC8);
    if ( sscanf(v0, v2, &v10, &v11, &v12) != 3 )
      goto LABEL_8;
  }
  _time32(&Time);
  v3 = _gmtime32(&Time);
  v4 = _mktime32(v3);
  v5 = _localtime32(&Time);
  v6 = v4 - _mktime32(v5);
  memset(&Tm, 0, 12);
  Tm.tm_wday = 0;
  Tm.tm_yday = 0;
  Tm.tm_year = v10 - 1900;
  Tm.tm_mon = v11 - 1;
  Tm.tm_mday = v12;
  Tm.tm_isdst = -1;
  if ( v10 < 1970
    || (unsigned int)(v11 - 1) > 0xB
    || v12 < 1
    || v12 > (unsigned __int8)byte_4A5307[v11]
    || (result = _mktime32(&Tm) - v6, result == -1) )
  {
LABEL_8:
    v8 = (const char *)sub_473493((int)&unk_475FDC);
    sub_401830(v8, v0);
  }
  return result;
}

//----- (00401B00) --------------------------------------------------------
int sub_401B00()
{
  char *v0; // edi
  int v2; // ebx
  int v3; // esi
  char v4; // al

  v0 = ArgList;
  if ( !ArgList )
    return 0;
  v2 = strlen(ArgList);
  v3 = 0;
  if ( v2 <= 0 )
    return 1;
  while ( 1 )
  {
    v4 = v0[v3];
    if ( v4 )
    {
      if ( !isdigit(v4) && v0[v3] != 46 )
        break;
    }
    if ( ++v3 >= v2 )
      return 1;
  }
  return 0;
}

//----- (00401B60) --------------------------------------------------------
char *__cdecl sub_401B60(int a1, char *String, int a3)
{
  int v3; // ebx
  char *v4; // esi
  int v5; // edx
  char v6; // al
  char *v7; // esi
  _DWORD *v8; // eax
  _BYTE *v9; // edi
  int v10; // ebp
  int v11; // ecx
  char *v12; // ebx
  int v13; // ecx
  int v14; // ecx
  char *v15; // esi
  int v16; // edx
  _BYTE *v17; // ebx
  int v18; // ecx
  int v19; // eax
  const char *v20; // eax
  const char *v21; // eax
  char *v22; // edi
  int v23; // eax
  char v24; // al
  int v25; // edx
  char *result; // eax
  const char *v27; // eax
  const char *v28; // eax
  char v29; // cl
  int v30; // edi
  int v31; // ebp
  char v32; // bl
  int v33; // eax
  const char *v34; // eax
  char v35; // bl
  char *v36; // esi
  int v37; // edi
  int v38; // ebp
  int v39; // eax
  int v40; // edi
  _BYTE *v41; // edi
  int v42; // eax
  _DWORD *v43; // [esp-Ch] [ebp-34h]
  _DWORD *v44; // [esp-8h] [ebp-30h]
  _DWORD *v45; // [esp-8h] [ebp-30h]
  int v46; // [esp-4h] [ebp-2Ch]
  char *EndPtr; // [esp+10h] [ebp-18h] BYREF
  size_t Src[2]; // [esp+14h] [ebp-14h] BYREF
  int v49; // [esp+1Ch] [ebp-Ch]
  char Stringa; // [esp+30h] [ebp+8h]

  v3 = a3;
  v4 = String;
  *(_BYTE *)(a3 + 9) = 0;
  *(_WORD *)(a3 + 10) = 1;
  if ( isspace(*String) )
  {
    do
      v5 = *++v4;
    while ( isspace(v5) );
  }
  v6 = *v4;
  if ( *v4 == 123 )
  {
    v7 = v4 + 1;
    *(_BYTE *)(a3 + 8) = 4;
    v8 = emalloc(40);
    *(_DWORD *)a3 = v8;
    zend_hash_init((int)v8, 2u, 0, (int)zval_ptr_dtor, 0);
    while ( 1 )
    {
      Src[0] = (size_t)malloc(0x10u);
      v9 = 0;
      v10 = 0;
      if ( isspace(*v7) )
      {
        do
          v11 = *++v7;
        while ( isspace(v11) );
      }
      if ( *v7 != 125 )
        break;
LABEL_30:
      v22 = v7;
      if ( isspace(*v7) )
      {
        do
          v23 = *++v7;
        while ( isspace(v23) );
      }
      v24 = *v7;
      if ( *v7 )
      {
        if ( v24 == 44 )
        {
          ++v7;
        }
        else if ( v24 != 125 )
        {
          v43 = estrndup(String, v22 - String);
          v28 = (const char *)sub_473493((int)&unk_4760B0);
          sub_4078E0(v28, v43, v7, a1);
        }
      }
      if ( isspace(*v7) )
      {
        do
          v25 = *++v7;
        while ( isspace(v25) );
      }
      if ( !*v7 )
      {
        if ( *v7 == 125 )
          return v7 + 1;
        return v7;
      }
      if ( *v7 == 125 )
        return v7 + 1;
    }
    String = v7;
    if ( *v7 != 45 )
      goto LABEL_10;
    while ( 1 )
    {
      ++v7;
LABEL_10:
      if ( *v7 != 95 && !isalnum(*v7) )
      {
        v12 = v7;
        if ( isspace(*v7) )
        {
          do
            v13 = *++v7;
          while ( isspace(v13) );
        }
        if ( *v7 == 61 && v7[1] == 62 )
        {
          v10 = v12 - String;
          v9 = malloc(v12 - String + 1);
          memcpy(v9, String, v12 - String);
          v9[v12 - String] = 0;
          v14 = v7[2];
          v15 = v7 + 2;
          if ( isspace(v14) )
          {
            do
              v16 = *++v15;
            while ( isspace(v16) );
          }
          String = v15;
        }
        v7 = (char *)sub_401B60(a1, String, Src[0]);
        if ( v9 )
        {
          v17 = v9;
          if ( *v9 == 45 )
            v17 = v9 + 1;
          if ( isdigit((char)*v17) )
          {
            do
              v18 = (char)*++v17;
            while ( isdigit(v18) );
          }
          if ( *v17 )
          {
            if ( zend_hash_add_or_update(*(_DWORD *)a3, v9, v10 + 1, Src, 4u, 0, 2) == -1 )
            {
              v45 = estrndup(String, v7 - String);
              v21 = (const char *)sub_473493((int)&unk_476040);
              sub_4078E0(v21, v9, v45, a1);
            }
          }
          else
          {
            v19 = atoi(v9);
            if ( zend_hash_index_update_or_next_insert(*(_DWORD *)a3, v19, Src, 4u, 0, 1) )
            {
              v44 = estrndup(String, v7 - String);
              v20 = (const char *)sub_473493((int)&unk_476000);
              sub_4078E0(v20, v9, v44, a1);
            }
          }
        }
        else if ( zend_hash_index_update_or_next_insert(*(_DWORD *)a3, 0, Src, 4u, 0, 4) == -1 )
        {
          v27 = (const char *)sub_473493((int)&unk_476080);
          sub_4078E0(v27, a3, a1);
        }
        goto LABEL_30;
      }
    }
  }
  if ( v6 != 45 && !isdigit(v6) )
  {
    v29 = *v4;
    Stringa = *v4;
    if ( *v4 == 39 || v29 == 34 )
    {
      v35 = v4[1];
      v36 = v4 + 1;
      v37 = 0;
      v38 = 0;
      v39 = 0;
      if ( !v35 )
        goto LABEL_81;
      while ( v35 != v29 )
      {
        ++v36;
        if ( v35 == 92 && *v36 )
          v35 = *v36++;
        if ( v37 == v38 )
        {
          v38 += 32;
          if ( v39 )
            v39 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v39, v38);
          else
            v39 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(v38);
        }
        *(_BYTE *)(v39 + v37) = v35;
        v35 = *v36;
        ++v37;
        if ( !*v36 )
          break;
        v29 = Stringa;
      }
      if ( v37 == v38 )
      {
LABEL_81:
        v46 = v38 + 32;
        if ( v39 )
          v39 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v39, v46);
        else
          v39 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(v46);
      }
      *(_BYTE *)(v39 + v37) = 0;
      v40 = v37 + 1;
      if ( *v36 == Stringa )
        ++v36;
      *(_DWORD *)(a3 + 4) = v40 - 1;
      *(_DWORD *)a3 = v39;
      result = v36;
      *(_BYTE *)(a3 + 8) = 3;
      return result;
    }
    if ( !isalnum(v29) )
    {
      v34 = (const char *)sub_473493((int)&unk_476100);
      sub_4078E0(v34, v4, a1);
    }
    v30 = 0;
    v31 = 0;
    v49 = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        if ( !isalnum(*v4) && *v4 != 92 )
        {
          if ( v31 == v49 )
          {
            v49 += 32;
            if ( v30 )
              v33 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v30, v49);
            else
              v33 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(v49);
            v30 = v33;
          }
          *(_BYTE *)(v30 + v31) = 0;
          *(_DWORD *)v3 = v30;
          result = v4;
          *(_DWORD *)(v3 + 4) = v31;
          *(_BYTE *)(v3 + 8) = 3;
          return result;
        }
        v32 = *v4++;
        if ( v32 == 92 && *v4 )
          v32 = *v4++;
        if ( v31 == v49 )
          break;
LABEL_60:
        *(_BYTE *)(v30 + v31) = v32;
        v3 = a3;
        ++v31;
      }
      v49 += 32;
      if ( v30 )
      {
        v30 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v30, v49);
        goto LABEL_60;
      }
      v30 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(v49);
      *(_BYTE *)(v30 + v31) = v32;
      v3 = a3;
      ++v31;
    }
  }
  v41 = v4 + 1;
  if ( isdigit(v4[1]) )
  {
    do
      v42 = (char)*++v41;
    while ( isdigit(v42) );
  }
  if ( toupper((char)*v41) == 69 || *v41 == 46 )
  {
    *(_BYTE *)(a3 + 8) = 2;
    *(double *)a3 = strtod(v4, &EndPtr);
    return EndPtr;
  }
  *(_DWORD *)a3 = strtol(v4, &EndPtr, 0);
  if ( *_errno() == 34 )
  {
    *(double *)a3 = strtod(v4, &EndPtr);
    result = EndPtr;
    *(_BYTE *)(a3 + 8) = 2;
  }
  else
  {
    result = EndPtr;
    *(_BYTE *)(a3 + 8) = 1;
  }
  return result;
}

//----- (00402130) --------------------------------------------------------
int __usercall sub_402130@<eax>(char **a1@<edi>, int a2)
{
  char *v2; // esi
  int v3; // ecx
  const char *v4; // eax
  char *v5; // esi
  int v6; // ecx
  int (__cdecl *v7)(int); // ecx
  int result; // eax
  const char *v9; // ecx
  const char *v10; // eax
  int v11[3]; // [esp+Ch] [ebp-1Ch] BYREF
  int v12[4]; // [esp+18h] [ebp-10h] BYREF

  v2 = *a1;
  if ( isspace(**a1) )
  {
    do
      v3 = *++v2;
    while ( isspace(v3) );
  }
  if ( !*v2 )
  {
    v4 = (const char *)sub_473493((int)&unk_476140);
    sub_4078E0(v4, a2);
  }
  v5 = sub_401B60(a2, v2, (int)v12);
  if ( isspace(*v5) )
  {
    do
      v6 = *++v5;
    while ( isspace(v6) );
  }
  v11[2] = 64;
  v11[1] = 0;
  v7 = *(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8);
  *a1 = v5;
  v11[0] = v7(65);
  *(_BYTE *)v11[0] = 0;
  sub_4404B0((int)v12, v11, 0);
  result = v11[0];
  v9 = (const char *)v11[0];
  v11[0] = 0;
  if ( strlen(v9) > 0xFFFE )
  {
    v10 = (const char *)sub_473493((int)&unk_476164);
    sub_4078E0(v10, a2);
  }
  return result;
}

//----- (00402230) --------------------------------------------------------
void __usercall sub_402230(const char *a1@<eax>, void *Block)
{
  int *v2; // ebp
  const char *v3; // esi
  int v4; // ecx
  const char *v5; // esi
  const char *v6; // edi
  int v7; // edx
  char v8; // al
  char *v9; // ebx
  int v10; // edi
  int v11; // eax
  void *v12; // edx
  int v13; // eax
  int v14; // ecx
  int v15; // eax
  int v16; // eax
  _DWORD *v17; // ecx
  const char *v18; // eax
  const char *v19; // eax
  const char *v20; // eax
  void *v21; // [esp-8h] [ebp-20h]
  int v22; // [esp-4h] [ebp-1Ch]
  int v23; // [esp+10h] [ebp-8h]
  char *v24; // [esp+14h] [ebp-4h]

  v2 = (int *)Block;
  v3 = a1;
  v22 = *a1;
  *(_DWORD *)Block = 0;
  v2[1] = 0;
  v2[2] = 32;
  v2[3] = 0;
  if ( isspace(v22) )
  {
    do
      v4 = *++v3;
    while ( isspace(v4) );
  }
  v24 = _strdup(v3);
  v5 = v24;
  v6 = v24;
  if ( !isalpha(*v24) )
  {
LABEL_26:
    v18 = (const char *)sub_473493((int)&unk_47618C);
    sub_4078E0(v18);
  }
  while ( 1 )
  {
    while ( isalnum(*v5) || *v5 == 95 )
      ++v5;
    if ( isspace(*v5) )
    {
      do
      {
        *v5 = 0;
        v7 = *++v5;
      }
      while ( isspace(v7) );
    }
    v8 = *v5;
    if ( !*v5 )
      goto LABEL_14;
    *v5 = 0;
    if ( v8 == 44 )
    {
      ++v5;
LABEL_14:
      Block = &unk_4761B8;
      v23 = 1;
      goto LABEL_15;
    }
    if ( v8 != 61 )
    {
      v19 = (const char *)sub_473493((int)&unk_4761BC);
      sub_4078E0(v19, v5, v6);
    }
    Block = (void *)++v5;
    v23 = 0;
LABEL_15:
    v9 = _strdup(v6);
    v10 = sub_402130((char **)&Block, (int)v9);
    if ( !v23 )
    {
      v5 = (const char *)Block;
      if ( *(_BYTE *)Block )
      {
        if ( *(_BYTE *)Block != 44 )
        {
          v21 = Block;
          v20 = (const char *)sub_473493((int)&unk_4761E4);
          sub_4078E0(v20, v21, v9);
        }
        v5 = (char *)Block + 1;
      }
    }
    v11 = v2[1];
    if ( *v2 == v11 )
    {
      v12 = dword_4A80FC;
      v13 = v2[2] + v11;
      v14 = v2[3];
      v2[1] = v13;
      if ( v14 )
        v15 = (*(int (__cdecl **)(int, int))(*(_DWORD *)v12 + 12))(v14, 12 * v13);
      else
        v15 = (*(int (__cdecl **)(int))(*(_DWORD *)v12 + 8))(12 * v13);
      v2[3] = v15;
    }
    v16 = *v2;
    v17 = (_DWORD *)(v2[3] + 12 * *v2);
    *v17 = 2;
    v17[1] = v9;
    v17[2] = v10;
    *v2 = v16 + 1;
    if ( !*v5 )
      break;
    v6 = v5;
    if ( !isalpha(*v5) )
      goto LABEL_26;
  }
  free(v24);
}

//----- (00402420) --------------------------------------------------------
void __usercall sub_402420(int *a1@<esi>)
{
  int v1; // edi
  int v2; // ebx
  int v3; // ebp
  int v4; // eax
  int v5; // eax
  int v6; // ecx
  int v7; // eax
  _DWORD *v8; // eax
  const char *v9; // eax
  int v10; // [esp-4h] [ebp-28h]
  int v11; // [esp+Ch] [ebp-18h]
  int v12[5]; // [esp+10h] [ebp-14h] BYREF

  sub_402230(ArgList, v12);
  v11 = 0;
  if ( v12[0] > 0 )
  {
    v1 = v12[3];
    do
    {
      v2 = 0;
      if ( *a1 > 0 )
      {
        v3 = 0;
        do
        {
          if ( !_stricmp(*(const char **)(a1[3] + v3 + 4), *(const char **)(v1 + 4)) )
          {
            v10 = *(_DWORD *)(v1 + 4);
            v9 = (const char *)sub_473493((int)&unk_476214);
            sub_4078E0(v9, v10);
          }
          ++v2;
          v3 += 12;
        }
        while ( v2 < *a1 );
      }
      v4 = a1[1];
      if ( *a1 == v4 )
      {
        v5 = a1[2] + v4;
        v6 = a1[3];
        a1[1] = v5;
        if ( v6 )
          v7 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v6, 12 * v5);
        else
          v7 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(12 * v5);
        a1[3] = v7;
      }
      v8 = (_DWORD *)(a1[3] + 12 * *a1);
      *v8 = *(_DWORD *)v1;
      v8[1] = *(_DWORD *)(v1 + 4);
      v8[2] = *(_DWORD *)(v1 + 8);
      ++*a1;
      v1 += 12;
      ++v11;
    }
    while ( v11 < v12[0] );
  }
}

//----- (00402520) --------------------------------------------------------
_DWORD *__usercall sub_402520@<eax>(_DWORD *a1@<esi>)
{
  int v1; // eax
  int v2; // eax
  int v3; // ecx
  int v4; // eax
  int v5; // edx
  _DWORD *result; // eax
  int v7; // ecx
  int v8; // edx
  int v9; // [esp-4h] [ebp-18h]
  int v10[5]; // [esp+0h] [ebp-14h] BYREF

  sub_402230(ArgList, v10);
  v1 = a1[32];
  if ( a1[31] == v1 )
  {
    v2 = a1[33] + v1;
    v3 = a1[34];
    a1[32] = v2;
    v9 = 16 * v2;
    if ( v3 )
      v4 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v3, v9);
    else
      v4 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(v9);
    a1[34] = v4;
  }
  v5 = v10[1];
  result = (_DWORD *)(a1[34] + 16 * a1[31]);
  *result = v10[0];
  v7 = v10[2];
  result[1] = v5;
  v8 = v10[3];
  result[2] = v7;
  result[3] = v8;
  ++a1[31];
  return result;
}

//----- (004025B0) --------------------------------------------------------
int sub_4025B0()
{
  char *v0; // esi
  const char *v1; // eax
  FILE *v2; // eax
  const char *v3; // eax
  const char *v4; // eax
  int result; // eax
  int v6; // [esp-8h] [ebp-Ch]
  int v7; // [esp-4h] [ebp-8h]

  v0 = ArgList;
  if ( !strcmp(ArgList, (const char *)sub_473493((int)&unk_476230)) )
  {
    sub_4015A0();
    v7 = dword_4A80CC;
    v6 = dword_4A80C8;
    v1 = (const char *)sub_473493((int)&unk_476240);
    printf(v1, &unk_47623C, 12000200, 4, v6, v7);
  }
  if ( !strcmp(v0, (const char *)sub_473493((int)&unk_476254)) )
  {
    puts("X");
    v2 = (FILE *)sub_44F01A();
    fflush(v2 + 1);
  }
  if ( !strcmp(v0, (const char *)sub_473493((int)&unk_476264)) )
  {
    dword_4AE2A4 = 1;
    Stream = (FILE *)(sub_44F01A() + 8);
  }
  v3 = (const char *)sub_473493((int)&unk_47626C);
  if ( !strncmp(v0, v3, 3u) )
    strncpy(Destination, v0 + 3, 0x20u);
  v4 = (const char *)sub_473493((int)&unk_476274);
  result = strncmp(v0, v4, 5u);
  if ( !result )
    return puts(byte_4A8101);
  return result;
}
// 4A80C8: using guessed type int dword_4A80C8;
// 4A80CC: using guessed type int dword_4A80CC;
// 4AE2A4: using guessed type int dword_4AE2A4;

//----- (00402740) --------------------------------------------------------
int sub_402740()
{
  _BYTE *v0; // ebx
  int v1; // edi
  FILE *v2; // esi
  const char *v3; // eax
  int v4; // ebx
  unsigned int st_size; // ebp
  void *v6; // edi
  const char *v7; // eax
  const char *v8; // eax
  const char *v9; // eax
  const char *v10; // eax
  const char *v11; // eax
  const char *v12; // eax
  const char *v13; // eax
  const char *v14; // eax
  const char *v15; // eax
  const char *v16; // eax
  const char *v17; // eax
  const char *v18; // eax
  const char *v19; // eax
  const char *v20; // eax
  const char *v21; // eax
  const char *v22; // eax
  const char *v23; // eax
  const char *v24; // eax
  const char *v25; // eax
  const char *v26; // eax
  const char *v27; // eax
  const char *v28; // eax
  const char *v29; // eax
  const char *v30; // eax
  const char *v31; // eax
  const char *v32; // eax
  const char *v33; // eax
  const char *v34; // eax
  const char *v35; // eax
  const char *v36; // eax
  const char *v37; // eax
  const char *v38; // eax
  const char *v39; // eax
  const char *v40; // eax
  const char *v41; // eax
  const char *v42; // eax
  const char *v43; // eax
  const char *v44; // eax
  const char *v45; // eax
  const char *v46; // eax
  const char *v47; // eax
  const char *v48; // eax
  const char *v49; // eax
  const char *v50; // eax
  const char *v51; // eax
  const char *v52; // eax
  const char *v53; // eax
  const char *v54; // eax
  const char *v55; // eax
  const char *v56; // eax
  const char *v57; // eax
  const char *v58; // eax
  const char *v59; // eax
  const char *v60; // eax
  const char *v61; // eax
  const char *v62; // eax
  const char *v63; // eax
  const char *v64; // eax
  const char *v65; // eax
  const char *v66; // eax
  const char *v67; // eax
  const char *v68; // eax
  const char *v69; // eax
  const char *v70; // eax
  const char *v71; // eax
  const char *v72; // eax
  const char *v73; // eax
  const char *v74; // eax
  const char *v75; // eax
  const char *v76; // eax
  const char *v77; // eax
  const char *v78; // eax
  const char *v79; // eax
  const char *v80; // eax
  const char *v81; // eax
  const char *v82; // eax
  const char *v83; // eax
  const char *v84; // eax
  const char *v85; // eax
  const char *v86; // eax
  const char *v87; // eax
  const char *v88; // eax
  const char *v89; // eax
  const char *v90; // eax
  const char *v91; // eax
  const char *v92; // eax
  const char *v93; // eax
  const char *v94; // eax
  const char *v95; // eax
  const char *v96; // eax
  const char *v97; // eax
  const char *v98; // eax
  const char *v99; // eax
  const char *v100; // eax
  const char *v101; // eax
  const char *v102; // eax
  const char *v103; // eax
  const char *v104; // eax
  const char *v105; // eax
  const char *v106; // eax
  const char *v107; // eax
  const char *v108; // eax
  const char *v109; // eax
  const char *v110; // eax
  const char *v111; // eax
  const char *v112; // eax
  const char *v113; // eax
  const char *v114; // eax
  const char *v115; // eax
  const char *v116; // eax
  const char *v117; // eax
  const char *v118; // eax
  const char *v119; // eax
  const char *v120; // eax
  const char *v121; // eax
  const char *v122; // eax
  const char *v123; // eax
  const char *v124; // eax
  const char *v125; // eax
  const char *v126; // eax
  const char *v127; // eax
  const char *v128; // eax
  const char *v129; // eax
  const char *v130; // eax
  const char *v131; // eax
  const char *v132; // eax
  const char *v133; // eax
  const char *v134; // eax
  const char *v135; // eax
  const char *v136; // eax
  const char *v137; // eax
  const char *v138; // eax
  const char *v139; // eax
  const char *v140; // eax
  const char *v141; // eax
  const char *v142; // eax
  const char *v143; // eax
  const char *v144; // eax
  const char *v145; // eax
  const char *v146; // eax
  const char *v147; // eax
  const char *v148; // eax
  const char *v149; // eax
  const char *v150; // eax
  const char *v151; // eax
  const char *v152; // eax
  const char *v153; // eax
  const char *v154; // eax
  const char *v155; // eax
  const char *v156; // eax
  const char *v157; // eax
  const char *v158; // eax
  const char *v159; // eax
  const char *v160; // eax
  const char *v161; // eax
  const char *v162; // eax
  const char *v163; // eax
  const char *v164; // eax
  const char *v165; // eax
  const char *v166; // eax
  const char *v167; // eax
  const char *v168; // eax
  const char *v169; // eax
  const char *v170; // eax
  const char *v171; // eax
  const char *v172; // eax
  const char *v173; // eax
  const char *v174; // eax
  const char *v175; // eax
  const char *v176; // eax
  const char *v177; // eax
  const char *v178; // eax
  const char *v179; // eax
  const char *v180; // eax
  const char *v181; // eax
  const char *v182; // eax
  const char *v183; // eax
  const char *v184; // eax
  const char *v185; // eax
  const char *v186; // eax
  const char *v187; // eax
  const char *v188; // eax
  const char *v189; // eax
  const char *v190; // eax
  const char *v191; // eax
  const char *v192; // eax
  const char *v193; // eax
  const char *v194; // eax
  const char *v195; // eax
  const char *v196; // eax
  const char *v197; // eax
  const char *v198; // eax
  const char *v199; // eax
  const char *v200; // eax
  const char *v201; // eax
  const char *v202; // eax
  const char *v203; // eax
  const char *v204; // eax
  const char *v205; // eax
  const char *v206; // eax
  const char *v207; // eax
  const char *v208; // eax
  const char *v209; // eax
  const char *v210; // eax
  const char *v211; // eax
  const char *v212; // eax
  const char *v213; // eax
  const char *v214; // eax
  const char *v215; // eax
  const char *v216; // eax
  const char *v217; // eax
  const char *v218; // eax
  const char *v219; // eax
  const char *v220; // eax
  const char *v221; // eax
  const char *v222; // eax
  const char *v223; // eax
  const char *v224; // eax
  const char *v225; // eax
  const char *v226; // eax
  const char *v227; // eax
  const char *v228; // eax
  const char *v229; // eax
  const char *v230; // eax
  const char *v231; // eax
  const char *v232; // eax
  const char *v233; // eax
  const char *v234; // eax
  const char *v235; // eax
  const char *v236; // eax
  const char *v237; // eax
  const char *v238; // eax
  const char *v239; // eax
  const char *v240; // eax
  const char *v241; // eax
  const char *v242; // eax
  const char *v243; // eax
  const char *v244; // eax
  const char *v245; // eax
  const char *v246; // eax
  const char *v247; // eax
  const char *v248; // eax
  const char *v249; // eax
  const char *v250; // eax
  const char *v251; // eax
  const char *v252; // eax
  const char *v253; // eax
  const char *v254; // eax
  const char *v255; // eax
  const char *v256; // eax
  const char *v257; // eax
  const char *v258; // eax
  const char *v259; // eax
  const char *v260; // eax
  const char *v261; // eax
  const char *v262; // eax
  const char *v263; // eax
  const char *v264; // eax
  const char *v265; // eax
  const char *v266; // eax
  const char *v267; // eax
  const char *v268; // eax
  const char *v269; // eax
  const char *v270; // eax
  int v272; // [esp-8h] [ebp-440h]
  struct _stat32 Stat; // [esp+10h] [ebp-428h] BYREF
  char Buffer[1024]; // [esp+34h] [ebp-404h] BYREF

  v0 = (_BYTE *)sub_473493((int)&unk_476280);
  v1 = 0;
  v2 = (FILE *)(sub_44F01A() + 8);
  if ( (!*v0 || *v0 == 108) && v0[1] == 97 && v0[2] == 110 )
    goto LABEL_9;
  v272 = dword_4AE29C;
  v3 = (const char *)sub_473493((int)&unk_47628C);
  sprintf(Buffer, v3, v272, v0);
  v4 = _open(Buffer, 0);
  if ( v4 == -1 )
    goto LABEL_9;
  _fstat32(v4, &Stat);
  st_size = Stat.st_size;
  if ( Stat.st_size )
  {
    v6 = malloc(Stat.st_size + 1);
    _read(v4, v6, st_size);
    *((_BYTE *)v6 + st_size) = 0;
    fputs((const char *)v6, v2);
    fflush(v2);
    free(v6);
    v1 = 1;
  }
  _close(v4);
  if ( !v1 )
  {
LABEL_9:
    v7 = (const char *)sub_473493((int)&unk_4762B0);
    fprintf(v2, v7);
    v8 = (const char *)sub_473493((int)&unk_476340);
    fprintf(v2, v8);
    v9 = (const char *)sub_473493((int)&unk_47635C);
    fprintf(v2, v9);
    v10 = (const char *)sub_473493((int)&unk_476384);
    fprintf(v2, v10);
    v11 = (const char *)sub_473493((int)&unk_4763C0);
    fprintf(v2, v11);
    v12 = (const char *)sub_473493((int)&unk_4763F0);
    fprintf(v2, v12);
    v13 = (const char *)sub_473493((int)&unk_476420);
    fprintf(v2, v13);
    v14 = (const char *)sub_473493((int)&unk_476460);
    fprintf(v2, v14);
    v15 = (const char *)sub_473493((int)&unk_4764A8);
    fprintf(v2, v15);
    v16 = (const char *)sub_473493((int)&unk_4764C8);
    fprintf(v2, v16);
    v17 = (const char *)sub_473493((int)&unk_4764E0);
    fprintf(v2, v17);
    v18 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v18);
    v19 = (const char *)sub_473493((int)&unk_476510);
    fprintf(v2, v19);
    v20 = (const char *)sub_473493((int)&unk_476534);
    fprintf(v2, v20);
    v21 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v21);
    v22 = (const char *)sub_473493((int)&unk_476568);
    fprintf(v2, v22);
    v23 = (const char *)sub_473493((int)&unk_476580);
    fprintf(v2, v23);
    v24 = (const char *)sub_473493((int)&unk_4765C0);
    fprintf(v2, v24);
    v25 = (const char *)sub_473493((int)&unk_476604);
    fprintf(v2, v25);
    v26 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v26);
    v27 = (const char *)sub_473493((int)&unk_47661C);
    fprintf(v2, v27);
    v28 = (const char *)sub_473493((int)&unk_476630);
    fprintf(v2, v28);
    v29 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v29);
    v30 = (const char *)sub_473493((int)&unk_476688);
    fprintf(v2, v30);
    v31 = (const char *)sub_473493((int)&unk_476698);
    fprintf(v2, v31);
    v32 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v32);
    v33 = (const char *)sub_473493((int)&unk_4766E8);
    fprintf(v2, v33);
    v34 = (const char *)sub_473493((int)&unk_4766F4);
    fprintf(v2, v34);
    v35 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v35);
    v36 = (const char *)sub_473493((int)&unk_476720);
    fprintf(v2, v36);
    v37 = (const char *)sub_473493((int)&unk_47673C);
    fprintf(v2, v37);
    v38 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v38);
    v39 = (const char *)sub_473493((int)&unk_476760);
    fprintf(v2, v39);
    v40 = (const char *)sub_473493((int)&unk_476778);
    fprintf(v2, v40);
    v41 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v41);
    v42 = (const char *)sub_473493((int)&unk_4767B0);
    fprintf(v2, v42);
    v43 = (const char *)sub_473493((int)&unk_4767D0);
    fprintf(v2, v43);
    v44 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v44);
    v45 = (const char *)sub_473493((int)&unk_476804);
    fprintf(v2, v45);
    v46 = (const char *)sub_473493((int)&unk_476820);
    fprintf(v2, v46);
    v47 = (const char *)sub_473493((int)&unk_476868);
    fprintf(v2, v47);
    v48 = (const char *)sub_473493((int)&unk_4768AC);
    fprintf(v2, v48);
    v49 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v49);
    v50 = (const char *)sub_473493((int)&unk_4768D4);
    fprintf(v2, v50);
    v51 = (const char *)sub_473493((int)&unk_4768E8);
    fprintf(v2, v51);
    v52 = (const char *)sub_473493((int)&unk_476934);
    fprintf(v2, v52);
    v53 = (const char *)sub_473493((int)&unk_476968);
    fprintf(v2, v53);
    v54 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v54);
    v55 = (const char *)sub_473493((int)&unk_47698C);
    fprintf(v2, v55);
    v56 = (const char *)sub_473493((int)&unk_4769A8);
    fprintf(v2, v56);
    v57 = (const char *)sub_473493((int)&unk_4769F8);
    fprintf(v2, v57);
    v58 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v58);
    v59 = (const char *)sub_473493((int)&unk_476A14);
    fprintf(v2, v59);
    v60 = (const char *)sub_473493((int)&unk_476A40);
    fprintf(v2, v60);
    v61 = (const char *)sub_473493((int)&unk_476A90);
    fprintf(v2, v61);
    v62 = (const char *)sub_473493((int)&unk_476AAC);
    fprintf(v2, v62);
    v63 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v63);
    v64 = (const char *)sub_473493((int)&unk_476AD4);
    fprintf(v2, v64);
    v65 = (const char *)sub_473493((int)&unk_476AE8);
    fprintf(v2, v65);
    v66 = (const char *)sub_473493((int)&unk_476B34);
    fprintf(v2, v66);
    v67 = (const char *)sub_473493((int)&unk_476B68);
    fprintf(v2, v67);
    v68 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v68);
    v69 = (const char *)sub_473493((int)&unk_476B8C);
    fprintf(v2, v69);
    v70 = (const char *)sub_473493((int)&unk_476BA4);
    fprintf(v2, v70);
    v71 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v71);
    v72 = (const char *)sub_473493((int)&unk_476BDC);
    fprintf(v2, v72);
    v73 = (const char *)sub_473493((int)&unk_476BF8);
    fprintf(v2, v73);
    v74 = (const char *)sub_473493((int)&unk_476C48);
    fprintf(v2, v74);
    v75 = (const char *)sub_473493((int)&unk_476CAC);
    fprintf(v2, v75);
    v76 = (const char *)sub_473493((int)&unk_476CD4);
    fprintf(v2, v76);
    v77 = (const char *)sub_473493((int)&unk_476CDC);
    fprintf(v2, v77);
    v78 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v78);
    v79 = (const char *)sub_473493((int)&unk_476CFC);
    fprintf(v2, v79);
    v80 = (const char *)sub_473493((int)&unk_476D1C);
    fprintf(v2, v80);
    v81 = (const char *)sub_473493((int)&unk_476D5C);
    fprintf(v2, v81);
    v82 = (const char *)sub_473493((int)&unk_476CD4);
    fprintf(v2, v82);
    v83 = (const char *)sub_473493((int)&unk_476D70);
    fprintf(v2, v83);
    v84 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v84);
    v85 = (const char *)sub_473493((int)&unk_476D90);
    fprintf(v2, v85);
    v86 = (const char *)sub_473493((int)&unk_476DB8);
    fprintf(v2, v86);
    v87 = (const char *)sub_473493((int)&unk_476E08);
    fprintf(v2, v87);
    v88 = (const char *)sub_473493((int)&unk_476E58);
    fprintf(v2, v88);
    v89 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v89);
    v90 = (const char *)sub_473493((int)&unk_476EA4);
    fprintf(v2, v90);
    v91 = (const char *)sub_473493((int)&unk_476EC0);
    fprintf(v2, v91);
    v92 = (const char *)sub_473493((int)&unk_476EF8);
    fprintf(v2, v92);
    v93 = (const char *)sub_473493((int)&unk_476F00);
    fprintf(v2, v93);
    v94 = (const char *)sub_473493((int)&unk_476F20);
    fprintf(v2, v94);
    v95 = (const char *)sub_473493((int)&unk_476EF8);
    fprintf(v2, v95);
    v96 = (const char *)sub_473493((int)&unk_476F68);
    fprintf(v2, v96);
    v97 = (const char *)sub_473493((int)&unk_476F88);
    fprintf(v2, v97);
    v98 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v98);
    v99 = (const char *)sub_473493((int)&unk_476FCC);
    fprintf(v2, v99);
    v100 = (const char *)sub_473493((int)&unk_476FF0);
    fprintf(v2, v100);
    v101 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v101);
    v102 = (const char *)sub_473493((int)&unk_477034);
    fprintf(v2, v102);
    v103 = (const char *)sub_473493((int)&unk_477048);
    fprintf(v2, v103);
    v104 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v104);
    v105 = (const char *)sub_473493((int)&unk_477080);
    fprintf(v2, v105);
    v106 = (const char *)sub_473493((int)&unk_477094);
    fprintf(v2, v106);
    v107 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v107);
    v108 = (const char *)sub_473493((int)&unk_4770CC);
    fprintf(v2, v108);
    v109 = (const char *)sub_473493((int)&unk_4770E0);
    fprintf(v2, v109);
    v110 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v110);
    v111 = (const char *)sub_473493((int)&unk_477124);
    fprintf(v2, v111);
    v112 = (const char *)sub_473493((int)&unk_477138);
    fprintf(v2, v112);
    v113 = (const char *)sub_473493((int)&unk_477184);
    fprintf(v2, v113);
    v114 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v114);
    v115 = (const char *)sub_473493((int)&unk_477194);
    fprintf(v2, v115);
    v116 = (const char *)sub_473493((int)&unk_4771A8);
    fprintf(v2, v116);
    v117 = (const char *)sub_473493((int)&unk_4771F4);
    fprintf(v2, v117);
    v118 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v118);
    v119 = (const char *)sub_473493((int)&unk_477218);
    fprintf(v2, v119);
    v120 = (const char *)sub_473493((int)&unk_477230);
    fprintf(v2, v120);
    v121 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v121);
    v122 = (const char *)sub_473493((int)&unk_477270);
    fprintf(v2, v122);
    v123 = (const char *)sub_473493((int)&unk_477284);
    fprintf(v2, v123);
    v124 = (const char *)sub_473493((int)&unk_4772C0);
    fprintf(v2, v124);
    v125 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v125);
    v126 = (const char *)sub_473493((int)&unk_477308);
    fprintf(v2, v126);
    v127 = (const char *)sub_473493((int)&unk_477324);
    fprintf(v2, v127);
    v128 = (const char *)sub_473493((int)&unk_477340);
    fprintf(v2, v128);
    v129 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v129);
    v130 = (const char *)sub_473493((int)&unk_477390);
    fprintf(v2, v130);
    v131 = (const char *)sub_473493((int)&unk_4773D8);
    fprintf(v2, v131);
    v132 = (const char *)sub_473493((int)&unk_477430);
    fprintf(v2, v132);
    v133 = (const char *)sub_473493((int)&unk_477480);
    fprintf(v2, v133);
    v134 = (const char *)sub_473493((int)&unk_476CD4);
    fprintf(v2, v134);
    v135 = (const char *)sub_473493((int)&unk_4774A0);
    fprintf(v2, v135);
    v136 = (const char *)sub_473493((int)&unk_4774BC);
    fprintf(v2, v136);
    v137 = (const char *)sub_473493((int)&unk_4774F8);
    fprintf(v2, v137);
    v138 = (const char *)sub_473493((int)&unk_477524);
    fprintf(v2, v138);
    v139 = (const char *)sub_473493((int)&unk_477560);
    fprintf(v2, v139);
    v140 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v140);
    v141 = (const char *)sub_473493((int)&unk_4775B0);
    fprintf(v2, v141);
    v142 = (const char *)sub_473493((int)&unk_4775F8);
    fprintf(v2, v142);
    v143 = (const char *)sub_473493((int)&unk_477634);
    fprintf(v2, v143);
    v144 = (const char *)sub_473493((int)&unk_477664);
    fprintf(v2, v144);
    v145 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v145);
    v146 = (const char *)sub_473493((int)&unk_47768C);
    fprintf(v2, v146);
    v147 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v147);
    v148 = (const char *)sub_473493((int)&unk_4776C4);
    fprintf(v2, v148);
    v149 = (const char *)sub_473493((int)&unk_4776E0);
    fprintf(v2, v149);
    v150 = (const char *)sub_473493((int)&unk_477730);
    fprintf(v2, v150);
    v151 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v151);
    v152 = (const char *)sub_473493((int)&unk_477780);
    fprintf(v2, v152);
    v153 = (const char *)sub_473493((int)&unk_4777A0);
    fprintf(v2, v153);
    v154 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v154);
    v155 = (const char *)sub_473493((int)&unk_4777FC);
    fprintf(v2, v155);
    v156 = (const char *)sub_473493((int)&unk_477808);
    fprintf(v2, v156);
    v157 = (const char *)sub_473493((int)&unk_477858);
    fprintf(v2, v157);
    v158 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v158);
    v159 = (const char *)sub_473493((int)&unk_47787C);
    fprintf(v2, v159);
    v160 = (const char *)sub_473493((int)&unk_4778A0);
    fprintf(v2, v160);
    v161 = (const char *)sub_473493((int)&unk_477918);
    fprintf(v2, v161);
    v162 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v162);
    v163 = (const char *)sub_473493((int)&unk_4779CC);
    fprintf(v2, v163);
    v164 = (const char *)sub_473493((int)&unk_4779E8);
    fprintf(v2, v164);
    v165 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v165);
    v166 = (const char *)sub_473493((int)&unk_477A38);
    fprintf(v2, v166);
    v167 = (const char *)sub_473493((int)&unk_477A60);
    fprintf(v2, v167);
    v168 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v168);
    v169 = (const char *)sub_473493((int)&unk_477AA0);
    fprintf(v2, v169);
    v170 = (const char *)sub_473493((int)&unk_477AC8);
    fprintf(v2, v170);
    v171 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v171);
    v172 = (const char *)sub_473493((int)&unk_477B0C);
    fprintf(v2, v172);
    v173 = (const char *)sub_473493((int)&unk_477B24);
    fprintf(v2, v173);
    v174 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v174);
    v175 = (const char *)sub_473493((int)&unk_477B60);
    fprintf(v2, v175);
    v176 = (const char *)sub_473493((int)&unk_477B80);
    fprintf(v2, v176);
    v177 = (const char *)sub_473493((int)&unk_477BC8);
    fprintf(v2, v177);
    v178 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v178);
    v179 = (const char *)sub_473493((int)&unk_477C00);
    fprintf(v2, v179);
    v180 = (const char *)sub_473493((int)&unk_477C20);
    fprintf(v2, v180);
    v181 = (const char *)sub_473493((int)&unk_477C68);
    fprintf(v2, v181);
    v182 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v182);
    v183 = (const char *)sub_473493((int)&unk_477C7C);
    fprintf(v2, v183);
    v184 = (const char *)sub_473493((int)&unk_477C98);
    fprintf(v2, v184);
    v185 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v185);
    v186 = (const char *)sub_473493((int)&unk_477CE4);
    fprintf(v2, v186);
    v187 = (const char *)sub_473493((int)&unk_477D08);
    fprintf(v2, v187);
    v188 = (const char *)sub_473493((int)&unk_477D50);
    fprintf(v2, v188);
    v189 = (const char *)sub_473493((int)&unk_477D98);
    fprintf(v2, v189);
    v190 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v190);
    v191 = (const char *)sub_473493((int)&unk_477DC8);
    fprintf(v2, v191);
    v192 = (const char *)sub_473493((int)&unk_477DE8);
    fprintf(v2, v192);
    v193 = (const char *)sub_473493((int)&unk_477E34);
    fprintf(v2, v193);
    v194 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v194);
    v195 = (const char *)sub_473493((int)&unk_477E48);
    fprintf(v2, v195);
    v196 = (const char *)sub_473493((int)&unk_477E60);
    fprintf(v2, v196);
    v197 = (const char *)sub_473493((int)&unk_477EB0);
    fprintf(v2, v197);
    v198 = (const char *)sub_473493((int)&unk_477EFC);
    fprintf(v2, v198);
    v199 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v199);
    v200 = (const char *)sub_473493((int)&unk_477F18);
    fprintf(v2, v200);
    v201 = (const char *)sub_473493((int)&unk_477F30);
    fprintf(v2, v201);
    v202 = (const char *)sub_473493((int)&unk_477F80);
    fprintf(v2, v202);
    v203 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v203);
    v204 = (const char *)sub_473493((int)&unk_477FAC);
    fprintf(v2, v204);
    v205 = (const char *)sub_473493((int)&unk_477FD0);
    fprintf(v2, v205);
    v206 = (const char *)sub_473493((int)&unk_478028);
    fprintf(v2, v206);
    v207 = (const char *)sub_473493((int)&unk_478078);
    fprintf(v2, v207);
    v208 = (const char *)sub_473493((int)&unk_4780C8);
    fprintf(v2, v208);
    v209 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v209);
    v210 = (const char *)sub_473493((int)&unk_4780D4);
    fprintf(v2, v210);
    v211 = (const char *)sub_473493((int)&unk_4780F8);
    fprintf(v2, v211);
    v212 = (const char *)sub_473493((int)&unk_478140);
    fprintf(v2, v212);
    v213 = (const char *)sub_473493((int)&unk_478188);
    fprintf(v2, v213);
    v214 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v214);
    v215 = (const char *)sub_473493((int)&unk_478198);
    fprintf(v2, v215);
    v216 = (const char *)sub_473493((int)&unk_4781E8);
    fprintf(v2, v216);
    v217 = (const char *)sub_473493((int)&unk_478230);
    fprintf(v2, v217);
    v218 = (const char *)sub_473493((int)&unk_478280);
    fprintf(v2, v218);
    v219 = (const char *)sub_473493((int)&unk_4782C8);
    fprintf(v2, v219);
    v220 = (const char *)sub_473493((int)&unk_478310);
    fprintf(v2, v220);
    v221 = (const char *)sub_473493((int)&unk_47835C);
    fprintf(v2, v221);
    v222 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v222);
    v223 = (const char *)sub_473493((int)&unk_47837C);
    fprintf(v2, v223);
    v224 = (const char *)sub_473493((int)&unk_4783B0);
    fprintf(v2, v224);
    v225 = (const char *)sub_473493((int)&unk_478400);
    fprintf(v2, v225);
    v226 = (const char *)sub_473493((int)&unk_478448);
    fprintf(v2, v226);
    v227 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v227);
    v228 = (const char *)sub_473493((int)&unk_478478);
    fprintf(v2, v228);
    v229 = (const char *)sub_473493((int)&unk_4784A0);
    fprintf(v2, v229);
    v230 = (const char *)sub_473493((int)&unk_4784E4);
    fprintf(v2, v230);
    v231 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v231);
    v232 = (const char *)sub_473493((int)&unk_47851C);
    fprintf(v2, v232);
    v233 = (const char *)sub_473493((int)&unk_478540);
    fprintf(v2, v233);
    v234 = (const char *)sub_473493((int)&unk_476CD4);
    fprintf(v2, v234);
    v235 = (const char *)sub_473493((int)&unk_478590);
    fprintf(v2, v235);
    v236 = (const char *)sub_473493((int)&unk_47859C);
    fprintf(v2, v236);
    v237 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v237);
    v238 = (const char *)sub_473493((int)&unk_4785A4);
    fprintf(v2, v238);
    v239 = (const char *)sub_473493((int)&unk_4785C0);
    fprintf(v2, v239);
    v240 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v240);
    v241 = (const char *)sub_473493((int)&unk_478604);
    fprintf(v2, v241);
    v242 = (const char *)sub_473493((int)&unk_478620);
    fprintf(v2, v242);
    v243 = (const char *)sub_473493((int)&unk_47866C);
    fprintf(v2, v243);
    v244 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v244);
    v245 = (const char *)sub_473493((int)&unk_478680);
    fprintf(v2, v245);
    v246 = (const char *)sub_473493((int)&unk_4786A8);
    fprintf(v2, v246);
    v247 = (const char *)sub_473493((int)&unk_4786F8);
    fprintf(v2, v247);
    v248 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v248);
    v249 = (const char *)sub_473493((int)&unk_47873C);
    fprintf(v2, v249);
    v250 = (const char *)sub_473493((int)&unk_478758);
    fprintf(v2, v250);
    v251 = (const char *)sub_473493((int)&unk_4787B0);
    fprintf(v2, v251);
    v252 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v252);
    v253 = (const char *)sub_473493((int)&unk_4787F0);
    fprintf(v2, v253);
    v254 = (const char *)sub_473493((int)&unk_478810);
    fprintf(v2, v254);
    v255 = (const char *)sub_473493((int)&unk_47885C);
    fprintf(v2, v255);
    v256 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v256);
    v257 = (const char *)sub_473493((int)&unk_478874);
    fprintf(v2, v257);
    v258 = (const char *)sub_473493((int)&unk_478888);
    fprintf(v2, v258);
    v259 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v259);
    v260 = (const char *)sub_473493((int)&unk_4788C4);
    fprintf(v2, v260);
    v261 = (const char *)sub_473493((int)&unk_4788D8);
    fprintf(v2, v261);
    v262 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v262);
    v263 = (const char *)sub_473493((int)&unk_47890C);
    fprintf(v2, v263);
    v264 = (const char *)sub_473493((int)&unk_478920);
    fprintf(v2, v264);
    v265 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v265);
    v266 = (const char *)sub_473493((int)&unk_478940);
    fprintf(v2, v266);
    v267 = (const char *)sub_473493((int)&unk_478950);
    fprintf(v2, v267);
    v268 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v268);
    v269 = (const char *)sub_473493((int)&unk_478968);
    fprintf(v2, v269);
    v270 = (const char *)sub_473493((int)&unk_47650C);
    fprintf(v2, v270);
  }
  return fflush(v2);
}
// 4AE29C: using guessed type int dword_4AE29C;

//----- (00403A70) --------------------------------------------------------
char *__usercall sub_403A70@<eax>(char **a1@<ebx>)
{
  char *v1; // esi
  char v2; // al
  char *result; // eax
  char *v4; // edi
  char v5; // al

  v1 = *a1;
  v2 = **a1;
  if ( !v2 )
    return 0;
  while ( isspace(v2) )
  {
    v2 = *++v1;
    if ( !v2 )
      return 0;
  }
  if ( !*v1 )
    return 0;
  v4 = v1;
  if ( *v1 )
  {
    do
    {
      if ( *v1 == 44 )
        break;
      if ( isspace(*v1) )
        break;
      ++v1;
    }
    while ( *v1 );
    if ( *v1 )
    {
      *v1 = 0;
      v5 = *++v1;
      if ( v5 )
      {
        while ( isspace(v5) )
        {
          v5 = *++v1;
          if ( !v5 )
          {
            result = v4;
            *a1 = v1;
            return result;
          }
        }
        if ( *v1 == 44 )
          ++v1;
      }
    }
  }
  result = v4;
  *a1 = v1;
  return result;
}

//----- (00403B20) --------------------------------------------------------
int __usercall sub_403B20@<eax>(char *a1@<eax>, _DWORD *a2@<edi>)
{
  char *i; // esi
  const char *v3; // eax
  const char *v4; // eax
  const char *v5; // eax
  const char *v6; // eax
  const char *v7; // eax
  const char *v8; // eax
  const char *v9; // eax
  const char *v11; // eax
  char *v12; // [esp+Ch] [ebp-4h] BYREF

  v12 = a1;
  for ( i = sub_403A70(&v12); i; i = sub_403A70(&v12) )
  {
    v3 = (const char *)sub_473493((int)&unk_4789B0);
    if ( !_stricmp(i, v3) )
    {
      a2[110] = 1;
    }
    else
    {
      v4 = (const char *)sub_473493((int)&unk_4789BC);
      if ( !_stricmp(i, v4) )
      {
        a2[109] = 1;
      }
      else
      {
        v5 = (const char *)sub_473493((int)&unk_4789C8);
        if ( !_stricmp(i, v5) )
        {
          a2[111] = 1;
        }
        else
        {
          v6 = (const char *)sub_473493((int)&unk_4789D4);
          if ( !_stricmp(i, v6) )
          {
            a2[107] = 1;
          }
          else
          {
            v7 = (const char *)sub_473493((int)&unk_4789E0);
            if ( !_stricmp(i, v7) )
            {
              a2[108] = 1;
            }
            else
            {
              v8 = (const char *)sub_473493((int)&unk_4789EC);
              if ( !_stricmp(i, v8) )
              {
                a2[109] = 1;
                a2[110] = 1;
                a2[111] = 1;
                a2[107] = 1;
                a2[108] = 1;
              }
              else
              {
                v9 = (const char *)sub_473493((int)&unk_4789F4);
                if ( _stricmp(i, v9) )
                {
                  v11 = (const char *)sub_473493((int)&unk_4789FC);
                  sub_4078E0(v11, i);
                }
              }
            }
          }
        }
      }
    }
  }
  return 1;
}

//----- (00403C70) --------------------------------------------------------
_DWORD *__cdecl sub_403C70(int a1, int *a2)
{
  unsigned int v2; // esi
  void *v3; // eax
  _DWORD *v4; // ebp
  unsigned int i; // esi
  const char *v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // ecx
  int v10; // eax
  const char *v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // ecx
  int v15; // eax
  const char *v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // ecx
  int v20; // eax
  const char *v21; // eax
  int v22; // eax
  int v23; // eax
  int v24; // ecx
  int v25; // eax
  char *v26; // eax
  int v27; // esi
  const char *v28; // eax
  const char *v29; // esi
  void *v30; // eax
  const char *v31; // eax
  unsigned int v32; // eax
  char v33; // cl
  const char *v34; // eax
  void *v35; // eax
  const char *v36; // eax
  const char *v37; // eax
  const char *v38; // eax
  const char *v39; // eax
  int v40; // eax
  int v41; // ecx
  int v42; // eax
  int v43; // eax
  int v44; // ecx
  int v45; // eax
  int v46; // eax
  unsigned int v47; // esi
  char *v48; // ebx
  char v49; // al
  int v50; // eax
  int v51; // eax
  int v52; // ecx
  int v53; // eax
  int v54; // eax
  int v55; // ecx
  int v56; // eax
  int v57; // eax
  unsigned int v58; // edi
  char *v59; // esi
  char v60; // al
  int v61; // eax
  int v62; // eax
  int v63; // ecx
  int v64; // eax
  int v65; // esi
  _WORD *v66; // edi
  char v67; // al
  _WORD *v68; // edi
  char v69; // al
  const char *v70; // eax
  const char *v71; // eax
  const char *v72; // eax
  const char *v73; // eax
  const char *v74; // eax
  char *v75; // eax
  char *v76; // edi
  BOOL v77; // esi
  int v78; // eax
  int v79; // eax
  int v80; // ecx
  int v81; // eax
  int v82; // ecx
  int v83; // eax
  unsigned int v84; // edi
  char *v85; // eax
  char v86; // cl
  int v87; // eax
  int v88; // ecx
  int v89; // eax
  int v90; // eax
  char *v91; // esi
  int v92; // eax
  const char **v93; // edi
  int v94; // eax
  int v95; // ecx
  int v96; // eax
  int v97; // ecx
  const char *v98; // ebx
  char *v99; // esi
  int v100; // eax
  const char *v101; // edi
  int v102; // eax
  int v103; // ecx
  int v104; // eax
  int v105; // ecx
  int v106; // eax
  int v107; // eax
  int v108; // ecx
  int v109; // eax
  int v110; // eax
  int v111; // eax
  int v112; // eax
  int v113; // ecx
  int v114; // eax
  int v115; // eax
  int v116; // ecx
  int v117; // eax
  int v118; // eax
  char *v119; // eax
  const char *v120; // eax
  int j; // eax
  CHAR *v122; // eax
  char *v123; // esi
  int v124; // eax
  int v125; // ecx
  int v126; // eax
  int v127; // eax
  int v128; // eax
  const char *v130; // eax
  const char *v131; // eax
  const char *v132; // eax
  const char *v133; // eax
  const char *v134; // eax
  const char *v135; // eax
  const char *v136; // eax
  const char *v137; // eax
  char *v138; // [esp-8h] [ebp-64h]
  void *v139; // [esp-4h] [ebp-60h]
  void *v140; // [esp-4h] [ebp-60h]
  const char *v141; // [esp-4h] [ebp-60h]
  int v142; // [esp-4h] [ebp-60h]
  int v143; // [esp-4h] [ebp-60h]
  const char *v144; // [esp-4h] [ebp-60h]
  int v145; // [esp-4h] [ebp-60h]
  int v146; // [esp-4h] [ebp-60h]
  int v147; // [esp-4h] [ebp-60h]
  int v148; // [esp-4h] [ebp-60h]
  char *v149; // [esp-4h] [ebp-60h]
  int v150; // [esp+10h] [ebp-4Ch] BYREF
  int v151; // [esp+14h] [ebp-48h] BYREF
  int *v152; // [esp+18h] [ebp-44h]
  int v153; // [esp+1Ch] [ebp-40h]
  int v154; // [esp+20h] [ebp-3Ch]
  int v155; // [esp+24h] [ebp-38h]
  int v156; // [esp+28h] [ebp-34h] BYREF
  _DWORD v157[11]; // [esp+2Ch] [ebp-30h] BYREF

  v2 = 0;
  v152 = a2;
  v153 = 0;
  v154 = 0;
  v155 = 1;
  v3 = (void *)off_4A4FE4(544);
  v4 = memset(v3, 0, 0x220u);
  if ( !dword_4A80D0 )
  {
    do
    {
      *(void **)((char *)&off_4A5318 + v2) = (void *)sub_473493(*(int *)((char *)&off_4A5318 + v2));
      v2 += 16;
    }
    while ( v2 < 0x5C0 );
    for ( i = 0; i < 0x70; i += 8 )
      *(void **)((char *)&off_4A58EC + i) = (void *)sub_473493(*(int *)((char *)&off_4A58EC + i));
    dword_4A80D0 = 1;
  }
  v4[59] = 0;
  v4[1] = 1;
  v4[6] = 1;
  v4[107] = 0;
  v4[108] = 0;
  v4[10] = 1;
  v4[115] = 0;
  v4[116] = 0;
  v4[117] = 0;
  v4[11] = 0;
  v4[12] = 8;
  v4[13] = 8;
  v4[14] = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(288);
  v4[54] = 0;
  v4[55] = 16;
  v4[56] = 16;
  v4[57] = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(576);
  v4[130] = 0;
  v4[131] = 8;
  v4[132] = 8;
  v4[133] = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(288);
  v4[40] = 0;
  v4[41] = 2;
  v4[42] = 2;
  v4[43] = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(8);
  v4[50] = 0;
  v4[51] = 0;
  v4[52] = 32;
  v4[53] = 0;
  v4[124] = 0;
  v4[125] = 0;
  v4[126] = 32;
  v4[127] = 0;
  v4[77] = 0;
  v4[78] = 0;
  v4[79] = 32;
  v4[80] = 0;
  v4[69] = 0;
  v4[70] = 0;
  v4[71] = 32;
  v4[72] = 0;
  v4[31] = 0;
  v4[32] = 0;
  v4[33] = 32;
  v4[34] = 0;
  v4[61] = 0;
  v4[62] = 0;
  v4[63] = 32;
  v4[64] = 0;
  v4[65] = 0;
  v4[66] = 0;
  v4[67] = 32;
  v4[68] = 0;
  v4[27] = 0;
  v4[28] = 0;
  v4[29] = 32;
  v4[30] = 0;
  v4[73] = 0;
  v4[74] = 0;
  v4[75] = 32;
  v4[76] = 0;
  v4[81] = 0;
  v4[82] = 0;
  v4[83] = 32;
  v4[84] = 0;
  v4[85] = 0;
  v4[86] = 0;
  v4[87] = 32;
  v4[88] = 0;
  v4[25] = 1;
  *v4 = 1;
  v4[104] = 1;
  v4[103] = 1;
  v4[106] = 0;
  v6 = (const char *)sub_473493((int)&unk_478A20);
  v157[0] = _strdup(v6);
  v7 = v4[12];
  v157[1] = 1;
  memset(&v157[2], 0, 12);
  v157[5] = 1;
  v157[6] = 1;
  v157[7] = 0;
  v157[8] = 0;
  if ( v4[11] == v7 )
  {
    v8 = v4[13] + v7;
    v9 = v4[14];
    v4[12] = v8;
    if ( v9 )
      v10 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v9, 36 * v8);
    else
      v10 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(36 * v8);
    v4[14] = v10;
  }
  qmemcpy((void *)(v4[14] + 36 * v4[11]++), v157, 0x24u);
  v11 = (const char *)sub_473493((int)&unk_478A28);
  v157[0] = _strdup(v11);
  v12 = v4[12];
  if ( v4[11] == v12 )
  {
    v13 = v4[13] + v12;
    v14 = v4[14];
    v4[12] = v13;
    if ( v14 )
      v15 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v14, 36 * v13);
    else
      v15 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(36 * v13);
    v4[14] = v15;
  }
  qmemcpy((void *)(v4[14] + 36 * v4[11]++), v157, 0x24u);
  v16 = (const char *)sub_473493((int)&unk_478A34);
  v157[0] = _strdup(v16);
  v17 = v4[12];
  if ( v4[11] == v17 )
  {
    v18 = v4[13] + v17;
    v19 = v4[14];
    v4[12] = v18;
    if ( v19 )
      v20 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v19, 36 * v18);
    else
      v20 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(36 * v18);
    v4[14] = v20;
  }
  qmemcpy((void *)(v4[14] + 36 * v4[11]++), v157, 0x24u);
  v21 = (const char *)sub_473493((int)&unk_478A40);
  v157[0] = _strdup(v21);
  v22 = v4[12];
  if ( v4[11] == v22 )
  {
    v23 = v4[13] + v22;
    v24 = v4[14];
    v4[12] = v23;
    if ( v24 )
      v25 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v24, 36 * v23);
    else
      v25 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(36 * v23);
    v4[14] = v25;
  }
  qmemcpy((void *)(v4[14] + 36 * v4[11]++), v157, 0x24u);
  v4[122] = 0;
  v4[123] = -1;
  dword_4A4E24 = 1;
  v150 = 0;
  v26 = (char *)sub_473493((int)&unk_478A4C);
  v27 = sub_4103A7(a1, v152, v26, &v150);
  v151 = v27;
  if ( v27 != -1 )
  {
    do
    {
      switch ( v27 )
      {
        case 65:
          v4[116] = 1;
          goto LABEL_224;
        case 66:
          v4[115] = 1;
          goto LABEL_224;
        case 73:
        case 75:
          v84 = strlen(ArgList);
          v85 = _strdup(ArgList);
          v86 = v85[v84 - 1];
          if ( v86 == 47 || v86 == 92 )
          {
            v157[4] = 1;
            v85[v84 - 1] = 0;
          }
          else
          {
            v157[4] = 0;
          }
          v157[0] = v85;
          v157[1] = v27 == 75;
          v157[5] = strpbrk(v85, "*[?") != 0;
          v157[8] = dword_4A5300++;
          v87 = v4[55];
          v157[6] = 0;
          v157[2] = 0;
          v157[3] = 0;
          v157[7] = 0;
          if ( v4[54] == v87 )
          {
            v88 = v4[57];
            v89 = v4[56] + v87;
            v4[55] = v89;
            v145 = 36 * v89;
            if ( v88 )
              v90 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v88, v145);
            else
              v90 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(v145);
            v4[57] = v90;
          }
          qmemcpy((void *)(v4[57] + 36 * v4[54]++), v157, 0x24u);
          goto LABEL_224;
        case 83:
          v4[2] = 1;
          v4[1] = 0;
          goto LABEL_224;
        case 86:
          v65 = sub_473493((int)&unk_478C94);
          strcpy((char *)v157, "12.0");
          v66 = (_WORD *)((char *)&v156 + 3);
          do
          {
            v67 = *((_BYTE *)v66 + 1);
            v66 = (_WORD *)((char *)v66 + 1);
          }
          while ( v67 );
          *v66 = 46;
          v68 = (_WORD *)((char *)&v156 + 3);
          do
          {
            v69 = *((_BYTE *)v68 + 1);
            v68 = (_WORD *)((char *)v68 + 1);
          }
          while ( v69 );
          *v68 = 50;
          v70 = (const char *)sub_473493((int)&unk_478CAC);
          printf(v70, v157);
          printf("\n");
          v71 = (const char *)sub_473493((int)&unk_478CDC);
          printf(v71, v65);
          v72 = (const char *)sub_473493((int)&unk_478CF4);
          printf(v72);
          v154 = 1;
          goto LABEL_224;
        case 88:
          sub_4025B0();
          goto LABEL_224;
        case 101:
        case 105:
        case 205:
        case 210:
        case 211:
          v47 = strlen(ArgList);
          v48 = _strdup(ArgList);
          v49 = v48[v47 - 1];
          if ( v49 == 47 || v49 == 92 )
          {
            v48[v47 - 1] = 0;
            v157[4] = 1;
          }
          else
          {
            v157[4] = 0;
          }
          v157[5] = strpbrk(v48, "*[?") != 0;
          v157[6] = 0;
          if ( v4[54] )
          {
            v157[1] = 1;
            v157[3] = 0;
            v157[2] = 0;
            v157[0] = _strdup(v48);
            v157[8] = dword_4A5300++;
            v50 = v4[55];
            v157[7] = 1;
            if ( v4[54] == v50 )
            {
              v51 = v4[56] + v50;
              v52 = v4[57];
              v4[55] = v51;
              if ( v52 )
                v53 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v52, 36 * v51);
              else
                v53 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(36 * v51);
              v4[57] = v53;
            }
            qmemcpy((void *)(v4[57] + 36 * v4[54]++), v157, 0x24u);
          }
          v157[1] = v151 != 101;
          if ( v151 == 205 || (v157[3] = 0, v151 == 211) )
            v157[3] = 1;
          if ( v151 == 210 || (v157[2] = 0, v151 == 211) )
            v157[2] = 1;
          v157[8] = dword_4A5300++;
          v54 = v4[12];
          v157[0] = v48;
          v157[7] = 0;
          if ( v4[11] == v54 )
          {
            v55 = v4[14];
            v56 = v4[13] + v54;
            v4[12] = v56;
            v143 = 36 * v56;
            if ( v55 )
              v57 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v55, v143);
            else
              v57 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(v143);
            v4[14] = v57;
          }
          qmemcpy((void *)(v4[14] + 36 * v4[11]++), v157, 0x24u);
          goto LABEL_224;
        case 104:
          sub_402740();
          v153 = 1;
          goto LABEL_224;
        case 111:
          v34 = (const char *)v4[3];
          if ( !v34 )
            goto LABEL_57;
          if ( v4[49] )
          {
            v35 = (void *)sub_473493((int)&unk_478A64);
          }
          else
          {
            if ( !strcmp(v34, ArgList) )
              goto LABEL_57;
            v35 = &unk_478A70;
          }
          v140 = v35;
          v138 = ArgList;
          v36 = (const char *)sub_473493((int)&unk_478A9C);
          sub_407970(v36, v138, v140);
LABEL_57:
          v141 = ArgList;
          v4[49] = 0;
          v4[3] = _strdup(v141);
          goto LABEL_224;
        case 118:
          v4[38] = 1;
          goto LABEL_224;
        case 128:
          v4[6] = 0;
          goto LABEL_224;
        case 133:
          v4[5] = 1;
          goto LABEL_224;
        case 134:
        case 143:
          goto LABEL_224;
        case 135:
          v4[10] = 1;
          goto LABEL_224;
        case 136:
          v4[15] = 1;
          goto LABEL_224;
        case 137:
          v4[16] = 1;
          goto LABEL_224;
        case 138:
          v4[20] = 1;
          goto LABEL_224;
        case 139:
          v4[21] = 1;
          goto LABEL_224;
        case 140:
          v4[22] = 1;
          goto LABEL_224;
        case 141:
          goto LABEL_81;
        case 142:
          v4[25] = 1;
          goto LABEL_224;
        case 144:
          v4[26] = 1;
          goto LABEL_224;
        case 145:
          v157[0] = _strdup(ArgList);
          dword_4A728C = ArgList;
          dword_4A7288 = 258;
          dword_4A80EC = 0;
          if ( sub_40C420(&v157[1]) )
          {
            v133 = (const char *)sub_473493((int)&unk_4825D0);
            sub_4078E0(v133);
          }
          v40 = v4[28];
          if ( v4[27] != v40 )
            goto LABEL_89;
          v41 = v4[30];
          v42 = v4[29] + v40;
          v4[28] = v42;
          v142 = 44 * v42;
          if ( !v41 )
            goto LABEL_86;
          goto LABEL_87;
        case 146:
          v132 = (const char *)sub_473408((int)&unk_478B38);
          sub_4078E0(v132);
        case 152:
          v4[44] = 1;
          goto LABEL_224;
        case 153:
          v4[45] = _strdup(ArgList);
          goto LABEL_224;
        case 154:
          v4[46] = _strdup(ArgList);
          goto LABEL_224;
        case 155:
        case 156:
          v76 = _strdup(ArgList);
          v77 = v27 == 155;
          v78 = v4[51];
          if ( v4[50] == v78 )
          {
            v79 = v4[52] + v78;
            v80 = v4[53];
            v4[51] = v79;
            if ( v80 )
              v81 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v80, 8 * v79);
            else
              v81 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(8 * v79);
            v4[53] = v81;
          }
          v82 = v4[50];
          v83 = v4[53];
          *(_DWORD *)(v83 + 8 * v82) = v77;
          *(_DWORD *)(v83 + 8 * v82 + 4) = v76;
          ++v4[50];
          goto LABEL_224;
        case 157:
          v4[47] = _strdup(ArgList);
          goto LABEL_224;
        case 158:
          v4[48] = _strdup(ArgList);
          goto LABEL_224;
        case 161:
          v28 = (const char *)v4[3];
          v29 = ArgList;
          if ( !v28 )
            goto LABEL_46;
          if ( v4[49] )
          {
            if ( !strcmp(v28, ArgList) )
              goto LABEL_46;
            v30 = (void *)sub_473493((int)&unk_478A64);
            v29 = ArgList;
          }
          else
          {
            v30 = &unk_478A70;
          }
          v139 = v30;
          v31 = (const char *)sub_473493((int)&unk_478A74);
          sub_407970(v31, v29, v139);
          v29 = ArgList;
LABEL_46:
          if ( *v29 )
          {
            v32 = strlen(v29);
            v33 = v29[v32 - 1];
            if ( v33 == 92 || v33 == 47 )
              v29[v32 - 1] = 0;
          }
          v4[49] = 1;
          v4[3] = _strdup(v29);
          goto LABEL_224;
        case 162:
          v4[58] = _strdup(ArgList);
          goto LABEL_224;
        case 163:
          v4[59] = 1;
          goto LABEL_224;
        case 164:
          v4[59] = 2;
          goto LABEL_224;
        case 165:
          v4[60] = 1;
          goto LABEL_224;
        case 166:
          v91 = _strdup(ArgList);
          v92 = v4[86];
          v93 = (const char **)&unk_4A58E8;
          if ( v4[85] == v92 )
          {
            v94 = v4[87] + v92;
            v95 = v4[88];
            v4[86] = v94;
            if ( v95 )
              v96 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v95, 4 * v94);
            else
              v96 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(4 * v94);
            v4[88] = v96;
          }
          *(_DWORD *)(v4[88] + 4 * v4[85]++) = _strdup(ArgList);
          if ( isspace(*v91) )
          {
            do
              v97 = *++v91;
            while ( isspace(v97) );
          }
          v98 = v91;
          if ( !*v91 )
            goto LABEL_185;
          break;
        case 167:
          v157[0] = _strdup(ArgList);
          sub_40CF10(v44, &v157[1]);
          v45 = v4[28];
          if ( v4[27] != v45 )
            goto LABEL_89;
          v41 = v4[30];
          v46 = v4[29] + v45;
          v4[28] = v46;
          v142 = 44 * v46;
          if ( v41 )
LABEL_87:
            v43 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 12))(v41);
          else
LABEL_86:
            v43 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(v142);
          v4[30] = v43;
LABEL_89:
          qmemcpy((void *)(v4[30] + 44 * v4[27]++), v157, 0x2Cu);
          goto LABEL_224;
        case 168:
          v107 = v4[74];
          if ( v4[73] == v107 )
          {
            v108 = v4[76];
            v109 = v4[75] + v107;
            v4[74] = v109;
            v146 = 4 * v109;
            if ( v108 )
              v110 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v108, v146);
            else
              v110 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(v146);
            v4[76] = v110;
          }
          *(_DWORD *)(v4[76] + 4 * v4[73]++) = _strdup(ArgList);
          sub_402420(v4 + 65);
          goto LABEL_224;
        case 171:
          v111 = v4[82];
          if ( v4[81] == v111 )
          {
            v112 = v4[83] + v111;
            v113 = v4[84];
            v4[82] = v112;
            if ( v113 )
              v114 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v113, 4 * v112);
            else
              v114 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(4 * v112);
            v4[84] = v114;
          }
          *(_DWORD *)(v4[84] + 4 * v4[81]++) = _strdup(ArgList);
          sub_402520(v4);
          goto LABEL_224;
        case 172:
          if ( !_stricmp(ArgList, "max") )
          {
            v4[25] = 0;
            v4[24] = 0;
          }
          else
          {
            v39 = (const char *)sub_473493((int)&unk_478AFC);
            if ( _stricmp(ArgList, v39) )
            {
              v131 = (const char *)sub_473493((int)&unk_478B04);
              sub_4078E0(v131);
            }
LABEL_81:
            v4[24] = 1;
            v4[25] = 0;
          }
          goto LABEL_224;
        case 173:
          v4[7] = 0;
          goto LABEL_224;
        case 174:
          *v4 = 1;
          goto LABEL_224;
        case 175:
          *v4 = 0;
          goto LABEL_224;
        case 178:
          v4[35] = sub_4019C0();
          if ( v4[36] )
          {
            free((void *)v4[36]);
            v4[36] = 0;
          }
          if ( v4[37] )
          {
            free((void *)v4[37]);
            v4[37] = 0;
          }
          v4[36] = _strdup(ArgList);
          goto LABEL_224;
        case 179:
          v4[35] = Time + sub_4018B0();
          if ( v4[36] )
          {
            free((void *)v4[36]);
            v4[36] = 0;
          }
          if ( v4[37] )
          {
            free((void *)v4[37]);
            v4[37] = 0;
          }
          v4[37] = _strdup(ArgList);
          goto LABEL_224;
        case 181:
          v4[92] = 1;
          goto LABEL_224;
        case 182:
          v4[93] = _strdup(ArgList);
          goto LABEL_224;
        case 183:
          v37 = (const char *)sub_473493((int)&unk_478AC0);
          if ( !_stricmp(ArgList, v37) )
          {
            v4[94] = 0;
          }
          else
          {
            v38 = (const char *)sub_473493((int)&unk_478AC8);
            if ( _stricmp(ArgList, v38) )
            {
              v149 = ArgList;
              v130 = (const char *)sub_473493((int)&unk_478AD4);
              sub_4078E0(v130, v149);
            }
            v4[94] = 1;
          }
          goto LABEL_224;
        case 184:
          v4[95] = _strdup(ArgList);
          goto LABEL_224;
        case 186:
          v4[96] = _strdup(ArgList);
          goto LABEL_224;
        case 190:
          v4[23] = 1;
          goto LABEL_224;
        case 191:
          v4[99] = 1;
          goto LABEL_224;
        case 192:
          v4[98] = _strdup(ArgList);
          goto LABEL_224;
        case 194:
          v150 = 0;
          v156 = 0;
          v151 = 0;
          if ( !sub_401B00() )
          {
            if ( dword_4AE2A4 == 1 )
            {
              v134 = (const char *)sub_473493((int)&unk_478D20);
              sub_4078E0(v134);
            }
            v135 = (const char *)sub_473493((int)&unk_478D80);
            sub_4078E0(v135);
          }
          v73 = (const char *)sub_473493((int)&unk_478DE0);
          sscanf(ArgList, v73, &v150, &v156, &v151);
          v144 = ArgList;
          v4[90] = v151 + 100 * (v156 + 100 * v150);
          v4[91] = _strdup(v144);
          goto LABEL_224;
        case 195:
          v4[100] = 1;
          goto LABEL_224;
        case 196:
          v4[109] = 1;
          goto LABEL_224;
        case 197:
          v4[107] = 1;
          goto LABEL_224;
        case 198:
          v4[110] = 1;
          goto LABEL_224;
        case 199:
          v4[113] = _strdup(ArgList);
          goto LABEL_224;
        case 200:
          v4[114] = _strdup(ArgList);
          goto LABEL_224;
        case 201:
          v75 = _strdup(ArgList);
          sub_403B20(v75, v4);
          goto LABEL_224;
        case 202:
          v4[101] = 0;
          goto LABEL_224;
        case 203:
          v4[102] = 1;
          goto LABEL_224;
        case 204:
          v4[111] = 1;
          goto LABEL_224;
        case 212:
          v115 = v4[125];
          if ( v4[124] == v115 )
          {
            v116 = v4[127];
            v117 = v4[126] + v115;
            v4[125] = v117;
            v147 = 4 * v117;
            if ( v116 )
              v118 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v116, v147);
            else
              v118 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(v147);
            v4[127] = v118;
          }
          *(_DWORD *)(v4[127] + 4 * v4[124]++) = _strdup(ArgList);
          goto LABEL_224;
        case 214:
          v4[8] = 1;
          goto LABEL_224;
        case 215:
          v4[7] = 1;
          goto LABEL_224;
        case 216:
          v4[129] = 1;
          goto LABEL_224;
        case 218:
          v4[108] = 1;
          goto LABEL_224;
        case 224:
          v58 = strlen(ArgList);
          v59 = _strdup(ArgList);
          v60 = v59[v58 - 1];
          if ( v60 == 47 || v60 == 92 )
          {
            v157[4] = 1;
            v59[v58 - 1] = 0;
          }
          else
          {
            v157[4] = 0;
          }
          v157[5] = strpbrk(v59, "*[?") != 0;
          v157[8] = unk_4A5304++;
          v61 = v4[131];
          v157[6] = 0;
          v157[1] = 1;
          v157[3] = 0;
          v157[2] = 0;
          v157[0] = v59;
          v157[7] = 0;
          if ( v4[130] == v61 )
          {
            v62 = v4[132] + v61;
            v63 = v4[133];
            v4[131] = v62;
            if ( v63 )
              v64 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v63, 36 * v62);
            else
              v64 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(36 * v62);
            v4[133] = v64;
          }
          qmemcpy((void *)(v4[133] + 36 * v4[130]++), v157, 0x24u);
          goto LABEL_224;
        case 225:
          v4[39] = 1;
          goto LABEL_224;
        case 226:
          *((_BYTE *)v4 + 536) = 1;
          goto LABEL_224;
        case 237:
          v74 = (const char *)sub_473493((int)&unk_478DEC);
          sub_407970(v74);
          goto LABEL_224;
        case 240:
          v4[117] = 1;
          goto LABEL_224;
        case 242:
          v4[10] = 0;
          goto LABEL_224;
        default:
          v155 = 0;
          goto LABEL_224;
      }
      while ( *v91 != 61 )
      {
        if ( !*++v91 )
        {
LABEL_185:
          if ( *v91 != 61 )
          {
            v136 = (const char *)sub_473493((int)&unk_478E28);
            sub_4078E0(v136);
          }
          break;
        }
      }
      *v91 = 0;
      v99 = v91 + 1;
      if ( off_4A58EC )
      {
        do
        {
          if ( !_stricmp(v93[1], v98) )
            break;
          v93 += 2;
        }
        while ( v93[1] );
      }
      if ( !v93[1] )
      {
        v137 = (const char *)sub_473493((int)&unk_478E48);
        sub_4078E0(v137, v98);
      }
      v100 = v4[62];
      v101 = *v93;
      if ( v4[61] == v100 )
      {
        v102 = v4[63] + v100;
        v103 = v4[64];
        v4[62] = v102;
        if ( v103 )
          v104 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v103, 8 * v102);
        else
          v104 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(8 * v102);
        v4[64] = v104;
      }
      v105 = v4[61];
      v106 = v4[64];
      *(_DWORD *)(v106 + 8 * v105) = v101;
      *(_DWORD *)(v106 + 8 * v105 + 4) = v99;
      ++v4[61];
LABEL_224:
      v150 = 0;
      v119 = (char *)sub_473493((int)&unk_478A4C);
      v27 = sub_4103A7(a1, v152, v119, &v150);
      v151 = v27;
    }
    while ( v27 != -1 );
    if ( v153 || v154 )
      sub_4075F0(0);
    if ( !v155 )
    {
      v120 = (const char *)sub_473493((int)&unk_478E88);
      sub_4078E0(v120);
    }
  }
  for ( j = dword_4A4E24; j < a1; dword_4A4E24 = j )
  {
    v122 = sub_408210((const CHAR *)v152[j]);
    v123 = _strdup(v122);
    v124 = v4[41];
    if ( v4[40] == v124 )
    {
      v125 = v4[43];
      v126 = v4[42] + v124;
      v4[41] = v126;
      v148 = 4 * v126;
      if ( v125 )
        v127 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v125, v148);
      else
        v127 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(v148);
      v4[43] = v127;
    }
    *(_DWORD *)(v4[43] + 4 * v4[40]) = v123;
    v128 = dword_4A4E24;
    ++v4[40];
    j = v128 + 1;
  }
  return v4;
}
// 40429B: conditional instruction was optimized away because edi.4!=0
// 40435B: conditional instruction was optimized away because esi.4==0
// 4045CC: variable 'v44' is possibly undefined
// 4A4E24: using guessed type int dword_4A4E24;
// 4A4FE4: using guessed type int (__cdecl *off_4A4FE4)(_DWORD);
// 4A5300: using guessed type int dword_4A5300;
// 4A5318: using guessed type void *off_4A5318;
// 4A58EC: using guessed type void *off_4A58EC;
// 4A7288: using guessed type int dword_4A7288;
// 4A80D0: using guessed type int dword_4A80D0;
// 4A80EC: using guessed type int dword_4A80EC;
// 4AE2A4: using guessed type int dword_4AE2A4;

//----- (00405490) --------------------------------------------------------
_BYTE *__usercall sub_405490@<eax>(const char *a1@<eax>)
{
  const char *v1; // esi
  unsigned int v2; // kr00_4
  _BYTE *result; // eax
  char v4; // dl
  _BYTE *i; // ecx
  char v6; // dl
  size_t v7; // [esp-4h] [ebp-8h]

  v1 = a1;
  v2 = strlen(a1);
  if ( (int)(2 * v2) <= dword_4A80DC )
  {
    result = (_BYTE *)dword_4A80D8;
  }
  else
  {
    dword_4A80DC = 2 * v2;
    v7 = 2 * v2 + 1;
    if ( dword_4A80D8 )
      result = malloc(v7);
    else
      result = realloc(0, v7);
    dword_4A80D8 = (int)result;
  }
  v4 = *v1;
  for ( i = result; *v1; ++i )
  {
    if ( v4 == 39 || v4 == 92 )
      *i++ = 92;
    v6 = *v1++;
    *i = v6;
    v4 = *v1;
  }
  *i = 0;
  return result;
}
// 4A80D8: using guessed type int dword_4A80D8;
// 4A80DC: using guessed type int dword_4A80DC;

//----- (00405510) --------------------------------------------------------
int __usercall sub_405510@<eax>(_DWORD *a1@<ebx>, FILE *a2@<esi>)
{
  int *v2; // edi
  int v3; // ebp
  const char *const *v4; // ebp
  int v5; // eax
  const char **v6; // edi
  int v7; // eax
  const char *v8; // eax
  const char *v9; // eax
  unsigned int v10; // ebp
  int v11; // edi
  const char *v12; // eax
  unsigned int i; // edi
  const char *v14; // eax
  const char *v15; // eax
  const char *v16; // eax
  const char *v17; // eax
  const char *v18; // eax
  const char *v19; // eax
  const char *v20; // eax
  const char *v21; // eax
  int *v22; // edi
  const char *v23; // eax
  unsigned int j; // edi
  const char *v25; // eax
  unsigned int k; // edi
  const char *v27; // eax
  int v28; // eax
  int v29; // edi
  int v30; // ebp
  const char *v31; // eax
  unsigned int v32; // edi
  int v33; // ebp
  int v34; // edi
  const char *v35; // ebp
  const char *v36; // eax
  const char *v37; // eax
  const char *v38; // eax
  int v39; // eax
  bool v40; // zf
  const char *v41; // eax
  const char *v42; // eax
  int v43; // eax
  const char *v44; // eax
  const char *v45; // eax
  unsigned int m; // edi
  const char *v47; // eax
  const char *v48; // eax
  const char *v49; // eax
  const char *v51; // [esp-8h] [ebp-24h]
  _BYTE *v52; // [esp-4h] [ebp-20h]
  int v53; // [esp-4h] [ebp-20h]
  _BYTE *v54; // [esp-4h] [ebp-20h]
  _BYTE *v55; // [esp-4h] [ebp-20h]
  _BYTE *v56; // [esp-4h] [ebp-20h]
  _BYTE *v57; // [esp-4h] [ebp-20h]
  _BYTE *v58; // [esp-4h] [ebp-20h]
  _BYTE *v59; // [esp-4h] [ebp-20h]
  _BYTE *v60; // [esp-4h] [ebp-20h]
  _BYTE *v61; // [esp-4h] [ebp-20h]
  _BYTE *v62; // [esp-4h] [ebp-20h]
  _BYTE *v63; // [esp+4h] [ebp-18h]
  int v64; // [esp+8h] [ebp-14h]
  int v65; // [esp+Ch] [ebp-10h]
  int v66; // [esp+10h] [ebp-Ch]
  int v67; // [esp+14h] [ebp-8h]
  int v68; // [esp+18h] [ebp-4h]
  int v69; // [esp+18h] [ebp-4h]

  if ( !dword_4A80D4 )
  {
    v2 = (int *)&off_4A5968;
    v3 = 45;
    do
    {
      *v2 = sub_473493(*v2);
      v2 += 3;
      --v3;
    }
    while ( v3 );
    dword_4A80D4 = 1;
  }
  v4 = (const char *const *)&off_4A5968;
  v68 = 45;
  do
  {
    v5 = *((_DWORD *)v4 - 1);
    v6 = (const char **)((char *)a1 + *((_DWORD *)v4 - 2));
    if ( v5 )
    {
      v7 = v5 - 1;
      if ( v7 )
      {
        if ( v7 == 1 && !*v6 )
        {
LABEL_10:
          fprintf(a2, "--");
          fprintf(a2, *v4);
          fprintf(a2, "\n");
        }
      }
      else if ( *v6 )
      {
        goto LABEL_10;
      }
    }
    else if ( *v6 )
    {
      fprintf(a2, "--");
      fprintf(a2, *v4);
      v52 = sub_405490(*v6);
      v8 = (const char *)sub_473493((int)&unk_478EC4);
      fprintf(a2, v8, v52);
      fprintf(a2, "\n");
    }
    v4 += 3;
    --v68;
  }
  while ( v68 );
  if ( !a1[25] )
  {
    if ( a1[24] )
      v9 = (const char *)sub_473493((int)&unk_478ECC);
    else
      v9 = (const char *)sub_473493((int)&unk_478EE0);
    fprintf(a2, v9);
    fprintf(a2, "\n");
  }
  v10 = 0;
  if ( a1[27] )
  {
    v11 = 0;
    do
    {
      if ( *(_DWORD *)(v11 + a1[30]) )
      {
        v53 = *(_DWORD *)(v11 + a1[30]);
        v12 = (const char *)sub_473493((int)&unk_478EF4);
        fprintf(a2, v12, v53);
        fprintf(a2, "\n");
      }
      ++v10;
      v11 += 44;
    }
    while ( v10 < a1[27] );
  }
  for ( i = 0; i < a1[73]; ++i )
  {
    v54 = sub_405490(*(const char **)(a1[76] + 4 * i));
    v14 = (const char *)sub_473493((int)&unk_478F0C);
    fprintf(a2, v14, v54);
    fprintf(a2, "\n");
  }
  if ( a1[110] )
  {
    v15 = (const char *)sub_473493((int)&unk_478F20);
    fprintf(a2, v15);
    fprintf(a2, "\n");
  }
  if ( a1[109] )
  {
    v16 = (const char *)sub_473493((int)&unk_478F38);
    fprintf(a2, v16);
    fprintf(a2, "\n");
  }
  if ( a1[107] )
  {
    v17 = (const char *)sub_473493((int)&unk_478F50);
    fprintf(a2, v17);
    fprintf(a2, "\n");
  }
  if ( a1[108] )
  {
    v18 = (const char *)sub_473493((int)&unk_478F68);
    fprintf(a2, v18);
    fprintf(a2, "\n");
  }
  if ( a1[115] )
  {
    v19 = (const char *)sub_473493((int)&unk_478F80);
    fprintf(a2, v19);
    fprintf(a2, "\n");
  }
  if ( a1[116] )
  {
    v20 = (const char *)sub_473493((int)&unk_478F8C);
    fprintf(a2, v20);
    fprintf(a2, "\n");
  }
  if ( a1[117] )
  {
    v21 = (const char *)sub_473493((int)&unk_478FA0);
    fprintf(a2, v21);
    fprintf(a2, "\n");
  }
  v22 = (int *)a1[106];
  if ( v22 )
  {
    sub_4409A0(v22, a2);
    fprintf(a2, "\n");
  }
  if ( a1[111] )
  {
    v23 = (const char *)sub_473493((int)&unk_478FB4);
    fprintf(a2, v23);
    fprintf(a2, "\n");
  }
  for ( j = 0; j < a1[81]; ++j )
  {
    v55 = sub_405490(*(const char **)(a1[84] + 4 * j));
    v25 = (const char *)sub_473493((int)&unk_478FCC);
    fprintf(a2, v25, v55);
    fprintf(a2, "\n");
  }
  for ( k = 0; k < a1[85]; ++k )
  {
    v56 = sub_405490(*(const char **)(a1[88] + 4 * k));
    v27 = (const char *)sub_473493((int)&unk_478FE0);
    fprintf(a2, v27, v56);
    fprintf(a2, "\n");
  }
  v28 = a1[130];
  if ( v28 > 1 )
  {
    v29 = 36;
    v30 = v28 - 1;
    do
    {
      v57 = sub_405490(*(const char **)(v29 + a1[57]));
      v31 = (const char *)sub_473493((int)&unk_478FF8);
      fprintf(a2, v31, v57);
      fprintf(a2, "\n");
      v29 += 36;
      --v30;
    }
    while ( v30 );
  }
  v32 = 0;
  v33 = 1;
  v64 = 0;
  v66 = 0;
  v69 = 1;
  if ( dword_4A5300 > 1 )
  {
    v67 = 0;
    v65 = 0;
    do
    {
      if ( v64 < a1[11] )
      {
        v34 = v65 + a1[14];
        if ( *(_DWORD *)(v34 + 24) )
        {
          ++v64;
          v65 += 36;
        }
        else if ( *(_DWORD *)(v34 + 32) == v33 )
        {
          if ( *(_DWORD *)(v34 + 4) )
          {
            if ( *(_DWORD *)(v34 + 8) )
              v35 = (const char *)sub_473493((int)&unk_479008);
            else
              v35 = byte_47627C;
            v36 = *(const char **)v34;
            if ( *(_DWORD *)(v34 + 12) )
            {
              v58 = sub_405490(v36);
              v51 = v35;
              v37 = (const char *)sub_473493((int)&unk_479014);
            }
            else
            {
              v58 = sub_405490(v36);
              v51 = v35;
              v37 = (const char *)sub_473493((int)&unk_479028);
            }
            fprintf(a2, v37, v51, v58);
            v33 = v69;
          }
          else
          {
            v59 = sub_405490(*(const char **)v34);
            v38 = (const char *)sub_473493((int)&unk_47903C);
            fprintf(a2, v38, v59);
          }
          fprintf(a2, "\n");
          ++v64;
          v65 += 36;
          v69 = ++v33;
        }
      }
      if ( v66 < a1[54] )
      {
        v39 = v67 + a1[57];
        if ( *(_DWORD *)(v39 + 24) )
        {
          ++v66;
          v67 += 36;
        }
        else if ( *(_DWORD *)(v39 + 32) == v33 )
        {
          v40 = *(_DWORD *)(v39 + 4) == 0;
          v41 = *(const char **)v39;
          if ( v40 )
          {
            v60 = sub_405490(v41);
            v42 = (const char *)sub_473493((int)&unk_47905C);
          }
          else
          {
            v60 = sub_405490(v41);
            v42 = (const char *)sub_473493((int)&unk_47904C);
          }
          fprintf(a2, v42, v60);
          fprintf(a2, "\n");
          ++v66;
          v67 += 36;
          v69 = ++v33;
        }
      }
    }
    while ( v33 < dword_4A5300 );
    v32 = 0;
  }
  if ( a1[50] )
  {
    do
    {
      v43 = a1[53];
      v40 = *(_DWORD *)(v43 + 8 * v32) == 0;
      v44 = *(const char **)(v43 + 8 * v32 + 4);
      if ( v40 )
      {
        v61 = sub_405490(v44);
        v45 = (const char *)sub_473493((int)&unk_479084);
      }
      else
      {
        v61 = sub_405490(v44);
        v45 = (const char *)sub_473493((int)&unk_47906C);
      }
      fprintf(a2, v45, v61);
      fprintf(a2, "\n");
      ++v32;
    }
    while ( v32 < a1[50] );
  }
  for ( m = 0; m < a1[40]; ++m )
  {
    v62 = sub_405490(*(const char **)(a1[43] + 4 * m));
    v47 = (const char *)sub_473493((int)&unk_47909C);
    fprintf(a2, v47, v62);
    fprintf(a2, "\n");
  }
  v48 = (const char *)a1[3];
  if ( v48 )
  {
    if ( a1[49] )
    {
      v63 = sub_405490(v48);
      v49 = (const char *)sub_473493((int)&unk_4790A4);
    }
    else
    {
      v63 = sub_405490(v48);
      v49 = (const char *)sub_473493((int)&unk_4790B4);
    }
    fprintf(a2, v49, v63);
    fprintf(a2, "\n");
  }
  return fprintf(a2, "\n");
}
// 4A5300: using guessed type int dword_4A5300;
// 4A5968: using guessed type void *off_4A5968;
// 4A80D4: using guessed type int dword_4A80D4;

//----- (00405BB0) --------------------------------------------------------
int __cdecl sub_405BB0(char *FileName)
{
  int v1; // ebx
  FILE *v2; // eax
  const char *v3; // eax
  char v4; // dl
  char v6[64]; // [esp+Ch] [ebp-58h] BYREF
  int v7; // [esp+4Ch] [ebp-18h] BYREF
  char *v8; // [esp+50h] [ebp-14h]
  int v9; // [esp+54h] [ebp-10h]
  FILE *Stream; // [esp+58h] [ebp-Ch]
  int v11; // [esp+5Ch] [ebp-8h]
  char v12; // [esp+63h] [ebp-1h]

  v1 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  Stream = 0;
  v11 = 0;
  sub_46C920();
  sub_4688D0();
  dword_4AB3DC = 0;
  if ( !FileName )
    return 0;
  v2 = fopen(FileName, "rb");
  Stream = v2;
  if ( v2 )
  {
    v8 = FileName;
    if ( (unsigned __int8)fgetc(v2) == 35 )
    {
      while ( (unsigned __int8)fgetc(Stream) != 10 )
        ;
      dword_4AB35C = 2;
    }
    else
    {
      dword_4AB35C = 1;
      rewind(Stream);
    }
  }
  else
  {
    v3 = (const char *)sub_473493((int)&unk_4790C4);
    sub_4079A0(v3, FileName);
    v8 = (char *)&unk_4790E4;
    Stream = (FILE *)sub_44F01A();
  }
  v4 = byte_4AB151;
  byte_4AB151 = 1;
  LOBYTE(v7) = 2;
  v9 = 0;
  LOBYTE(v11) = 0;
  v12 = v4;
  qmemcpy(v6, Buf, sizeof(v6));
  if ( !_setjmp3(Buf, 0) )
    v1 = zend_compile_file(&v7, 2);
  qmemcpy(Buf, v6, sizeof(Buf));
  byte_4AB151 = v12;
  sub_468A70();
  zend_destroy_file_handle((int)&v7);
  return v1;
}
// 4AAFBC: using guessed type int (__cdecl *zend_compile_file)(_DWORD, _DWORD);
// 4AB151: using guessed type char byte_4AB151;
// 4AB35C: using guessed type int dword_4AB35C;
// 4AB3DC: using guessed type int dword_4AB3DC;

//----- (00405D00) --------------------------------------------------------
_DWORD *__usercall sub_405D00@<eax>(int *a1@<eax>, _DWORD *a2)
{
  int v2; // ebx
  int v3; // esi
  int v4; // edi
  int v5; // ecx
  int v6; // edx
  int v7; // esi
  int v8; // edi
  int v9; // ebx
  int v10; // ecx
  int v11; // edx
  int v12; // esi
  int v13; // edi
  int v14; // ebx
  int v15; // ebp
  int v16; // edx
  int v17; // esi
  int v18; // edi
  int v19; // ebx
  int v20; // ecx
  int v21; // ebp
  int v22; // esi
  int v23; // edi
  int v24; // ecx
  int v25; // ebp
  int v26; // esi
  int v27; // edi
  int v28; // ecx
  int v29; // eax
  int v30; // edx
  int v31; // edi
  int v32; // ecx
  int v33; // eax
  int v34; // edx
  int v35; // edi
  int v36; // ecx
  int v37; // eax
  int v38; // edx
  int v39; // edi
  int v40; // ecx
  int v41; // eax
  int v42; // edx
  int v43; // esi
  int v44; // edi
  int v45; // eax
  int v46; // ecx
  int v47; // esi
  int v48; // edi
  int v49; // eax
  int v50; // ecx
  int v51; // edx
  int v52; // esi
  int v53; // edi
  _DWORD *result; // eax
  int v55; // ebx
  int v56; // ecx
  int v57; // ecx
  int v58; // [esp+14h] [ebp-40h]
  int v59; // [esp+18h] [ebp-3Ch]
  int v60; // [esp+1Ch] [ebp-38h]
  int v61; // [esp+20h] [ebp-34h]
  int v62; // [esp+24h] [ebp-30h]
  int v63; // [esp+28h] [ebp-2Ch]
  int v64; // [esp+2Ch] [ebp-28h]
  int v65; // [esp+30h] [ebp-24h]
  int v66; // [esp+34h] [ebp-20h]
  int v67; // [esp+3Ch] [ebp-18h]
  int v68; // [esp+40h] [ebp-14h]
  int v69; // [esp+44h] [ebp-10h]
  int v70; // [esp+48h] [ebp-Ch]
  int v71; // [esp+4Ch] [ebp-8h]
  int v72; // [esp+50h] [ebp-4h]

  v2 = a2[1];
  v3 = a2[3];
  v4 = a2[2];
  v58 = *a1;
  v5 = __ROL4__(*a2 + *a1 + (v2 & v4 | v3 & ~v2), 3);
  v60 = a1[1];
  v6 = __ROL4__(v3 + v60 + (v5 & v2 | v4 & ~v5), 7);
  v59 = a1[2];
  v7 = __ROL4__(v4 + v59 + (v5 & v6 | v2 & ~v6), 11);
  v61 = a1[3];
  v8 = __ROR4__(v2 + v61 + (v7 & v6 | v5 & ~v7), 13);
  v9 = __ROL4__(v5 + a1[4] + (v8 & v7 | v6 & ~v8), 3);
  v63 = a1[4];
  v10 = __ROL4__(v6 + a1[5] + (v9 & v8 | v7 & ~v9), 7);
  v68 = a1[5];
  v11 = __ROL4__(v7 + a1[6] + (v9 & v10 | v8 & ~v10), 11);
  v66 = a1[6];
  v12 = __ROR4__(v8 + a1[7] + (v11 & v10 | v9 & ~v11), 13);
  v71 = a1[7];
  v13 = __ROL4__(v9 + a1[8] + (v12 & v11 | v10 & ~v12), 3);
  v62 = a1[8];
  v14 = __ROL4__(v10 + a1[9] + (v13 & v12 | v11 & ~v13), 7);
  v67 = a1[9];
  v15 = __ROL4__(v11 + a1[10] + (v13 & v14 | v12 & ~v14), 11);
  v65 = a1[10];
  v16 = __ROR4__(v12 + a1[11] + (v15 & v14 | v13 & ~v15), 13);
  v70 = a1[11];
  v17 = __ROL4__(v13 + a1[12] + (v16 & v15 | v14 & ~v16), 3);
  v64 = a1[12];
  v69 = a1[13];
  v18 = __ROL4__(v14 + v69 + (v17 & v16 | v15 & ~v17), 7);
  v19 = a1[14];
  v20 = __ROL4__(v15 + v19 + (v17 & v18 | v16 & ~v18), 11);
  v72 = a1[15];
  v21 = __ROR4__(v16 + v72 + (v20 & v18 | v17 & ~v20), 13);
  v22 = __ROL4__(*a1 + (v21 & v20 | v18 & (v21 | v20)) + v17 + 1518500249, 3);
  v23 = __ROL4__(v63 + (v22 & v21 | v20 & (v22 | v21)) + v18 + 1518500249, 5);
  v24 = __ROL4__(v62 + (v22 & v21 | v23 & (v22 | v21)) + v20 + 1518500249, 9);
  v25 = __ROL4__(v64 + (v22 & v24 | v23 & (v22 | v24)) + v21 + 1518500249, 13);
  v26 = __ROL4__(v60 + (v25 & v24 | v23 & (v25 | v24)) + v22 + 1518500249, 3);
  v27 = __ROL4__(v68 + (v26 & v25 | v24 & (v26 | v25)) + v23 + 1518500249, 5);
  v28 = __ROL4__(v67 + (v26 & v25 | v27 & (v26 | v25)) + v24 + 1518500249, 9);
  v29 = __ROL4__(v69 + (v26 & v28 | v27 & (v26 | v28)) + v25 + 1518500249, 13);
  v30 = __ROL4__(v59 + (v29 & v28 | v27 & (v29 | v28)) + v26 + 1518500249, 3);
  v31 = __ROL4__(v27 + v66 + (v30 & v29 | v28 & (v30 | v29)) + 1518500249, 5);
  v32 = __ROL4__(v65 + (v30 & v29 | v31 & (v30 | v29)) + v28 + 1518500249, 9);
  v33 = __ROL4__(v19 + (v30 & v32 | v31 & (v30 | v32)) + v29 + 1518500249, 13);
  v34 = __ROL4__(v61 + (v33 & v32 | v31 & (v33 | v32)) + v30 + 1518500249, 3);
  v35 = __ROL4__(v31 + v71 + (v34 & v33 | v32 & (v34 | v33)) + 1518500249, 5);
  v36 = __ROL4__(v70 + (v34 & v33 | v35 & (v34 | v33)) + v32 + 1518500249, 9);
  v37 = __ROL4__(v72 + (v34 & v36 | v35 & (v34 | v36)) + v33 + 1518500249, 13);
  v38 = __ROL4__(v58 + (v37 ^ v36 ^ v35) + v34 + 1859775393, 3);
  v39 = __ROL4__(v62 + (v38 ^ v37 ^ v36) + v35 + 1859775393, 9);
  v40 = __ROL4__(v63 + (v38 ^ v37 ^ v39) + v36 + 1859775393, 11);
  v41 = __ROL4__(v37 + v64 + (v38 ^ v40 ^ v39) + 1859775393, 15);
  v42 = __ROL4__(v59 + (v41 ^ v40 ^ v39) + v38 + 1859775393, 3);
  v43 = __ROL4__(v65 + (v42 ^ v41 ^ v40) + v39 + 1859775393, 9);
  v44 = __ROL4__(v66 + (v42 ^ v41 ^ v43) + v40 + 1859775393, 11);
  v45 = __ROL4__(v41 + v19 + (v42 ^ v44 ^ v43) + 1859775393, 15);
  v46 = __ROL4__(v60 + (v45 ^ v44 ^ v43) + v42 + 1859775393, 3);
  v47 = __ROL4__(v67 + (v46 ^ v45 ^ v44) + v43 + 1859775393, 9);
  v48 = __ROL4__(v68 + (v46 ^ v45 ^ v47) + v44 + 1859775393, 11);
  v49 = __ROL4__(v45 + v69 + (v46 ^ v48 ^ v47) + 1859775393, 15);
  v50 = __ROL4__(v61 + (v49 ^ v48 ^ v47) + v46 + 1859775393, 3);
  v51 = __ROL4__(v70 + (v50 ^ v49 ^ v48) + v47 + 1859775393, 9);
  v52 = __ROL4__(v71 + (v50 ^ v49 ^ v51) + v48 + 1859775393, 11);
  v53 = v72 + (v50 ^ v52 ^ v51) + v49 + 1859775393;
  result = a2;
  v55 = v50 + *a2;
  v56 = v52 + a2[2];
  a2[1] += __ROL4__(v53, 15);
  a2[2] = v56;
  v57 = a2[3];
  *a2 = v55;
  a2[3] = v51 + v57;
  return result;
}

//----- (004061B0) --------------------------------------------------------
void __cdecl sub_4061B0(int a1, char *Source, int a3, const char *a4)
{
  _DWORD *v4; // esi
  _BYTE *v5; // ebx
  const char *v6; // ebx
  _BYTE *v7; // edi
  char *v8; // eax
  char *v9; // edi
  _DWORD *v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // esi
  int v15; // edx
  int v16; // eax
  _DWORD *v17; // eax
  int v18; // [esp-4h] [ebp-24h]
  _BYTE *v19; // [esp+1Ch] [ebp-4h]

  v4 = (_DWORD *)dword_4A6A80;
  if ( !dword_4A6A80 )
    return;
  v5 = 0;
  if ( !a4 )
    goto LABEL_16;
  v6 = a4;
  v7 = malloc(strlen(a4) + 1);
  v19 = v7;
  if ( !*a4 )
    goto LABEL_15;
  do
  {
    if ( isprint(*v6) )
    {
      *v7 = *v6;
    }
    else
    {
      if ( *v6 != 9 )
        goto LABEL_9;
      *v7 = 32;
    }
    ++v7;
LABEL_9:
    ++v6;
  }
  while ( *v6 );
  for ( ; v7 > v19; --v7 )
  {
    if ( !isspace((char)*(v7 - 1)) && *(v7 - 1) != 44 )
      break;
  }
  v4 = (_DWORD *)dword_4A6A80;
LABEL_15:
  v5 = v19;
  *v7 = 0;
LABEL_16:
  if ( Source )
  {
    v8 = _strdup(Source);
    v4 = (_DWORD *)dword_4A6A80;
    v9 = v8;
  }
  else
  {
    v9 = 0;
  }
  ++*((_DWORD *)dword_4A80FC + 3);
  v10 = dword_4A80FC;
  if ( *((_DWORD *)dword_4A80FC + 3) == *((_DWORD *)dword_4A80FC + 1) )
  {
    *((_DWORD *)dword_4A80FC + 1) += 32;
    v11 = off_4A4FE8(*((_DWORD *)dword_4A80FC + 2), 4 * *((_DWORD *)dword_4A80FC + 1));
    v4 = (_DWORD *)dword_4A6A80;
    *((_DWORD *)dword_4A80FC + 2) = v11;
    v10 = dword_4A80FC;
  }
  *(_DWORD *)(v10[2] + 4 * v10[3]) = &unk_4A4FF0;
  *(_DWORD *)dword_4A80FC = *(_DWORD *)(*((_DWORD *)dword_4A80FC + 2) + 4 * *((_DWORD *)dword_4A80FC + 3));
  v12 = v4[1];
  if ( *v4 == v12 )
  {
    v13 = v4[2] + v12;
    v4[1] = v13;
    v14 = v4[3];
    v15 = *(_DWORD *)dword_4A80FC;
    v18 = 16 * v13;
    if ( v14 )
      v16 = (*(int (__cdecl **)(int, int))(v15 + 12))(v14, v18);
    else
      v16 = (*(int (__cdecl **)(int))(v15 + 8))(v18);
    v4 = (_DWORD *)dword_4A6A80;
    *(_DWORD *)(dword_4A6A80 + 12) = v16;
  }
  v17 = (_DWORD *)(16 * *v4 + v4[3]);
  *v17 = a1;
  v17[1] = v9;
  v17[2] = a3;
  v17[3] = v5;
  ++*v4;
  --*((_DWORD *)dword_4A80FC + 3);
  *(_DWORD *)dword_4A80FC = *(_DWORD *)(*((_DWORD *)dword_4A80FC + 2) + 4 * *((_DWORD *)dword_4A80FC + 3));
}
// 4A4FE8: using guessed type int (__cdecl *off_4A4FE8)(_DWORD, _DWORD);
// 4A6A80: using guessed type int dword_4A6A80;

//----- (00406360) --------------------------------------------------------
_DWORD *__usercall sub_406360@<eax>(_DWORD *a1@<eax>)
{
  _DWORD *v2; // eax

  ++*((_DWORD *)dword_4A80FC + 3);
  v2 = dword_4A80FC;
  if ( *((_DWORD *)dword_4A80FC + 3) == *((_DWORD *)dword_4A80FC + 1) )
  {
    *((_DWORD *)dword_4A80FC + 1) += 32;
    *((_DWORD *)dword_4A80FC + 2) = off_4A4FE8(*((_DWORD *)dword_4A80FC + 2), 4 * *((_DWORD *)dword_4A80FC + 1));
    v2 = dword_4A80FC;
  }
  *(_DWORD *)(v2[2] + 4 * v2[3]) = &unk_4A4FF0;
  *(_DWORD *)dword_4A80FC = *(_DWORD *)(*((_DWORD *)dword_4A80FC + 2) + 4 * *((_DWORD *)dword_4A80FC + 3));
  if ( !a1 )
    a1 = (_DWORD *)(*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(16);
  *a1 = 0;
  a1[1] = 8;
  a1[2] = 8;
  a1[3] = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(128);
  --*((_DWORD *)dword_4A80FC + 3);
  *(_DWORD *)dword_4A80FC = *(_DWORD *)(*((_DWORD *)dword_4A80FC + 2) + 4 * *((_DWORD *)dword_4A80FC + 3));
  return a1;
}
// 4A4FE8: using guessed type int (__cdecl *off_4A4FE8)(_DWORD, _DWORD);

//----- (00406420) --------------------------------------------------------
void *__usercall sub_406420@<eax>(int *a1@<edi>)
{
  _DWORD *v1; // eax
  int v2; // ebp
  int v3; // ebx
  int v4; // esi
  void *v5; // eax
  int v6; // esi
  void *v7; // esi
  void *result; // eax

  ++*((_DWORD *)dword_4A80FC + 3);
  v1 = dword_4A80FC;
  if ( *((_DWORD *)dword_4A80FC + 3) == *((_DWORD *)dword_4A80FC + 1) )
  {
    *((_DWORD *)dword_4A80FC + 1) += 32;
    *((_DWORD *)dword_4A80FC + 2) = off_4A4FE8(*((_DWORD *)dword_4A80FC + 2), 4 * *((_DWORD *)dword_4A80FC + 1));
    v1 = dword_4A80FC;
  }
  *(_DWORD *)(v1[2] + 4 * v1[3]) = &unk_4A4FF0;
  *(_DWORD *)dword_4A80FC = *(_DWORD *)(*((_DWORD *)dword_4A80FC + 2) + 4 * *((_DWORD *)dword_4A80FC + 3));
  if ( a1 )
  {
    v2 = 0;
    if ( *a1 > 0 )
    {
      v3 = 0;
      do
      {
        v4 = a1[3];
        v5 = *(void **)(v4 + v3 + 4);
        v6 = v3 + v4;
        if ( v5 )
          free(v5);
        v7 = *(void **)(v6 + 12);
        if ( v7 )
          free(v7);
        ++v2;
        v3 += 16;
      }
      while ( v2 < *a1 );
    }
    if ( a1[3] )
    {
      (*(void (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 16))(a1[3]);
      a1[3] = 0;
    }
    a1[1] = 0;
    *a1 = 0;
  }
  --*((_DWORD *)dword_4A80FC + 3);
  result = dword_4A80FC;
  *(_DWORD *)dword_4A80FC = *(_DWORD *)(*((_DWORD *)dword_4A80FC + 2) + 4 * *((_DWORD *)dword_4A80FC + 3));
  return result;
}
// 4A4FE8: using guessed type int (__cdecl *off_4A4FE8)(_DWORD, _DWORD);

//----- (00406520) --------------------------------------------------------
int sub_406520(char *Format, ...)
{
  char Buffer[1024]; // [esp+0h] [ebp-404h] BYREF
  va_list va; // [esp+40Ch] [ebp+8h] BYREF

  va_start(va, Format);
  _vsnprintf(Buffer, 0x400u, Format, va);
  puts(Buffer);
  return 0;
}

//----- (00406580) --------------------------------------------------------
int __cdecl sub_406580(int a1, char *Source, int a3, char *Format, va_list ArgList)
{
  int result; // eax
  char Buffer[1028]; // [esp+8h] [ebp-408h] BYREF

  _vsnprintf(Buffer, 0x400u, Format, ArgList);
  result = a1;
  if ( (a1 & dword_4AB12C) != 0 )
  {
    sub_4061B0(a1, Source, a3, Buffer);
    zend_bailout((int)byte_47627C, 0);
  }
  return result;
}
// 4AB12C: using guessed type int dword_4AB12C;

//----- (00406610) --------------------------------------------------------
size_t __cdecl sub_406610(void *Buffer, size_t ElementCount)
{
  FILE *v2; // eax

  v2 = (FILE *)sub_44F01A();
  return fwrite(Buffer, 1u, ElementCount, v2 + 1);
}

//----- (00406630) --------------------------------------------------------
FILE *__cdecl sub_406630(char *FileName, _DWORD *a2)
{
  FILE *result; // eax
  FILE *v3; // esi

  result = fopen(FileName, "r");
  v3 = result;
  if ( result )
  {
    if ( a2 )
    {
      *a2 = estrdup(FileName);
      return v3;
    }
  }
  else
  {
    if ( a2 )
      *a2 = 0;
    return 0;
  }
  return result;
}

//----- (00406680) --------------------------------------------------------
int __cdecl sub_406680(int a1, int a2, int a3)
{
  *(_BYTE *)(a3 + 8) = 0;
  return 0;
}

//----- (00406690) --------------------------------------------------------
void sub_406690()
{
  char *v0; // ecx
  char *v1; // ecx
  char *v2; // ecx
  char *v3; // ecx
  char *v4; // ecx
  char *v5; // ecx
  char *v6; // ecx
  char *v7; // ecx
  int v8[9]; // [esp+Ch] [ebp-8Ch] BYREF
  int Src[26]; // [esp+30h] [ebp-68h] BYREF

  v8[0] = (int)sub_406580;
  v8[1] = (int)sub_406520;
  v8[2] = (int)sub_406610;
  v8[3] = (int)sub_406630;
  v8[4] = (int)zend_highlight;
  v8[5] = (int)zend_highlight;
  v8[6] = (int)zend_highlight;
  v8[7] = (int)sub_406680;
  v8[8] = (int)zend_highlight;
  sub_468150((int)v8);
  qmemcpy(Src, off_495190, sizeof(Src));
  Src[24] = 0;
  zend_llist_add_element((int)&zend_extensions, Src);
  v0 = (char *)sub_473493((int)&unk_4790EC);
  sub_46CA20(v0, strlen(v0));
  v1 = (char *)sub_473493((int)&unk_4790F4);
  sub_46CA20(v1, strlen(v1));
  v2 = (char *)sub_473493((int)&unk_4790FC);
  sub_46CA20(v2, strlen(v2));
  v3 = (char *)sub_473493((int)&unk_479108);
  sub_46CA20(v3, strlen(v3));
  v4 = (char *)sub_473493((int)&unk_479114);
  sub_46CA20(v4, strlen(v4));
  v5 = (char *)sub_473493((int)&unk_47911C);
  sub_46CA20(v5, strlen(v5));
  v6 = (char *)sub_473493((int)&unk_479128);
  sub_46CA20(v6, strlen(v6));
  v7 = (char *)sub_473493((int)&unk_479134);
  sub_46CA20(v7, strlen(v7));
  dword_4AB148 = 14;
  dword_4AB12C = 2047;
  zend_llist_apply_with_del((int)&zend_extensions, (int (__cdecl *)(_DWORD *))sub_40F690);
}
// 40F640: using guessed type int __cdecl zend_highlight(_DWORD);
// 495190: using guessed type char (*off_495190[5])[4];
// 4AB12C: using guessed type int dword_4AB12C;
// 4AB148: using guessed type int dword_4AB148;

//----- (00406870) --------------------------------------------------------
void __usercall sub_406870(const char *a1@<ebx>, _DWORD *a2@<edi>, char *FileName)
{
  int v3; // esi
  const char *v4; // eax
  const char *v5; // eax
  struct __utimbuf32 Time; // [esp+8h] [ebp-50h] BYREF
  struct _stat32 Stat; // [esp+10h] [ebp-48h] BYREF
  struct _stat32 v8; // [esp+34h] [ebp-24h] BYREF

  if ( a2[9] || a2[8] || a2[10] )
  {
    v3 = 1;
    if ( _stat32(a1, &Stat) )
    {
      v4 = (const char *)sub_473493((int)&unk_479140);
      sub_4079A0(v4, a1);
      v3 = 0;
    }
    if ( _stat32(FileName, &v8) )
    {
      if ( *_errno() != 2 )
      {
        v5 = (const char *)sub_473493((int)&unk_479140);
        sub_4079A0(v5, FileName);
      }
    }
    else if ( v3 )
    {
      if ( a2[9] )
      {
        Time = *(struct __utimbuf32 *)&Stat.st_atime;
        _utime32(FileName, &Time);
      }
      if ( a2[8] )
        _chmod(FileName, Stat.st_mode & 0x1FF);
    }
  }
}

//----- (00406940) --------------------------------------------------------
int __usercall sub_406940@<eax>(int a1@<edx>, char *a2@<ecx>, char *a3, int a4, int a5)
{
  int v5; // eax
  int v6; // ecx
  int v7; // eax
  int v8; // ecx
  int v9; // edx
  int v10; // eax
  int v11; // ecx
  int v12; // edx
  int v13; // eax
  int v14; // ecx
  int v15; // edx
  int v16; // eax
  int v17; // ecx
  int v18; // edx
  int v19; // eax
  int v20; // ecx
  int v21; // edx
  int v22; // eax
  int v23; // ecx
  int v24; // edx
  int v25; // eax
  int v26; // ecx
  int v27; // edx
  int v28; // eax
  int v29; // ecx
  void *v30; // eax
  const char *v31; // ecx
  unsigned int v32; // eax
  unsigned int v33; // edx
  int *v34; // edi
  unsigned int v35; // esi
  int v36; // eax
  int *v37; // ecx
  unsigned int v38; // eax
  int v39; // edx
  int v40; // ecx
  int v41; // edx
  int v42; // ecx
  char *v43; // esi
  const char *v44; // eax
  int v45; // eax
  char *v46; // ecx
  char *v47; // edx
  char v48; // al
  int v49; // edx
  int v50; // eax
  int v51; // eax
  int v52; // ecx
  int v53; // ecx
  __int16 v54; // dx
  signed int v55; // eax
  signed int v56; // ecx
  bool v57; // sf
  int v58; // esi
  const char *v59; // eax
  const char *v60; // eax
  int v62; // [esp+14h] [ebp-124h]
  int v63; // [esp+14h] [ebp-124h]
  char v66; // [esp+24h] [ebp-114h]
  int v67; // [esp+28h] [ebp-110h]
  int v68[4]; // [esp+2Ch] [ebp-10Ch] BYREF
  int v69; // [esp+3Ch] [ebp-FCh] BYREF
  int v70; // [esp+40h] [ebp-F8h]
  int v71; // [esp+44h] [ebp-F4h]
  int v72; // [esp+48h] [ebp-F0h]
  int v73[3]; // [esp+4Ch] [ebp-ECh] BYREF
  int v74[54]; // [esp+58h] [ebp-E0h] BYREF

  v62 = dword_4A52F4;
  dword_4A4F44 = (unsigned __int16)dword_4AE100 + 3552306;
  zend_hash_clean(dword_4AB374);
  zend_hash_clean(dword_4AB370);
  dword_4AE2E0 = 0;
  dword_4AE2E4 = 0;
  dword_4AE2E8 = 32;
  dword_4AE2EC = 0;
  v74[22] = 0;
  v5 = sub_473493((int)&unk_479170);
  v6 = *(_DWORD *)(a4 + 52);
  v74[4] = v5;
  v7 = *(_DWORD *)(a4 + 52);
  v74[5] = 4;
  v74[6] = v7 & 0xFFFFFFF0 | (9 - (v6 & 0xF));
  if ( *(_DWORD *)(a4 + 64) )
    v74[6] |= 0x40u;
  if ( !*(_DWORD *)(a4 + 108) )
    v74[6] |= 0x80u;
  if ( !*(_DWORD *)(a4 + 116) )
    v74[6] |= 0x400u;
  if ( !*(_DWORD *)(a4 + 120) )
    v74[6] |= 0x8000u;
  if ( *(_DWORD *)(a4 + 128) )
    v74[6] |= 0x10000u;
  if ( *(_DWORD *)(a4 + 144) )
    v74[6] |= 0x1000u;
  if ( *(_DWORD *)(a4 + 132) )
    v74[6] |= 0x100u;
  if ( *(_DWORD *)(a4 + 136) )
    v74[6] |= 0x4000u;
  if ( *(_DWORD *)(a4 + 140) )
    v74[6] |= 0x200u;
  if ( *(_DWORD *)(a4 + 148) )
    v74[6] |= 0x800u;
  v8 = *(_DWORD *)(a4 + 72);
  v9 = *(_DWORD *)(a4 + 104);
  v74[23] = *(_DWORD *)(a4 + 64);
  v10 = *(_DWORD *)(a4 + 76);
  v74[24] = v8;
  v11 = *(_DWORD *)(a4 + 80);
  v74[33] = v9;
  v12 = *(_DWORD *)(a4 + 84);
  v74[26] = v10;
  v13 = *(_DWORD *)(a4 + 88);
  v74[27] = v11;
  v14 = *(_DWORD *)(a4 + 92);
  v74[28] = v12;
  v15 = *(_DWORD *)(a4 + 108);
  v74[29] = v13;
  v16 = *(_DWORD *)(a4 + 112);
  v74[30] = v14;
  v17 = *(_DWORD *)(a4 + 116);
  v74[34] = v15;
  v18 = *(_DWORD *)(a4 + 132);
  v74[35] = v16;
  v19 = *(_DWORD *)(a4 + 136);
  v74[36] = v17;
  v20 = *(_DWORD *)(a4 + 140);
  v74[40] = v18;
  v21 = *(_DWORD *)(a4 + 144);
  v74[41] = v19;
  v22 = *(_DWORD *)(a4 + 148);
  v74[42] = v20;
  v23 = *(_DWORD *)(a4 + 152);
  v74[43] = v21;
  v74[44] = v22;
  v74[45] = v23;
  v74[50] = a4 + 164;
  v24 = *(_DWORD *)(a4 + 212);
  v74[51] = a4 + 180;
  v25 = *(_DWORD *)(a4 + 124);
  v74[52] = a4 + 196;
  v26 = *(_DWORD *)(a4 + 216);
  v74[16] = v24;
  v27 = *(_DWORD *)(a4 + 220);
  v74[39] = v25;
  v28 = *(_DWORD *)(a4 + 224);
  v74[53] = v26;
  v29 = *(_DWORD *)(a4 + 228);
  v74[46] = v27;
  v74[47] = v28;
  v74[48] = v29;
  if ( *(_DWORD *)(a4 + 160) )
  {
    v30 = malloc(0x11u);
    v31 = *(const char **)(a4 + 160);
    v67 = (int)v30;
    v32 = (unsigned int)&v31[strlen(v31) + 1];
    v33 = v32 - (_DWORD)v31;
    v66 = v32 - (_BYTE)v31;
    v34 = (int *)v31;
    v69 = 1732584193;
    v70 = -271733879;
    v71 = -1732584194;
    v72 = 271733878;
    memset(v73, 0, sizeof(v73));
    if ( v32 != (_DWORD)v31 )
    {
      v35 = v33 >> 6;
      if ( v33 >> 6 )
      {
        do
        {
          --v35;
          v36 = 512;
          v37 = v73;
          do
          {
            v38 = *(unsigned __int8 *)v37 + v36;
            *(_BYTE *)v37 = v38;
            v36 = v38 >> 8;
            v37 = (int *)((char *)v37 + 1);
          }
          while ( v36 );
          sub_405D00(v34, &v69);
          v34 += 16;
        }
        while ( v35 );
        LOBYTE(v33) = v66;
      }
    }
    sub_4446D0(8 * (v33 & 0x3F), &v69, v34);
    v39 = v70;
    *(_DWORD *)v67 = v69;
    v40 = v71;
    *(_DWORD *)(v67 + 4) = v39;
    v41 = v72;
    *(_DWORD *)(v67 + 8) = v40;
    *(_DWORD *)(v67 + 12) = v41;
    *(_BYTE *)(v67 + 16) = 0;
    v74[49] = v67;
  }
  else
  {
    v74[49] = 0;
  }
  if ( *(_DWORD *)(a4 + 96) )
    a1 = *(_DWORD *)(a4 + 96);
  if ( a1 )
  {
    v74[31] = 1;
    v74[32] = a1;
  }
  else
  {
    v74[32] = 0;
    v74[31] = 0;
  }
  v42 = *(_DWORD *)(a4 + 28);
  v74[25] = *(_DWORD *)(a4 + 60);
  v74[12] = v42;
  if ( v42 )
  {
    v43 = (char *)malloc(strlen((const char *)v74[12]) + 1024);
    v44 = (const char *)sub_473493((int)&unk_479178);
    v45 = sprintf(v43, v44, "12.0");
    if ( *(_BYTE *)v74[12] )
      v43[v45++] = 10;
    v46 = (char *)v74[12];
    v47 = &v43[v45];
    do
    {
      v48 = *v46;
      *v47++ = *v46++;
    }
    while ( v48 );
    v74[12] = (int)v43;
  }
  v74[5] += dword_4AE290 != 0 ? 0 : 78;
  v49 = *(_DWORD *)(a4 + 4);
  v50 = *(_DWORD *)(a4 + 12);
  v74[9] = *(_DWORD *)a4;
  v74[10] = v49;
  v74[14] = v50;
  v51 = *(_DWORD *)(a4 + 24);
  v52 = *(_DWORD *)(a4 + 20);
  v74[17] = *(_DWORD *)(a4 + 16);
  v74[15] = v51;
  v74[18] = v52;
  v63 = dword_4AE100 + v62 * dword_4A52F8 + dword_4A52FC;
  v74[19] = 1;
  if ( !v74[14] || v74[14] > v63 )
    v74[14] = v63;
  v74[13] = (int)a2;
  HIWORD(v74[2]) = 3075;
  LOWORD(v74[3]) = 512;
  v74[7] = 0;
  v74[8] = -369351759;
  if ( dword_4AE13C )
  {
    v53 = *(_DWORD *)(dword_4AE13C + 20);
    v74[0] = *(_DWORD *)(dword_4AE13C + 26);
    v54 = *(_WORD *)(dword_4AE13C + 24);
    v74[1] = v53;
    LOWORD(v74[2]) = v54;
  }
  else
  {
    memset(v74, 0, 10);
  }
  if ( v74[26] )
  {
    if ( !v74[27] )
    {
      v55 = strlen((const char *)v74[28]);
      v56 = 0;
      for ( dword_4A4F44 = 3552306; v56 < v55; ++v56 )
        dword_4A4F44 += *(char *)(v74[28] + v56);
    }
  }
  v74[20] = 0;
  v74[21] = 0;
  qmemcpy(&unk_4A7BF0, v74, 0xD8u);
  zend_llist_apply((_DWORD **)&zend_extensions, (int (__cdecl *)(_DWORD *))sub_406500);
  v57 = *(int *)a4 < 0;
  dword_4A6A80 = a5;
  if ( !v57 )
    byte_4AB3A5 = *(_BYTE *)a4;
  if ( *(int *)(a4 + 8) >= 0 )
    byte_4AB3A7 = *(_BYTE *)(a4 + 8);
  v58 = sub_405BB0(a3);
  zend_llist_apply((_DWORD **)&zend_extensions, (int (__cdecl *)(_DWORD *))sub_406510);
  if ( !v58 )
    return 0;
  sub_406870(a3, (_DWORD *)a4, a2);
  if ( *(_DWORD *)(a4 + 56) )
  {
    sub_406360(v68);
    v57 = *(int *)a4 < 0;
    dword_4A6A80 = (int)v68;
    if ( !v57 )
      byte_4AB3A5 = *(_BYTE *)a4;
    if ( *(int *)(a4 + 8) >= 0 )
      byte_4AB3A7 = *(_BYTE *)(a4 + 8);
    zend_hash_clean(dword_4AB374);
    zend_hash_clean(dword_4AB370);
    if ( sub_405BB0(a2) )
    {
      v59 = (const char *)sub_473493((int)&unk_479210);
      sub_4079F0(v59, a2);
    }
    else
    {
      v60 = (const char *)sub_473493((int)&unk_479224);
      sub_407970(v60, a2);
    }
    sub_406420(v68);
  }
  **(_DWORD **)(v58 + 12) = 1;
  destroy_op_array(v58);
  efree(v58);
  return 1;
}
// 406500: using guessed type int sub_406500();
// 406510: using guessed type int sub_406510();
// 4A4F44: using guessed type int dword_4A4F44;
// 4A52F4: using guessed type int dword_4A52F4;
// 4A52F8: using guessed type int dword_4A52F8;
// 4A52FC: using guessed type int dword_4A52FC;
// 4A6A80: using guessed type int dword_4A6A80;
// 4AB3A5: using guessed type char byte_4AB3A5;
// 4AB3A7: using guessed type char byte_4AB3A7;
// 4AE100: using guessed type int dword_4AE100;
// 4AE13C: using guessed type int dword_4AE13C;
// 4AE290: using guessed type int dword_4AE290;
// 4AE2E0: using guessed type int dword_4AE2E0;
// 4AE2E4: using guessed type int dword_4AE2E4;
// 4AE2E8: using guessed type int dword_4AE2E8;
// 4AE2EC: using guessed type int dword_4AE2EC;
// 406940: using guessed type int var_10C[4];

//----- (00407050) --------------------------------------------------------
BOOL __usercall sub_407050@<eax>(char *FileName@<ecx>, char *a2@<eax>, _DWORD *a3)
{
  int v5; // esi

  v5 = sub_444310(FileName, a2);
  if ( !v5 )
    sub_406870(FileName, a3, a2);
  return v5 == 0;
}

//----- (004070A0) --------------------------------------------------------
char *__usercall sub_4070A0@<eax>(char **a1@<eax>, int a2, int a3)
{
  void *v3; // ebx
  int v4; // esi
  const char **v5; // ebp
  unsigned int v6; // eax
  unsigned int v7; // edi
  char *v8; // eax
  const char *v9; // ecx
  char *v10; // edx
  char v11; // al
  bool v12; // zf
  int v13; // ebp
  char *v14; // esi
  char *v15; // edi
  const char *v16; // esi
  const char *v17; // eax
  const char *v18; // eax
  const char *v19; // ebp
  unsigned int v20; // edi
  const char *v22; // [esp+10h] [ebp-8h]
  char *Format; // [esp+14h] [ebp-4h]
  char *Formata; // [esp+14h] [ebp-4h]

  v3 = 0;
  if ( a1 )
  {
    v4 = 0;
    if ( (int)*a1 > 0 )
    {
      v5 = (const char **)a1[3];
      Format = *a1;
      do
      {
        v6 = strlen(*v5);
        v7 = v6;
        if ( v3 )
          v8 = (char *)realloc(v3, v6 + v4 + 9);
        else
          v8 = (char *)malloc(v6 + 9);
        v3 = v8;
        *(_DWORD *)&v8[v4] = 2109231;
        v9 = *v5;
        v10 = &v8[v4 + 3];
        do
        {
          v11 = *v9;
          *v10++ = *v9++;
        }
        while ( v11 );
        ++v5;
        v12 = Format-- == (char *)1;
        *((_BYTE *)v3 + v7 + v4 + 3) = 10;
        v4 += v7 + 4;
      }
      while ( !v12 );
    }
    *((_BYTE *)v3 + v4) = 0;
  }
  v13 = a2;
  if ( *(_DWORD *)(a2 + 4) )
  {
    v14 = _strdup(*(const char **)(a2 + 4));
  }
  else
  {
    v15 = *(char **)(a2 + 16);
    v22 = *(const char **)(a2 + 8);
    if ( !v15 )
    {
      v16 = *(const char **)(a2 + 12);
      if ( !v16 )
        v16 = (const char *)sub_473408((int)&unk_479238);
      v15 = (char *)malloc(strlen(v16) + 18);
      v17 = (const char *)sub_473493((int)&unk_479498);
      sprintf(v15, v17, v16);
    }
    if ( !v22 )
      v22 = (const char *)sub_473493((int)&unk_4794B0);
    if ( *(_DWORD *)a2 )
    {
      if ( a3 )
        v18 = (const char *)sub_473408((int)&unk_4794C8);
      else
        v18 = (const char *)sub_473408((int)&unk_4797F8);
      Formata = (char *)v18;
      v14 = (char *)malloc(strlen(v18) + strlen(v22) + strlen(v15));
      sprintf(v14, Formata, v22, v15);
      v13 = a2;
    }
    else if ( *(_DWORD *)(a2 + 12) || *(_DWORD *)(a2 + 16) )
    {
      v14 = _strdup(v15);
    }
    else
    {
      v19 = (const char *)sub_473493((int)&unk_479BA8);
      v14 = (char *)malloc(strlen(v19) + strlen(v15));
      sprintf(v14, v19, v15);
      v13 = a2;
    }
    if ( v15 != *(char **)(v13 + 16) )
      free(v15);
  }
  if ( !v3 )
    return v14;
  if ( v14 )
  {
    v20 = strlen((const char *)v3);
    v3 = realloc(v3, strlen(v14) + v20 + 1);
    strcpy((char *)v3 + v20, v14);
  }
  return (char *)v3;
}

//----- (004072F0) --------------------------------------------------------
int sub_4072F0()
{
  __int16 *v0; // eax
  unsigned __int16 v1; // cx
  int v2; // eax
  char *v3; // esi
  const char *v4; // eax
  char *v5; // eax
  _BYTE *v6; // edx
  char v7; // cl
  const char *v8; // eax
  const char *v9; // eax
  const char *v10; // eax
  const char *v11; // eax
  FILE *v12; // eax
  FILE *v13; // edi
  const char *v14; // esi
  const char *v15; // eax
  char v16; // al
  char *i; // esi
  const char *v18; // eax
  int result; // eax
  int wProcessorArchitecture; // [esp-10h] [ebp-1D8h]
  DWORD dwMajorVersion; // [esp-Ch] [ebp-1D4h]
  DWORD dwProcessorType; // [esp-Ch] [ebp-1D4h]
  DWORD dwMinorVersion; // [esp-8h] [ebp-1D0h]
  DWORD dwBuildNumber; // [esp-8h] [ebp-1D0h]
  int wProcessorLevel; // [esp-8h] [ebp-1D0h]
  DWORD dwPlatformId; // [esp-4h] [ebp-1CCh]
  int wProcessorRevision; // [esp-4h] [ebp-1CCh]
  struct _SYSTEM_INFO SystemInfo; // [esp+Ch] [ebp-1BCh] BYREF
  struct _OSVERSIONINFOA VersionInformation; // [esp+30h] [ebp-198h] BYREF
  char Str1[10]; // [esp+C4h] [ebp-104h] BYREF
  char v31; // [esp+CEh] [ebp-FAh] BYREF
  char Buffer[128]; // [esp+144h] [ebp-84h] BYREF

  Time = 0;
  dword_4AE124 = 0;
  _time32(&Time);
  dword_4AE130 = GetCurrentProcessId();
  dword_4AE138 = 0;
  memset(&VersionInformation, 0, sizeof(VersionInformation));
  VersionInformation.dwOSVersionInfoSize = 148;
  if ( GetVersionExA(&VersionInformation) )
  {
    v0 = &word_4A5288;
    if ( word_4A5288 )
    {
      v1 = word_4A5288;
      do
      {
        if ( v1 == VersionInformation.dwMajorVersion
          && (unsigned __int16)v0[1] == VersionInformation.dwMinorVersion
          && (unsigned __int16)v0[2] == VersionInformation.dwPlatformId )
        {
          break;
        }
        v1 = v0[6];
        v0 += 6;
      }
      while ( v1 );
    }
    v2 = *((_DWORD *)v0 + 2);
    if ( v2 )
    {
      v3 = (char *)sub_473493(v2);
    }
    else
    {
      dwPlatformId = VersionInformation.dwPlatformId;
      dwMinorVersion = VersionInformation.dwMinorVersion;
      dwMajorVersion = VersionInformation.dwMajorVersion;
      v4 = (const char *)sub_473493((int)&unk_479C54);
      sprintf(Buffer, v4, dwMajorVersion, dwMinorVersion, dwPlatformId);
      v3 = Buffer;
    }
    v5 = (char *)sub_473493((int)&unk_479C6C);
    v6 = &unk_4AE148;
    do
    {
      v7 = *v5;
      *v6++ = *v5++;
    }
    while ( v7 );
    dwBuildNumber = VersionInformation.dwBuildNumber;
    v8 = (const char *)sub_473493((int)&unk_479C78);
    sprintf(::Buffer, v8, v3, dwBuildNumber, VersionInformation.szCSDVersion);
  }
  if ( gethostname(name, 64) )
  {
    v9 = (const char *)sub_473493((int)&unk_479C84);
    sub_4079A0(v9);
  }
  memset(&SystemInfo, 0, sizeof(SystemInfo));
  GetSystemInfo(&SystemInfo);
  wProcessorRevision = SystemInfo.wProcessorRevision;
  wProcessorLevel = SystemInfo.wProcessorLevel;
  dwProcessorType = SystemInfo.dwProcessorType;
  wProcessorArchitecture = SystemInfo.wProcessorArchitecture;
  v10 = (const char *)sub_473493((int)&unk_479C9C);
  sprintf(Buffer, v10, wProcessorArchitecture, dwProcessorType, wProcessorLevel, wProcessorRevision);
  dword_4AE288 = (int)_strdup(Buffer);
  v11 = (const char *)sub_473493((int)&unk_479CAC);
  v12 = fopen(v11, "r");
  v13 = v12;
  if ( v12 )
  {
    v14 = byte_47627C;
    if ( fgets(Str1, 127, v12) )
    {
      while ( 1 )
      {
        v15 = (const char *)sub_473493((int)&unk_479CBC);
        if ( !strncmp(Str1, v15, 0xAu) )
          break;
        if ( !fgets(Str1, 127, v13) )
          goto LABEL_30;
      }
      v16 = v31;
      for ( i = &v31; v16; v16 = *++i )
      {
        if ( v16 == 58 )
          break;
      }
      v14 = i + 1;
      if ( *v14 )
        ++v14;
      v18 = v14;
      if ( *v14 )
      {
        do
          ++v18;
        while ( *v18 );
        if ( v18 > v14 )
          *((_BYTE *)v18 - 1) = 0;
      }
    }
LABEL_30:
    fclose(v13);
    dword_4AE288 = (int)_strdup(v14);
  }
  dword_4AE128 = Time - 630492749;
  dword_4A7BBC = 0;
  dword_4A7BC0 = 0;
  dword_4A7BC8 = 0;
  dword_4AE12C = Time - 928492381;
  result = 0;
  dword_4AE2F0 = 0;
  dword_4AE2F4 = 0;
  dword_4AE2F8 = 0;
  dword_4AE2FC = 0;
  dword_4A7BC4 = 32;
  return result;
}
// 4A5288: using guessed type __int16 word_4A5288;
// 4A7BBC: using guessed type int dword_4A7BBC;
// 4A7BC0: using guessed type int dword_4A7BC0;
// 4A7BC4: using guessed type int dword_4A7BC4;
// 4A7BC8: using guessed type int dword_4A7BC8;
// 4AE124: using guessed type int dword_4AE124;
// 4AE128: using guessed type int dword_4AE128;
// 4AE12C: using guessed type int dword_4AE12C;
// 4AE130: using guessed type int dword_4AE130;
// 4AE138: using guessed type int dword_4AE138;
// 4AE288: using guessed type int dword_4AE288;
// 4AE2F0: using guessed type int dword_4AE2F0;
// 4AE2F4: using guessed type int dword_4AE2F4;
// 4AE2F8: using guessed type int dword_4AE2F8;
// 4AE2FC: using guessed type int dword_4AE2FC;

//----- (004075F0) --------------------------------------------------------
void __usercall __noreturn sub_4075F0(int a1@<edi>)
{
  FILE *v1; // eax
  FILE *v2; // eax
  void **v3; // esi

  v1 = (FILE *)sub_44F01A();
  fflush(v1 + 1);
  v2 = (FILE *)sub_44F01A();
  fflush(v2 + 2);
  v3 = (void **)Block;
  (*((void (__cdecl **)(_DWORD))Block + 5))(*(_DWORD *)Block);
  free(*v3);
  free(v3);
  if ( dword_4AE294 )
    _exit(a1);
  exit(a1);
}
// 4AE294: using guessed type int dword_4AE294;

//----- (00407650) --------------------------------------------------------
int __usercall sub_407650@<eax>(
        DWORD dwMessageId@<ecx>,
        const char *a2@<eax>,
        FILE *Stream,
        int a4,
        va_list ArgList,
        char *Buffer)
{
  const char *v6; // ebp
  char *v9; // eax
  char *v10; // edi
  int v11; // ecx
  const char *v12; // eax
  char *v13; // edi
  char *v14; // ebx
  const char *v15; // esi
  const char *v16; // eax
  char *v17; // edi
  void **v18; // eax
  char *v19; // esi
  FILE *v20; // ebp
  int v21; // ecx
  const char *v22; // ebx
  const char *v23; // eax

  v6 = Buffer;
  if ( !Stream )
    Stream = (FILE *)(sub_44F01A() + 8);
  v9 = dword_4A80E0;
  if ( !dword_4A80E0 )
  {
    v9 = (char *)malloc(0x400u);
    dword_4A80E0 = v9;
  }
  v10 = v9;
  if ( dword_4AE2A4 && isspace(*a2) )
  {
    do
      v11 = *++a2;
    while ( isspace(v11) );
  }
  if ( a4 && !dword_4AE2A4 )
  {
    v12 = (const char *)sub_473493((int)&unk_479CCC);
    v10 += sprintf(v10, v12, a4);
  }
  v13 = &v10[vsprintf(v10, a2, ArgList)];
  if ( dwMessageId )
  {
    if ( FormatMessageA(0x1300u, 0, dwMessageId, 0x400u, (LPSTR)&Buffer, 0, 0) )
    {
      v14 = Buffer;
      v15 = &Buffer[strlen(Buffer) - 1];
      if ( v15 > Buffer )
      {
        do
        {
          if ( !isspace(*v15) )
            break;
          --v15;
        }
        while ( v15 > v14 );
      }
      *v15 = 0;
      if ( *v14 )
      {
        v16 = (const char *)sub_473493((int)&unk_479CD4);
        v13 += sprintf(v13, v16, v14);
      }
    }
    LocalFree(Buffer);
  }
  if ( v6 )
    v13 += sprintf(v13, " %s", v6);
  *v13 = 10;
  v17 = v13 + 1;
  *v17 = 0;
  if ( dword_4AE2A4 )
  {
    v18 = sub_44F01A();
    v19 = dword_4A80E0;
    v20 = (FILE *)(v18 + 8);
    while ( v19 < v17 )
    {
      if ( isspace(*v19) )
      {
        do
          v21 = *++v19;
        while ( isspace(v21) );
      }
      if ( *v19 )
      {
        v22 = v19;
        do
        {
          if ( *v19 == 10 )
            break;
          ++v19;
        }
        while ( *v19 );
        *v19 = 0;
        if ( a4 )
        {
          v23 = (const char *)sub_473493((int)&unk_479CCC);
          printf(v23, a4);
        }
        puts(v22);
        ++v19;
      }
    }
  }
  else
  {
    fputs(dword_4A80E0, Stream);
    v20 = Stream;
  }
  return fflush(v20);
}
// 4AE2A4: using guessed type int dword_4AE2A4;

//----- (00407850) --------------------------------------------------------
void __noreturn sub_407850(const char *a1, ...)
{
  char *v1; // eax
  va_list va; // [esp+8h] [ebp+8h] BYREF

  va_start(va, a1);
  v1 = (char *)sub_473493((int)&unk_479CE0);
  sub_407650(0, a1, 0, (int)&unk_479D38, va, v1);
  exit(1);
}

//----- (00407880) --------------------------------------------------------
void __usercall __noreturn sub_407880(va_list a1@<eax>, const char *a2)
{
  FILE *v2; // eax
  FILE *v3; // eax
  int v4; // [esp-Ch] [ebp-Ch]

  v4 = sub_473493((int)&unk_479D3C);
  v2 = (FILE *)sub_44F01A();
  sub_407650(0, a2, v2 + 2, v4, a1, 0);
  if ( !dword_4AE2A4 )
  {
    v3 = (FILE *)sub_44F01A();
    fputs("\n", v3 + 2);
  }
  sub_4075F0(1);
}
// 4AE2A4: using guessed type int dword_4AE2A4;

//----- (004078E0) --------------------------------------------------------
void __noreturn sub_4078E0(const char *a1, ...)
{
  va_list va; // [esp+8h] [ebp+8h] BYREF

  va_start(va, a1);
  sub_407880(va, a1);
}

//----- (004078F0) --------------------------------------------------------
int sub_4078F0(const char *a1, ...)
{
  FILE *v1; // eax
  int v3; // [esp-Ch] [ebp-Ch]
  va_list va; // [esp+8h] [ebp+8h] BYREF

  va_start(va, a1);
  v3 = sub_473493((int)&unk_479D3C);
  v1 = (FILE *)sub_44F01A();
  return sub_407650(0, a1, v1 + 2, v3, va, 0);
}

//----- (00407920) --------------------------------------------------------
void __noreturn sub_407920(const char *a1, ...)
{
  DWORD LastError; // esi
  FILE *v2; // eax
  int v3; // [esp-Ch] [ebp-14h]
  va_list va; // [esp+10h] [ebp+8h] BYREF

  va_start(va, a1);
  LastError = GetLastError();
  v3 = sub_473493((int)&unk_479D3C);
  v2 = (FILE *)sub_44F01A();
  sub_407650(LastError, a1, v2 + 2, v3, va, 0);
  sub_4075F0(1);
}

//----- (00407970) --------------------------------------------------------
int sub_407970(const char *a1, ...)
{
  int v1; // eax
  va_list va; // [esp+8h] [ebp+8h] BYREF

  va_start(va, a1);
  v1 = sub_473493((int)&unk_479D44);
  return sub_407650(0, a1, 0, v1, va, 0);
}

//----- (004079A0) --------------------------------------------------------
int sub_4079A0(const char *a1, ...)
{
  DWORD LastError; // esi
  int v2; // eax
  va_list va; // [esp+Ch] [ebp+8h] BYREF

  va_start(va, a1);
  LastError = GetLastError();
  v2 = sub_473493((int)&unk_479D44);
  return sub_407650(LastError, a1, 0, v2, va, 0);
}

//----- (004079D0) --------------------------------------------------------
int sub_4079D0(const char *a1, ...)
{
  va_list va; // [esp+8h] [ebp+8h] BYREF

  va_start(va, a1);
  return sub_407650(0, a1, 0, 0, va, 0);
}

//----- (004079F0) --------------------------------------------------------
int sub_4079F0(const char *a1, ...)
{
  int result; // eax
  va_list va; // [esp+8h] [ebp+8h] BYREF

  va_start(va, a1);
  if ( dword_4AE134 )
    return sub_407650(0, a1, 0, 0, va, 0);
  return result;
}
// 4AE134: using guessed type int dword_4AE134;

//----- (00407A20) --------------------------------------------------------
int __cdecl sub_407A20(
        const char **a1,
        int a2,
        int (__cdecl *a3)(const char **, char **, int, int),
        unsigned __int8 (__cdecl *a4)(char *, int),
        int a5)
{
  const char *v5; // edi
  char *v6; // ebp
  unsigned int v7; // ebx
  _DWORD *v8; // eax
  int v9; // edx
  int v10; // esi
  const char *v11; // ebx
  char *v12; // eax
  char v13; // cl
  int v14; // edi
  struct _stat32 *v15; // ebp
  char v16; // al
  char *v17; // edi
  int v18; // eax
  int v19; // eax
  char **v20; // eax
  char *v21; // edi
  int v22; // eax
  int v23; // eax
  char **v24; // eax
  const char *v25; // eax
  _DWORD *v26; // eax
  int v27; // ecx
  char *v28; // ebp
  char **v29; // esi
  int v30; // ebx
  int v31; // eax
  char *v32; // edi
  int v33; // eax
  char *v34; // eax
  char v35; // cl
  int v36; // eax
  int *v37; // esi
  int v38; // eax
  int v39; // ebp
  int v40; // eax
  int v41; // ecx
  int (__cdecl *v42)(int, int); // edx
  int v43; // eax
  char *v44; // edi
  int v45; // eax
  int v46; // eax
  char *v47; // edi
  int v48; // ebp
  _BYTE *v49; // esi
  char *v50; // eax
  int v51; // edx
  char v52; // cl
  int v53; // eax
  int v54; // eax
  int v55; // esi
  int v56; // eax
  int v57; // eax
  const char *v59; // eax
  int v60; // [esp-4h] [ebp-50h]
  char *Block; // [esp+10h] [ebp-3Ch]
  char *Blocka; // [esp+10h] [ebp-3Ch]
  char *FileName; // [esp+14h] [ebp-38h]
  unsigned int v64; // [esp+18h] [ebp-34h]
  char *v65; // [esp+18h] [ebp-34h]
  int v66; // [esp+20h] [ebp-2Ch]
  int v67; // [esp+20h] [ebp-2Ch]
  int NumOfElements; // [esp+2Ch] [ebp-20h]
  int v69; // [esp+30h] [ebp-1Ch]
  char *Base; // [esp+38h] [ebp-14h]
  int v71; // [esp+3Ch] [ebp-10h]
  int v72; // [esp+40h] [ebp-Ch]
  char *v73; // [esp+48h] [ebp-4h]

  v5 = *a1;
  FileName = (char *)*a1;
  v6 = sub_40F2B0(*a1);
  Block = v6;
  if ( v6 )
  {
    v7 = strlen(v5);
    v64 = v7;
    NumOfElements = 0;
    v69 = 16;
    Base = (char *)(*(int (__thiscall **)(void *, int))(*(_DWORD *)dword_4A80FC + 8))(dword_4A80FC, 192);
    v71 = 0;
    v72 = 32;
    v73 = (char *)(*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(384);
    if ( !dword_4A6A84 )
    {
      v8 = malloc(0x10u);
      v9 = *(_DWORD *)dword_4A80FC;
      dword_4A6A84 = (int)v8;
      *v8 = 0;
      v8[1] = 64;
      v8[2] = 64;
      *(_DWORD *)(dword_4A6A84 + 12) = (*(int (__cdecl **)(int))(v9 + 8))(256);
    }
    if ( v5[v7 - 1] == 92 )
      v64 = v7 - 1;
    else
      v5[v7] = 92;
    v10 = sub_40F3A0((int)v6);
    if ( v10 )
    {
      v66 = (int)&v5[v64 + 1];
      do
      {
        v11 = (const char *)(v10 + 10);
        v12 = (char *)(v10 + 10);
        do
        {
          v13 = *v12;
          v12[v66 - (v10 + 10)] = *v12;
          ++v12;
        }
        while ( v13 );
        if ( !a4 || a4(FileName, a5) )
        {
          v14 = dword_4A6A84;
          if ( !*(_DWORD *)dword_4A6A84 )
          {
            **(_DWORD **)(v14 + 12) = malloc(0x24u);
            *(_DWORD *)v14 = 1;
          }
          v15 = *(struct _stat32 **)(*(_DWORD *)(v14 + 12) + 4 * (*(_DWORD *)v14)-- - 4);
          if ( _stat32(FileName, v15) )
          {
            v25 = (const char *)sub_473493((int)&unk_479D50);
            sub_4079A0(v25, FileName);
          }
          else if ( *v11 != 46 || (a2 & 4) != 0 && (v16 = *(_BYTE *)(v10 + 11)) != 0 && v16 != 46 )
          {
            if ( (v15->st_mode & 0xF000) == 0x4000 )
            {
              v17 = _strdup(v11);
              v18 = v69;
              if ( NumOfElements == v69 )
              {
                v69 += 16;
                v60 = 12 * (v18 + 16);
                if ( Base )
                  v19 = (*(int (__cdecl **)(char *, int))(*(_DWORD *)dword_4A80FC + 12))(Base, v60);
                else
                  v19 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(v60);
                Base = (char *)v19;
              }
              v20 = (char **)&Base[12 * NumOfElements];
              *v20 = v17;
              v20[1] = (char *)v15;
              v20[2] = 0;
              ++NumOfElements;
            }
            else
            {
              v21 = _strdup(v11);
              if ( v71 == v72 )
              {
                v22 = v72 + 32;
                v72 += 32;
                if ( v73 )
                  v23 = (*(int (__cdecl **)(char *, int))(*(_DWORD *)dword_4A80FC + 12))(v73, 12 * v22);
                else
                  v23 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(12 * v22);
                v73 = (char *)v23;
              }
              v24 = (char **)&v73[12 * v71];
              *v24 = v21;
              v24[1] = (char *)v15;
              v24[2] = 0;
              ++v71;
            }
            goto LABEL_35;
          }
          v26 = (_DWORD *)dword_4A6A84;
          v27 = *(_DWORD *)dword_4A6A84;
          *(_DWORD *)(*(_DWORD *)(dword_4A6A84 + 12) + 4 * v27) = v15;
          *v26 = v27 + 1;
        }
LABEL_35:
        v10 = sub_40F3A0((int)Block);
      }
      while ( v10 );
    }
    _findclose(*(_DWORD *)Block);
    if ( *((_DWORD *)Block + 72) )
      free(*((void **)Block + 72));
    free(Block);
    if ( (a2 & 0x80u) == 0 )
    {
      qsort(Base, NumOfElements, 0xCu, (_CoreCrtNonSecureSearchSortCompareFunction)CompareFunction);
      qsort(v73, v71, 0xCu, (_CoreCrtNonSecureSearchSortCompareFunction)CompareFunction);
    }
    Blocka = (char *)NumOfElements;
    if ( (a2 & 0x10) != 0 )
      Blocka = (char *)(NumOfElements + v71);
    v28 = &FileName[v64];
    v65 = v28;
    *v28 = 0;
    if ( NumOfElements <= 0 )
    {
      v30 = a5;
    }
    else
    {
      v29 = (char **)Base;
      v30 = a5;
      v31 = a2 & 8;
      v67 = NumOfElements;
      while ( 1 )
      {
        --Blocka;
        v32 = *v29;
        if ( v31 && ((a2 & 0x20) != 0 || (a2 & 1) == 0) )
        {
          v33 = 2;
          if ( !Blocka )
            v33 = 3;
          v29[2] = (char *)a3(a1, v29, v33, a5);
        }
        if ( (a2 & 3) == 3 )
        {
          *v28 = 92;
          v34 = v32;
          do
          {
            v35 = *v34;
            v34[v28 - v32 + 1] = *v34;
            ++v34;
          }
          while ( v35 );
          *v29 = FileName;
          sub_407A20(v29, a2, a3, a4, a5);
          *v29 = v32;
          *v28 = 0;
        }
        if ( (a2 & 8) != 0 && (a2 & 0x40) != 0 )
        {
          v36 = 4;
          if ( !Blocka )
            v36 = 5;
          v29[2] = (char *)a3(a1, v29, v36, a5);
        }
        v29 += 3;
        if ( !--v67 )
          break;
        v31 = a2 & 8;
      }
    }
    v37 = (int *)dword_4A6A84;
    v38 = *(_DWORD *)dword_4A6A84;
    *v28 = 0;
    v39 = v71;
    if ( v38 + v71 > v37[1] )
    {
      v40 = v38 + v37[2] + v71;
      v41 = v37[3];
      v42 = *(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12);
      v37[1] = v40;
      v43 = v42(v41, 4 * v40);
      v37 = (int *)dword_4A6A84;
      *(_DWORD *)(dword_4A6A84 + 12) = v43;
    }
    if ( v71 > 0 )
    {
      v44 = v73;
      do
      {
        if ( (a2 & 0x10) != 0 )
        {
          v45 = 0;
          if ( !--Blocka )
            v45 = 1;
          a3(a1, (char **)v44, v45, v30);
          v37 = (int *)dword_4A6A84;
        }
        free(*(void **)v44);
        v46 = *v37;
        *(_DWORD *)(v37[3] + 4 * v46) = *((_DWORD *)v44 + 1);
        v44 += 12;
        --v39;
        *v37 = v46 + 1;
      }
      while ( v39 );
    }
    *v65 = 92;
    if ( NumOfElements > 0 )
    {
      v47 = Base;
      v48 = NumOfElements;
      do
      {
        if ( (a2 & 2) != 0 && (a2 & 1) == 0 )
        {
          v49 = *(_BYTE **)v47;
          v50 = *(char **)v47;
          v51 = (int)&v65[-*(_DWORD *)v47 + 1];
          do
          {
            v52 = *v50;
            v50[v51] = *v50;
            ++v50;
          }
          while ( v52 );
          *(_DWORD *)v47 = FileName;
          sub_407A20(v47, a2, a3, a4, a5);
          *(_DWORD *)v47 = v49;
          v37 = (int *)dword_4A6A84;
        }
        free(*(void **)v47);
        v53 = v37[1];
        if ( *v37 == v53 )
        {
          v54 = v37[2] + v53;
          v37[1] = v54;
          v55 = v37[3];
          if ( v55 )
            v56 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v55, 4 * v54);
          else
            v56 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(4 * v54);
          v37 = (int *)dword_4A6A84;
          *(_DWORD *)(dword_4A6A84 + 12) = v56;
        }
        v57 = *v37;
        *(_DWORD *)(v37[3] + 4 * v57) = *((_DWORD *)v47 + 1);
        v47 += 12;
        --v48;
        *v37 = v57 + 1;
      }
      while ( v48 );
    }
    if ( Base )
      (*(void (__cdecl **)(char *))(*(_DWORD *)dword_4A80FC + 16))(Base);
    if ( v73 )
      (*(void (__cdecl **)(char *))(*(_DWORD *)dword_4A80FC + 16))(v73);
    *v65 = 0;
    return 1;
  }
  else
  {
    v59 = (const char *)sub_473493((int)&unk_479D68);
    sub_4079A0(v59, v5);
    return 0;
  }
}
// 4A6A84: using guessed type int dword_4A6A84;

//----- (00408060) --------------------------------------------------------
const char *__usercall sub_408060@<eax>(const char *a1@<esi>, struct _stat32 *Stat)
{
  const char *v2; // ebp
  int v3; // eax
  int v4; // edi
  int v5; // eax

  v2 = a1;
  v3 = strlen(a1);
  v4 = v3;
  if ( a1[v3 - 1] == 92 && v3 > 3 )
  {
    strcpy(byte_4A6E88, a1);
    byte_4A6E88[--v4] = 0;
    v2 = byte_4A6E88;
  }
  v5 = _stat32(v2, Stat);
  if ( v5 )
  {
    if ( v2 != byte_4A6E88 )
      v2 = strcpy(byte_4A6E88, a1);
    byte_4A6E88[v4] = 92;
    byte_4A6E89[v4] = 0;
    v5 = _stat32(v2, Stat);
  }
  return v5 == 0 ? v2 : 0;
}

//----- (00408110) --------------------------------------------------------
int __usercall sub_408110@<eax>(
        const char *a1@<eax>,
        int a2,
        int (__cdecl *a3)(const char **, char **, int, int),
        unsigned __int8 (__cdecl *a4)(char *, int),
        int a5)
{
  int v5; // ebx
  const char *v7; // edi
  const char *v8; // ecx
  _BYTE *v9; // edx
  void *v10; // esi
  char v11; // al
  const char *v13; // eax
  void *Block[2]; // [esp+Ch] [ebp-30h] BYREF
  int v15; // [esp+14h] [ebp-28h]
  struct _stat32 v16; // [esp+18h] [ebp-24h] BYREF

  v5 = 0;
  if ( !a3 )
    return 0;
  v7 = sub_408060(a1, &v16);
  if ( !v7 )
  {
    v13 = (const char *)sub_473493((int)&unk_479D80);
    sub_4079A0(v13, a1);
    return 0;
  }
  if ( (v16.st_mode & 0xF000) != 0x4000 )
    return 0;
  Block[1] = &v16;
  Block[0] = malloc(0x200u);
  v15 = 0;
  v8 = v7;
  v9 = Block[0];
  v10 = Block[0];
  do
  {
    v11 = *v8;
    *v9++ = *v8++;
  }
  while ( v11 );
  if ( v10 )
  {
    if ( (a2 & 0x20) != 0 )
      v15 = a3(0, (char **)Block, 2, a5);
    v5 = sub_407A20((const char **)Block, a2, a3, a4, a5);
    if ( (a2 & 0x40) != 0 )
      v15 = a3(0, (char **)Block, 4, a5);
  }
  free(Block[0]);
  return v5;
}

//----- (00408210) --------------------------------------------------------
CHAR *__usercall sub_408210@<eax>(const CHAR *a1@<eax>)
{
  const char *v2; // eax
  CHAR *v3; // eax
  int v4; // esi
  CHAR *v5; // edx
  int v7; // [esp-8h] [ebp-Ch]

  if ( !dword_4A80E4 )
    dword_4A80E4 = (int)_getcwd(0, 0);
  if ( PathIsRelativeA(a1) )
  {
    v7 = dword_4A80E4;
    v2 = (const char *)sub_473493((int)&unk_479DA0);
    sprintf(pszBuf, v2, v7, a1);
    v3 = pszBuf;
  }
  else
  {
    v3 = (CHAR *)a1;
  }
  v4 = 0;
  if ( *v3 )
  {
    v5 = (CHAR *)(pszPath - v3);
    do
    {
      if ( *v3 == 47 )
        v3[(_DWORD)v5] = 92;
      else
        v3[(_DWORD)v5] = *v3;
      ++v3;
      ++v4;
    }
    while ( *v3 );
  }
  pszPath[v4] = 0;
  PathCanonicalizeA(pszBuf, pszPath);
  return pszBuf;
}
// 4A80E4: using guessed type int dword_4A80E4;

//----- (004082B0) --------------------------------------------------------
int __usercall sub_4082B0@<eax>(const char *a1@<eax>)
{
  char *v1; // edi
  char *v2; // esi
  int v3; // ebp
  char v4; // al
  char v5; // bl

  v1 = _strdup(a1);
  v2 = v1;
  v3 = 0;
  if ( isalpha(*v1) )
  {
    if ( v1[1] == 58 )
    {
      v4 = v1[2];
      if ( v4 == 47 || v4 == 92 )
        v2 = v1 + 3;
    }
  }
  if ( *v2 )
  {
    while ( 1 )
    {
      while ( *v2 == 47 || *v2 == 92 )
        ++v2;
      for ( ; *v2; ++v2 )
      {
        if ( *v2 == 47 )
          break;
        if ( *v2 == 92 )
          break;
      }
      v5 = *v2;
      *v2 = 0;
      if ( _mkdir(v1) )
      {
        if ( *_errno() != 17 )
          break;
      }
      *v2 = v5;
      if ( !v5 )
      {
        free(v1);
        return 0;
      }
    }
    v3 = *_errno();
  }
  free(v1);
  return v3;
}

//----- (00408360) --------------------------------------------------------
int __usercall sub_408360@<eax>(int result@<eax>, _BYTE *a2@<ecx>)
{
  int v2; // edi
  int v3; // esi

  v2 = 0;
  if ( *a2 )
  {
    v3 = result - (_DWORD)a2;
    do
    {
      if ( *a2 == 47 )
        a2[v3] = 92;
      else
        a2[v3] = *a2;
      ++a2;
      ++v2;
    }
    while ( *a2 );
  }
  *(_BYTE *)(v2 + result) = 0;
  return result;
}

//----- (00408390) --------------------------------------------------------
HANDLE __usercall sub_408390@<eax>(const CHAR *a1@<ebx>, const CHAR *lpFileName)
{
  HANDLE FileA; // edi
  HANDLE result; // eax
  void *v4; // esi
  const char *v5; // eax
  const char *v6; // eax
  struct _FILETIME LastWriteTime; // [esp+10h] [ebp-18h] BYREF
  struct _FILETIME LastAccessTime; // [esp+18h] [ebp-10h] BYREF
  struct _FILETIME CreationTime; // [esp+20h] [ebp-8h] BYREF

  FileA = CreateFileA(lpFileName, 0xC0000000, 5u, 0, 3u, 0x2000000u, 0);
  result = CreateFileA(a1, 0x80000000, 5u, 0, 3u, 0x2000000u, 0);
  v4 = result;
  if ( result )
  {
    if ( FileA )
    {
      if ( !GetFileTime(result, &CreationTime, &LastAccessTime, &LastWriteTime) )
      {
        v5 = (const char *)sub_473493((int)&unk_479DAC);
        sub_4079A0(v5, a1);
      }
      if ( !SetFileTime(FileA, &CreationTime, &LastAccessTime, &LastWriteTime) )
      {
        v6 = (const char *)sub_473493((int)&unk_479DCC);
        sub_4079A0(v6, lpFileName);
      }
    }
    result = (HANDLE)CloseHandle(v4);
  }
  if ( FileA )
    return (HANDLE)CloseHandle(FileA);
  return result;
}

//----- (00408460) --------------------------------------------------------
char *__usercall sub_408460@<eax>(int a1@<edi>)
{
  _DWORD *v1; // eax
  _DWORD *v2; // esi
  _DWORD *v3; // eax
  int v4; // esi
  char *result; // eax
  struct WSAData WSAData; // [esp+8h] [ebp-19Ch] BYREF

  if ( WSAStartup(2u, &WSAData) )
  {
    sub_473493((int)&unk_4A4F48);
    sub_473200();
  }
  sub_4072F0();
  srand(dword_4AE130 + dword_4AE124 / 10000);
  dword_4AE100 = Time;
  if ( !dword_4A80FC )
  {
    v1 = (_DWORD *)off_4A4FE4(16);
    dword_4A80FC = v1;
    v2 = v1;
    *v1 = 0;
    v1[2] = 0;
    v1[3] = 0;
    v1[1] = 64;
    v3 = (_DWORD *)off_4A4FE4(256);
    v2[2] = v3;
    v2[3] = 0;
    *v3 = &unk_4A4FF0;
    *v2 = &unk_4A4FF0;
  }
  sub_406690();
  if ( a1 > 1 )
  {
    v4 = a1 - 1;
    do
    {
      sub_473493((int)&unk_479DE8);
      --v4;
    }
    while ( v4 );
  }
  result = sub_47320D();
  dword_4AE298 = (int)result;
  return result;
}
// 473200: using guessed type void __noreturn sub_473200(void);
// 4A4FE4: using guessed type int (__cdecl *off_4A4FE4)(_DWORD);
// 4AE100: using guessed type int dword_4AE100;
// 4AE124: using guessed type int dword_4AE124;
// 4AE130: using guessed type int dword_4AE130;
// 4AE298: using guessed type int dword_4AE298;

//----- (00408570) --------------------------------------------------------
int __usercall sub_408570@<eax>(int a1@<eax>)
{
  int result; // eax
  int v2; // eax

  if ( a1 > 32 )
  {
    if ( a1 > 256 )
    {
      if ( a1 == 512 )
        return sub_473493((int)&unk_479D44);
      if ( a1 == 1024 )
        return sub_473493((int)&unk_479E10);
    }
    else
    {
      if ( a1 == 256 )
        return sub_473493((int)&unk_479DF0);
      v2 = a1 - 64;
      if ( !v2 )
        return sub_473493((int)&unk_479DF0);
      if ( v2 == 64 )
        return sub_473493((int)&unk_479D44);
    }
    return sub_473493((int)&unk_479E1C);
  }
  if ( a1 == 32 )
    return sub_473493((int)&unk_479D44);
  switch ( a1 )
  {
    case 1:
    case 16:
      return sub_473493((int)&unk_479DF0);
    case 2:
      return sub_473493((int)&unk_479D44);
    case 4:
      result = sub_473493((int)&unk_479E00);
      break;
    case 8:
      return sub_473493((int)&unk_479E10);
    default:
      return sub_473493((int)&unk_479E1C);
  }
  return result;
}

//----- (00408620) --------------------------------------------------------
void __cdecl sub_408620(int a1, int *a2)
{
  int v2; // esi
  const char *v3; // eax
  char *v4; // eax
  int v5; // ebx
  int *v6; // edi
  const char *v7; // eax
  const char *v8; // ebp
  char *v9; // eax
  char *v10; // esi
  char *i; // eax
  char v12; // bl
  int v13; // [esp-18h] [ebp-2Ch]
  int v14; // [esp-14h] [ebp-28h]
  int v15; // [esp-10h] [ebp-24h]
  int v16; // [esp-10h] [ebp-24h]
  int v17; // [esp-Ch] [ebp-20h]
  int v18; // [esp-Ch] [ebp-20h]
  int v19; // [esp+8h] [ebp-Ch]
  int v20; // [esp+Ch] [ebp-8h]
  char *v21; // [esp+10h] [ebp-4h]
  int v22; // [esp+18h] [ebp+4h]

  v2 = *a2;
  if ( !a1 || v2 )
  {
    v3 = (const char *)sub_473493((int)&unk_479E2C);
    v4 = getenv(v3);
    if ( v4 && *v4 == 49 )
    {
      v5 = 1;
      v22 = 1;
    }
    else
    {
      v22 = 0;
      v5 = 0;
    }
    if ( v2 > 0 )
    {
      v19 = 0;
      v20 = v2;
      do
      {
        v6 = (int *)(v19 + a2[3]);
        if ( dword_4AE2A4 )
        {
          v7 = (const char *)sub_473493((int)&unk_479E44);
        }
        else if ( v5 )
        {
          v7 = (const char *)sub_473493((int)&unk_479E6C);
        }
        else
        {
          v7 = (const char *)sub_473493((int)&unk_479E5C);
        }
        v8 = v7;
        if ( dword_4AE2A4 )
        {
          if ( *(_BYTE *)v6[3] )
          {
            v9 = _strdup((const char *)v6[3]);
            v21 = v9;
            v10 = v9;
            if ( *v9 )
            {
              do
              {
                for ( i = v10; *v10; ++v10 )
                {
                  if ( *v10 == 10 )
                    break;
                }
                v12 = *v10;
                *v10 = 0;
                sub_4079D0(v8, v6[1], v6[2], *v6, i);
                if ( v12 )
                  *v10++ = v12;
              }
              while ( *v10 );
              v9 = v21;
              v5 = v22;
            }
            free(v9);
          }
          else
          {
            sub_4079D0(v7, v6[1], v6[2], *v6, byte_47627C);
          }
        }
        else if ( v5 )
        {
          v17 = v6[2];
          v15 = v6[1];
          v14 = v6[3];
          v13 = sub_408570(*v6);
          sub_4079D0(v8, v13, v14, v15, v17);
        }
        else
        {
          v18 = v6[3];
          v16 = sub_408570(*v6);
          sub_4079D0(v8, v6[1], v6[2], v16, v18);
        }
        v19 += 16;
        --v20;
      }
      while ( v20 );
    }
  }
}
// 4AE2A4: using guessed type int dword_4AE2A4;

//----- (00408790) --------------------------------------------------------
void *__usercall sub_408790@<eax>(char *FileName@<ecx>, int a2@<eax>)
{
  const char *v4; // eax
  bool v5; // sf
  int v6; // eax
  BOOL v7; // esi
  void *result; // eax
  int v9[4]; // [esp+8h] [ebp-10h] BYREF

  sub_406360(v9);
  v4 = (const char *)sub_473493((int)&unk_479E88);
  sub_4079F0(v4, FileName);
  v5 = *(int *)a2 < 0;
  dword_4A6A80 = (int)v9;
  if ( !v5 )
    byte_4AB3A5 = *(_BYTE *)a2;
  if ( *(int *)(a2 + 8) >= 0 )
    byte_4AB3A7 = *(_BYTE *)(a2 + 8);
  zend_hash_clean(dword_4AB374);
  zend_hash_clean(dword_4AB370);
  v6 = sub_405BB0(FileName);
  v7 = v6 != 0;
  if ( v9[0] )
  {
    if ( dword_4AE2A0 != 7 )
      dword_4AE2A0 = 8;
    sub_408620(v6 != 0, v9);
  }
  result = sub_406420(v9);
  if ( !v7 )
    dword_4AE2A0 = 7;
  return result;
}
// 4A6A80: using guessed type int dword_4A6A80;
// 4AB3A5: using guessed type char byte_4AB3A5;
// 4AB3A7: using guessed type char byte_4AB3A7;
// 4AE2A0: using guessed type int dword_4AE2A0;

//----- (00408860) --------------------------------------------------------
int __cdecl sub_408860(_DWORD *a1, int a2, int a3, int a4)
{
  char *v4; // eax

  if ( a1[8] && !a1[11] && a1[9] )
  {
    v4 = sub_40F160((int)a1);
    sub_408790(v4, a4);
  }
  return 1;
}

//----- (00408890) --------------------------------------------------------
_DWORD *__usercall sub_408890@<eax>(int *a1@<ebx>, _DWORD *a2, int a3, int *a4, int a5)
{
  _DWORD *result; // eax
  char *v6; // esi
  const char *v7; // eax
  const char *v8; // eax
  const char *v9; // eax
  int v10; // [esp-14h] [ebp-2A8h]
  int v11; // [esp-10h] [ebp-2A4h]
  int v12; // [esp-Ch] [ebp-2A0h]
  int v13; // [esp-8h] [ebp-29Ch]
  int v14; // [esp-4h] [ebp-298h]
  int i; // [esp+10h] [ebp-284h]
  struct _stat32 Stat; // [esp+14h] [ebp-280h] BYREF
  int v17[151]; // [esp+38h] [ebp-25Ch] BYREF

  result = a2;
  for ( i = 0; i < *a2; ++i )
  {
    v6 = *(char **)(a2[3] + 4 * i);
    if ( _stat32(v6, &Stat) )
    {
      v9 = (const char *)sub_473493((int)&unk_479EBC);
      sub_4079A0(v9, v6);
    }
    else if ( (Stat.st_mode & 0xF000) == 0x4000 )
    {
      memset(v17, 0, 0x258u);
      memset(v17, 255, 16);
      sub_40E440(&v17[59]);
      v17[142] = (int)a4;
      v17[143] = (int)a1;
      v17[144] = a5;
      v7 = (const char *)sub_473493((int)&unk_4826F0);
      sub_4079F0(v7);
      sub_408110(
        v6,
        62,
        (int (__cdecl *)(const char **, char **, int, int))sub_40E780,
        (unsigned __int8 (__cdecl *)(char *, int))sub_40EF40,
        (int)v17);
      if ( dword_4AE2A4 )
      {
        v14 = v17[149];
        v13 = v17[148];
        v12 = v17[147];
        v11 = v17[146];
        v10 = v17[145];
        v8 = (const char *)sub_473493((int)&unk_479EA0);
        printf(v8, v10, v11, v12, v13, v14);
      }
      sub_40F1F0(&v17[59], (int (__cdecl *)(int, int, bool, int))sub_408860, 0, a3);
      sub_40E4C0(&v17[59], 0);
    }
    else if ( sub_409C30(a1, v6, a4) )
    {
      sub_408790(v6, a3);
    }
    result = (_DWORD *)(i + 1);
  }
  return result;
}
// 4AE2A4: using guessed type int dword_4AE2A4;

//----- (00408A50) --------------------------------------------------------
int __cdecl sub_408A50(char *FileName, char *a2)
{
  char *v2; // edi
  int v3; // ebp
  int v4; // eax
  int v5; // ebx
  const char *v6; // eax
  const char *v7; // eax
  void *v8; // eax
  int v9; // eax
  bool v10; // sf
  int v11; // esi
  unsigned int v12; // edi
  int v13; // eax
  bool v14; // sf
  const char *v15; // eax
  const char *v16; // eax

  v2 = FileName;
  v3 = _open(FileName, 0x8000);
  v4 = _open(a2, 33537, 438);
  v5 = v4;
  if ( v3 < 0 )
  {
    v6 = (const char *)sub_473493((int)&unk_479ED4);
    sub_407920(v6, FileName);
  }
  if ( v4 < 0 )
  {
    v7 = (const char *)sub_473493((int)&unk_479EF4);
    sub_407920(v7, a2);
  }
  v8 = DstBuf;
  if ( !DstBuf )
  {
    v8 = malloc(0x2000u);
    DstBuf = v8;
  }
  v9 = _read(v3, v8, 0x2000u);
  v10 = v9 < 0;
  if ( v9 > 0 )
  {
    do
    {
      v11 = 0;
      v12 = v9;
      while ( 1 )
      {
        v13 = _write(v5, (char *)DstBuf + v11, v12);
        v14 = v13 < 0;
        if ( v13 <= 0 )
          break;
        v11 += v13;
        v12 -= v13;
        if ( !v12 )
        {
          v14 = v13 < 0;
          break;
        }
      }
      if ( v14 )
      {
        v16 = (const char *)sub_473493((int)&unk_479F14);
        sub_407920(v16, a2);
      }
      v9 = _read(v3, DstBuf, 0x2000u);
    }
    while ( v9 > 0 );
    v2 = FileName;
    v10 = v9 < 0;
  }
  if ( v10 )
  {
    v15 = (const char *)sub_473493((int)&unk_479F2C);
    sub_4078E0(v15, v2);
  }
  _close(v3);
  return _close(v5);
}
// 408AE6: conditional instruction was optimized away because eax.4>=1

//----- (00408B70) --------------------------------------------------------
int __cdecl sub_408B70(int *a1, int a2, int a3)
{
  char *v3; // edi
  char *v4; // eax
  unsigned int v5; // eax
  int v6; // ebp
  const char *v7; // eax
  char *v8; // ecx
  char *v9; // esi
  char v10; // dl
  const char *v11; // edx
  unsigned int v12; // eax
  char *v13; // edi
  const char *v15; // eax
  const char *v16; // eax
  const char *v17; // eax
  const CHAR *v19; // [esp+14h] [ebp-40Ch] BYREF
  char FileName[1028]; // [esp+18h] [ebp-408h] BYREF

  v3 = sub_40F030((int)a1, 1);
  v4 = *(char **)(*a1 + 244);
  v19 = v3;
  v5 = strlen(sub_40F100(v4));
  v6 = 1;
  if ( !a1[80] || a1[81] )
  {
    v8 = *(char **)a2;
    v9 = &FileName[-*(_DWORD *)a2];
    do
    {
      v10 = *v8;
      v8[(_DWORD)v9] = *v8;
      ++v8;
    }
    while ( v10 );
    v11 = &v3[v5 - 1];
    v12 = strlen(v11) + 1;
    v13 = (char *)&v19 + 3;
    while ( *++v13 )
      ;
    qmemcpy(v13, v11, v12);
    if ( a3 )
    {
      if ( *(_DWORD *)(*(_DWORD *)(a2 + 4) + 32) && _chmod(FileName, a1[71]) )
      {
        v17 = (const char *)sub_473493((int)&unk_479FA0);
        sub_4079A0(v17, FileName);
      }
    }
    else
    {
      if ( _mkdir(FileName) )
      {
        if ( *_errno() != 17 )
        {
          v6 = 0;
          v15 = (const char *)sub_473493((int)&unk_479F48);
          sub_4079A0(v15, FileName);
        }
      }
      else
      {
        if ( a1[80] )
          v16 = (const char *)sub_473493((int)&unk_479F68);
        else
          v16 = (const char *)sub_473493((int)&unk_479F88);
        sub_4079F0(v16, FileName);
      }
      sub_408390(v19, FileName);
    }
  }
  else if ( !a3 )
  {
    v7 = (const char *)sub_473493((int)&unk_479FC4);
    sub_4079F0(v7, v3);
  }
  return v6;
}

//----- (00408D20) --------------------------------------------------------
int __usercall sub_408D20@<eax>(char *a1@<eax>, int a2@<edi>, char *a3@<esi>, int a4)
{
  const char *v5; // eax
  const char *v6; // eax

  if ( !*(_DWORD *)(a2 + 8) )
  {
    v5 = (const char *)sub_473493((int)&unk_479FDC);
    sub_4079F0(v5, a1, a3);
    _chmod(a3, 511);
    sub_408A50(a1, a3);
    if ( *(_DWORD *)(*(_DWORD *)(a2 + 4) + 36) )
      sub_408390(a1, a3);
    if ( *(_DWORD *)(*(_DWORD *)(a2 + 4) + 32) && _chmod(a3, *(_DWORD *)(a4 + 12) & 0x1FF) )
    {
      v6 = (const char *)sub_473493((int)&unk_479FA0);
      sub_4079A0(v6, a3);
    }
  }
  return 1;
}

//----- (00408DB0) --------------------------------------------------------
int __cdecl sub_408DB0(char *FileName)
{
  int v1; // ebx
  FILE *v2; // eax
  FILE *v3; // esi
  int v4; // eax
  size_t v5; // edi
  const char *v6; // eax
  const char *v8; // eax
  int Str1[3]; // [esp+8h] [ebp-10h] BYREF

  v1 = 0;
  v2 = fopen(FileName, "rb");
  v3 = v2;
  if ( !v2 )
    return v1;
  if ( fgetc(v2) == 35 && fgetc(v3) == 33 )
  {
    do
      v4 = fgetc(v3);
    while ( v4 != -1 && v4 != 10 );
  }
  else
  {
    rewind(v3);
  }
  v5 = fread(Str1, 1u, 9u, v3);
  fclose(v3);
  if ( v5 != 9 )
    return v1;
  v6 = (const char *)sub_473493((int)&unk_479FEC);
  if ( !strncmp((const char *)Str1, v6, 7u) )
    return 2;
  v8 = (const char *)sub_473493((int)&unk_479FF8);
  if ( strncmp((const char *)Str1, v8, 9u) )
  {
    if ( Str1[0] > 1314353730 )
    {
      if ( Str1[0] > 1738981189 )
      {
        if ( Str1[0] != 1748269360 && Str1[0] != 1936155757 )
          return v1;
      }
      else if ( Str1[0] != 1738981189 && Str1[0] != 1450126132 && Str1[0] != 1663783496 )
      {
        return 0;
      }
    }
    else if ( Str1[0] != 1314353730 )
    {
      if ( Str1[0] > 35084335 )
      {
        if ( Str1[0] != 346024979 && Str1[0] != 1069295747 )
          return 0;
      }
      else if ( Str1[0] != 35084335 && Str1[0] != -2010398461 && Str1[0] != -1632208190 && Str1[0] != -559038242 )
      {
        return 0;
      }
    }
  }
  return 1;
}
// 408DB0: using guessed type int Str1[3];

//----- (00408F60) --------------------------------------------------------
BOOL __cdecl sub_408F60(char *FileNamea)
{
  char *FileName; // ecx
  struct _stat32 v3; // [esp+0h] [ebp-48h] BYREF
  struct _stat32 Stat; // [esp+24h] [ebp-24h] BYREF

  return _stat32(FileName, &Stat) != -1 && _stat32(FileNamea, &v3) != -1 && v3.st_mtime >= Stat.st_mtime;
}
// 408F69: variable 'FileName' is possibly undefined

//----- (00408FB0) --------------------------------------------------------
int __usercall sub_408FB0@<eax>(int ArgList@<ecx>, int a2@<eax>)
{
  int v2; // eax
  int result; // eax
  const char *v4; // eax
  const char *v5; // eax

  v2 = a2 - 1;
  if ( v2 )
  {
    result = v2 - 1;
    if ( !result )
    {
      v4 = (const char *)sub_473493((int)&unk_47A030);
      return sub_407970(v4, ArgList);
    }
  }
  else
  {
    v5 = (const char *)sub_473493((int)&unk_47A004);
    return sub_407970(v5, ArgList);
  }
  return result;
}

//----- (00409000) --------------------------------------------------------
int __cdecl sub_409000(_DWORD *a1, int a2, int a3, int a4)
{
  char *v4; // edi
  unsigned int v5; // esi
  char *v6; // eax
  char *v7; // edx
  char v8; // cl
  const char *v9; // esi
  unsigned int v10; // eax
  char *v11; // edi
  int v13; // edi
  int v14; // eax
  const char *v15; // eax
  const char *v16; // eax
  int v17; // eax
  const char *v18; // eax
  int v19; // eax
  char *v20; // edi
  unsigned int v21; // esi
  char *v22; // eax
  char *v23; // edx
  char v24; // cl
  unsigned int v25; // eax
  char *v26; // esi
  char *v27; // edi
  int result; // eax
  char *v30; // [esp-4h] [ebp-434h]
  char *v31; // [esp+10h] [ebp-420h]
  char *v32; // [esp+10h] [ebp-420h]
  int v33; // [esp+14h] [ebp-41Ch]
  int v34[3]; // [esp+18h] [ebp-418h] BYREF
  char v35; // [esp+27h] [ebp-409h] BYREF
  char FileName[1028]; // [esp+28h] [ebp-408h] BYREF

  v33 = 1;
  if ( a1[8] )
  {
    if ( a1[11] )
    {
      v30 = sub_40F160((int)a1);
      v18 = (const char *)sub_473493((int)&unk_47A0A0);
      sub_4079F0(v18, v30);
      goto LABEL_24;
    }
    v4 = sub_40F160((int)a1);
    v31 = v4;
    v5 = strlen(sub_40F100(*(char **)(*a1 + 244)));
    v6 = *(char **)a4;
    v7 = &FileName[-*(_DWORD *)a4];
    do
    {
      v8 = *v6;
      v6[(_DWORD)v7] = *v6;
      ++v6;
    }
    while ( v8 );
    v9 = &v4[v5 - 1];
    v10 = strlen(v9) + 1;
    v11 = &v35;
    while ( *++v11 )
      ;
    qmemcpy(v11, v9, v10);
    v13 = a4;
    if ( !*(_DWORD *)(*(_DWORD *)(a4 + 4) + 100) || !sub_408F60(FileName) )
    {
      v14 = sub_408DB0(v31);
      if ( a1[10] )
      {
        if ( v14 )
        {
LABEL_11:
          sub_408FB0((int)v31, v14);
LABEL_22:
          v33 = sub_408D20(v31, v13, FileName, (int)a1);
          goto LABEL_24;
        }
        v15 = (const char *)sub_473493((int)&unk_47A05C);
        sub_4079F0(v15, v31, FileName);
        _chmod(FileName, 511);
        v33 = sub_407050(v31, FileName, *(_DWORD **)(a4 + 4));
      }
      else if ( a1[9] )
      {
        if ( v14 )
          goto LABEL_11;
        sub_406360(v34);
        v16 = (const char *)sub_473493((int)&unk_47A080);
        sub_4079F0(v16, v31, FileName);
        v17 = sub_406940(a1[73], FileName, v31, *(_DWORD *)(a4 + 4), (int)v34);
        v33 = v17;
        if ( v34[0] )
        {
          if ( dword_4AE2A0 != 7 )
            dword_4AE2A0 = 8;
          sub_408620(v17, v34);
        }
        sub_406420(v34);
      }
      else if ( *(_DWORD *)(a4 + 12) )
      {
        v13 = a4;
        goto LABEL_22;
      }
    }
  }
LABEL_24:
  if ( a3 )
  {
    v19 = a1[1];
    if ( *(_DWORD *)(v19 + 324) )
    {
      if ( *(_DWORD *)(*(_DWORD *)(a4 + 4) + 36) )
      {
        v20 = sub_40F030(v19, 1);
        v32 = v20;
        v21 = strlen(sub_40F100(*(char **)(*a1 + 244)));
        v22 = *(char **)a4;
        v23 = &FileName[-*(_DWORD *)a4];
        do
        {
          v24 = *v22;
          v22[(_DWORD)v23] = *v22;
          ++v22;
        }
        while ( v24 );
        v25 = strlen(&v20[v21 - 1]) + 1;
        v26 = &v20[v21 - 1];
        v27 = &v35;
        while ( *++v27 )
          ;
        qmemcpy(v27, v26, v25);
        sub_408390(v32, FileName);
      }
    }
  }
  result = 1;
  if ( !v33 )
    dword_4AE2A0 = 7;
  return result;
}
// 4091EE: conditional instruction was optimized away because eax.4!=0
// 4AE2A0: using guessed type int dword_4AE2A0;

//----- (004092F0) --------------------------------------------------------
int __cdecl sub_4092F0(char **a1, int a2, char a3)
{
  char *v3; // edx
  char *v4; // eax
  int v5; // edx
  char v6; // cl
  char *v7; // ecx
  char v8; // dl
  char *v9; // eax
  char v10; // dl
  __int16 v11; // ax
  const char *v12; // eax
  const char *v13; // eax
  const char *v14; // eax
  const char *v15; // eax
  const char *v16; // eax
  char FileName[1024]; // [esp+0h] [ebp-404h] BYREF

  if ( a1 )
  {
    v3 = *a1;
    v4 = FileName;
    FileName[0] = **a1;
    if ( FileName[0] )
    {
      v5 = v3 - FileName;
      do
      {
        v6 = (v4++)[v5 + 1];
        *v4 = v6;
      }
      while ( v6 );
    }
    v7 = *(char **)a2;
    *v4 = 92;
    v8 = *v7;
    v9 = v4 + 1;
    *v9 = *v7;
    if ( v8 )
    {
      do
      {
        v10 = *++v7;
        *++v9 = v10;
      }
      while ( v10 );
    }
    v11 = *(_WORD *)(*(_DWORD *)(a2 + 4) + 6);
    if ( (v11 & 0xF000) == 0x4000 )
    {
      if ( (a3 & 2) != 0 && (v11 & 0x1C0) != 448 && _chmod(FileName, 511) )
      {
        v12 = (const char *)sub_473493((int)&unk_47A0B4);
        sub_4079A0(v12, FileName);
      }
      if ( (a3 & 4) != 0 )
      {
        v13 = (const char *)sub_473493((int)&unk_47A0D0);
        sub_4079F0(v13, FileName);
        if ( _rmdir(FileName) )
        {
          v14 = (const char *)sub_473493((int)&unk_47A0E0);
          sub_407920(v14, FileName);
        }
      }
    }
    else
    {
      _chmod(FileName, 511);
      v15 = (const char *)sub_473493((int)&unk_47A100);
      sub_4079F0(v15, FileName);
      if ( _unlink(FileName) )
      {
        v16 = (const char *)sub_473493((int)&unk_47A110);
        sub_407920(v16, FileName);
      }
    }
  }
  return 0;
}

//----- (00409470) --------------------------------------------------------
void __usercall sub_409470(int a1@<ecx>, _DWORD *a2@<ebx>, const char *a3, char *FileName, int a5, int a6, int a7)
{
  int v7; // eax
  BOOL v8; // esi
  const char *v9; // eax
  const char *v10; // eax
  const char *v11; // eax
  const char *v12; // eax
  _WORD *v13; // edi
  char v14; // al
  char *v15; // edi
  const char *v17; // eax
  const char *v18; // eax
  unsigned int v19; // kr08_4
  int v20; // esi
  int v21; // ecx
  char v22; // dl
  const char *v23; // eax
  const char *v24; // eax
  const char *v25; // eax
  const char *v26; // eax
  const char *v27; // eax
  int v28; // ecx
  bool v29; // zf
  const char *v30; // eax
  const char *v31; // eax
  int v32; // [esp-14h] [ebp-1064h]
  int v33; // [esp-10h] [ebp-1060h]
  int v34; // [esp-Ch] [ebp-105Ch]
  int v35; // [esp-8h] [ebp-1058h]
  int v36; // [esp-4h] [ebp-1054h]
  int v38[4]; // [esp+14h] [ebp-103Ch] BYREF
  struct _stat32 Stat; // [esp+24h] [ebp-102Ch] BYREF
  char NewFilename[236]; // [esp+48h] [ebp-1008h] BYREF
  _DWORD v41[196]; // [esp+134h] [ebp-F1Ch] BYREF
  char v42; // [esp+447h] [ebp-C09h] BYREF
  char Path[1024]; // [esp+448h] [ebp-C08h] BYREF
  char String1[1024]; // [esp+848h] [ebp-808h] BYREF
  char String2[1028]; // [esp+C48h] [ebp-408h] BYREF

  strcpy(NewFilename, a3);
  v7 = _stat32(FileName, &Stat);
  v8 = v7 == 0;
  if ( v7 )
  {
    v11 = (const char *)sub_473493((int)&unk_47A1DC);
    sub_4079F0(v11, FileName);
    if ( _mkdir(FileName) )
    {
      v12 = (const char *)sub_473493((int)&unk_47A1FC);
      sub_407920(v12, FileName);
    }
  }
  else
  {
    if ( (Stat.st_mode & 0xF000) != 0x4000 )
    {
      v9 = (const char *)sub_473493((int)&unk_47A128);
      sub_4078E0(v9, FileName);
    }
    if ( !a2[23] && !a2[21] && !a2[20] && !a2[22] && !a2[115] && !a2[116] )
    {
      v10 = (const char *)sub_473493((int)&unk_47A148);
      sub_4078E0(v10);
    }
  }
  strcpy(Path, FileName);
  v13 = (_WORD *)((char *)&Stat.st_ctime + 3);
  do
  {
    v14 = *((_BYTE *)v13 + 1);
    v13 = (_WORD *)((char *)v13 + 1);
  }
  while ( v14 );
  *v13 = 92;
  v15 = &v42;
  while ( *++v15 )
    ;
  *(_WORD *)v15 = 92;
  sub_408360((int)String1, NewFilename);
  sub_408360((int)String2, Path);
  if ( !_strnicmp(String1, String2, strlen(String1)) && !a2[60] )
  {
    if ( !v8 )
      _rmdir(FileName);
    v17 = (const char *)sub_473493((int)&unk_47A228);
    sub_4078E0(v17);
  }
  if ( !_strnicmp(String2, String1, strlen(String2)) )
  {
    if ( !v8 )
      _rmdir(FileName);
    v18 = (const char *)sub_473493((int)&unk_47A260);
    sub_4078E0(v18);
  }
  if ( v8 && !a2[22] && !a2[23] && !a2[116] )
  {
    if ( a2[20] )
    {
      v19 = strlen(Path);
      v20 = 1;
      v21 = 0;
      do
      {
        v22 = Path[v21];
        NewFilename[v21++] = v22;
      }
      while ( v22 );
      while ( 1 )
      {
        sprintf((char *const)&Stat.st_ctime + v19 + 3, ".%d", v20++);
        if ( !rename(Path, NewFilename) )
          break;
        if ( *_errno() != 41 && *_errno() != 17 )
        {
          v23 = (const char *)sub_473493((int)&unk_47A2A4);
          sub_407920(v23, Path, NewFilename);
        }
      }
      v24 = (const char *)sub_473493((int)&unk_47A2C0);
      sub_4079F0(v24, Path, NewFilename);
      v25 = (const char *)sub_473493((int)&unk_47A1DC);
      sub_4079F0(v25, FileName);
      if ( _mkdir(FileName) )
      {
        v26 = (const char *)sub_473493((int)&unk_47A1FC);
        sub_407920(v26, FileName);
      }
    }
    else if ( a2[21] || a2[115] )
    {
      sub_408110(Path, 255, (int (__cdecl *)(const char **, char **, int, int))sub_4092F0, 0, 0);
      if ( _rmdir(Path) )
      {
        v27 = (const char *)sub_473493((int)&unk_47A2E4);
        sub_4079A0(v27, Path);
      }
      else if ( _mkdir(Path) )
      {
        v31 = (const char *)sub_473493((int)&unk_47A30C);
        sub_407920(v31, Path);
      }
    }
  }
  sub_40EFB0(NewFilename);
  v28 = a2[4];
  v29 = a2[5] == 0;
  v38[1] = a1;
  v38[2] = v28;
  v41[83] = a5;
  v41[84] = a6;
  v38[3] = v29;
  v38[0] = (int)FileName;
  v41[85] = a7;
  sub_40F000((int)NewFilename, a3);
  if ( dword_4AE2A4 )
  {
    v36 = v41[90];
    v35 = v41[89];
    v34 = v41[88];
    v33 = v41[87];
    v32 = v41[86];
    v30 = (const char *)sub_473493((int)&unk_479EA0);
    printf(v30, v32, v33, v34, v35, v36);
  }
  sub_40F1F0(
    v41,
    (int (__cdecl *)(int, int, bool, int))sub_409000,
    (int (__cdecl *)(_DWORD, int, int))sub_408B70,
    (int)v38);
  sub_40E4C0(v41, 0);
}
// 4AE2A4: using guessed type int dword_4AE2A4;
// 409470: using guessed type char NewFilename[236];
// 409470: using guessed type char Path[1024];

//----- (00409910) --------------------------------------------------------
BOOL __cdecl sub_409910(char *FileName)
{
  char **v1; // ecx
  BOOL v2; // edi
  FILE *v3; // eax
  FILE *v4; // ebp
  int v5; // esi
  char v6; // al
  char v7; // bl
  char v8; // al
  char v9; // al
  char v10; // al
  char v11; // al
  char v12; // al
  char v13; // al
  unsigned int v14; // edi
  unsigned __int8 *v15; // eax
  unsigned __int8 *v16; // edx
  int v17; // ecx
  int v18; // ecx
  int v19; // ecx
  int v21; // [esp-24h] [ebp-3Ch]
  int v22; // [esp-20h] [ebp-38h]
  int v23; // [esp-18h] [ebp-30h]
  int v24; // [esp-14h] [ebp-2Ch]
  int v25; // [esp-14h] [ebp-2Ch]
  char **v26; // [esp+8h] [ebp-10h]
  int v27; // [esp+Ch] [ebp-Ch] BYREF
  char v28[4]; // [esp+10h] [ebp-8h] BYREF

  v26 = v1;
  v2 = 0;
  v3 = fopen(FileName, "r");
  v4 = v3;
  if ( v3 )
  {
    if ( fread(&byte_4A7088, 1u, 2u, v3) != 2
      || byte_4A7088 != 35
      || byte_4A7089[0] != 33
      || !fgets(byte_4A708A, 509, v4) )
    {
      goto LABEL_34;
    }
    v5 = 2;
    byte_4A7287 = 0;
    while ( isspace(*(&byte_4A7088 + v5)) )
    {
      if ( ++v5 >= 512 )
        goto LABEL_34;
    }
    while ( 1 )
    {
      v6 = *(&byte_4A7088 + v5);
      if ( !v6 || isspace(v6) )
        break;
      if ( ++v5 >= 512 )
        goto LABEL_34;
    }
    if ( (unsigned int)(v5 - 5) > 0x1FA )
      goto LABEL_34;
    v7 = tolower(byte_4A7085[v5]);
    v8 = tolower(byte_4A7086[v5]);
    v24 = byte_4A7087[v5];
    BYTE1(v27) = v8;
    v9 = tolower(v24);
    if ( v7 == 112 && BYTE1(v27) == 104 && v9 == 112 )
    {
      v2 = 1;
      goto LABEL_29;
    }
    if ( v5 < 9 )
    {
LABEL_34:
      fclose(v4);
      return v2;
    }
    LOBYTE(v27) = tolower(byte_4A7081[v5]);
    v10 = tolower(byte_4A7082[v5]);
    v25 = byte_4A7083[v5];
    BYTE1(v27) = v10;
    v11 = tolower(v25);
    v23 = byte_4A7084[v5];
    BYTE2(v27) = v11;
    HIBYTE(v27) = tolower(v23);
    v12 = tolower(byte_4A7085[v5]);
    v22 = byte_4A7086[v5];
    v28[0] = v12;
    v13 = tolower(v22);
    v21 = byte_4A7087[v5];
    v28[1] = v13;
    v28[2] = tolower(v21);
    v14 = 7;
    v15 = (unsigned __int8 *)sub_473493((int)&unk_47A338);
    v16 = (unsigned __int8 *)&v27;
    if ( v27 == *(_DWORD *)v15 )
    {
      v14 = 3;
      v15 += 4;
      v16 = (unsigned __int8 *)v28;
    }
    v17 = *v16 - *v15;
    if ( !v17 )
    {
      v17 = v16[1] - v15[1];
      if ( !v17 )
      {
        v17 = v16[2] - v15[2];
        if ( !v17 )
        {
          if ( v14 <= 3 )
          {
            v18 = 0;
LABEL_28:
            v2 = v18 == 0;
            if ( !v18 )
            {
LABEL_29:
              if ( v26 )
              {
                for ( ; *(&byte_4A7088 + v5); ++v5 )
                  ;
                do
                  v19 = byte_4A7087[v5--];
                while ( isspace(v19) );
                byte_4A7089[v5] = 0;
                *v26 = _strdup(&byte_4A7088);
              }
              goto LABEL_34;
            }
            goto LABEL_34;
          }
          v17 = v16[3] - v15[3];
        }
      }
    }
    v18 = (v17 >> 31) | 1;
    goto LABEL_28;
  }
  return v2;
}
// 4099C8: conditional instruction was optimized away because esi.4<200
// 40992A: variable 'v1' is possibly undefined
// 4A7287: using guessed type char byte_4A7287;

//----- (00409BB0) --------------------------------------------------------
BOOL __usercall sub_409BB0@<eax>(int *a1@<ebx>, char *a2)
{
  BOOL result; // eax
  int v3; // ebp
  const char **v4; // esi
  BOOL v5; // eax
  int v6; // [esp+0h] [ebp-8h]
  BOOL v7; // [esp+4h] [ebp-4h]

  result = 0;
  v7 = 0;
  if ( a1 )
  {
    v6 = 0;
    if ( *a1 > 0 )
    {
      v3 = 0;
      do
      {
        v4 = (const char **)(v3 + a1[3]);
        if ( !v4[4] )
        {
          if ( v4[5] )
            v5 = sub_40E5E0(*v4, a2);
          else
            v5 = sub_40E700(a2, *v4);
          if ( v5 )
            v7 = v4[1] == 0;
        }
        v3 += 36;
        ++v6;
      }
      while ( v6 < *a1 );
      return v7;
    }
  }
  return result;
}

//----- (00409C30) --------------------------------------------------------
int __usercall sub_409C30@<eax>(int *a1@<eax>, char *FileName, int *a3)
{
  int v3; // esi
  char *v4; // edi
  int v5; // ebx
  const char **v6; // esi
  BOOL v7; // eax
  int v9; // [esp+10h] [ebp-8h]
  int v10; // [esp+14h] [ebp-4h]

  v3 = 0;
  v4 = FileName;
  v9 = 0;
  if ( a1 && sub_409BB0(a1, FileName) )
    return v3;
  if ( sub_409910(FileName) )
  {
    v9 = 1;
    v3 = 1;
  }
  v5 = 0;
  if ( !a3 )
    return v3;
  v10 = 0;
  if ( *a3 <= 0 )
    return v3;
  do
  {
    v6 = (const char **)(v5 + a3[3]);
    if ( !v6[4] )
    {
      if ( v6[5] )
      {
        v7 = sub_40E5E0(*v6, v4);
        v4 = FileName;
      }
      else
      {
        v7 = sub_40E700(v4, *v6);
      }
      if ( v7 )
      {
        if ( !v6[1] || (v9 = 1, v6[3]) )
          v9 = 0;
      }
    }
    v5 += 36;
    ++v10;
  }
  while ( v10 < *a3 );
  return v9;
}

//----- (00409D10) --------------------------------------------------------
int __usercall sub_409D10@<eax>(int *a1@<ebx>, char *a2)
{
  int result; // eax
  int v3; // ebp
  const char **v4; // esi
  BOOL v5; // eax
  int v6; // [esp+0h] [ebp-8h]
  int v7; // [esp+4h] [ebp-4h]

  result = 0;
  v6 = 0;
  if ( a1 )
  {
    v7 = 0;
    if ( *a1 > 0 )
    {
      v3 = 0;
      do
      {
        v4 = (const char **)(v3 + a1[3]);
        if ( !v4[4] )
        {
          if ( v4[5] )
            v5 = sub_40E5E0(*v4, a2);
          else
            v5 = sub_40E700(a2, *v4);
          if ( v5 )
          {
            if ( !v4[1] || (v6 = 1, !v4[3]) )
              v6 = 0;
          }
        }
        v3 += 36;
        ++v7;
      }
      while ( v7 < *a1 );
      return v6;
    }
  }
  return result;
}

//----- (00409DA0) --------------------------------------------------------
void *__usercall sub_409DA0@<eax>(int *a1@<edx>, _DWORD *a2@<ecx>, char *pszPath, int a4, char *a5, int *a6, int a7)
{
  char *v7; // esi
  CHAR *v8; // edi
  CHAR *v9; // edi
  const char *v10; // eax
  void *result; // eax
  int v12; // edi
  const char *v13; // eax
  const char *v14; // eax
  int v15; // eax
  int v16; // esi
  int v17; // edx
  int v18; // ecx
  int v19; // edx
  int v20; // eax
  int v21; // ebx
  const char *v22; // eax
  int v25[4]; // [esp+2Ch] [ebp-964h] BYREF
  int *v26; // [esp+3Ch] [ebp-954h]
  CHAR pszBuf[296]; // [esp+40h] [ebp-950h] BYREF
  CHAR v28[264]; // [esp+168h] [ebp-828h] BYREF
  CHAR Buffer[264]; // [esp+270h] [ebp-720h] BYREF
  char DstBuf[264]; // [esp+378h] [ebp-618h] BYREF
  CHAR String2[264]; // [esp+480h] [ebp-510h] BYREF
  char v32[1028]; // [esp+588h] [ebp-408h] BYREF

  v26 = a6;
  v7 = pszPath;
  _getcwd(DstBuf, 260);
  if ( PathIsRelativeA(pszPath) )
    sprintf(Buffer, "%s\\%s", DstBuf, pszPath);
  else
    strcpy(Buffer, pszPath);
  if ( PathIsRelativeA(pszPath) )
    sprintf(v28, "%s\\%s", DstBuf, a5);
  else
    strcpy(v28, a5);
  if ( Buffer[0] )
  {
    v8 = Buffer;
    do
    {
      if ( *v8 == 47 )
        *v8 = 92;
      else
        *v8 = tolower(*v8);
      ++v8;
    }
    while ( *v8 );
  }
  if ( v28[0] )
  {
    v9 = v28;
    do
    {
      if ( *v9 == 47 )
        *v9 = 92;
      else
        *v9 = tolower(*v9);
      ++v9;
    }
    while ( *v9 );
  }
  PathCanonicalizeA(pszBuf, Buffer);
  PathCanonicalizeA(String2, v28);
  if ( !_stricmp(pszBuf, String2) )
  {
    v10 = (const char *)sub_473493((int)&unk_47A34C);
    sub_4078E0(v10);
  }
  if ( *pszPath != 47 && *pszPath != 92 )
  {
    strcpy(v32, pszPath);
    v7 = v32;
  }
  if ( sub_409BB0(v26, pszPath) )
  {
    v22 = (const char *)sub_473493((int)&unk_47A0A0);
    return (void *)sub_4079F0(v22, v7);
  }
  if ( !a2[25] || (result = (void *)sub_408F60(a5)) == 0 )
  {
    v12 = sub_408DB0(pszPath);
    if ( sub_409D10(a1, v7) )
    {
      if ( !v12 )
      {
        v13 = (const char *)sub_473493((int)&unk_47A05C);
        sub_4079F0(v13, v7, a5);
        _chmod(a5, 511);
        result = (void *)sub_407050(v7, a5, a2);
LABEL_39:
        v16 = (int)result;
LABEL_40:
        if ( !v16 )
          dword_4AE2A0 = 7;
        return result;
      }
    }
    else
    {
      if ( !sub_409C30(0, v7, a1) )
      {
LABEL_38:
        memset(pszBuf, 0, sizeof(pszBuf));
        v17 = *(_DWORD *)(a4 + 24);
        *(_DWORD *)&pszBuf[12] = *(unsigned __int16 *)(a4 + 6);
        v18 = *(_DWORD *)(a4 + 28);
        *(_DWORD *)&pszBuf[16] = v17;
        v19 = *(__int16 *)(a4 + 10);
        v20 = *(__int16 *)(a4 + 12);
        *(_DWORD *)&pszBuf[8] = v7;
        *(_DWORD *)&pszBuf[20] = v18;
        *(_DWORD *)&pszBuf[28] = v20;
        *(_DWORD *)&pszBuf[24] = v19;
        v21 = *(_DWORD *)(a7 + 16);
        qmemcpy(&pszBuf[48], a2, 0xECu);
        v25[1] = (int)a2;
        v25[2] = v21;
        result = (void *)sub_408D20(pszPath, (int)v25, a5, (int)pszBuf);
        *(_DWORD *)(a7 + 16) = v21;
        goto LABEL_39;
      }
      if ( !v12 )
      {
        sub_406360(v25);
        v14 = (const char *)sub_473493((int)&unk_47A080);
        sub_4079F0(v14, v7, a5);
        v15 = sub_406940(0, a5, v7, (int)a2, (int)v25);
        v16 = v15;
        if ( v25[0] )
        {
          if ( dword_4AE2A0 != 7 )
            dword_4AE2A0 = 8;
          sub_408620(v15, v25);
        }
        result = sub_406420(v25);
        goto LABEL_40;
      }
    }
    sub_408FB0((int)v7, v12);
    goto LABEL_38;
  }
  return result;
}
// 4AE2A0: using guessed type int dword_4AE2A0;

//----- (0040A170) --------------------------------------------------------
_DWORD *__usercall sub_40A170@<eax>(int *a1@<edx>, _DWORD *a2@<ecx>, int *a3, char *a4, int *a5, int a6, _DWORD *a7)
{
  char *v7; // eax
  int *v8; // edi
  char *v9; // ebp
  char v10; // cl
  char v11; // al
  bool v12; // zf
  char *v13; // esi
  const char *v14; // eax
  char *v15; // ecx
  char v16; // dl
  char v17; // al
  char v18; // al
  char *v19; // eax
  int v20; // edx
  char v21; // cl
  const char *v23; // eax
  const char *v24; // eax
  int v25; // [esp+14h] [ebp-43Ch]
  struct _stat32 v28; // [esp+2Ch] [ebp-424h] BYREF
  char v29[1023]; // [esp+50h] [ebp-400h] BYREF
  char FileName[1028]; // [esp+450h] [ebp+0h] BYREF

  v7 = a4;
  v8 = a3;
  v9 = FileName;
  FileName[0] = *a4;
  if ( FileName[0] )
  {
    do
    {
      v10 = *++v7;
      *++v9 = v10;
    }
    while ( v10 );
    for ( ; v9 >= FileName && v9 - FileName != 0; --v9 )
    {
      v11 = *(v9 - 1);
      if ( v11 != 47 && v11 != 92 )
        break;
    }
  }
  v12 = a7[49] == 0;
  *v9 = 0;
  if ( !v12 )
  {
    *v9++ = 92;
    *v9 = 0;
  }
  v25 = 0;
  if ( *a3 > 0 )
  {
    while ( 1 )
    {
      v13 = *(char **)(v8[3] + 4 * v25);
      v14 = sub_408060(v13, &v28);
      if ( !v14 )
      {
        v24 = (const char *)sub_473493((int)&unk_47A3B0);
        sub_407920(v24, v13);
      }
      if ( a7[49] )
        break;
LABEL_37:
      if ( (v28.st_mode & 0xF000) == 0x4000 )
        sub_409470((int)a2, a7, v13, FileName, (int)a1, (int)a5, a6);
      else
        sub_409DA0(a1, a2, v13, (int)&v28, FileName, a5, (int)a7);
      if ( ++v25 >= *v8 )
        return shutdown_memory_manager(1, 1);
    }
    v15 = v29;
    while ( *v14 == 47 || *v14 == 92 )
      ++v14;
    v29[0] = *v14;
    if ( v29[0] )
    {
      do
      {
        v16 = *++v14;
        *++v15 = v16;
      }
      while ( v16 );
    }
    for ( *v15 = 0; v15 > v29; --v15 )
    {
      v17 = *(v15 - 1);
      if ( v17 == 47 )
        break;
      if ( v17 == 92 )
        break;
    }
    if ( *v15 )
    {
      if ( strcmp(v15, (const char *)&word_478CA4) && strcmp(v15, "..") )
      {
        v8 = a3;
        goto LABEL_34;
      }
      v8 = a3;
    }
    strcpy(v29, v13);
    v15 = v29;
    if ( !v29[0] )
      goto LABEL_42;
    do
      ++v15;
    while ( *v15 );
    for ( ; v15 > v29; --v15 )
    {
      v18 = *(v15 - 1);
      if ( v18 == 47 )
        break;
      if ( v18 == 92 )
        break;
    }
LABEL_34:
    if ( !*v15 )
    {
LABEL_42:
      v23 = (const char *)sub_473493((int)&unk_47A37C);
      sub_4078E0(v23, v13);
    }
    v19 = v15;
    v20 = v9 - v15;
    do
    {
      v21 = *v19;
      v19[v20] = *v19;
      ++v19;
    }
    while ( v21 );
    goto LABEL_37;
  }
  return shutdown_memory_manager(1, 1);
}
// 478CA4: using guessed type __int16 word_478CA4;

//----- (0040A440) --------------------------------------------------------
int __usercall sub_40A440@<eax>(const char *a1@<eax>, int *a2@<ebx>)
{
  char *v2; // edi
  char *v3; // ebp
  unsigned int i; // esi
  unsigned __int8 v5; // al
  int v6; // eax
  void *v7; // edx
  int v8; // eax
  int v9; // ecx
  int v10; // eax
  int result; // eax
  const char *v12; // eax
  int v13; // eax
  int v14; // [esp-4h] [ebp-Ch]

  v2 = _strdup(a1);
  v3 = v2;
  for ( i = strlen(v2); i; v2[--i] = 0 )
  {
    if ( !isspace(v2[i - 1]) )
      break;
  }
  v5 = *v2;
  if ( *v2 )
  {
    while ( v5 == 9 || v5 >= 0x20u )
    {
      v5 = *++v3;
      if ( !v5 )
        goto LABEL_8;
    }
    if ( v5 )
    {
      v14 = v5;
      v12 = (const char *)sub_473493((int)&unk_47A3D0);
      sub_4078E0(v12, v3, v14);
    }
  }
LABEL_8:
  v6 = a2[1];
  if ( *a2 == v6 )
  {
    v7 = dword_4A80FC;
    v8 = a2[2] + v6;
    v9 = a2[3];
    a2[1] = v8;
    if ( !v9 )
    {
      a2[3] = (*(int (__cdecl **)(int))(*(_DWORD *)v7 + 8))(4 * v8);
      v10 = *a2;
      *(_DWORD *)(a2[3] + 4 * v10) = v2;
      result = v10 + 1;
      *a2 = result;
      return result;
    }
    a2[3] = (*(int (__cdecl **)(int, int))(*(_DWORD *)v7 + 12))(v9, 4 * v8);
  }
  v13 = *a2;
  *(_DWORD *)(a2[3] + 4 * v13) = v2;
  result = v13 + 1;
  *a2 = result;
  return result;
}

//----- (0040A510) --------------------------------------------------------
char __cdecl sub_40A510(_DWORD *a1)
{
  char *v1; // ecx
  char *v2; // esi
  int v3; // ecx
  char *v4; // eax
  char *v5; // edi
  char v6; // bl
  char v7; // al
  int v8; // eax
  int v9; // eax
  int v10; // ecx
  int v11; // eax
  char Source[8192]; // [esp+10h] [ebp-2004h] BYREF

  v2 = v1;
  do
  {
    if ( isspace(*v2) )
    {
      do
        v3 = *++v2;
      while ( isspace(v3) );
    }
    LOBYTE(v4) = *v2;
    if ( !*v2 )
      break;
    v5 = Source;
    if ( (_BYTE)v4 == 34 || (_BYTE)v4 == 39 )
      v6 = *v2++;
    else
      v6 = 0;
    for ( LOBYTE(v4) = *v2; *v2; ++v5 )
    {
      if ( (_BYTE)v4 == v6 )
        break;
      if ( !v6 )
      {
        v4 = (char *)isspace((char)v4);
        if ( v4 )
          break;
      }
      if ( *v2 == 92 && v2[1] )
        ++v2;
      v7 = *v2++;
      *v5 = v7;
      LOBYTE(v4) = *v2;
    }
    *v5 = 0;
    if ( Source[0] )
    {
      v8 = a1[1];
      if ( *a1 == v8 )
      {
        v9 = a1[2] + v8;
        v10 = a1[3];
        a1[1] = v9;
        if ( v10 )
          v11 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v10, 4 * v9);
        else
          v11 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(4 * v9);
        a1[3] = v11;
      }
      v4 = _strdup(Source);
      *(_DWORD *)(a1[3] + 4 * (*a1)++) = v4;
    }
    if ( v6 && *v2 == v6 )
      ++v2;
  }
  while ( *v2 );
  return (char)v4;
}
// 40A533: variable 'v1' is possibly undefined

//----- (0040A650) --------------------------------------------------------
int __cdecl sub_40A650(int *a1, const char *a2)
{
  unsigned int v3; // eax
  unsigned int v4; // ebx
  char v5; // al
  int *v6; // edx
  int result; // eax
  void **v8; // edi
  _BYTE *i; // eax
  const char *v10; // eax
  char v11; // cl
  char *v12; // esi
  char *v13; // eax
  char *v14; // edx
  char v15; // cl
  int v16; // [esp+8h] [ebp-4h]
  int v17; // [esp+14h] [ebp+8h]

  v3 = (unsigned int)&a2[strlen(a2) + 1];
  v4 = v3 - (_DWORD)(a2 + 1);
  v5 = *(_BYTE *)(v3 - 2);
  if ( v5 == 47 || v5 == 92 )
    --v4;
  v6 = a1;
  result = 0;
  v16 = 0;
  if ( *a1 > 0 )
  {
    v17 = 0;
    do
    {
      v8 = (void **)(v17 + v6[3]);
      for ( i = *v8; *i; ++i )
      {
        if ( *i == 47 )
          *i = 92;
      }
      v10 = (const char *)*v8;
      if ( *(_BYTE *)*v8 == 64 )
      {
        v11 = v10[1];
        if ( v11 == 47 || v11 == 92 )
        {
          v12 = (char *)malloc(v4 + strlen(v10));
          strcpy(v12, a2);
          v13 = (char *)*v8 + 1;
          v14 = &v12[v4];
          do
          {
            v15 = *v13;
            *v14++ = *v13++;
          }
          while ( v15 );
          free(*v8);
          v6 = a1;
          *v8 = v12;
        }
      }
      v17 += 36;
      result = ++v16;
    }
    while ( v16 < *v6 );
  }
  return result;
}

//----- (0040A730) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char *v3; // esi
  __time32_t v4; // eax
  FILE *v5; // eax
  char **p_ptr; // esi
  char *v7; // edi
  char *v8; // edi
  int i; // esi
  int v10; // eax
  int v11; // eax
  int v12; // ecx
  int v13; // eax
  int v14; // eax
  int v15; // eax
  _DWORD *v16; // eax
  int v17; // eax
  const char *v18; // eax
  FILE *v19; // eax
  FILE *v20; // ebx
  int v21; // eax
  char **st_dev; // esi
  __time32_t v23; // edi
  unsigned int v24; // eax
  char v25; // cl
  char *v26; // esi
  bool v27; // zf
  char *v28; // eax
  int v29; // ecx
  int j; // ebx
  int v31; // eax
  int v32; // eax
  int v33; // eax
  int v34; // eax
  int v35; // eax
  int v36; // eax
  int v37; // eax
  int v38; // eax
  int v39; // eax
  int v40; // esi
  char *v41; // esi
  char *v42; // eax
  char v43; // cl
  char *v44; // eax
  void *v45; // esi
  const char *v46; // eax
  int v47; // eax
  int v48; // eax
  int v49; // eax
  int v50; // eax
  int v51; // eax
  int v52; // eax
  const char *v53; // eax
  int v54; // eax
  int v55; // eax
  int v56; // eax
  int v57; // eax
  int v58; // eax
  int v59; // edx
  int v60; // ecx
  int v61; // eax
  int v62; // ecx
  int v63; // eax
  int v64; // ecx
  int v65; // edx
  int v66; // eax
  int v67; // ecx
  int v68; // edx
  int v69; // eax
  int v70; // ecx
  int v71; // edx
  int v72; // eax
  int v73; // ecx
  int v74; // edx
  int v75; // eax
  int v76; // ecx
  int v77; // edx
  int v78; // eax
  int v79; // ecx
  int v80; // edx
  int v81; // eax
  int v82; // ecx
  int v83; // edx
  int v84; // eax
  int v85; // eax
  int v86; // ecx
  int v87; // edx
  int v88; // eax
  int v89; // ecx
  int v90; // edx
  FILE *v91; // esi
  int (__cdecl *v92)(int); // edx
  int v93; // eax
  bool v94; // cc
  int v95; // esi
  FILE *v96; // ebx
  char *v97; // esi
  int v98; // eax
  int v99; // eax
  const char *v100; // eax
  _BYTE *v101; // eax
  int k; // esi
  _BYTE *v103; // ebx
  size_t v104; // eax
  _BYTE *v105; // eax
  int v106; // eax
  __time32_t v107; // ecx
  __time32_t v108; // edx
  int v109; // eax
  void **flag; // esi
  const char *v111; // ebx
  BOOL v112; // edx
  int v113; // eax
  int v114; // eax
  int v115; // eax
  int v116; // eax
  int v117; // eax
  int v118; // eax
  FILE *v119; // esi
  __time32_t v120; // eax
  int (__cdecl *v121)(int); // edx
  __time32_t v122; // eax
  __time32_t st_atime; // edx
  int *v124; // ebx
  int v125; // eax
  int (__cdecl *v126)(int); // ecx
  int v127; // eax
  int *v128; // ebx
  int *v129; // esi
  int v130; // eax
  int v131; // ecx
  int v132; // edx
  _DWORD *v133; // eax
  _DWORD *v134; // eax
  int v135; // ecx
  _DWORD *v136; // eax
  __time32_t v137; // ecx
  int v138; // ebx
  int *v139; // esi
  int v140; // ecx
  int v141; // ebx
  _DWORD *v142; // eax
  __time32_t v143; // edx
  int *v144; // esi
  int v145; // eax
  int v146; // ecx
  int v147; // ecx
  __time32_t v148; // eax
  _DWORD *v149; // eax
  _DWORD *v150; // ebx
  int v151; // eax
  int v152; // eax
  int v153; // eax
  int v154; // edx
  _DWORD *v155; // eax
  _DWORD *v156; // ecx
  _DWORD *v157; // ebx
  int v158; // eax
  int v159; // eax
  int v160; // eax
  int v161; // edx
  _DWORD *v162; // eax
  _DWORD *v163; // ecx
  const char *v164; // eax
  int v165; // eax
  int v166; // eax
  int v167; // eax
  int v168; // eax
  int v170; // eax
  int v171; // eax
  int v172; // eax
  int v173; // eax
  int v174; // [esp-10h] [ebp-25B0h]
  int v175; // [esp-4h] [ebp-25A4h]
  const char *v176; // [esp-4h] [ebp-25A4h]
  int v177; // [esp-4h] [ebp-25A4h]
  int v178; // [esp-4h] [ebp-25A4h]
  char Stream; // [esp+0h] [ebp-25A0h]
  char Streama; // [esp+0h] [ebp-25A0h]
  char Streamb; // [esp+0h] [ebp-25A0h]
  FILE *v182; // [esp+10h] [ebp-2590h]
  FILE *v183; // [esp+10h] [ebp-2590h]
  FILE *ptr; // [esp+10h] [ebp-2590h]
  FILE *v185; // [esp+10h] [ebp-2590h]
  FILE *v186; // [esp+10h] [ebp-2590h]
  FILE *v187; // [esp+10h] [ebp-2590h]
  FILE *v188; // [esp+14h] [ebp-258Ch]
  FILE *v189; // [esp+14h] [ebp-258Ch]
  FILE *v190; // [esp+14h] [ebp-258Ch]
  FILE *v191; // [esp+18h] [ebp-2588h]
  FILE *v192; // [esp+18h] [ebp-2588h]
  FILE *v193; // [esp+18h] [ebp-2588h]
  FILE *v194; // [esp+18h] [ebp-2588h]
  int v195; // [esp+1Ch] [ebp-2584h]
  int v196; // [esp+1Ch] [ebp-2584h]
  int v197; // [esp+20h] [ebp-2580h]
  __time32_t v198; // [esp+20h] [ebp-2580h]
  _DWORD *v199; // [esp+24h] [ebp-257Ch]
  int v200; // [esp+24h] [ebp-257Ch]
  int *v201; // [esp+28h] [ebp-2578h]
  int v202; // [esp+28h] [ebp-2578h]
  __time32_t Time; // [esp+2Ch] [ebp-2574h] BYREF
  int v204; // [esp+30h] [ebp-2570h]
  int v205; // [esp+34h] [ebp-256Ch]
  struct _stat32 Stat; // [esp+38h] [ebp-2568h] BYREF
  int v207; // [esp+68h] [ebp-2538h]
  _DWORD *v208; // [esp+74h] [ebp-252Ch]
  int v209[61]; // [esp+78h] [ebp-2528h] BYREF
  struct _stat32 v210; // [esp+16Ch] [ebp-2434h] BYREF
  int v211; // [esp+190h] [ebp-2410h]
  __int16 v212; // [esp+194h] [ebp-240Ch]
  char ArgList[1024]; // [esp+198h] [ebp-2408h] BYREF
  char v215; // [esp+598h] [ebp-2008h] BYREF
  _BYTE v216[3]; // [esp+599h] [ebp-2007h] BYREF

  memset(&::Time, 0, 0x1B4u);
  sub_408460();
  v3 = (char *)sub_473493(&unk_47A400);
  v4 = _time32(&Time);
  srand(v4 + *v3);
  sub_4132F0();
  if ( sub_412CD0() == -1 || sub_412C50() == -1 )
    exit(125);
  v5 = (FILE *)malloc(4 * argc);
  v182 = v5;
  if ( argc > 0 )
  {
    p_ptr = &v5->_ptr;
    v7 = (char *)((char *)argv - (char *)v5);
    v195 = argc;
    do
    {
      *p_ptr = _strdup(*(const char **)((char *)p_ptr + (_DWORD)v7));
      ++p_ptr;
      --v195;
    }
    while ( v195 );
  }
  v8 = (char *)sub_403C70(argc, v182);
  for ( i = 0; i < *((_DWORD *)v8 + 124); ++i )
  {
    strlen(*(const char **)(*((_DWORD *)v8 + 127) + 4 * i));
    sub_46CA20(*(char **)(*((_DWORD *)v8 + 127) + 4 * i));
  }
  dword_4AE134 = *((_DWORD *)v8 + 38);
  dword_4AB12C = 2047;
  if ( (*((_DWORD *)v8 + 107) || *((_DWORD *)v8 + 109) || *((_DWORD *)v8 + 110)) && !*((_DWORD *)v8 + 113) )
  {
    if ( dword_4AE2A4 )
    {
      v10 = sub_473493(&unk_47A410);
      sub_4078E0(v10);
    }
    v11 = sub_473493(&unk_47A46C);
    sub_4078E0(v11);
  }
  v12 = *((_DWORD *)v8 + 59);
  if ( v12 && !*((_DWORD *)v8 + 58) )
  {
    v13 = sub_473493(&unk_47A4A8);
    sub_4078E0(v13);
  }
  if ( *((_DWORD *)v8 + 93) )
  {
    if ( *((_DWORD *)v8 + 27) || *((_DWORD *)v8 + 35) )
    {
      if ( dword_4AE2A4 )
      {
        v14 = sub_473493(&unk_47A4F0);
        sub_4078E0(v14);
      }
      v15 = sub_473493(&unk_47A5C0);
      sub_4078E0(v15);
    }
  }
  else
  {
    v16 = (_DWORD *)*((_DWORD *)v8 + 106);
    if ( v16 && *v16 == 2 )
    {
      v17 = sub_473493(&unk_47A678);
      sub_4078E0(v17);
    }
  }
  v18 = (const char *)*((_DWORD *)v8 + 58);
  if ( v18 )
  {
    if ( v12 != 1 )
    {
      v19 = fopen(v18, "r");
      v175 = *((_DWORD *)v8 + 58);
      v20 = v19;
      v191 = v19;
      v21 = sub_473493(&unk_47A6E4);
      sub_4079F0(v21, v175);
      if ( v20 )
      {
        v204 = 32;
        v205 = 32;
        st_dev = (char **)(*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(128);
        v176 = *argv;
        Stat.st_dev = (_dev_t)st_dev;
        v23 = 1;
        *st_dev = _strdup(v176);
        Time = 1;
        if ( fgets(&v215, 0x2000, v20) )
        {
          do
          {
            v24 = &v216[strlen(&v215)] - v216;
            v26 = &v215;
            if ( v24 >= 0x1FFF )
            {
              v33 = sub_473493(&unk_47A708);
              sub_4078E0(v33);
            }
            v27 = ArgList[v24 + 1023] == 10;
            v28 = &ArgList[v24 + 1023];
            if ( v27 )
              *v28 = v25;
            if ( isspace(v215) )
            {
              do
                v29 = *++v26;
              while ( isspace(v29) );
            }
            if ( *v26 && *v26 != 35 )
              sub_40A510(&Time);
          }
          while ( fgets(&v215, 0x2000, v20) );
          st_dev = (char **)Stat.st_dev;
          v23 = Time;
        }
        for ( j = 1; j < argc; ++v23 )
        {
          if ( v23 == v204 )
          {
            v31 = v205 + v204;
            v204 += v205;
            if ( st_dev )
              v32 = (*(int (__cdecl **)(char **, int))(*(_DWORD *)dword_4A80FC + 12))(st_dev, 4 * v204);
            else
              v32 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(4 * v31);
            st_dev = (char **)v32;
          }
          st_dev[v23] = _strdup(argv[j++]);
        }
        v8 = (char *)sub_403C70(v23, st_dev);
        dword_4AE134 = *((_DWORD *)v8 + 38);
        fclose(v191);
      }
    }
  }
  if ( *((_DWORD *)v8 + 129) )
  {
    sub_40F420();
    exit(0);
  }
  if ( *((_DWORD *)v8 + 115) && *((_DWORD *)v8 + 116) )
  {
    v34 = sub_473493(&unk_47A738);
    sub_4078E0(v34);
  }
  if ( *((_DWORD *)v8 + 98) && *((_DWORD *)v8 + 116) )
  {
    if ( *((_DWORD *)v8 + 38) )
    {
      v35 = sub_473493(&unk_47A790);
      sub_4079F0(v35, Stream);
    }
    free(*((void **)v8 + 98));
    *((_DWORD *)v8 + 98) = 0;
  }
  v36 = *((_DWORD *)v8 + 115);
  if ( (v36 || *((_DWORD *)v8 + 116)) && !*(_DWORD *)v8 )
  {
    v37 = sub_473493(&unk_47A7E8);
    sub_4078E0(v37);
  }
  if ( (*((_DWORD *)v8 + 23) != 0)
     + (v36 != 0)
     + (*((_DWORD *)v8 + 116) != 0)
     + (*((_DWORD *)v8 + 20) != 0)
     + (*((_DWORD *)v8 + 21) != 0)
     + (*((_DWORD *)v8 + 22) != 0) > 1 )
  {
    v38 = sub_473493(&unk_47A838);
    sub_4078E0(v38);
  }
  if ( *((_DWORD *)v8 + 4) && dword_4AE138 && (*((_DWORD *)v8 + 17) || *((_DWORD *)v8 + 18) || *((_DWORD *)v8 + 19)) )
  {
    v39 = sub_473493(&unk_47A8B8);
    sub_407970(v39, Stream);
    *((_DWORD *)v8 + 4) = 0;
  }
  sub_473493(&unk_47A960);
  zend_highlight(byte_4A8101);
  v196 = sub_4015A0();
  if ( argc == 1 )
  {
    sub_402740();
    exit(0);
  }
  if ( *((_DWORD *)v8 + 40) == 1 )
  {
    v40 = **((_DWORD **)v8 + 43);
    sub_40A650(v8 + 44, v40);
    sub_40A650(v8 + 216, v40);
    sub_40A650(v8 + 520, v40);
  }
  v41 = (char *)*((_DWORD *)v8 + 3);
  if ( v41 )
  {
    if ( !*((_DWORD *)v8 + 49) )
    {
      v42 = (char *)*((_DWORD *)v8 + 3);
      do
      {
        v43 = *v42;
        v42[ArgList - v41] = *v42;
        ++v42;
      }
      while ( v43 );
      v44 = &ArgList[strlen(ArgList) - 1];
      if ( v44 <= ArgList )
        goto LABEL_90;
      if ( *v44 == 47 || *v44 == 92 )
        --v44;
      if ( v44 <= ArgList )
        goto LABEL_90;
      while ( *v44 != 47 && *v44 != 92 )
      {
        if ( --v44 <= ArgList )
          goto LABEL_90;
      }
      if ( v44 <= ArgList )
        goto LABEL_90;
      *v44 = 0;
      v41 = ArgList;
      if ( *((_DWORD *)v8 + 39) )
        goto LABEL_100;
      if ( _stat32(ArgList, (struct _stat32 *)&Stat.st_gid) < 0 )
      {
        v47 = sub_473493(&unk_47A978);
        sub_4078E0(v47);
      }
    }
    if ( !*((_DWORD *)v8 + 39) )
    {
LABEL_90:
      v45 = (void *)*((_DWORD *)v8 + 3);
      if ( v45 )
      {
        v46 = (const char *)sub_408210();
        *((_DWORD *)v8 + 3) = _strdup(v46);
        free(v45);
      }
      goto LABEL_92;
    }
LABEL_100:
    if ( _stat32(v41, (struct _stat32 *)&Stat.st_gid) < 0 )
    {
      v48 = sub_473493(&unk_47A1DC);
      sub_4079F0(v48, (char)v41);
      if ( sub_4082B0() )
      {
        v49 = sub_473493(&unk_47A1FC);
        sub_407920(v49, (char)v41);
      }
    }
    goto LABEL_90;
  }
LABEL_92:
  if ( *((_DWORD *)v8 + 3) )
  {
    if ( *((_DWORD *)v8 + 49) )
      sub_473493(&unk_478A64);
    memset(v209, 0, 0xECu);
    if ( !*((_DWORD *)v8 + 40) )
    {
      if ( *((_DWORD *)v8 + 49) )
      {
        v50 = sub_473493(&unk_47A9DC);
        sub_4078E0(v50);
      }
      v51 = sub_473493(&unk_47AA14);
      sub_4078E0(v51);
    }
    if ( *((_DWORD *)v8 + 2) )
    {
      v52 = sub_473493(&unk_47AA44);
      sub_4078E0(v52);
    }
    v53 = (const char *)*((_DWORD *)v8 + 3);
    if ( *((_DWORD *)v8 + 49) )
    {
      if ( _stat32(v53, (struct _stat32 *)&Stat.st_gid) )
      {
        if ( *_errno() != 2 )
        {
          v56 = sub_473493(&unk_47AAD4);
          sub_407920(v56, Stream);
        }
        if ( !*((_DWORD *)v8 + 39) )
        {
          v55 = sub_473493(&unk_47AAA0);
          sub_4078E0(v55);
        }
      }
      else if ( (HIWORD(Stat.st_rdev) & 0xF000) != 0x4000 )
      {
        v54 = sub_473493(&unk_47AA78);
        sub_4078E0(v54);
      }
    }
    else if ( !_stat32(v53, &v210)
           && !_stat32(**((const char ***)v8 + 43), (struct _stat32 *)&Stat.st_gid)
           && ((HIWORD(Stat.st_rdev) & 0xF000) == 0x4000 && (v210.st_mode & 0xF000) != 0x4000
            || (HIWORD(Stat.st_rdev) & 0xF000) != 0x4000 && (v210.st_mode & 0xF000) == 0x4000) )
    {
      v57 = sub_473493(&unk_47AAF8);
      sub_4078E0(v57);
    }
    v58 = *((_DWORD *)v8 + 39);
    v59 = *((_DWORD *)v8 + 7);
    v209[0] = *((_DWORD *)v8 + 6);
    v60 = *((_DWORD *)v8 + 35);
    v209[39] = v58;
    v61 = *((_DWORD *)v8 + 8);
    v209[3] = v60;
    v62 = *((_DWORD *)v8 + 135);
    v209[2] = v61;
    v63 = *((_DWORD *)v8 + 89);
    v209[17] = v62;
    v64 = *((_DWORD *)v8 + 100);
    v209[1] = v59;
    v65 = *(_DWORD *)v8;
    v209[16] = v63;
    v66 = *((_DWORD *)v8 + 99);
    v209[27] = v64;
    v67 = *((_DWORD *)v8 + 103);
    v209[15] = v65;
    v68 = *((_DWORD *)v8 + 90);
    v209[26] = v66;
    v69 = *((_DWORD *)v8 + 101);
    v209[30] = v67;
    v70 = *((_DWORD *)v8 + 105);
    v209[18] = v68;
    v71 = *((_DWORD *)v8 + 102);
    v209[28] = v69;
    v72 = *((_DWORD *)v8 + 106);
    v209[32] = v70;
    v73 = *((_DWORD *)v8 + 109);
    v209[29] = v71;
    v74 = *((_DWORD *)v8 + 104);
    v209[54] = v72;
    v75 = *((_DWORD *)v8 + 108);
    v209[35] = v73;
    v76 = *((_DWORD *)v8 + 112);
    v209[31] = v74;
    v77 = *((_DWORD *)v8 + 107);
    v209[34] = v75;
    v78 = *((_DWORD *)v8 + 111);
    v209[38] = v76;
    v79 = *((_DWORD *)v8 + 113);
    v209[33] = v77;
    v80 = *((_DWORD *)v8 + 110);
    v209[37] = v78;
    v81 = *((_DWORD *)v8 + 116);
    v209[40] = v79;
    v82 = *((_DWORD *)v8 + 114);
    v209[36] = v80;
    v83 = *((_DWORD *)v8 + 115);
    v209[56] = v81;
    v209[55] = v83;
    v209[41] = 0;
    v209[42] = 0;
    v209[43] = 32;
    memset(&v209[44], 0, 12);
    v209[47] = 32;
    memset(&v209[48], 0, 12);
    v209[51] = 32;
    v209[52] = 0;
    if ( v82 && !sub_40C170(v82, (int)&v209[45]) )
      exit(1);
    if ( *((_DWORD *)v8 + 93) && !*((_DWORD *)v8 + 95) )
    {
      if ( dword_4AE2A4 )
      {
        v84 = sub_473493(&unk_47AB48);
        sub_4078E0(v84);
      }
      v85 = sub_473493(&unk_47AB98);
      sub_4078E0(v85);
    }
    v86 = *((_DWORD *)v8 + 95);
    v87 = *((_DWORD *)v8 + 96);
    v209[19] = *((_DWORD *)v8 + 93);
    v209[20] = *((_DWORD *)v8 + 94);
    v209[23] = *((_DWORD *)v8 + 97);
    v88 = *((_DWORD *)v8 + 50);
    v209[21] = v86;
    v89 = *((_DWORD *)v8 + 23);
    v209[22] = v87;
    v90 = *((_DWORD *)v8 + 98);
    v209[25] = v89;
    v209[24] = v90;
    v192 = 0;
    if ( v88 )
    {
      if ( *((_DWORD *)v8 + 116) && !*((_DWORD *)v8 + 117) )
      {
        if ( *((_DWORD *)v8 + 116) && !dword_4AE2A4 )
        {
          v99 = sub_473493(&unk_47AC28);
          sub_4079F0(v99, Stream);
        }
      }
      else
      {
        v91 = (FILE *)malloc(0x10u);
        v92 = *(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8);
        v192 = v91;
        v91->_ptr = 0;
        v91->_cnt = 8;
        v91->_base = (char *)8;
        v93 = v92(32);
        v94 = *((_DWORD *)v8 + 50) <= 0;
        v91->_flag = v93;
        v188 = 0;
        if ( !v94 )
        {
          do
          {
            v95 = *((_DWORD *)v8 + 53) + 8 * (_DWORD)v188;
            if ( *(_DWORD *)v95 )
            {
              v96 = fopen(*(const char **)(v95 + 4), "r");
              if ( !v96 )
              {
                v98 = sub_473493(&unk_47ABF0);
                sub_4078E0(v98);
              }
              v97 = (char *)malloc(0x400u);
              while ( fgets(v97, 1024, v96) )
                sub_40A440();
              free(v97);
              fclose(v96);
            }
            else
            {
              sub_40A440();
            }
            v188 = (FILE *)((char *)v188 + 1);
          }
          while ( (int)v188 < *((_DWORD *)v8 + 50) );
        }
      }
    }
    v27 = *((_DWORD *)v8 + 44) == 0;
    *(_DWORD *)&Stat.st_gid = *((_DWORD *)v8 + 10) == 0;
    if ( !v27 || *((_DWORD *)v8 + 116) )
    {
      Stat.st_rdev = (_dev_t)byte_47627C;
    }
    else
    {
      v100 = (const char *)*((_DWORD *)v8 + 48);
      if ( v100 )
      {
        v183 = fopen(v100, "r");
        if ( !v183 )
        {
          v106 = sub_473493(&unk_47ACC0);
          sub_4078E0(v106);
        }
        v101 = malloc(0x401u);
        for ( k = 0; ; v101 = realloc(v103, k + 1025) )
        {
          v103 = v101;
          v104 = fread(&v101[k], 1u, 0x400u, v183);
          k += v104;
          if ( v104 != 1024 )
            break;
        }
        v103[k] = 0;
        fclose(v183);
        v27 = *v103 == 0;
        Stat.st_rdev = (_dev_t)v103;
        v105 = v103;
        if ( !v27 )
        {
          do
          {
            if ( *v105 != 13 )
              *v103++ = *v105;
            ++v105;
          }
          while ( *v105 );
        }
        *v103 = 0;
      }
      else
      {
        Stat.st_rdev = 0;
      }
    }
    v107 = *((_DWORD *)v8 + 45);
    v108 = *((_DWORD *)v8 + 46);
    Stat.st_size = *((_DWORD *)v8 + 47);
    v109 = *(_DWORD *)v8;
    Stat.st_atime = v107;
    Stat.st_mtime = v108;
    v209[7] = sub_4070A0(&Stat.st_gid, v109);
    if ( v192 )
    {
      if ( (int)v192->_ptr > 0 )
      {
        flag = (void **)v192->_flag;
        ptr = (FILE *)v192->_ptr;
        do
        {
          free(*flag++);
          ptr = (FILE *)((char *)ptr - 1);
        }
        while ( ptr );
      }
      if ( v192->_flag )
      {
        (*(void (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 16))(v192->_flag);
        v192->_flag = 0;
      }
      v192->_cnt = 0;
      v192->_ptr = 0;
      free(v192);
    }
    v111 = (const char *)*((_DWORD *)v8 + 18);
    v112 = *((_DWORD *)v8 + 16) == 0;
    v27 = *((_DWORD *)v8 + 17) == 0;
    v209[8] = *((_DWORD *)v8 + 15) == 0;
    v209[9] = v112;
    v209[10] = v27;
    if ( v111 )
    {
      if ( !dword_4AE138 )
      {
        v114 = sub_473493(&unk_47AD20);
        sub_4078E0(v114);
      }
      if ( !isdigit(*v111) && (*v111 != 45 || !isdigit(v111[1])) )
      {
        v113 = sub_473493(&unk_47ACF8);
        sub_4078E0(v113);
      }
      v209[11] = atoi(v111);
    }
    else
    {
      v209[11] = 0;
    }
    if ( *((_DWORD *)v8 + 24) )
      v209[13] = 1;
    else
      v209[13] = *((_DWORD *)v8 + 25) != 0 ? 2 : 0;
    v115 = v196;
    v209[14] = *((_DWORD *)v8 + 26);
    if ( v196 > 0 )
      goto LABEL_183;
    if ( v196 < 0 )
    {
      v117 = sub_473493(&unk_47AD98);
      sub_4078F0(v117, Stream);
      v118 = sub_473493(&unk_47ADEC);
      sub_4078F0(v118, Streama);
      sub_4075F0();
    }
    if ( *((_DWORD *)v8 + 27) || *((_DWORD *)v8 + 31) )
    {
      v119 = (FILE *)off_4A4FE4(16);
      v119->_cnt = 2;
      v119->_base = (char *)2;
      v119->_ptr = 0;
      v185 = v119;
      v119->_flag = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(32);
      v120 = *((_DWORD *)v8 + 31);
      Time = v120;
      if ( v120 )
      {
        v121 = *(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8);
        *(_DWORD *)&Stat.st_gid = 0;
        v122 = v121(16 * v120);
        v94 = *((_DWORD *)v8 + 31) <= 0;
        st_atime = v122;
        Stat.st_atime = v122;
        v197 = 0;
        if ( !v94 )
        {
          v193 = 0;
          v199 = (_DWORD *)v122;
          do
          {
            v124 = (int *)((char *)v193 + *((_DWORD *)v8 + 34));
            v125 = *v124;
            v201 = v124;
            v211 = v125;
            if ( v125 )
            {
              v126 = *(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8);
              v207 = 0;
              v127 = v126(8 * v125);
              v94 = *v124 <= 0;
              v208 = (_DWORD *)v127;
              *(_DWORD *)&Stat.st_nlink = 0;
              if ( !v94 )
              {
                v189 = 0;
                *(_DWORD *)&Stat.st_ino = v127;
                do
                {
                  v128 = (int *)((char *)v189 + v201[3]);
                  v129 = (int *)off_4A4FE4(16);
                  *v129 = 0;
                  v129[1] = 1;
                  v129[2] = 1;
                  v130 = (*(int (__thiscall **)(void *, int))(*(_DWORD *)dword_4A80FC + 8))(dword_4A80FC, 12);
                  v131 = *v129;
                  v129[3] = v130;
                  v132 = *v128;
                  ++v207;
                  v189 = (FILE *)((char *)v189 + 12);
                  v133 = (_DWORD *)(v130 + 12 * v131);
                  *v133 = v132;
                  v133[1] = v128[1];
                  v133[2] = v128[2];
                  v134 = *(_DWORD **)&Stat.st_ino;
                  ++*v129;
                  *v134 = 3;
                  v134[1] = v129;
                  *(_DWORD *)&Stat.st_ino = v134 + 2;
                  v94 = ++*(_DWORD *)&Stat.st_nlink < *v201;
                }
                while ( v94 );
              }
              v135 = v211;
              ++*(_DWORD *)&Stat.st_gid;
              v119 = v185;
              *v199 = v207;
              v199[1] = v135;
              v199[2] = v135;
              v199[3] = v208;
              v199 += 4;
            }
            v193 = (FILE *)((char *)v193 + 16);
            ++v197;
          }
          while ( v197 < *((_DWORD *)v8 + 31) );
          st_atime = Stat.st_atime;
        }
        v136 = (_DWORD *)(v119->_flag + 16 * (int)v119->_ptr);
        *v136 = *(_DWORD *)&Stat.st_gid;
        v137 = Time;
        v136[1] = Time;
        v136[2] = v137;
        v136[3] = st_atime;
        ++v119->_ptr;
      }
      v138 = *((_DWORD *)v8 + 27);
      v202 = v138;
      if ( v138 )
      {
        v212 = 0;
        *(_DWORD *)&Stat.st_gid = 0;
        Stat.st_atime = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(16 * v138);
        v139 = (int *)Stat.st_atime;
        v190 = 0;
        v198 = Stat.st_atime;
        v200 = v138;
        *(_DWORD *)&Stat.st_gid = v138;
        do
        {
          v140 = *(_DWORD *)dword_4A80FC;
          Time = (__time32_t)&v190->_cnt + *((_DWORD *)v8 + 30);
          v141 = 0;
          v142 = (_DWORD *)(*(int (__cdecl **)(int))(v140 + 8))(32);
          v208 = v142;
          if ( v8[536] )
          {
            *v142 = 5;
            v142[1] = v204;
            v141 = 1;
          }
          v143 = Time;
          if ( *(_DWORD *)Time )
          {
            v27 = *((_DWORD *)v8 + 92) == 0;
            v142[2 * v141++ + 1] = Time;
            v142[2 * v141 - 2] = 2 * !v27 + 2;
          }
          if ( *(_DWORD *)(v143 + 16) )
          {
            v142[2 * v141] = 0;
            v142[2 * v141++ + 1] = v143 + 16;
          }
          Time = v143 + 32;
          if ( *(_DWORD *)(v143 + 32) || v212 != *(_WORD *)(v143 + 36) )
          {
            v144 = (int *)off_4A4FE4(16);
            *v144 = 0;
            v144[1] = 1;
            v144[2] = 1;
            v145 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(6);
            v146 = *v144;
            v144[3] = v145;
            v147 = v145 + 6 * v146;
            v148 = Time;
            *(_DWORD *)v147 = *(_DWORD *)Time;
            *(_WORD *)(v147 + 4) = *(_WORD *)(v148 + 4);
            ++*v144;
            v142 = v208;
            v208[2 * v141 + 1] = v144;
            v139 = (int *)v198;
            v142[2 * v141++] = 1;
          }
          v190 = (FILE *)((char *)v190 + 44);
          *v139 = v141;
          v139[1] = 4;
          v139[2] = 4;
          v139[3] = (int)v142;
          v139 += 4;
          v27 = v200-- == 1;
          v198 = (__time32_t)v139;
        }
        while ( !v27 );
        v149 = (_DWORD *)(v185->_flag + 16 * (int)v185->_ptr);
        v119 = v185;
        *v149 = *(_DWORD *)&Stat.st_gid;
        v149[1] = v202;
        v149[2] = v202;
        v149[3] = Stat.st_atime;
        ++v185->_ptr;
      }
      v115 = v196;
      v209[4] = (int)v119;
    }
    else
    {
      v209[4] = 0;
    }
    dword_4AE290 = v115 == 0;
    v150 = malloc(0x10u);
    *v150 = 0;
    v150[1] = *((_DWORD *)v8 + 65);
    v151 = *((_DWORD *)v8 + 65);
    if ( !v151 )
      v151 = 32;
    v150[2] = v151;
    v152 = *((_DWORD *)v8 + 65);
    if ( v152 )
      v153 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(12 * v152);
    else
      v153 = 0;
    v150[3] = v153;
    v154 = 0;
    if ( *((int *)v8 + 65) > 0 )
    {
      v186 = 0;
      do
      {
        v155 = (char **)((char *)&v186->_ptr + *((_DWORD *)v8 + 68));
        v186 = (FILE *)((char *)v186 + 12);
        v156 = (_DWORD *)(v150[3] + 12 * *v150);
        *v156 = *v155;
        v156[1] = v155[1];
        v156[2] = v155[2];
        ++*v150;
        ++v154;
      }
      while ( v154 < *((_DWORD *)v8 + 65) );
    }
    v209[6] = (int)v150;
    v157 = malloc(0x10u);
    *v157 = 0;
    v157[1] = *((_DWORD *)v8 + 69);
    v158 = *((_DWORD *)v8 + 69);
    if ( !v158 )
      v158 = 32;
    v157[2] = v158;
    v159 = *((_DWORD *)v8 + 69);
    if ( v159 )
      v160 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(12 * v159);
    else
      v160 = 0;
    v161 = 0;
    v157[3] = v160;
    if ( *((int *)v8 + 69) > 0 )
    {
      v187 = 0;
      do
      {
        v162 = (char **)((char *)&v187->_ptr + *((_DWORD *)v8 + 72));
        v187 = (FILE *)((char *)v187 + 12);
        v163 = (_DWORD *)(v157[3] + 12 * *v157);
        *v163 = *v162;
        v163[1] = v162[1];
        v163[2] = v162[2];
        ++*v157;
        ++v161;
      }
      while ( v161 < *((_DWORD *)v8 + 69) );
    }
    v209[5] = (int)(v8 + 244);
    v174 = *((_DWORD *)v8 + 3);
    v209[53] = (int)v157;
    sub_40A170(v8 + 160, v174, v8 + 216, v8 + 520, v8);
  }
  else
  {
    if ( v196 > 0 )
    {
LABEL_183:
      v116 = sub_473493(&unk_47AD68);
      sub_4078F0(v116, Stream);
      goto LABEL_184;
    }
    if ( v196 < 0 )
    {
      v170 = sub_473493(&unk_47AD98);
      sub_4078F0(v170, Stream);
      v171 = sub_473493(&unk_47ADEC);
      sub_4078F0(v171, Streamb);
LABEL_184:
      sub_4075F0();
    }
    dword_4AE290 = v196 == 0;
    if ( *((_DWORD *)v8 + 2) )
    {
      sub_408890(v8 + 160, v8 + 24, v8 + 44, v8 + 520);
    }
    else if ( *((_DWORD *)v8 + 40) )
    {
      v172 = sub_473493(&unk_47AE2C);
      sub_4078E0(v172);
    }
  }
  v164 = (const char *)*((_DWORD *)v8 + 58);
  if ( v164 && *((_DWORD *)v8 + 59) )
  {
    v194 = fopen(v164, "w");
    if ( !v194 )
    {
      v178 = *((_DWORD *)v8 + 58);
      v173 = sub_473493(&unk_47AE90);
      sub_407920(v173, v178);
    }
    if ( *((_DWORD *)v8 + 38) )
    {
      v177 = *((_DWORD *)v8 + 58);
      v165 = sub_473493(&unk_47AE6C);
      sub_4079D0(v165, v177);
      sub_44F01A();
      sub_405510();
    }
    sub_405510();
    fclose(v194);
  }
  if ( *((_DWORD *)v8 + 14) )
  {
    (*(void (__cdecl **)(_DWORD))(*(_DWORD *)dword_4A80FC + 16))(*((_DWORD *)v8 + 14));
    *((_DWORD *)v8 + 14) = 0;
  }
  v166 = *((_DWORD *)v8 + 57);
  *((_DWORD *)v8 + 12) = 0;
  *((_DWORD *)v8 + 11) = 0;
  if ( v166 )
  {
    (*(void (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 16))(v166);
    *((_DWORD *)v8 + 57) = 0;
  }
  v167 = *((_DWORD *)v8 + 133);
  *((_DWORD *)v8 + 55) = 0;
  *((_DWORD *)v8 + 54) = 0;
  if ( v167 )
  {
    (*(void (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 16))(v167);
    *((_DWORD *)v8 + 133) = 0;
  }
  v168 = *((_DWORD *)v8 + 43);
  *((_DWORD *)v8 + 131) = 0;
  *((_DWORD *)v8 + 130) = 0;
  if ( v168 )
  {
    (*(void (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 16))(v168);
    *((_DWORD *)v8 + 43) = 0;
  }
  *((_DWORD *)v8 + 41) = 0;
  *((_DWORD *)v8 + 40) = 0;
  free(v8);
  if ( dword_4AE2A4 )
    Sleep(0x3E8u);
  return dword_4AE2A0;
}
// 40A920: conditional instruction was optimized away because eax.4!=0
// 40B356: conditional instruction was optimized away because eax.4!=0
// 40B849: conditional instruction was optimized away because ebx.4!=0
// 40AA2C: variable 'v25' is possibly undefined
// 40AB99: variable 'Stream' is possibly undefined
// 40B61D: variable 'Streama' is possibly undefined
// 40BCE1: variable 'Streamb' is possibly undefined
// 4015A0: using guessed type int sub_4015A0(void);
// 402740: using guessed type int sub_402740(void);
// 403C70: using guessed type int __cdecl sub_403C70(_DWORD, _DWORD);
// 405510: using guessed type int sub_405510(void);
// 4070A0: using guessed type _DWORD __cdecl sub_4070A0(_DWORD, _DWORD);
// 4075F0: using guessed type void __noreturn sub_4075F0(void);
// 408210: using guessed type int sub_408210(void);
// 4082B0: using guessed type int sub_4082B0(void);
// 408460: using guessed type int sub_408460(void);
// 408890: using guessed type int __cdecl sub_408890(_DWORD, _DWORD, _DWORD, _DWORD);
// 40A170: using guessed type _DWORD __cdecl sub_40A170(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 40A440: using guessed type int sub_40A440(void);
// 40A510: using guessed type _DWORD __cdecl sub_40A510(_DWORD);
// 40A650: using guessed type _DWORD __cdecl sub_40A650(_DWORD, _DWORD);
// 40F420: using guessed type int sub_40F420(void);
// 40F640: using guessed type int __cdecl zend_highlight(_DWORD);
// 412C50: using guessed type int sub_412C50(void);
// 412CD0: using guessed type int sub_412CD0(void);
// 4132F0: using guessed type int sub_4132F0(void);
// 44F01A: using guessed type int sub_44F01A(void);
// 4A4FE4: using guessed type int (__cdecl *off_4A4FE4)(_DWORD);
// 4AB12C: using guessed type int dword_4AB12C;
// 4AE134: using guessed type int dword_4AE134;
// 4AE138: using guessed type int dword_4AE138;
// 4AE290: using guessed type int dword_4AE290;
// 4AE2A0: using guessed type int dword_4AE2A0;
// 4AE2A4: using guessed type int dword_4AE2A4;

//----- (0040BD70) --------------------------------------------------------
int __usercall sub_40BD70@<eax>(const char *a1@<eax>, int ArgList, int a3, char a4, int *a5)
{
  const char *v5; // esi
  int v6; // ebx
  int v7; // ebp
  char i; // al
  char v9; // al
  const char *v10; // edi
  const char *v11; // eax
  const char *v13; // eax
  const char *v14; // eax
  int v15; // [esp-8h] [ebp-18h]

  v5 = a1;
  v6 = 0;
  v7 = 0;
  if ( !*a1 )
    goto LABEL_17;
  do
  {
    if ( *v5 == 35 || iscntrl(*v5) )
      break;
    for ( i = *v5; i; i = *++v5 )
    {
      if ( !isspace(i) )
        break;
    }
    v9 = *v5;
    v10 = v5;
    if ( !*v5 )
      break;
    do
    {
      if ( v9 == 35 )
        break;
      if ( isspace(v9) )
        break;
      v9 = *++v5;
    }
    while ( v9 );
    if ( v5 != v10 )
    {
      if ( strncmp(v10, "name", v5 - v10) )
      {
        v14 = (const char *)sub_473493((int)&unk_47AEF8);
        sub_4078E0(v14, ArgList, v10, a3);
      }
      if ( v6 )
      {
        v13 = (const char *)sub_473493((int)&unk_47AEC4);
        sub_4078E0(v13, ArgList, a3);
      }
      v6 = 1;
    }
  }
  while ( *v5 );
  if ( !v6 )
  {
LABEL_17:
    v6 = 1;
    v7 = 1;
  }
  if ( !a4 && (a5[1] || a5[2]) )
  {
    v15 = *a5;
    v11 = (const char *)sub_473493((int)&unk_47AF30);
    sub_407970(v11, ArgList, v15, a3);
  }
  a5[1] = v6;
  a5[2] = v7;
  return 1;
}
// 40BD70: using guessed type int ArgList;

//----- (0040BEA0) --------------------------------------------------------
int __usercall sub_40BEA0@<eax>(char *a1@<eax>, _DWORD *a2@<edi>, _DWORD *a3)
{
  char *v3; // esi
  bool v4; // zf
  char v6; // al
  char v7; // al
  _BYTE *v8; // esi

  v3 = a1;
  v4 = *a1 == 0;
  *a2 = 0;
  if ( !v4 )
  {
    while ( isspace(*v3) )
    {
      if ( !*++v3 )
        return 0;
    }
  }
  v6 = *v3;
  if ( !*v3 || v6 == 35 )
    return 0;
  *a3 = v3;
  if ( !v6 )
    return 1;
  do
  {
    if ( *v3 == 35 )
      break;
    if ( isspace(*v3) )
      break;
    ++v3;
  }
  while ( *v3 );
  if ( !*v3 )
    return 1;
  *v3 = 0;
  v7 = v3[1];
  v8 = v3 + 1;
  if ( !v7 )
    goto LABEL_15;
  while ( isspace(v7) )
  {
    v7 = *++v8;
    if ( !v7 )
      goto LABEL_15;
  }
  if ( !*v8 || *v8 == 35 )
  {
LABEL_15:
    *a2 = 0;
    return 1;
  }
  *a2 = v8;
  return 1;
}

//----- (0040BF50) --------------------------------------------------------
int __usercall sub_40BF50@<eax>(int *a1@<eax>, int a2, int a3, char *Source, const char *a5)
{
  char v5; // bl
  int *v7; // esi
  _DWORD *v8; // eax
  int result; // eax
  int v10; // eax
  int v11; // ecx
  int v12; // eax
  int v13; // eax
  int v14; // [esp-4h] [ebp-18h]
  char v15; // [esp+10h] [ebp-4h]

  v5 = 0;
  v15 = 0;
  v7 = (int *)sub_445360(a1, Source);
  if ( !v7 )
  {
    v5 = 1;
    v15 = 1;
    v7 = (int *)malloc(0x10u);
    *v7 = (int)_strdup(Source);
    v7[1] = 1;
    v7[2] = 1;
    v8 = malloc(0x10u);
    v7[3] = (int)v8;
    *v8 = 0;
    *(_DWORD *)(v7[3] + 4) = 0;
    *(_DWORD *)(v7[3] + 8) = 32;
    *(_DWORD *)(v7[3] + 12) = 0;
  }
  if ( !a5 || (result = sub_40BD70(a5, a2, a3, v15, v7)) != 0 )
  {
    if ( v5 )
    {
      v10 = a1[1];
      if ( *a1 == v10 )
      {
        v11 = a1[3];
        v12 = a1[2] + v10;
        a1[1] = v12;
        v14 = 4 * v12;
        if ( v11 )
          v13 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v11, v14);
        else
          v13 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(v14);
        a1[3] = v13;
      }
      *(_DWORD *)(a1[3] + 4 * (*a1)++) = v7;
    }
    return 1;
  }
  return result;
}

//----- (0040C040) --------------------------------------------------------
int __usercall sub_40C040@<eax>(_DWORD *a1@<esi>, char *Source)
{
  int v2; // eax
  int v3; // eax
  int v4; // ecx
  int v5; // eax

  v2 = a1[1];
  if ( *a1 == v2 )
  {
    v3 = a1[2] + v2;
    v4 = a1[3];
    a1[1] = v3;
    if ( v4 )
      v5 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v4, 4 * v3);
    else
      v5 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(4 * v3);
    a1[3] = v5;
  }
  *(_DWORD *)(a1[3] + 4 * (*a1)++) = _strdup(Source);
  return 1;
}

//----- (0040C0A0) --------------------------------------------------------
int __usercall sub_40C0A0@<eax>(char *a1@<edi>, int a2, int a3, const char *a4, int *a5, _DWORD *a6)
{
  char *v6; // eax
  char *v7; // ebp
  int v8; // esi
  char *v9; // ebx
  int result; // eax
  const char *v11; // eax

  v6 = strstr(a1, SubStr);
  v7 = v6;
  if ( !v6 )
  {
    result = sub_40BF50(a5, a2, a3, a1, a4);
    if ( !result )
      return result;
    return 1;
  }
  v8 = v6 - a1;
  v9 = (char *)malloc(v6 - a1 + 1);
  strncpy(v9, a1, v7 - a1);
  v9[v8] = 0;
  if ( v8 != 1 || strcmp(v9, "*") )
  {
    v11 = (const char *)sub_473493((int)&unk_47AF84);
    sub_4078E0(v11);
  }
  result = sub_40C040(a6, v7 + 2);
  if ( result )
    return 1;
  return result;
}

//----- (0040C170) --------------------------------------------------------
int __usercall sub_40C170@<eax>(const char *ArgList@<ecx>, _DWORD *a2@<ebx>, _DWORD *a3@<esi>, int *a4)
{
  int v5; // ebp
  FILE *v6; // eax
  const char *v7; // eax
  const char *v8; // eax
  char *v9; // edi
  const char *v10; // eax
  const char *v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // ecx
  int v15; // eax
  int result; // eax
  int v17; // eax
  int v18; // ecx
  int v19; // eax
  int v20; // eax
  const char *v21; // eax
  const char *v22; // eax
  int v23; // [esp-8h] [ebp-42Ch]
  int v24; // [esp-8h] [ebp-42Ch]
  int v25; // [esp-4h] [ebp-428h]
  int v26; // [esp+8h] [ebp-41Ch]
  const char *v27; // [esp+Ch] [ebp-418h] BYREF
  const char *v28; // [esp+10h] [ebp-414h]
  char *String1; // [esp+14h] [ebp-410h] BYREF
  FILE *Stream; // [esp+18h] [ebp-40Ch]
  int *v31; // [esp+1Ch] [ebp-408h]
  char Buffer[1024]; // [esp+20h] [ebp-404h] BYREF

  v31 = a4;
  v5 = 1;
  v28 = ArgList;
  v26 = 1;
  String1 = 0;
  v27 = 0;
  v6 = fopen(ArgList, "rb");
  Stream = v6;
  if ( !a2 && !a3 )
    v5 = 2;
  if ( !v6 )
  {
    v7 = (const char *)sub_473493((int)&unk_47AFBC);
    sub_407920(v7, ArgList);
  }
  if ( fgets(Buffer, 1024, v6) )
  {
    do
    {
      if ( sub_40BEA0(Buffer, &v27, &String1) )
      {
        v8 = (const char *)sub_473493((int)&unk_47AFF0);
        v9 = String1;
        if ( !_stricmp(String1, v8) )
        {
          v5 = 1;
        }
        else
        {
          v10 = (const char *)sub_473493((int)&unk_47B000);
          if ( !_stricmp(v9, v10) )
          {
            v5 = 2;
          }
          else
          {
            v11 = (const char *)sub_473493((int)&unk_47B00C);
            if ( !_stricmp(v9, v11) )
            {
              v5 = 3;
            }
            else if ( v5 == 1 )
            {
              if ( v27 )
              {
                v23 = (int)v28;
                v21 = (const char *)sub_473493((int)&unk_47B018);
                sub_4078E0(v21, v23, v26);
              }
              v12 = a2[1];
              if ( *a2 == v12 )
              {
                v13 = a2[2] + v12;
                v14 = a2[3];
                a2[1] = v13;
                if ( v14 )
                  v15 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v14, 4 * v13);
                else
                  v15 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(4 * v13);
                a2[3] = v15;
              }
              *(_DWORD *)(a2[3] + 4 * (*a2)++) = _strdup(v9);
            }
            else if ( v5 == 2 )
            {
              if ( v31 )
              {
                result = sub_40C0A0(v9, (int)v28, v26, v27, v31, a3);
                if ( !result )
                  return result;
              }
            }
            else if ( a3 )
            {
              if ( v27 )
              {
                v24 = (int)v28;
                v22 = (const char *)sub_473493((int)&unk_47B054);
                sub_4078E0(v22, v24, v26);
              }
              v17 = a3[1];
              if ( *a3 == v17 )
              {
                v18 = a3[3];
                v19 = a3[2] + v17;
                a3[1] = v19;
                v25 = 4 * v19;
                if ( v18 )
                  v20 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v18, v25);
                else
                  v20 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(v25);
                a3[3] = v20;
              }
              *(_DWORD *)(a3[3] + 4 * (*a3)++) = _strdup(v9);
            }
          }
        }
      }
      ++v26;
    }
    while ( fgets(Buffer, 1024, Stream) );
  }
  fclose(Stream);
  return 1;
}
// 40C334: conditional instruction was optimized away because ebp.4==3

//----- (0040C420) --------------------------------------------------------
int __usercall sub_40C420@<eax>(_DWORD *a1@<ebx>)
{
  unsigned int v1; // esi
  int v2; // eax
  char *v3; // edi
  char *v4; // ebp
  int v5; // ebp
  int v6; // edi
  char *v7; // eax
  char *v8; // esi
  int v9; // ecx
  int v10; // edx
  char *v11; // esi
  char *v12; // eax
  char *v13; // edx
  char *v14; // esi
  char *v15; // edi
  bool v16; // zf
  unsigned int v17; // eax
  int v18; // esi
  int v19; // edx
  int v20; // ecx
  unsigned int v21; // edx
  int v22; // eax
  unsigned int v23; // eax
  int v24; // eax
  int v25; // eax
  int v26; // edx
  _DWORD *v27; // eax
  void *v28; // ecx
  void *v29; // edx
  void *v30; // eax
  void *v31; // ecx
  _DWORD *v32; // eax
  __int16 v33; // cx
  void *v34; // eax
  void *v35; // ecx
  void *v36; // edx
  void *v37; // eax
  void *v38; // ecx
  void *v39; // edx
  void *v40; // eax
  void *v41; // ecx
  void *v42; // edx
  void *v43; // eax
  void *v44; // ecx
  void *v45; // edx
  void *v46; // eax
  void *v47; // ecx
  void *v48; // eax
  void *v49; // ecx
  void *v50; // edx
  _DWORD *v51; // esi
  char *v52; // esi
  char *v53; // eax
  void *v54; // eax
  _DWORD *v55; // eax
  char *v56; // eax
  __int16 v57; // cx
  int v58; // edx
  unsigned int v59; // eax
  const char *v60; // eax
  void *v61; // eax
  void *v62; // ecx
  char *v63; // eax
  void *v64; // eax
  void *v65; // ebp
  void *v66; // ecx
  unsigned int v67; // edx
  int v68; // eax
  void *v69; // edx
  void *v70; // ecx
  int v71; // edx
  unsigned int v72; // eax
  unsigned int v73; // ebp
  int v74; // edx
  void *v75; // esi
  char *v76; // eax
  void *v77; // eax
  _DWORD *v78; // ecx
  void *v79; // edx
  void *v80; // eax
  void *v81; // ecx
  void *v82; // edx
  __int16 v83; // cx
  void *v84; // edx
  int v85; // esi
  const char *v87; // eax
  const char *v88; // eax
  const char *v89; // eax
  const char *v90; // eax
  const char *v91; // eax
  const char *v92; // eax
  void *v93; // [esp-Ch] [ebp-2E10h]
  size_t v94; // [esp-8h] [ebp-2E0Ch]
  int v95; // [esp-4h] [ebp-2E08h]
  _DWORD *v96; // [esp-4h] [ebp-2E08h]
  _DWORD *v97; // [esp-4h] [ebp-2E08h]
  void *v98; // [esp-4h] [ebp-2E08h]
  _DWORD *v99; // [esp-4h] [ebp-2E08h]
  char *v100; // [esp+10h] [ebp-2DF4h]
  char *v101; // [esp+10h] [ebp-2DF4h]
  char *v102; // [esp+10h] [ebp-2DF4h]
  int v103; // [esp+14h] [ebp-2DF0h]
  int v104; // [esp+14h] [ebp-2DF0h]
  int v105; // [esp+18h] [ebp-2DECh]
  char *v106; // [esp+1Ch] [ebp-2DE8h]
  int v107; // [esp+20h] [ebp-2DE4h]
  int v108; // [esp+20h] [ebp-2DE4h]
  int v109; // [esp+20h] [ebp-2DE4h]
  int v110; // [esp+24h] [ebp-2DE0h]
  int v111; // [esp+28h] [ebp-2DDCh]
  char *Block; // [esp+2Ch] [ebp-2DD8h]
  char *Blocka; // [esp+2Ch] [ebp-2DD8h]
  int v114; // [esp+30h] [ebp-2DD4h]
  char *v115; // [esp+34h] [ebp-2DD0h]
  void *Src[14]; // [esp+38h] [ebp-2DCCh] BYREF
  char v117[56]; // [esp+70h] [ebp-2D94h] BYREF
  char v118[11200]; // [esp+A8h] [ebp-2D5Ch] BYREF
  char v119[404]; // [esp+2C68h] [ebp-19Ch] BYREF

  v1 = 200;
  v106 = v119;
  v115 = v118;
  v110 = 200;
  memset(v117, 0, sizeof(v117));
  v103 = 0;
  v111 = 0;
  v114 = 0;
  v2 = -2;
  v3 = v119;
  v105 = -2;
  v100 = v119;
  v4 = v118;
  while ( 1 )
  {
    *(_WORD *)v3 = v103;
    if ( &v106[2 * v1 - 2] <= v3 )
      break;
LABEL_19:
    v18 = v103;
    v19 = byte_482288[v103];
    v108 = v19;
    if ( v19 == -23 )
      goto LABEL_39;
    if ( v2 == -2 )
    {
      v2 = sub_40CF70((int)v117);
      v18 = v103;
      v19 = v108;
      v105 = v2;
    }
    if ( v2 > 0 )
    {
      v20 = (unsigned int)v2 > 0x107 ? 2 : (unsigned __int8)byte_4820F0[v2];
    }
    else
    {
      v20 = 0;
      v2 = 0;
      v105 = 0;
    }
    v21 = v20 + v19;
    if ( v21 > 0x35 )
      goto LABEL_39;
    if ( byte_482308[v21] == v20 )
    {
      if ( !byte_4822D0[v21] )
      {
        v2 = v105;
        goto LABEL_40;
      }
      if ( byte_4822D0[v21] == 22 )
        goto LABEL_109;
      if ( v111 )
        --v111;
      if ( v105 )
        v105 = -2;
      v2 = v105;
      v4 += 56;
      v100 += 2;
      v103 = (unsigned __int8)byte_4822D0[v21];
      qmemcpy(v4, v117, 0x38u);
      v1 = v110;
      v3 = v100;
    }
    else
    {
      v2 = v105;
LABEL_39:
      v109 = (unsigned __int8)byte_482240[v18];
      if ( byte_482240[v18] )
      {
        v104 = (unsigned __int8)byte_48221C[v109];
        Blocka = &v4[-56 * v104];
        qmemcpy(Src, Blocka + 56, sizeof(Src));
        switch ( v109 )
        {
          case 2:
          case 3:
            qmemcpy(a1, v4 + 16, 0x28u);
            break;
          case 4:
            *a1 = 0;
            a1[1] = 0;
            a1[2] = 0;
            a1[3] = 0;
            a1[8] = 0;
            a1[9] = 0;
            a1[4] = 0;
            a1[6] = 32;
            a1[7] = 0;
            a1[5] = 32;
            v25 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(640);
            v26 = a1[4];
            a1[7] = v25;
            v27 = (_DWORD *)(v25 + 20 * v26);
            *v27 = *((_DWORD *)v4 + 4);
            v27[1] = *((_DWORD *)v4 + 5);
            v27[2] = *((_DWORD *)v4 + 6);
            v27[3] = *((_DWORD *)v4 + 7);
            v27[4] = *((_DWORD *)v4 + 8);
            ++a1[4];
            break;
          case 5:
            v28 = (void *)*((_DWORD *)v4 - 5);
            Src[1] = *((void **)v4 + 1);
            v29 = (void *)*((_DWORD *)v4 - 4);
            memset(&Src[4], 0, 16);
            v30 = (void *)*((_DWORD *)v4 - 6);
            Src[9] = v28;
            v31 = (void *)*((_DWORD *)v4 + 12);
            Src[10] = v29;
            LOWORD(v29) = *((_WORD *)v4 + 26);
            Src[8] = v30;
            v32 = (_DWORD *)*((_DWORD *)v4 - 3);
            Src[12] = v31;
            LOWORD(Src[13]) = (_WORD)v29;
            goto LABEL_76;
          case 6:
            v33 = *((_WORD *)v4 + 26);
            Src[12] = 0;
            Src[13] = 0;
            memset(&Src[4], 0, 32);
            Src[12] = *((void **)v4 + 12);
            LOWORD(Src[13]) = v33;
            break;
          case 7:
            v34 = (void *)*((_DWORD *)v4 - 24);
            v35 = (void *)*((_DWORD *)v4 - 23);
            Src[1] = *((void **)v4 + 1);
            v36 = (void *)*((_DWORD *)v4 - 22);
            Src[4] = v34;
            v37 = (void *)*((_DWORD *)v4 - 21);
            Src[5] = v35;
            v38 = (void *)*((_DWORD *)v4 - 6);
            Src[6] = v36;
            v39 = (void *)*((_DWORD *)v4 - 5);
            Src[7] = v37;
            v40 = (void *)*((_DWORD *)v4 - 4);
            Src[8] = v38;
            v41 = (void *)*((_DWORD *)v4 - 3);
            Src[9] = v39;
            v42 = (void *)*((_DWORD *)v4 + 12);
            Src[10] = v40;
            LOWORD(v40) = *((_WORD *)v4 + 26);
            Src[11] = v41;
            Src[12] = v42;
            LOWORD(Src[13]) = (_WORD)v40;
            break;
          case 8:
            v43 = 0;
            memset(&Src[4], 0, 12);
            goto LABEL_62;
          case 9:
            v48 = (void *)*((_DWORD *)v4 - 10);
            v49 = (void *)*((_DWORD *)v4 - 9);
            Src[1] = *((void **)v4 + 1);
            v50 = (void *)*((_DWORD *)v4 - 8);
            Src[4] = v48;
            v43 = (void *)*((_DWORD *)v4 - 7);
            Src[5] = v49;
            Src[6] = v50;
LABEL_62:
            v44 = (void *)*((_DWORD *)v4 + 8);
            v45 = (void *)*((_DWORD *)v4 + 9);
            Src[7] = v43;
            v46 = (void *)*((_DWORD *)v4 + 10);
            Src[8] = v44;
            v47 = (void *)*((_DWORD *)v4 + 11);
            Src[10] = v46;
            Src[9] = v45;
            Src[11] = v47;
            Src[12] = 0;
            LOWORD(Src[13]) = 0;
            break;
          case 11:
          case 14:
            goto LABEL_73;
          case 12:
            Src[1] = *((void **)v4 + 1);
            break;
          case 13:
            Src[1] = *((void **)v4 + 1);
            break;
          case 15:
            Src[6] = (void *)32;
            Src[5] = (void *)32;
            v51 = (_DWORD *)(*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(128);
            v94 = *((_DWORD *)v4 + 1) - *(_DWORD *)v4;
            v93 = *(void **)v4;
            Src[7] = v51;
            *v51 = estrndup(v93, v94);
            Src[4] = (void *)1;
            break;
          case 16:
            v52 = (char *)Src[4];
            if ( Src[4] == Src[5] )
            {
              v53 = (char *)Src[6] + (unsigned int)Src[5];
              Src[5] = (char *)Src[5] + (unsigned int)Src[6];
              if ( Src[7] )
                v54 = (void *)(*(int (__cdecl **)(void *, int))(*(_DWORD *)dword_4A80FC + 12))(Src[7], 4 * (_DWORD)v53);
              else
                v54 = (void *)(*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(4 * (_DWORD)v53);
              Src[7] = v54;
            }
            v55 = estrndup(*(void **)v4, *((_DWORD *)v4 + 1) - *(_DWORD *)v4);
            *((_DWORD *)Src[7] + (_DWORD)v52) = v55;
            Src[4] = v52 + 1;
LABEL_73:
            Src[1] = *((void **)v4 + 1);
            break;
          case 17:
            Src[0] = *(void **)v4;
            Src[1] = Src[0];
            goto LABEL_75;
          case 19:
            if ( *((int *)v4 + 3) > 255 )
            {
              v95 = *((_DWORD *)v4 + 3);
              v60 = (const char *)sub_473493((int)&unk_482378);
              sub_4078E0(v60, v95);
            }
            break;
          case 20:
            v61 = (void *)(*((_DWORD *)v4 + 3) << 24);
            Src[4] = (void *)8;
            Src[5] = v61;
            break;
          case 21:
            v62 = (void *)*((_DWORD *)v4 + 1);
            v63 = (char *)Src[4] + 8;
            Src[1] = v62;
            Src[4] = v63;
            if ( (unsigned int)v63 > 0x20 )
            {
              v96 = estrndup(Src[0], (size_t)v62 - (unsigned int)Src[0]);
              v87 = (const char *)sub_473493((int)&unk_48239C);
              sub_4078E0(v87, v96);
            }
            Src[5] = (void *)((int)Src[5] | (*((_DWORD *)v4 + 3) << (32 - (_BYTE)v63)));
            break;
          case 22:
            memset(&Src[4], 0, 20);
            v64 = (void *)*((_DWORD *)v4 + 5);
            v65 = (void *)*((_DWORD *)v4 + 4);
            Src[4] = v64;
            Src[5] = v65;
            Src[6] = (void *)-(1 << (32 - (_BYTE)v65));
            break;
          case 23:
            v66 = (void *)*((_DWORD *)v4 - 23);
            v67 = *((_DWORD *)v4 + 5);
            memset(&Src[4], 0, 20);
            Src[1] = *((void **)v4 + 1);
            v68 = *((_DWORD *)v4 + 4);
            Src[4] = v66;
            if ( v68 == 8 )
            {
              v69 = (void *)HIBYTE(v67);
              if ( !v69 )
              {
                v89 = (const char *)sub_473493((int)&unk_4823C4);
                sub_4078E0(v89);
              }
              if ( (unsigned int)v69 > 0x20 )
              {
                v98 = v69;
                v90 = (const char *)sub_473493((int)&unk_4823E8);
                sub_4078E0(v90, v98);
              }
              Src[5] = v69;
              Src[6] = (void *)-(1 << (32 - (_BYTE)v69));
            }
            else
            {
              if ( v68 != 32 )
              {
                v97 = estrndup(*(void **)v4, *((_DWORD *)v4 + 1) - *(_DWORD *)v4);
                v88 = (const char *)sub_473493((int)&unk_482410);
                sub_4078E0(v88, v97);
              }
              Src[6] = (void *)v67;
              Src[5] = 0;
            }
            break;
          case 24:
            v70 = (void *)*((_DWORD *)v4 + 1);
            v71 = *((_DWORD *)v4 + 4);
            v16 = *((_DWORD *)v4 - 24) == 32;
            Src[1] = v70;
            memset(&Src[4], 0, 20);
            if ( !v16 )
            {
              v99 = estrndup(Src[0], (size_t)v70 - (unsigned int)Src[0]);
              v91 = (const char *)sub_473493((int)&unk_482434);
              sub_4078E0(v91, v99);
            }
            v72 = *((_DWORD *)v4 - 23);
            v73 = *((_DWORD *)v4 + 5) >> (32 - v71);
            Src[4] = (void *)v72;
            Src[7] = (void *)v73;
            if ( v71 != 32 )
            {
              v73 |= v72 & ~((1 << v71) - 1);
              Src[7] = (void *)v73;
            }
            if ( v73 < v72 )
            {
              Src[7] = (void *)v72;
              Src[4] = (void *)v73;
            }
            Src[5] = 0;
            break;
          case 25:
            v74 = *(_DWORD *)dword_4A80FC;
            Src[10] = (void *)32;
            Src[9] = (void *)32;
            v32 = (_DWORD *)(*(int (__cdecl **)(int))(v74 + 8))(640);
            *v32 = *((_DWORD *)v4 + 4);
            v32[1] = *((_DWORD *)v4 + 5);
            v32[2] = *((_DWORD *)v4 + 6);
            v32[3] = *((_DWORD *)v4 + 7);
            v32[4] = *((_DWORD *)v4 + 8);
            Src[8] = (void *)1;
            goto LABEL_76;
          case 26:
            v75 = Src[8];
            if ( Src[8] == Src[9] )
            {
              v76 = (char *)Src[10] + (unsigned int)Src[9];
              Src[9] = (char *)Src[9] + (unsigned int)Src[10];
              if ( Src[11] )
                v77 = (void *)(*(int (__cdecl **)(void *, int))(*(_DWORD *)dword_4A80FC + 12))(
                                Src[11],
                                20 * (_DWORD)v76);
              else
                v77 = (void *)(*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(20 * (_DWORD)v76);
              Src[11] = v77;
            }
            v78 = (char *)Src[11] + 20 * (_DWORD)v75;
            *v78 = *((_DWORD *)v4 + 4);
            v78[1] = *((_DWORD *)v4 + 5);
            v78[2] = *((_DWORD *)v4 + 6);
            v78[3] = *((_DWORD *)v4 + 7);
            v78[4] = *((_DWORD *)v4 + 8);
            Src[8] = (char *)v75 + 1;
            break;
          case 27:
            v79 = (void *)*((_DWORD *)v4 + 9);
            v80 = (void *)*((_DWORD *)v4 + 10);
            Src[8] = *((void **)v4 + 8);
            v81 = (void *)*((_DWORD *)v4 + 11);
            Src[9] = v79;
            v82 = (void *)*((_DWORD *)v4 + 1);
            Src[10] = v80;
            Src[11] = v81;
            Src[1] = v82;
            break;
          case 28:
          case 29:
          case 34:
LABEL_75:
            v32 = 0;
            Src[13] = 0;
            Src[12] = 0;
            memset(&Src[4], 0, 28);
LABEL_76:
            Src[11] = v32;
            break;
          case 32:
            v83 = *((_WORD *)v4 - 2);
            v84 = (void *)*((_DWORD *)v4 + 1);
            Src[12] = *((void **)v4 - 2);
            LOWORD(Src[13]) = v83;
            Src[1] = v84;
            break;
          case 33:
            v92 = (const char *)sub_473493((int)&unk_48246C);
            sub_4078E0(v92);
          default:
            break;
        }
        v56 = &v100[-2 * v104];
        v4 = Blocka + 56;
        qmemcpy(Blocka + 56, Src, 0x38u);
        v57 = *(_WORD *)v56;
        v58 = (unsigned __int8)byte_4821F8[v109];
        v102 = v56;
        v59 = *(__int16 *)v56 + byte_4822B0[v58];
        if ( v59 <= 0x35 && byte_482308[v59] == v57 )
        {
          v100 = v102 + 2;
          v1 = v110;
          v3 = v100;
          v103 = (unsigned __int8)byte_4822D0[v59];
          v2 = v105;
        }
        else
        {
          v100 = v102 + 2;
          v1 = v110;
          v3 = v100;
          v2 = v105;
          v103 = byte_482268[v58];
        }
      }
      else
      {
LABEL_40:
        if ( v111 )
        {
          if ( v111 == 3 )
          {
            if ( v2 > 0 )
            {
              v105 = -2;
            }
            else
            {
              if ( !v2 )
                goto LABEL_110;
              v18 = v103;
            }
          }
        }
        else
        {
          ++v114;
        }
        v111 = 3;
        while ( 1 )
        {
          v22 = byte_482288[v18];
          if ( v22 != -23 )
          {
            v23 = v22 + 1;
            if ( v23 <= 0x35 && byte_482308[v23] == 1 )
            {
              v24 = (unsigned __int8)byte_4822D0[v23];
              if ( v24 )
                break;
            }
          }
          if ( v3 == v106 )
            goto LABEL_110;
          v18 = *((__int16 *)v3 - 1);
          v4 -= 56;
          v3 -= 2;
          v100 = v3;
        }
        if ( v24 == 22 )
        {
LABEL_109:
          v85 = 0;
          goto LABEL_111;
        }
        v4 += 56;
        v100 += 2;
        qmemcpy(v4, v117, 0x38u);
        v1 = v110;
        v3 = v100;
        v103 = v24;
        v2 = v105;
      }
    }
  }
  v5 = ((v3 - v106) >> 1) + 1;
  if ( v1 >= 0x2710 )
    goto LABEL_108;
  v6 = 2 * v1;
  v110 = 2 * v1;
  if ( 2 * v1 > 0x2710 )
  {
    v6 = 10000;
    v110 = 10000;
  }
  Block = v106;
  v7 = (char *)malloc(58 * v6 + 55);
  v8 = v7;
  if ( !v7 )
  {
LABEL_108:
    v85 = 2;
    goto LABEL_111;
  }
  if ( v5 )
  {
    v9 = v106 - v7;
    v10 = v5;
    do
    {
      *(_WORD *)v7 = *(_WORD *)&v7[v9];
      v7 += 2;
      --v10;
    }
    while ( v10 );
    v6 = v110;
  }
  v106 = v8;
  v11 = &v8[56 * ((2 * v6 + 55) / 0x38u)];
  v101 = v11;
  if ( v5 )
  {
    v12 = v11;
    v13 = (char *)(v115 - v11);
    v107 = v5;
    do
    {
      v14 = &v12[(_DWORD)v13];
      v15 = v12;
      v12 += 56;
      v16 = v107-- == 1;
      qmemcpy(v15, v14, 0x38u);
    }
    while ( !v16 );
    v11 = v101;
  }
  v115 = v11;
  if ( Block != v119 )
    free(Block);
  v17 = (unsigned int)&v106[2 * v5 - 2];
  v4 = &v11[56 * v5 - 56];
  v100 = (char *)v17;
  if ( (unsigned int)&v106[2 * v110 - 2] > v17 )
  {
    v3 = (char *)v17;
    v2 = v105;
    goto LABEL_19;
  }
LABEL_110:
  v85 = 1;
LABEL_111:
  if ( v106 != v119 )
    free(v106);
  return v85;
}
// 40C638: conditional instruction was optimized away because ecx.4 is in (1..FF)

//----- (0040CF10) --------------------------------------------------------
char *__usercall sub_40CF10@<eax>(int a1@<ecx>, _DWORD *a2@<ebx>)
{
  const char *v2; // eax
  char *result; // eax
  const char *v4; // eax

  dword_4A728C = ArgList;
  dword_4A7288 = 259;
  dword_4A80EC = 1;
  if ( sub_40C420(a2) )
  {
    v2 = (const char *)sub_473493((int)&unk_4824A0);
    sub_4078E0(v2, a1);
  }
  result = dword_4A728C;
  if ( *dword_4A728C )
  {
    v4 = (const char *)sub_473493((int)&unk_4825A4);
    sub_4078E0(v4);
  }
  return result;
}
// 4A7288: using guessed type int dword_4A7288;
// 4A80EC: using guessed type int dword_4A80EC;

//----- (0040CF70) --------------------------------------------------------
int __usercall sub_40CF70@<eax>(int a1@<esi>)
{
  char *v1; // eax
  int v2; // ecx
  int result; // eax
  char v4; // cl
  char *v5; // edx
  const char *v6; // eax
  const char *v7; // eax
  char *v8; // ecx
  char *v9; // ecx
  char v10; // al
  int v11; // eax
  char *v12; // edx
  char v13; // al
  char v14; // cl
  char v15; // dl
  char *v16; // eax
  char v17; // cl
  char v18; // dl
  int v19; // [esp-4h] [ebp-20h]
  int v20; // [esp-4h] [ebp-20h]
  int v21; // [esp+0h] [ebp-1Ch] BYREF
  char v22; // [esp+4h] [ebp-18h] BYREF
  char v23; // [esp+8h] [ebp-14h] BYREF
  char v24; // [esp+Ch] [ebp-10h] BYREF
  char v25; // [esp+10h] [ebp-Ch] BYREF
  char v26; // [esp+14h] [ebp-8h] BYREF
  char v27; // [esp+18h] [ebp-4h] BYREF

  if ( isspace(*dword_4A728C) )
  {
    do
      v19 = *++dword_4A728C;
    while ( isspace(v19) );
  }
  v1 = dword_4A728C;
  v2 = dword_4A7288;
  *(_DWORD *)a1 = dword_4A728C;
  *(_DWORD *)(a1 + 4) = v1;
  if ( v2 )
  {
    result = v2;
    dword_4A7288 = 0;
    return result;
  }
  if ( dword_4A80EC )
  {
    v4 = *v1;
    v5 = 0;
    if ( *v1 )
    {
      while ( v4 != 64 )
      {
        if ( v4 == 44 && !v5 )
          v5 = v1;
        v4 = *++v1;
        if ( !v4 )
        {
          dword_4A728C = v1;
          goto LABEL_13;
        }
      }
      dword_4A728C = v1;
    }
    else
    {
LABEL_13:
      if ( *v1 != 64 )
      {
LABEL_22:
        dword_4A728C = *(char **)a1;
        goto LABEL_23;
      }
    }
    if ( v5 )
    {
      v1 = v5;
      dword_4A728C = v5;
    }
    if ( (unsigned int)v1 > *(_DWORD *)a1 )
    {
      *(_DWORD *)(a1 + 4) = v1;
      return 261;
    }
    if ( *v1 == 64 )
      dword_4A80EC = 0;
    goto LABEL_22;
  }
LABEL_23:
  v6 = (const char *)sub_473493((int)&unk_4825F4);
  if ( sscanf(dword_4A728C, v6, &v22, &v23, &v24, &v25, &v26, &v27, &v21) >= 6
    || (v7 = (const char *)sub_473493((int)&unk_482618),
        sscanf(dword_4A728C, v7, &v22, &v23, &v24, &v25, &v26, &v27, &v21) >= 6) )
  {
    v14 = v22;
    v15 = v23;
    *(_BYTE *)(a1 + 50) = v24;
    *(_BYTE *)(a1 + 53) = v27;
    v16 = &dword_4A728C[v21];
    *(_BYTE *)(a1 + 48) = v14;
    v17 = v25;
    *(_BYTE *)(a1 + 49) = v15;
    v18 = v26;
    dword_4A728C = v16;
    *(_DWORD *)(a1 + 4) = v16;
    *(_BYTE *)(a1 + 51) = v17;
    *(_BYTE *)(a1 + 52) = v18;
    return 262;
  }
  else if ( isalnum(*dword_4A728C)
         || (LOBYTE(result) = *dword_4A728C, *dword_4A728C == 42)
         || (_BYTE)result == 63
         || (_BYTE)result == 33
         || (_BYTE)result == 91
         || (_BYTE)result == 93
         || (result & 0x80u) != 0 )
  {
    if ( !isdigit(*dword_4A728C) )
      goto LABEL_45;
    if ( isdigit(*dword_4A728C) )
    {
      do
        v20 = *++dword_4A728C;
      while ( isdigit(v20) );
    }
    if ( isalpha(*dword_4A728C) )
    {
LABEL_45:
      v9 = dword_4A728C;
    }
    else
    {
      v9 = dword_4A728C;
      v10 = *dword_4A728C;
      if ( *dword_4A728C != 42 && v10 != 63 && v10 != 33 && v10 != 91 && v10 != 93 )
      {
        v11 = atoi(*(const char **)a1);
        v12 = dword_4A728C;
        *(_DWORD *)(a1 + 12) = v11;
        *(_DWORD *)(a1 + 4) = v12;
        return 263;
      }
    }
    while ( 1 )
    {
      if ( !isalnum(*v9) )
      {
        v13 = *dword_4A728C;
        if ( *dword_4A728C != 42
          && v13 != 63
          && v13 != 33
          && v13 != 91
          && v13 != 93
          && v13 != 45
          && v13 != 95
          && v13 >= 0 )
        {
          break;
        }
      }
      v9 = ++dword_4A728C;
    }
    *(_DWORD *)(a1 + 4) = dword_4A728C;
    return 261;
  }
  else
  {
    v8 = dword_4A728C + 1;
    *(_DWORD *)(a1 + 4) = dword_4A728C + 1;
    if ( (_BYTE)result )
      dword_4A728C = v8;
    return (unsigned __int8)result;
  }
}
// 4A7288: using guessed type int dword_4A7288;
// 4A80EC: using guessed type int dword_4A80EC;

//----- (0040D250) --------------------------------------------------------
int __cdecl sub_40D250(unsigned __int8 *a1, char *a2, unsigned int a3, int a4, unsigned int a5)
{
  char *v5; // ecx
  unsigned __int8 v6; // bl
  unsigned __int8 *v7; // ebp
  BOOL v8; // edi
  int result; // eax
  bool v10; // zf
  int v11; // eax
  unsigned __int8 v12; // dl
  int v13; // edi
  unsigned __int8 v14; // bl
  unsigned __int8 v15; // al
  unsigned __int8 v16; // al
  int v17; // ecx
  unsigned __int8 *v18; // edx
  unsigned __int8 v19; // al
  int v20; // ecx
  unsigned __int8 *v21; // esi
  char v22; // al
  char v23; // al
  unsigned __int8 v24; // cl
  unsigned __int8 v25; // dl
  signed __int8 v26; // cl
  unsigned __int8 v27; // al
  unsigned __int8 *v28; // ebp
  _BYTE *v29; // ebp
  char v30; // al
  int v31; // eax
  char *v32; // esi
  unsigned __int8 v33; // bl
  char *v34; // eax
  int v35; // esi
  char *v36; // edi
  char *v37; // eax
  int v38; // ebp
  int v39; // eax
  unsigned int v40; // esi
  int v41; // eax
  unsigned __int8 *v42; // ebp
  char *v43; // ebx
  char *Buf; // [esp+10h] [ebp-2Ch]
  char *Bufa; // [esp+10h] [ebp-2Ch]
  unsigned __int8 *v46; // [esp+14h] [ebp-28h]
  unsigned __int8 *v47; // [esp+14h] [ebp-28h]
  unsigned __int8 *v48; // [esp+14h] [ebp-28h]
  unsigned __int8 v49; // [esp+1Bh] [ebp-21h]
  int v50; // [esp+24h] [ebp-18h]
  unsigned int v51; // [esp+24h] [ebp-18h]
  int v52; // [esp+28h] [ebp-14h]
  char v53[8]; // [esp+30h] [ebp-Ch] BYREF

  v5 = a2;
  v6 = *a1;
  v7 = a1;
  Buf = a2;
  if ( !*a1 )
  {
LABEL_171:
    if ( v5 != (char *)a3 )
      return (a5 & 8) == 0 || *v5 != 47;
    return 0;
  }
  v8 = a4;
LABEL_3:
  ++v7;
  v50 = 0;
  if ( (a5 & 0x10) != 0 && v6 < 0x80u && isupper(v6) )
    v6 = tolower(v6);
  switch ( v6 )
  {
    case '!':
    case '+':
    case '@':
      if ( (a5 & 0x20) == 0 )
        goto LABEL_157;
      if ( *v7 != 40 )
        goto LABEL_157;
      result = sub_40DFA0(v6, (const char *)v7, (unsigned int)Buf, a3, v8, a5);
      if ( result == -1 )
        goto LABEL_157;
      return result;
    case '*':
      if ( (a5 & 0x20) != 0 && *v7 == 40 )
      {
        result = sub_40DFA0(v6, (const char *)v7, (unsigned int)Buf, a3, v8, a5);
        if ( result != -1 )
          return result;
      }
      v32 = Buf;
      if ( Buf != (char *)a3 && *Buf == 46 && v8 )
        return 1;
      while ( 1 )
      {
        v33 = *v7++;
        if ( v33 != 63 && v33 != 42 )
          break;
        if ( *v7 == 40 && (a5 & 0x20) != 0 && (v34 = sub_40DED0((int)v7), v34 != (char *)v7) )
        {
          v7 = (unsigned __int8 *)v34;
        }
        else if ( v33 == 63 )
        {
          if ( v32 == (char *)a3 || *v32 == 47 && (a5 & 1) != 0 )
            return 1;
          ++v32;
        }
      }
      v47 = v7;
      Bufa = v32;
      if ( !v33 )
      {
        v35 = a5 & 1;
        if ( (a5 & 1) != 0 && ((a5 & 8) != 0 || !memchr(Bufa, 47, a3 - (_DWORD)Bufa)) )
          return 0;
        return v35;
      }
      v36 = (char *)memchr(v32, (a5 & 1) != 0 ? 0x2F : 0, a3 - (_DWORD)v32);
      if ( !v36 )
        v36 = (char *)a3;
      if ( v33 == 91 || (a5 & 0x20) != 0 && (v33 == 64 || v33 == 43 || v33 == 33) && *v7 == 40 )
      {
        v40 = a5;
        if ( (a5 & 1) == 0 )
          v40 = a5 & 0xFFFFFFFB;
        v41 = a4;
        v42 = v7 - 1;
        if ( Bufa < v36 )
        {
          v43 = Bufa;
          do
          {
            if ( !sub_40D250(v42, v43, a3, v41, v40) )
              return 0;
            ++v43;
            v41 = 0;
          }
          while ( v43 < v36 );
        }
        return 1;
      }
      if ( v33 == 47 )
      {
        if ( (a5 & 1) != 0 )
        {
          v37 = v32;
          if ( (unsigned int)v32 >= a3 )
            return 1;
          while ( *v37 != 47 )
          {
            if ( (unsigned int)++v37 >= a3 )
              return 1;
          }
          return (unsigned int)v37 >= a3 || *v37 != 47 || sub_40D250(v7, v37 + 1, a3, a5 & 4, a5);
        }
      }
      else if ( (a5 & 1) != 0 )
      {
        v51 = a5;
        goto LABEL_219;
      }
      v51 = a5 & 0xFFFFFFFB;
LABEL_219:
      v38 = a4;
      if ( v33 == 92 && (a5 & 2) == 0 )
        v33 = *v47;
      if ( (a5 & 0x10) != 0 && v33 < 0x80u && isupper(v33) )
        v33 = tolower(v33);
      v48 = v47 - 1;
      if ( v32 >= v36 )
        return 1;
      while ( 1 )
      {
        v39 = (a5 & 0x10) != 0 && (unsigned __int8)*v32 < 0x80u && isupper((unsigned __int8)*v32)
            ? tolower((unsigned __int8)*v32)
            : (unsigned __int8)*v32;
        if ( v39 == v33 && !sub_40D250(v48, v32, a3, v38, v51) )
          break;
        ++v32;
        v38 = 0;
        if ( v32 >= v36 )
          return 1;
      }
      return 0;
    case '/':
      if ( (a5 & 5) != 5 )
        goto LABEL_157;
      if ( Buf == (char *)a3 || v6 != *Buf )
        return 1;
      v50 = 1;
      goto LABEL_169;
    case '?':
      if ( (a5 & 0x20) != 0 && *v7 == 40 )
      {
        result = sub_40DFA0(v6, (const char *)v7, (unsigned int)Buf, a3, v8, a5);
        if ( result != -1 )
          return result;
      }
      if ( Buf == (char *)a3 || *Buf == 47 && (a5 & 1) != 0 )
        return 1;
      if ( *Buf != 46 )
        goto LABEL_169;
      v10 = !v8;
      goto LABEL_168;
    case '[':
      v11 = dword_4A7290;
      if ( !dword_4A7290 )
      {
        v11 = getenv("POSIXLY_CORRECT") != 0 ? 1 : -1;
        dword_4A7290 = v11;
      }
      if ( Buf == (char *)a3 )
        return 1;
      v12 = *Buf;
      if ( *Buf == 46 )
      {
        if ( v8 )
          return 1;
      }
      if ( v12 == 47 && (a5 & 1) != 0 )
        return 1;
      if ( *v7 == 33 || v11 < 0 && *v7 == 94 )
      {
        v52 = 1;
        ++v7;
      }
      else
      {
        v52 = 0;
      }
      v13 = a5 & 0x10;
      if ( (a5 & 0x10) != 0 && v12 < 0x80u && isupper(v12) )
        v49 = tolower((unsigned __int8)*Buf);
      else
        v49 = *Buf;
      v14 = *v7++;
      v46 = v7;
      break;
    case '\\':
      if ( (a5 & 2) != 0 )
        goto LABEL_22;
      v6 = *v7++;
      if ( !v6 )
        return 1;
      if ( (a5 & 0x10) != 0 && v6 < 0x80u && isupper(v6) )
        v6 = tolower(v6);
LABEL_22:
      if ( Buf == (char *)a3 )
        return 1;
      if ( (a5 & 0x10) != 0 && (unsigned __int8)*Buf < 0x80u && isupper((unsigned __int8)*Buf) )
        v10 = tolower((unsigned __int8)*Buf) == v6;
      else
        v10 = (unsigned __int8)*Buf == v6;
      goto LABEL_168;
    default:
LABEL_157:
      if ( Buf == (char *)a3 )
        return 1;
      if ( (a5 & 0x10) != 0 && (unsigned __int8)*Buf < 0x80u && isupper((unsigned __int8)*Buf) )
        v31 = tolower((unsigned __int8)*Buf);
      else
        v31 = (unsigned __int8)*Buf;
      v10 = v6 == v31;
      goto LABEL_168;
  }
  do
  {
    while ( (a5 & 2) != 0 || v14 != 92 )
    {
      if ( v14 == 91 )
      {
        if ( *v7 == 58 )
        {
          v20 = 0;
          v21 = v7;
          while ( 1 )
          {
            if ( v20 == 6 )
              return 1;
            v22 = *++v7;
            if ( v22 == 58 )
              break;
            if ( (unsigned __int8)(v22 - 97) > 0x18u )
              goto LABEL_114;
            v53[v20++] = v22;
          }
          if ( v7[1] == 93 )
          {
            v53[v20] = 0;
            v46 = v7 + 2;
            if ( !strcmp(v53, "alnum") && (unsigned __int8)*Buf < 0x80u && isalnum((unsigned __int8)*Buf)
              || !strcmp(v53, "alpha") && (unsigned __int8)*Buf < 0x80u && isalpha((unsigned __int8)*Buf)
              || !strcmp(v53, "blank") && (*Buf == 32 || *Buf == 9)
              || !strcmp(v53, "cntrl") && (unsigned __int8)*Buf < 0x80u && iscntrl((unsigned __int8)*Buf)
              || !strcmp(v53, "digit") && (unsigned __int8)*Buf < 0x80u && isdigit((unsigned __int8)*Buf)
              || !strcmp(v53, "graph")
              && (unsigned __int8)*Buf < 0x80u
              && isprint((unsigned __int8)*Buf)
              && !isspace((unsigned __int8)*Buf)
              || !strcmp(v53, "lower") && (unsigned __int8)*Buf < 0x80u && islower((unsigned __int8)*Buf)
              || !strcmp(v53, "print") && (unsigned __int8)*Buf < 0x80u && isprint((unsigned __int8)*Buf)
              || !strcmp(v53, "punct") && (unsigned __int8)*Buf < 0x80u && ispunct((unsigned __int8)*Buf)
              || !strcmp(v53, "space") && (unsigned __int8)*Buf < 0x80u && isspace((unsigned __int8)*Buf)
              || !strcmp(v53, "upper") && (unsigned __int8)*Buf < 0x80u && isupper((unsigned __int8)*Buf)
              || !strcmp(v53, "xdigit") && (unsigned __int8)*Buf < 0x80u && isxdigit((unsigned __int8)*Buf) )
            {
              goto LABEL_55;
            }
            v14 = *v46;
            v13 = a5 & 0x10;
            v46 = v7 + 3;
            v7 += 3;
            goto LABEL_135;
          }
LABEL_114:
          v7 = v21;
          v46 = v21;
          v14 = 91;
          goto LABEL_120;
        }
      }
      else if ( !v14 )
      {
        return 1;
      }
      if ( v13 && v14 < 0x80u && isupper(v14) )
        v14 = tolower(v14);
LABEL_120:
      v23 = *v7;
      if ( *v7 == 45 && (v24 = v7[1]) != 0 && v24 != 93 )
      {
        v25 = v49;
      }
      else
      {
        v25 = v49;
        if ( v14 == v49 )
          goto LABEL_55;
      }
      v26 = v14;
      v14 = *v7++;
      v46 = v7;
      if ( v23 != 45 )
        goto LABEL_135;
      v27 = *v7;
      if ( *v7 != 93 )
      {
        v28 = v7 + 1;
        v46 = v28;
        if ( (a5 & 2) == 0 && v27 == 92 )
        {
          v27 = *v28++;
          v46 = v28;
        }
        if ( !v27 )
          return 1;
        if ( v26 <= (int)v25 && v25 <= v27 )
          goto LABEL_55;
        v14 = *v28;
        v7 = v28 + 1;
        v46 = v7;
        goto LABEL_135;
      }
    }
    v15 = *v7;
    if ( !*v7 )
      return 1;
    if ( v13 && v15 < 0x80u && isupper(v15) )
      v14 = tolower(*v7);
    else
      v14 = *v7;
    v46 = ++v7;
    if ( v14 == v49 )
    {
LABEL_55:
      v7 = v46;
      while ( 1 )
      {
        while ( 1 )
        {
          v16 = *v7++;
          if ( !v16 )
            return 1;
          if ( (a5 & 2) != 0 || v16 != 92 )
            break;
          if ( !*v7 )
            return 1;
          ++v7;
        }
        if ( v16 != 91 )
          goto LABEL_152;
        switch ( *v7 )
        {
          case ':':
            v17 = 0;
            v18 = v7;
            do
            {
              v19 = *++v7;
              if ( ++v17 == 6 )
                return 1;
              if ( v19 == 58 && v7[1] == 93 )
                goto LABEL_151;
            }
            while ( v19 >= 0x61u && v19 < 0x7Au );
            v7 = v18;
            break;
          case '=':
            v29 = v7 + 1;
            if ( !*v29 )
              return 1;
            v7 = v29 + 1;
            if ( *v7 != 61 || v7[1] != 93 )
              return 1;
LABEL_151:
            v16 = v7[2];
            v7 += 3;
LABEL_152:
            if ( v16 == 93 )
            {
              v10 = v52 == 0;
LABEL_168:
              if ( !v10 )
                return 1;
LABEL_169:
              v6 = *v7;
              v8 = v50;
              ++Buf;
              a4 = v50;
              if ( !*v7 )
              {
                v5 = Buf;
                goto LABEL_171;
              }
              goto LABEL_3;
            }
            break;
          case '.':
            ++v7;
            while ( 1 )
            {
              v30 = *++v7;
              if ( !v30 )
                return 1;
              if ( v30 == 46 && v7[1] == 93 )
                goto LABEL_151;
            }
        }
      }
    }
LABEL_135:
    ;
  }
  while ( v14 != 93 );
  if ( v52 )
    goto LABEL_169;
  return 1;
}
// 40D250: too many cbuild loops
// 4A7290: using guessed type int dword_4A7290;
// 40D250: using guessed type char var_C[8];

//----- (0040DED0) --------------------------------------------------------
char *__cdecl sub_40DED0(int a1)
{
  char v1; // cl
  char *v2; // esi
  int v3; // eax
  char v4; // cl
  char v5; // cl

  v1 = *(_BYTE *)(a1 + 1);
  v2 = (char *)(a1 + 1);
  if ( v1 )
  {
    v3 = dword_4A7290;
    do
    {
      if ( v1 == 91 )
      {
        if ( !v3 )
        {
          v3 = getenv("POSIXLY_CORRECT") != 0 ? 1 : -1;
          dword_4A7290 = v3;
        }
        v4 = *++v2;
        if ( v4 == 33 || v3 < 0 && v4 == 94 )
          ++v2;
        v5 = *v2;
        if ( *v2 != 93 || (v5 = v2[1], ++v2, v5 != 93) )
        {
          do
          {
            ++v2;
            if ( !v5 )
              return (char *)a1;
            v5 = *v2;
          }
          while ( *v2 != 93 );
        }
      }
      else if ( (v1 == 63 || v1 == 42 || v1 == 43 || v1 == 64 || v1 == 33) && v2[1] == 40 )
      {
        v2 = (char *)sub_40DED0(v2 + 1);
        v3 = dword_4A7290;
      }
      else if ( v1 == 41 )
      {
        return v2 + 1;
      }
      v1 = *++v2;
    }
    while ( v1 );
  }
  return (char *)a1;
}
// 4A7290: using guessed type int dword_4A7290;

//----- (0040DFA0) --------------------------------------------------------
int __cdecl sub_40DFA0(int a1, const char *a2, unsigned int a3, unsigned int a4, BOOL a5, unsigned int a6)
{
  int v6; // ecx
  int v7; // esi
  int v8; // edi
  const void *v9; // ebx
  char v10; // al
  char v11; // al
  char v12; // al
  int v13; // edx
  int v14; // eax
  void *v15; // esp
  int **v16; // eax
  int v17; // eax
  void *v18; // esp
  int **v19; // ecx
  unsigned int v20; // ebx
  int result; // eax
  int *v22; // eax
  unsigned int v23; // esi
  int v24; // eax
  bool v25; // zf
  unsigned int v26; // eax
  unsigned int v27; // ecx
  BOOL v28; // eax
  unsigned int v29; // eax
  BOOL v30; // ecx
  unsigned int v31; // ebx
  int v32; // eax
  unsigned int v33; // eax
  const void *v34; // esi
  char *v35; // edi
  int *v36; // edx
  unsigned int v38; // edi
  int *v39; // esi
  int v40; // eax
  unsigned int v41; // eax
  unsigned int v42; // ecx
  BOOL v43; // eax
  int v44; // [esp+0h] [ebp-24h] BYREF
  _BYTE v45[8]; // [esp+4h] [ebp-20h] BYREF
  int v46; // [esp+Ch] [ebp-18h]
  unsigned int v47; // [esp+10h] [ebp-14h]
  int v48; // [esp+14h] [ebp-10h]
  int *v49; // [esp+18h] [ebp-Ch] BYREF
  int **i; // [esp+1Ch] [ebp-8h]

  i = &v49;
  v49 = 0;
  v47 = strlen(a2);
  v6 = dword_4A7290;
  v7 = 0;
  v8 = (int)(a2 + 1);
  v48 = 0;
  v9 = a2 + 1;
  do
  {
    v10 = *(_BYTE *)v8;
    if ( !*(_BYTE *)v8 )
      return -1;
    if ( v10 == 91 )
    {
      if ( !v6 )
      {
        v6 = getenv("POSIXLY_CORRECT") != 0 ? 1 : -1;
        dword_4A7290 = v6;
      }
      v11 = *(_BYTE *)++v8;
      if ( v11 == 33 || v6 < 0 && v11 == 94 )
        ++v8;
      v12 = *(_BYTE *)v8;
      if ( *(_BYTE *)v8 != 93 || (v12 = *(_BYTE *)(v8 + 1), ++v8, v12 != 93) )
      {
        do
        {
          ++v8;
          if ( !v12 )
            return -1;
          v12 = *(_BYTE *)v8;
        }
        while ( *(_BYTE *)v8 != 93 );
      }
    }
    else
    {
      if ( (v10 == 63 || v10 == 42 || v10 == 43 || v10 == 64 || v10 == 33) && *(_BYTE *)(v8 + 1) == 40 )
      {
        v48 = ++v7;
        goto LABEL_37;
      }
      if ( v10 == 41 )
      {
        v13 = v7--;
        v48 = v7;
        if ( v13 )
          goto LABEL_37;
        if ( a1 == 63 || a1 == 64 )
          v14 = v47 + 4;
        else
          v14 = v8 - (_DWORD)v9 + 5;
        v15 = alloca(v14);
        memcpy(v45, v9, v8 - (_DWORD)v9);
        v16 = i;
        *(_BYTE *)((char *)&v44 - (_BYTE *)v9 + v8 + 4) = 0;
        v44 = 0;
        *v16 = &v44;
        goto LABEL_36;
      }
      if ( v10 == 124 && !v7 )
      {
        if ( a1 == 63 || a1 == 64 )
          v17 = v47 + 4;
        else
          v17 = v8 - (_DWORD)v9 + 5;
        v18 = alloca(v17);
        memcpy(v45, v9, v8 - (_DWORD)v9);
        v19 = i;
        *(_BYTE *)((char *)&v44 - (_BYTE *)v9 + v8 + 4) = 0;
        v44 = 0;
        *v19 = &v44;
        v9 = (const void *)(v8 + 1);
LABEL_36:
        v6 = dword_4A7290;
        i = (int **)&v44;
        v7 = v48;
      }
    }
LABEL_37:
    v46 = ++v8;
  }
  while ( v7 >= 0 );
  switch ( a1 )
  {
    case '!':
      v38 = a3;
      if ( a3 > a4 )
        return 1;
      while ( 2 )
      {
        v39 = v49;
        if ( v49 )
        {
          v40 = a6 & 1;
          for ( i = (int **)v40; ; v40 = (int)i )
          {
            v25 = v40 == 0;
            v41 = a6;
            if ( v25 )
              v41 = a6 & 0xFFFFFFFB;
            if ( !sub_40D250(v39 + 1, a3, v38, a5, v41) )
              break;
            v39 = (int *)*v39;
            if ( !v39 )
              goto LABEL_91;
          }
          if ( v39 )
            goto LABEL_100;
        }
LABEL_91:
        v42 = a6;
        if ( (a6 & 1) == 0 )
          v42 = a6 & 0xFFFFFFFB;
        if ( v38 == a3 )
          v43 = a5;
        else
          v43 = *(_BYTE *)(v38 - 1) == 47 && (a6 & 5) == 5;
        if ( sub_40D250(v46, v38, a4, v43, v42) )
        {
LABEL_100:
          if ( ++v38 > a4 )
            return 1;
          continue;
        }
        return 0;
      }
    case '*':
      v20 = a6;
      if ( !sub_40D250(v8, a3, a4, a5, a6) )
        return 0;
      goto LABEL_42;
    case '+':
      v20 = a6;
LABEL_42:
      v22 = v49;
      v23 = a3;
      break;
    case '?':
      v31 = a6;
      result = sub_40D250(v8, a3, a4, a5, a6);
      if ( !result )
        return result;
      goto LABEL_73;
    case '@':
      v31 = a6;
LABEL_73:
      v32 = v31 & 1;
      i = (int **)v32;
      while ( 2 )
      {
        if ( !v32 )
          v31 &= ~4u;
        v33 = strlen((const char *)v8) + 1;
        v34 = (const void *)v8;
        v35 = (char *)v49 + 3;
        v36 = v49 + 1;
        while ( *++v35 )
          ;
        qmemcpy(v35, v34, v33);
        if ( !sub_40D250(v36, a3, a4, a5, v31) )
          return 0;
        v49 = (int *)*v49;
        if ( v49 )
        {
          v31 = a6;
          v8 = v46;
          v32 = (int)i;
          continue;
        }
        break;
      }
      return 1;
    default:
      return -1;
  }
  do
  {
    if ( v23 <= a4 )
    {
      v24 = v20 & 1;
      for ( i = (int **)v24; ; v24 = (int)i )
      {
        v25 = v24 == 0;
        v26 = v20;
        if ( v25 )
          v26 = v20 & 0xFFFFFFFB;
        if ( !sub_40D250(v49 + 1, a3, v23, a5, v26) )
        {
          v27 = v20;
          if ( !i )
            v27 = v20 & 0xFFFFFFFB;
          if ( v23 == a3 )
            v28 = a5;
          else
            v28 = *(_BYTE *)(v23 - 1) == 47 && (v20 & 5) == 5;
          if ( !sub_40D250(v8, v23, a4, v28, v27) )
            return 0;
          if ( v23 != a3 )
          {
            v29 = v20;
            if ( !i )
              v29 = v20 & 0xFFFFFFFB;
            v30 = *(_BYTE *)(v23 - 1) == 47 && (v20 & 5) == 5;
            if ( !sub_40D250(a2 - 1, v23, a4, v30, v29) )
              return 0;
          }
        }
        if ( ++v23 > a4 )
          break;
      }
      v23 = a3;
      v22 = v49;
    }
    v22 = (int *)*v22;
    v49 = v22;
  }
  while ( v22 );
  return 1;
}
// 40D250: using guessed type _DWORD __cdecl sub_40D250(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A7290: using guessed type int dword_4A7290;

//----- (0040E440) --------------------------------------------------------
_DWORD *__usercall sub_40E440@<eax>(_DWORD *a1@<eax>)
{
  _DWORD *v1; // esi

  v1 = a1;
  if ( !a1 )
    v1 = (_DWORD *)off_4A4FE4(332);
  v1[63] = 0;
  v1[64] = 8;
  v1[65] = 8;
  v1[66] = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(2368);
  v1[67] = 0;
  v1[68] = 8;
  v1[69] = 8;
  v1[70] = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(32);
  return v1;
}
// 4A4FE4: using guessed type int (__cdecl *off_4A4FE4)(_DWORD);

//----- (0040E4C0) --------------------------------------------------------
void __cdecl sub_40E4C0(_DWORD *a1, int a2)
{
  int v2; // esi
  bool v3; // cc
  void *v4; // [esp-4h] [ebp-144h]
  int v5; // [esp+10h] [ebp-130h]
  int v6; // [esp+14h] [ebp-12Ch]
  void *v7[74]; // [esp+18h] [ebp-128h] BYREF

  v2 = 0;
  v6 = 0;
  if ( (int)a1[63] > 0 )
  {
    v5 = 0;
    do
    {
      qmemcpy(v7, (const void *)(v5 + a1[66]), sizeof(v7));
      free(v7[2]);
      if ( v7[73] )
        free(v7[73]);
      v5 += 296;
      ++v6;
    }
    while ( v6 < a1[63] );
    v2 = 0;
  }
  if ( a1[66] )
  {
    (*(void (__cdecl **)(_DWORD))(*(_DWORD *)dword_4A80FC + 16))(a1[66]);
    a1[66] = 0;
  }
  v3 = a1[67] <= 0;
  a1[64] = 0;
  a1[63] = 0;
  if ( !v3 )
  {
    do
      sub_40E4C0(*(void **)(a1[70] + 4 * v2++), a2);
    while ( v2 < a1[67] );
  }
  if ( a1[70] )
  {
    (*(void (__cdecl **)(_DWORD))(*(_DWORD *)dword_4A80FC + 16))(a1[70]);
    a1[70] = 0;
  }
  v4 = (void *)a1[2];
  a1[68] = 0;
  a1[67] = 0;
  free(v4);
  if ( a2 )
    free(a1);
}

//----- (0040E5E0) --------------------------------------------------------
BOOL __usercall sub_40E5E0@<eax>(_BYTE *a1@<edi>, char *a2)
{
  BOOL result; // eax
  char *v4; // eax
  int v5; // edx
  _BYTE *v6; // esi
  _BYTE *v7; // ecx
  char *i; // ecx
  char *v9; // edx
  char v10; // al
  int v11; // [esp+8h] [ebp+4h]

  result = 0;
  if ( *a1 )
  {
    if ( dword_4A80F0 )
    {
      v4 = (char *)dword_4A80F4;
    }
    else
    {
      dword_4A80F0 = (int)malloc(0x400u);
      v4 = (char *)malloc(0x200u);
      dword_4A80F4 = (int)v4;
    }
    v5 = 1;
    v6 = (_BYTE *)dword_4A80F0;
    v11 = 1;
    v7 = a1;
    if ( *a1 )
    {
      do
      {
        *v6 = *v7;
        if ( *v7 == 47 || *v7 == 92 )
        {
          *v6 = 47;
          ++v5;
        }
        ++v7;
        ++v6;
      }
      while ( *v7 );
      v11 = v5;
    }
    *v6 = 0;
    for ( i = a2; *i; ++i )
      ;
    v9 = &i[v4 - a2];
    *v9 = 0;
    do
    {
      v10 = *--i;
      --v9;
      if ( v10 != 47 )
      {
        do
        {
          if ( v10 == 92 )
            break;
          if ( i <= a2 )
            break;
          --i;
          *v9 = v10;
          v10 = *i;
          --v9;
        }
        while ( *i != 47 );
      }
      *v9 = *i;
      if ( *i == 47 || *i == 92 )
        *v9 = 47;
      --v11;
    }
    while ( v11 && i > a2 );
    if ( (*v9 == 47 || *v9 == 92) && *(_BYTE *)dword_4A80F0 != 47 && *(_BYTE *)dword_4A80F0 != 92 )
      ++v9;
    return sub_40D250((unsigned __int8 *)dword_4A80F0, v9, (unsigned int)&v9[strlen(v9)], 0, 0x11u) == 0;
  }
  return result;
}
// 4A80F0: using guessed type int dword_4A80F0;
// 4A80F4: using guessed type int dword_4A80F4;

//----- (0040E700) --------------------------------------------------------
BOOL __usercall sub_40E700@<eax>(const char *a1@<eax>, const char *a2@<edx>)
{
  int v3; // ebp
  signed int v4; // edi
  signed int v5; // esi
  const char *v6; // ebx
  char v7; // bl
  BOOL result; // eax

  v3 = 0;
  if ( (*a2 == 47 || *a2 == 92) && *a1 != 47 && *a1 != 92 )
  {
    v3 = 1;
    ++a2;
  }
  v4 = strlen(a1);
  v5 = strlen(a2);
  result = 0;
  if ( v4 >= v5 )
  {
    v6 = &a1[v4 - v5];
    if ( !_stricmp(v6, a2) )
    {
      if ( v4 == v5 )
        return 1;
      if ( !v3 )
      {
        v7 = *(v6 - 1);
        if ( v7 == 47 || v7 == 92 )
          return 1;
      }
    }
  }
  return result;
}

//----- (0040E780) --------------------------------------------------------
_DWORD *__cdecl sub_40E780(int *a1, int a2, int a3, int a4)
{
  _DWORD *v4; // ebx
  int v5; // ecx
  int v6; // eax
  int v7; // ecx
  int v8; // eax
  int v9; // edi
  int *v10; // eax
  const char **v11; // esi
  char *v12; // eax
  BOOL v13; // eax
  int *v14; // eax
  int v15; // esi
  char *v16; // eax
  BOOL v18; // eax
  int v19; // eax
  const char *v21; // eax
  _DWORD *v22; // ebx
  int v23; // eax
  int v24; // ecx
  int v25; // edx
  int v26; // ecx
  int v27; // edx
  char *v28; // eax
  int v29; // eax
  int v30; // ecx
  int v31; // eax
  int v32; // eax
  int v33; // edx
  int v34; // esi
  int v35; // eax
  int *v36; // ecx
  int v37; // ebx
  char *v38; // eax
  int v40; // edx
  int v41; // eax
  int v42; // ebx
  char *v43; // eax
  int v45; // eax
  const char *v46; // eax
  int v47; // [esp-8h] [ebp-148h]
  int v48; // [esp-8h] [ebp-148h]
  int v49; // [esp-4h] [ebp-144h]
  const char *v50; // [esp-4h] [ebp-144h]
  const char *v51; // [esp-4h] [ebp-144h]
  int v52; // [esp-4h] [ebp-144h]
  int v53; // [esp+Ch] [ebp-134h]
  int v54; // [esp+Ch] [ebp-134h]
  int v55; // [esp+Ch] [ebp-134h]
  int v56; // [esp+Ch] [ebp-134h]
  _DWORD *v57; // [esp+10h] [ebp-130h]
  int v58; // [esp+10h] [ebp-130h]
  int v59; // [esp+10h] [ebp-130h]
  int v60; // [esp+10h] [ebp-130h]
  int v61; // [esp+10h] [ebp-130h]
  _DWORD *v62; // [esp+14h] [ebp-12Ch]
  int v63[74]; // [esp+18h] [ebp-128h] BYREF

  if ( (*(_WORD *)(*(_DWORD *)(a2 + 4) + 6) & 0xF000) == 0x4000 )
  {
    if ( a1 )
    {
      v57 = (_DWORD *)a1[2];
      if ( !v57 )
      {
        v50 = *(const char **)a2;
        v47 = *a1;
        v21 = (const char *)sub_473493((int)&unk_4826AC);
        sub_4079F0(v21, v47, v50);
        return 0;
      }
      v4 = sub_40E440(0);
      *v4 = a4;
      v4[2] = _strdup(*(const char **)a2);
      v4[1] = v57;
      qmemcpy(v4 + 3, v57 + 3, 0xECu);
      v4[77] = v57[77];
      v4[78] = v57[78];
      v4[79] = v57[79];
      v4[82] = v57[82];
      v4[80] = v57[80];
      v4[81] = 0;
      v4[71] = *(_WORD *)(*(_DWORD *)(a2 + 4) + 6) & 0x1FF;
      v4[72] = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 24);
      v4[73] = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 28);
      v4[74] = *(__int16 *)(*(_DWORD *)(a2 + 4) + 10);
      v4[75] = *(__int16 *)(*(_DWORD *)(a2 + 4) + 12);
      *((_BYTE *)v4 + 248) = 0;
      v5 = v57[68];
      if ( v57[67] == v5 )
      {
        v6 = v5 + v57[69];
        v7 = v57[70];
        v57[68] = v6;
        v49 = 4 * v6;
        if ( v7 )
          v8 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v7, v49);
        else
          v8 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(v49);
        v57[70] = v8;
      }
      v9 = a4;
      *(_DWORD *)(v57[70] + 4 * v57[67]++) = v4;
      ++*(_DWORD *)(a4 + 580);
      v4[76] = 1;
      v10 = *(int **)(a4 + 572);
      if ( v10 )
      {
        v58 = 0;
        if ( *v10 > 0 )
        {
          v53 = 0;
          do
          {
            v11 = (const char **)(v53 + *(_DWORD *)(*(_DWORD *)(v9 + 572) + 12));
            if ( v11[4] )
            {
              v12 = sub_40F030((int)v4, 1);
              if ( v11[5] )
              {
                v13 = sub_40E5E0(*v11, v12);
                v9 = a4;
              }
              else
              {
                v13 = sub_40E700(v12, *v11);
              }
              if ( v13 )
                v4[80] = v11[1] == 0;
            }
            v53 += 36;
            ++v58;
          }
          while ( v58 < **(_DWORD **)(v9 + 572) );
        }
      }
      if ( !*((_BYTE *)v4 + 248) )
      {
        v14 = *(int **)(a4 + 568);
        if ( v14 )
        {
          v59 = 0;
          if ( *v14 > 0 )
          {
            v54 = 0;
            do
            {
              v15 = v54 + *(_DWORD *)(*(_DWORD *)(a4 + 568) + 12);
              if ( *(_DWORD *)(v15 + 16) )
              {
                v16 = sub_40F030((int)v4, 1);
                if ( *(_DWORD *)(v15 + 20) ? sub_40E5E0(*(_BYTE **)v15, v16) : sub_40E700(v16, *(const char **)v15) )
                {
                  if ( *(_DWORD *)(v15 + 4) )
                  {
                    if ( *(_DWORD *)(v15 + 8) )
                    {
                      v4[79] = 1;
                      v4[78] = 0;
                    }
                    else
                    {
                      v4[79] = 0;
                    }
                    if ( *(_DWORD *)(v15 + 12) )
                      v4[78] = 1;
                    else
                      v4[77] = 1;
                  }
                  else
                  {
                    v4[77] = 0;
                    v4[78] = 0;
                    v4[79] = 0;
                  }
                  v4[82] = v59;
                }
              }
              v54 += 36;
              ++v59;
            }
            while ( v59 < **(_DWORD **)(a4 + 568) );
          }
        }
      }
      v18 = v4[80] == 0;
      v4[81] = v18;
      if ( v18 )
      {
        v19 = v4[1];
        if ( v19 )
        {
          while ( !*(_DWORD *)(v19 + 324) )
          {
            *(_DWORD *)(v19 + 324) = 1;
            v19 = *(_DWORD *)(v19 + 4);
            if ( !v19 )
              return v4;
          }
        }
      }
    }
    else
    {
      v4 = (_DWORD *)(a4 + 236);
      *(_DWORD *)(a4 + 236) = a4;
      *(_DWORD *)(a4 + 244) = _strdup(*(const char **)a2);
      *(_DWORD *)(a4 + 240) = 0;
      *(_DWORD *)(a4 + 552) = 0;
      *(_DWORD *)(a4 + 556) = 0;
      *(_DWORD *)(a4 + 564) = -1;
      *(_DWORD *)(a4 + 544) = 1;
      *(_DWORD *)(a4 + 548) = 1;
      *(_DWORD *)(a4 + 560) = 1;
      *(_DWORD *)(a4 + 520) = *(_WORD *)(*(_DWORD *)(a2 + 4) + 6) & 0x1FF;
      *(_DWORD *)(a4 + 524) = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 24);
      *(_DWORD *)(a4 + 528) = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 28);
      *(_DWORD *)(a4 + 532) = *(__int16 *)(*(_DWORD *)(a2 + 4) + 10);
      *(_DWORD *)(a4 + 536) = *(__int16 *)(*(_DWORD *)(a2 + 4) + 12);
      *(_BYTE *)(a4 + 484) = 0;
      *(_DWORD *)(a4 + 248) = -1;
      *(_DWORD *)(a4 + 252) = -1;
      *(_DWORD *)(a4 + 256) = -1;
      *(_DWORD *)(a4 + 260) = -1;
    }
    return v4;
  }
  else
  {
    v22 = (_DWORD *)a1[2];
    v62 = v22;
    v51 = *(const char **)a2;
    if ( !v22 )
    {
      v48 = *a1;
      v46 = (const char *)sub_473493((int)&unk_4826D0);
      sub_407850(v46, v48, v51);
    }
    v63[0] = a4;
    v63[2] = (int)_strdup(v51);
    v23 = *(_DWORD *)(a2 + 4);
    v24 = *(_DWORD *)(v23 + 24);
    v63[3] = *(unsigned __int16 *)(v23 + 6);
    v25 = *(_DWORD *)(v23 + 28);
    v63[4] = v24;
    v26 = *(__int16 *)(v23 + 10);
    v63[5] = v25;
    v27 = *(__int16 *)(v23 + 12);
    v63[6] = v26;
    v63[7] = v27;
    v63[1] = (int)v22;
    qmemcpy(&v63[12], v22 + 3, 0xECu);
    LOBYTE(v63[71]) = 0;
    v63[9] = 0;
    v63[10] = 0;
    v28 = sub_40F160((int)v63);
    if ( sub_409910(v28) )
      v63[9] = 1;
    v63[73] = 0;
    v29 = v22[64];
    v63[11] = v22[80];
    if ( v22[63] == v29 )
    {
      v30 = v22[66];
      v31 = v22[65] + v29;
      v22[64] = v31;
      v52 = 296 * v31;
      if ( v30 )
        v32 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v30, v52);
      else
        v32 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(v52);
      v22[66] = v32;
    }
    qmemcpy((void *)(v22[66] + 296 * v22[63]), v63, 0x128u);
    v33 = v22[66];
    ++v22[63];
    v34 = 296 * v22[63] + v33 - 296;
    v35 = a4;
    ++*(_DWORD *)(a4 + 580);
    *(_DWORD *)(v34 + 32) = 1;
    v36 = *(int **)(a4 + 572);
    if ( v36 )
    {
      v60 = 0;
      if ( *v36 > 0 )
      {
        v55 = 0;
        while ( 1 )
        {
          v37 = v55 + *(_DWORD *)(*(_DWORD *)(v35 + 572) + 12);
          if ( !*(_DWORD *)(v37 + 16) )
          {
            v38 = sub_40F160(v34);
            if ( *(_DWORD *)(v37 + 20) ? sub_40E5E0(*(_BYTE **)v37, v38) : sub_40E700(v38, *(const char **)v37) )
              *(_DWORD *)(v34 + 44) = *(_DWORD *)(v37 + 4) == 0;
          }
          v55 += 36;
          if ( ++v60 >= **(_DWORD **)(a4 + 572) )
            break;
          v35 = a4;
        }
      }
    }
    if ( !*(_BYTE *)(v34 + 284) && *(_DWORD *)(a4 + 568) )
    {
      v40 = v62[77];
      if ( (v40 || v62[78]) && !v62[79] )
        v41 = 0;
      else
        v41 = v62[82] + 1;
      if ( v62[79] )
      {
        *(_DWORD *)(v34 + 36) = v40;
        *(_DWORD *)(v34 + 40) = v62[78];
      }
      v61 = v41;
      if ( v41 < **(_DWORD **)(a4 + 568) )
      {
        v56 = 36 * v41;
        do
        {
          v42 = v56 + *(_DWORD *)(*(_DWORD *)(a4 + 568) + 12);
          if ( !*(_DWORD *)(v42 + 16) )
          {
            v43 = sub_40F160(v34);
            if ( *(_DWORD *)(v42 + 20) ? sub_40E5E0(*(_BYTE **)v42, v43) : sub_40E700(v43, *(const char **)v42) )
            {
              if ( *(_DWORD *)(v42 + 4) )
              {
                *(_DWORD *)(v34 + 36) = *(_DWORD *)(v42 + 12) == 0;
                *(_DWORD *)(v34 + 40) = *(_DWORD *)(v42 + 12);
              }
              else
              {
                *(_DWORD *)(v34 + 36) = 0;
                *(_DWORD *)(v34 + 40) = 0;
              }
            }
          }
          v56 += 36;
          ++v61;
        }
        while ( v61 < **(_DWORD **)(a4 + 568) );
      }
    }
    if ( !*(_DWORD *)(v34 + 44) && !v62[81] )
    {
      v45 = v62[1];
      for ( v62[81] = 1; v45; v45 = *(_DWORD *)(v45 + 4) )
      {
        if ( *(_DWORD *)(v45 + 324) )
          break;
        *(_DWORD *)(v45 + 324) = 1;
      }
    }
    if ( *(_DWORD *)(v34 + 44) )
    {
      ++*(_DWORD *)(a4 + 592);
      return *(_DWORD **)(a2 + 8);
    }
    else if ( *(_DWORD *)(v34 + 40) )
    {
      ++*(_DWORD *)(a4 + 596);
      return *(_DWORD **)(a2 + 8);
    }
    else
    {
      if ( *(_DWORD *)(v34 + 36) )
        ++*(_DWORD *)(a4 + 584);
      else
        ++*(_DWORD *)(a4 + 588);
      return *(_DWORD **)(a2 + 8);
    }
  }
}

//----- (0040EF40) --------------------------------------------------------
char __cdecl sub_40EF40(char *a1, int a2)
{
  int v2; // ebp
  int v3; // esi
  int i; // ebx
  const char **v5; // eax

  v2 = **(_DWORD **)(a2 + 576);
  v3 = 0;
  if ( v2 <= 0 )
    return 1;
  for ( i = 0; ; i += 36 )
  {
    v5 = (const char **)(i + *(_DWORD *)(*(_DWORD *)(a2 + 576) + 12));
    if ( v5[5] ? sub_40E5E0(*v5, a1) : sub_40E700(a1, *v5) )
      break;
    if ( ++v3 >= v2 )
      return 1;
  }
  return 0;
}

//----- (0040EFB0) --------------------------------------------------------
_DWORD *__usercall sub_40EFB0@<eax>(_DWORD *a1@<eax>)
{
  _DWORD *v1; // esi

  v1 = a1;
  if ( !a1 )
    v1 = (_DWORD *)off_4A4FE4(600);
  memset(v1, 0, 0x258u);
  *v1 = -1;
  v1[1] = -1;
  v1[2] = -1;
  v1[3] = -1;
  sub_40E440(v1 + 59);
  return v1;
}
// 4A4FE4: using guessed type int (__cdecl *off_4A4FE4)(_DWORD);

//----- (0040F000) --------------------------------------------------------
int __cdecl sub_40F000(int a1, const char *a2)
{
  const char *v2; // eax

  v2 = (const char *)sub_473493((int)&unk_4826F0);
  sub_4079F0(v2);
  return sub_408110(
           a2,
           62,
           (int (__cdecl *)(const char **, char **, int, int))sub_40E780,
           (unsigned __int8 (__cdecl *)(char *, int))sub_40EF40,
           a1);
}

//----- (0040F030) --------------------------------------------------------
char *__cdecl sub_40F030(int a1, int a2)
{
  int v2; // eax
  char *v3; // ecx
  char *v4; // edx
  char v5; // al
  char v7; // al

  v2 = *(_DWORD *)(a1 + 4);
  if ( v2 )
  {
    sub_40F030(v2, a2);
    if ( byte_4A7698[0] )
    {
      v7 = byte_4A7697[strlen(byte_4A7698)];
      if ( v7 != 92 && v7 != 9007 )
        *(_WORD *)&byte_4A7698[strlen(byte_4A7698)] = 92;
    }
    qmemcpy(
      &byte_4A7698[strlen(byte_4A7698)],
      *(const void **)(a1 + 8),
      *(_DWORD *)(a1 + 8) + strlen(*(const char **)(a1 + 8)) + 1 - *(_DWORD *)(a1 + 8));
    return byte_4A7698;
  }
  else if ( a2 )
  {
    v3 = *(char **)(a1 + 8);
    v4 = byte_4A7698;
    do
    {
      v5 = *v3;
      *v4++ = *v3++;
    }
    while ( v5 );
    return byte_4A7698;
  }
  else
  {
    byte_4A7698[0] = 0;
    return byte_4A7698;
  }
}

//----- (0040F100) --------------------------------------------------------
char *__usercall sub_40F100@<eax>(char *a1@<eax>)
{
  int v1; // edx
  char v2; // cl
  char v3; // al

  v1 = byte_4A7298 - a1;
  do
  {
    v2 = *a1;
    a1[v1] = *a1;
    ++a1;
  }
  while ( v2 );
  v3 = byte_4A7297[strlen(byte_4A7298)];
  if ( v3 != 92 && v3 != 47 )
    *(_WORD *)&byte_4A7298[strlen(byte_4A7298)] = 92;
  return byte_4A7298;
}

//----- (0040F160) --------------------------------------------------------
char *__usercall sub_40F160@<eax>(int a1@<esi>)
{
  char *v1; // eax
  char v2; // cl
  const char *v3; // eax
  char *v5; // ecx
  char *v6; // edx
  char v7; // al
  char *v8; // [esp-8h] [ebp-8h]
  int v9; // [esp-4h] [ebp-4h]

  v1 = sub_40F030(*(_DWORD *)(a1 + 4), 1);
  if ( *v1 )
  {
    v2 = v1[strlen(v1) - 1];
    if ( v2 == 92 || v2 == 47 )
    {
      v9 = *(_DWORD *)(a1 + 8);
      v8 = v1;
      v3 = (const char *)sub_473493((int)&unk_48270C);
    }
    else
    {
      v9 = *(_DWORD *)(a1 + 8);
      v8 = v1;
      v3 = (const char *)sub_473493((int)&unk_479DA0);
    }
    sprintf(byte_4A7498, v3, v8, v9);
    return byte_4A7498;
  }
  else
  {
    v5 = *(char **)(a1 + 8);
    v6 = byte_4A7498;
    do
    {
      v7 = *v5;
      *v6++ = *v5++;
    }
    while ( v7 );
    return byte_4A7498;
  }
}

//----- (0040F1F0) --------------------------------------------------------
int __cdecl sub_40F1F0(_DWORD *a1, int (__cdecl *a2)(int, int, bool, int), int (__cdecl *a3)(_DWORD, int, int), int a4)
{
  int result; // eax
  int v5; // esi
  int v6; // esi
  int v7; // ebx
  int v8; // ecx

  result = 1;
  v5 = 0;
  do
  {
    if ( v5 >= a1[67] )
      break;
    if ( a3 )
    {
      result = a3(*(_DWORD *)(a1[70] + 4 * v5), a4, 0);
      if ( !result )
        break;
    }
    result = sub_40F1F0(*(_DWORD *)(a1[70] + 4 * v5), a2, a3, a4);
    if ( a3 )
    {
      result = a3(*(_DWORD *)(a1[70] + 4 * v5), a4, 1);
      if ( !result )
        break;
    }
    ++v5;
  }
  while ( result );
  v6 = 0;
  if ( result )
  {
    v7 = 0;
    do
    {
      v8 = a1[63];
      if ( v6 >= v8 )
        break;
      result = a2(v7 + a1[66], v6, v6 == v8 - 1, a4);
      ++v6;
      v7 += 296;
    }
    while ( result );
  }
  return result;
}

//----- (0040F2B0) --------------------------------------------------------
char *__usercall sub_40F2B0@<eax>(const char *a1@<eax>)
{
  char *v2; // edi
  signed int v3; // esi
  char v4; // al
  char *v5; // esi
  intptr_t v6; // ebx

  v2 = (char *)malloc(strlen(a1) + 3);
  strcpy(v2, a1);
  v3 = strlen(v2) - 1;
  if ( v3 >= 0 )
  {
    v4 = v2[v3];
    if ( v4 == 47 || v4 == 92 && !IsDBCSLeadByte(v2[v3 - 1]) )
      v2[v3] = 0;
  }
  strcat(v2, "/*");
  v5 = (char *)malloc(0x230u);
  *((_WORD *)v5 + 2) = 0;
  *((_WORD *)v5 + 3) = 0;
  *((_DWORD *)v5 + 72) = _strdup(a1);
  v6 = _findfirst32(v2, (struct _finddata32_t *)(v5 + 8));
  if ( v6 >= 0 )
    goto LABEL_9;
  if ( *_errno() == 2 )
  {
    *((_WORD *)v5 + 3) = 1;
LABEL_9:
    *(_DWORD *)v5 = v6;
    free(v2);
    return v5;
  }
  return 0;
}

//----- (0040F3A0) --------------------------------------------------------
int __usercall sub_40F3A0@<eax>(int a1@<esi>)
{
  int result; // eax

  if ( !a1 || *(_WORD *)(a1 + 6) )
    return 0;
  if ( *(_WORD *)(a1 + 4) && _findnext32(*(_DWORD *)a1, (struct _finddata32_t *)(a1 + 8)) < 0 )
  {
    *(_WORD *)(a1 + 6) = 1;
    return 0;
  }
  ++*(_WORD *)(a1 + 4);
  strncpy((char *)(a1 + 302), (const char *)(a1 + 28), 0x101u);
  result = a1 + 292;
  *(_DWORD *)(a1 + 292) = 1;
  *(_WORD *)(a1 + 300) = strlen((const char *)(a1 + 302));
  *(_DWORD *)(a1 + 296) = *(__int16 *)(a1 + 4);
  return result;
}

//----- (0040F420) --------------------------------------------------------
int sub_40F420()
{
  int v0; // ebp
  const char *v1; // esi
  const char *v2; // eax
  int v3; // eax
  SOCKET v4; // esi
  const char **v5; // edi
  char *v6; // eax
  const char *v7; // eax
  const char *v8; // eax
  const char *v10; // eax
  int v11; // [esp-Ch] [ebp-130h]
  int v12; // [esp-8h] [ebp-12Ch]
  int v13; // [esp-4h] [ebp-128h]
  int v14; // [esp+10h] [ebp-114h] BYREF
  int v15; // [esp+14h] [ebp-110h] BYREF
  int v16; // [esp+18h] [ebp-10Ch] BYREF
  int v17; // [esp+1Ch] [ebp-108h] BYREF
  char Buffer[256]; // [esp+20h] [ebp-104h] BYREF

  v15 = 0;
  v16 = 0;
  v14 = 0;
  v17 = 0;
  v0 = 0;
  v1 = (const char *)sub_473493((int)&unk_482718);
  v2 = (const char *)sub_473493((int)&unk_482730);
  sprintf(Buffer, v2, &unk_482774, 12000200, &unk_47623C);
  v3 = sub_472937(v1, Buffer);
  v4 = v3;
  v5 = 0;
  if ( v3 == -1 )
    goto LABEL_16;
  v6 = sub_47270A(v3);
  if ( v6 )
  {
    if ( *v6 )
      v5 = (const char **)sub_472882(v6);
    else
      free(v6);
  }
  closesocket(v4);
  if ( !v5 )
    goto LABEL_16;
  v7 = (const char *)sub_473493((int)&unk_482778);
  if ( sscanf(v5[5], v7, &v15, &v16, &v14, &v17) >= 3 )
    v0 = 1;
  free(v5);
  if ( !v0 )
  {
LABEL_16:
    v10 = (const char *)sub_473493((int)&unk_482808);
    return printf(v10);
  }
  if ( v14 + 100 * (v16 + 100 * v15) <= 120002 )
  {
    v10 = (const char *)sub_473493((int)&unk_4827E4);
    return printf(v10);
  }
  v13 = v14;
  v12 = v16;
  if ( v15 == 12 )
  {
    v11 = 12;
    v8 = (const char *)sub_473493((int)&unk_4827B8);
  }
  else
  {
    v11 = v15;
    v8 = (const char *)sub_473493((int)&unk_482788);
  }
  return printf(v8, v11, v12, v13);
}

//----- (0040F590) --------------------------------------------------------
int __cdecl array_init(int a1)
{
  _DWORD *v1; // eax

  v1 = emalloc(40);
  *(_DWORD *)a1 = v1;
  zend_hash_init((int)v1, 0, 0, (int)zval_ptr_dtor, 0);
  *(_BYTE *)(a1 + 8) = 4;
  return 0;
}

//----- (0040F5C0) --------------------------------------------------------
char __cdecl zval_ptr_dtor(int *a1)
{
  int v1; // eax
  __int16 v2; // cx

  --*(_WORD *)(*a1 + 10);
  v1 = *a1;
  v2 = *(_WORD *)(*a1 + 10);
  if ( v2 )
  {
    if ( v2 == 1 && *(_BYTE *)(v1 + 8) != 5 )
      *(_BYTE *)(v1 + 9) = 0;
  }
  else
  {
    LOBYTE(v1) = zval_dtor(*a1);
    if ( *a1 != dword_4AAFD8 )
      LOBYTE(v1) = efree(*a1);
  }
  return v1;
}
// 4AAFD8: using guessed type int dword_4AAFD8;

//----- (0040F610) --------------------------------------------------------
int zend_register_ini_entries()
{
  return 0;
}

//----- (0040F620) --------------------------------------------------------
char zend_is_executing()
{
  return 0;
}

//----- (0040F630) --------------------------------------------------------
const char *zend_ini_string()
{
  return byte_47627C;
}

//----- (0040F650) --------------------------------------------------------
int __cdecl zend_register_extension(const void *a1, int a2)
{
  int Src[26]; // [esp+8h] [ebp-68h] BYREF

  qmemcpy(Src, a1, sizeof(Src));
  Src[24] = a2;
  zend_llist_add_element((int)&zend_extensions, Src);
  return 0;
}

//----- (0040F690) --------------------------------------------------------
BOOL __cdecl sub_40F690(int a1)
{
  int (__cdecl *v1)(int); // eax

  v1 = *(int (__cdecl **)(int))(a1 + 20);
  return v1 && v1(a1);
}

//----- (0040F6D0) --------------------------------------------------------
int (__cdecl *__cdecl sub_40F6D0(int a1, int a2))(int)
{
  int (__cdecl *result)(int); // eax

  result = *(int (__cdecl **)(int))(a1 + 60);
  if ( result )
    return (int (__cdecl *)(int))result(a2);
  return result;
}

//----- (0040F6F0) --------------------------------------------------------
int __cdecl init_op_array(int a1, char a2, int a3)
{
  int v3; // edi
  _DWORD *v4; // eax

  *(_BYTE *)a1 = a2;
  *(_DWORD *)(a1 + 56) = 0;
  v3 = 0x2000;
  if ( !dword_4AB3DC )
    v3 = a3;
  v4 = emalloc(4);
  *(_DWORD *)(a1 + 12) = v4;
  *v4 = 1;
  *(_DWORD *)(a1 + 24) = v3;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 16) = erealloc(0, 88 * v3, 0);
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 64) = zend_get_compiled_filename();
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = -1;
  *(_DWORD *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 44) = 0;
  *(_BYTE *)(a1 + 60) = 0;
  *(_BYTE *)(a1 + 61) = 0;
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 68) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 76) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  return zend_llist_apply_with_argument((_DWORD **)&zend_extensions, (int (__cdecl *)(_DWORD *, int))sub_40F6B0, a1);
}
// 40F6B0: using guessed type int sub_40F6B0();
// 4AB3DC: using guessed type int dword_4AB3DC;

//----- (0040F790) --------------------------------------------------------
_DWORD *__cdecl destroy_zend_function(_BYTE *a1)
{
  _DWORD *result; // eax

  result = (_DWORD *)((unsigned __int8)*a1 - 2);
  if ( *a1 == 2 )
    return destroy_op_array((int)a1);
  return result;
}

//----- (0040F7B0) --------------------------------------------------------
void __cdecl destroy_zend_class(int a1)
{
  if ( (int)--**(_DWORD **)(a1 + 16) <= 0 )
  {
    if ( *(_BYTE *)a1 == 1 )
    {
      free(*(void **)(a1 + 4));
      free(*(void **)(a1 + 16));
    }
    else
    {
      if ( *(_BYTE *)a1 != 2 )
        return;
      efree(*(_DWORD *)(a1 + 4));
      efree(*(_DWORD *)(a1 + 16));
    }
    zend_hash_destroy((void *)(a1 + 24));
    zend_hash_destroy((void *)(a1 + 64));
  }
}

//----- (0040F810) --------------------------------------------------------
_DWORD *__cdecl destroy_op_array(int a1)
{
  unsigned int v1; // esi
  unsigned int v2; // ebx
  _DWORD *result; // eax

  v1 = *(_DWORD *)(a1 + 16);
  v2 = v1 + 88 * *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 48) )
  {
    zend_hash_destroy(*(void **)(a1 + 48));
    efree(*(_DWORD *)(a1 + 48));
  }
  result = *(_DWORD **)(a1 + 12);
  --*result;
  if ( !**(_DWORD **)(a1 + 12) )
  {
    efree(*(_DWORD *)(a1 + 12));
    for ( ; v1 < v2; v1 += 88 )
    {
      if ( *(_DWORD *)(v1 + 32) == 1 )
        zval_dtor(v1 + 40);
      if ( *(_DWORD *)(v1 + 56) == 1 )
        zval_dtor(v1 + 64);
    }
    efree(*(_DWORD *)(a1 + 16));
    if ( *(_DWORD *)(a1 + 8) )
      efree(*(_DWORD *)(a1 + 8));
    if ( *(_DWORD *)(a1 + 4) )
      efree(*(_DWORD *)(a1 + 4));
    result = *(_DWORD **)(a1 + 32);
    if ( result )
      result = (_DWORD *)efree(*(_DWORD *)(a1 + 32));
    if ( *(_BYTE *)(a1 + 61) )
      return (_DWORD *)zend_llist_apply_with_argument(
                         (_DWORD **)&zend_extensions,
                         (int (__cdecl *)(_DWORD *, int))sub_40F6D0,
                         a1);
  }
  return result;
}

//----- (0040F8F0) --------------------------------------------------------
_DWORD *__usercall sub_40F8F0@<eax>(_DWORD *a1@<edi>)
{
  unsigned int v1; // esi
  unsigned int v2; // eax
  int v3; // eax
  int v4; // ecx
  int v5; // eax
  _DWORD *result; // eax

  v1 = a1[5];
  a1[5] = v1 + 1;
  v2 = a1[6];
  if ( v1 >= v2 )
  {
    if ( dword_4AB3DC )
    {
      v3 = sub_473493((int)&unk_482850);
      zend_printf(v3);
      zend_bailout((int)byte_47627C, 0);
    }
    v4 = a1[4];
    v5 = 4 * v2;
    a1[6] = v5;
    a1[4] = erealloc(v4, 88 * v5, 0);
  }
  result = (_DWORD *)(a1[4] + 88 * v1);
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  result[5] = 0;
  result[6] = 0;
  result[7] = 0;
  result[21] = dword_4AB35C;
  result[2] = 8;
  result[20] = 0;
  result[8] = 0;
  result[9] = 0;
  result[10] = 0;
  result[11] = 0;
  result[12] = 0;
  result[13] = 0;
  result[14] = 0;
  result[15] = 0;
  result[16] = 0;
  result[17] = 0;
  result[18] = 0;
  result[19] = 0;
  return result;
}
// 4AAEB4: using guessed type int (__cdecl *zend_printf)(_DWORD);
// 4AB35C: using guessed type int dword_4AB35C;
// 4AB3DC: using guessed type int dword_4AB3DC;

//----- (0040F9A0) --------------------------------------------------------
unsigned int __thiscall sub_40F9A0(_DWORD *this)
{
  unsigned int result; // eax
  unsigned int v2; // edx
  _BYTE *v3; // ecx

  result = this[4];
  v2 = result + 88 * this[5];
  if ( result < v2 )
  {
    v3 = (_BYTE *)(result + 88);
    do
    {
      if ( *(_BYTE *)result == 101 )
      {
        if ( (unsigned int)v3 >= v2 || *v3 == 101 )
          *(_BYTE *)result = 0;
        else
          *(_DWORD *)(result + 84) = *(_DWORD *)(result + 172);
      }
      result += 88;
      v3 += 88;
    }
    while ( result < v2 );
  }
  return result;
}

//----- (0040F9E0) --------------------------------------------------------
int (__cdecl *__cdecl sub_40F9E0(int a1, int a2))(int)
{
  int (__cdecl *result)(int); // eax

  result = *(int (__cdecl **)(int))(a1 + 40);
  if ( result )
    return (int (__cdecl *)(int))result(a2);
  return result;
}

//----- (0040FA00) --------------------------------------------------------
int __usercall sub_40FA00@<eax>(int a1@<esi>)
{
  unsigned int v1; // eax
  unsigned int i; // ecx
  _DWORD *v3; // eax
  int v4; // edx

  if ( *(_BYTE *)a1 == 2 || *(_BYTE *)a1 == 4 )
  {
    if ( byte_4AB3B8 )
      sub_40F9A0((_DWORD *)a1);
    if ( byte_4AB3B9 )
      zend_llist_apply_with_argument((_DWORD **)&zend_extensions, (int (__cdecl *)(_DWORD *, int))sub_40F9E0, a1);
    v1 = *(_DWORD *)(a1 + 16);
    for ( i = v1 + 88 * *(_DWORD *)(a1 + 20); v1 < i; v1 += 88 )
    {
      if ( *(_DWORD *)(v1 + 32) == 1 )
      {
        *(_BYTE *)(v1 + 49) = 1;
        *(_WORD *)(v1 + 50) = 2;
      }
      if ( *(_DWORD *)(v1 + 56) == 1 )
      {
        *(_BYTE *)(v1 + 73) = 1;
        *(_WORD *)(v1 + 74) = 2;
      }
    }
    v3 = erealloc(*(_DWORD *)(a1 + 16), 88 * *(_DWORD *)(a1 + 20), 0);
    v4 = *(_DWORD *)(a1 + 20);
    *(_BYTE *)(a1 + 61) = 1;
    *(_DWORD *)(a1 + 16) = v3;
    *(_DWORD *)(a1 + 24) = v4;
  }
  return 0;
}
// 4AB3B8: using guessed type char byte_4AB3B8;
// 4AB3B9: using guessed type char byte_4AB3B9;

//----- (0040FAA0) --------------------------------------------------------
int __usercall sub_40FAA0@<eax>(int a1@<eax>, int a2@<ebx>, _DWORD *a3, double *a4)
{
  int v5; // edi
  char v6; // al
  double *v8; // eax
  char *v9; // [esp+34h] [ebp-14h] BYREF
  int v10; // [esp+38h] [ebp-10h]
  char *EndPtr; // [esp+3Ch] [ebp-Ch] BYREF
  double X; // [esp+40h] [ebp-8h]

  v5 = 10;
  if ( !a2 )
    return 0;
  if ( a2 >= 2 && *(_BYTE *)a1 == 48 )
  {
    v6 = *(_BYTE *)(a1 + 1);
    if ( v6 == 120 || v6 == 88 )
      v5 = 16;
  }
  *_errno() = 0;
  v10 = strtol((const char *)a1, &v9, v5);
  if ( *_errno() == 34 )
  {
    v9 = 0;
LABEL_13:
    if ( v5 == 16 )
      return 0;
    *_errno() = 0;
    X = strtod((const char *)a1, &EndPtr);
    if ( *_errno() != 34 )
    {
      if ( EndPtr == (char *)(a2 + a1) )
      {
        if ( _finite(X) )
        {
          v8 = a4;
          if ( !a4 )
            return 2;
LABEL_18:
          *v8 = X;
          return 2;
        }
        return 0;
      }
      if ( EndPtr > v9 )
      {
        v8 = a4;
        if ( a4 )
          goto LABEL_18;
      }
    }
    if ( v9 && a3 )
    {
      *a3 = v10;
      return 1;
    }
    return 0;
  }
  if ( v9 != (char *)(a1 + a2) )
    goto LABEL_13;
  if ( a3 )
    *a3 = v10;
  return 1;
}

//----- (0040FBC0) --------------------------------------------------------
unsigned int __cdecl convert_scalar_to_number(int a1)
{
  unsigned int result; // eax
  char (*v2)[4]; // edi

  result = *(unsigned __int8 *)(a1 + 8);
  switch ( *(_BYTE *)(a1 + 8) )
  {
    case 0:
      *(_DWORD *)a1 = 0;
      goto LABEL_10;
    case 3:
      v2 = *(char (**)[4])a1;
      result = sub_40FAA0(*(_DWORD *)a1, *(_DWORD *)(a1 + 4), (_DWORD *)a1, (double *)a1);
      *(_BYTE *)(a1 + 8) = result;
      if ( !(_BYTE)result || (unsigned __int8)result > 2u )
      {
        result = strtol(*(const char **)a1, 0, 10);
        *(_DWORD *)a1 = result;
        *(_BYTE *)(a1 + 8) = 1;
      }
      if ( v2 )
      {
        if ( v2 != empty_string )
          result = efree((int)v2);
      }
      break;
    case 6:
LABEL_10:
      *(_BYTE *)(a1 + 8) = 1;
      break;
    case 7:
      result = zend_list_delete(*(_DWORD *)a1);
      *(_BYTE *)(a1 + 8) = 1;
      break;
    default:
      return result;
  }
  return result;
}
// 4954CC: using guessed type char (*empty_string)[4];

//----- (0040FC70) --------------------------------------------------------
int __cdecl zend_str_tolower(_BYTE *a1, int a2)
{
  int result; // eax
  _BYTE *i; // esi

  result = a2;
  for ( i = a1; i < &a1[a2]; ++i )
  {
    result = tolower((char)*i);
    *i = result;
  }
  return result;
}

//----- (0040FCA0) --------------------------------------------------------
char __cdecl convert_to_long(int a1)
{
  return convert_to_long_base(a1, 10);
}

//----- (0040FCB0) --------------------------------------------------------
char __cdecl convert_to_long_base(int a1, int Radix)
{
  int v2; // eax
  double v3; // st7
  char (*v4)[4]; // edi
  int v5; // eax
  BOOL v6; // edi
  char *v7; // eax

  LOBYTE(v2) = *(_BYTE *)(a1 + 8);
  switch ( (char)v2 )
  {
    case 0:
      goto LABEL_11;
    case 1:
    case 6:
      goto LABEL_12;
    case 2:
      v3 = *(double *)a1;
      *(_BYTE *)(a1 + 8) = 1;
      v2 = (__int64)v3;
      *(_DWORD *)a1 = v2;
      return v2;
    case 3:
      v4 = *(char (**)[4])a1;
      v2 = strtol(*(const char **)a1, 0, Radix);
      *(_DWORD *)a1 = v2;
      if ( !v4 || v4 == empty_string )
        goto LABEL_12;
      LOBYTE(v2) = efree((int)v4);
      *(_BYTE *)(a1 + 8) = 1;
      break;
    case 4:
      v5 = zend_hash_num_elements(*(_DWORD *)a1);
      goto LABEL_8;
    case 5:
      v5 = zend_hash_num_elements(*(_DWORD *)(a1 + 4));
LABEL_8:
      v6 = v5 != 0;
      LOBYTE(v2) = zval_dtor(a1);
      *(_DWORD *)a1 = v6;
      *(_BYTE *)(a1 + 8) = 1;
      break;
    case 7:
      LOBYTE(v2) = zend_list_delete(*(_DWORD *)a1);
      *(_BYTE *)(a1 + 8) = 1;
      break;
    default:
      v7 = (char *)sub_473493((int)&unk_4828B0);
      zend_error(2, v7);
      LOBYTE(v2) = zval_dtor(a1);
LABEL_11:
      *(_DWORD *)a1 = 0;
LABEL_12:
      *(_BYTE *)(a1 + 8) = 1;
      break;
  }
  return v2;
}
// 4954CC: using guessed type char (*empty_string)[4];

//----- (0040FE00) --------------------------------------------------------
char __cdecl convert_to_string(int a1)
{
  _DWORD *v1; // eax
  char *v2; // edi
  const char *v3; // eax
  char *v4; // edi
  char *v5; // eax
  const char *v6; // eax
  char *v7; // eax
  void *v8; // eax
  void *v9; // eax
  char *v10; // eax
  int v12; // [esp-4h] [ebp-4Ch]
  double v13; // [esp+40h] [ebp-8h]

  LOBYTE(v1) = *(_BYTE *)(a1 + 8);
  switch ( (char)v1 )
  {
    case 0:
      LOBYTE(v1) = (_BYTE)empty_string;
      *(_DWORD *)a1 = empty_string;
      *(_DWORD *)(a1 + 4) = 0;
      *(_BYTE *)(a1 + 8) = 3;
      break;
    case 1:
      v4 = *(char **)a1;
      v5 = (char *)emalloc(19);
      *(_DWORD *)a1 = v5;
      v1 = (_DWORD *)sprintf(v5, "%ld", v4);
      *(_DWORD *)(a1 + 4) = v1;
      *(_BYTE *)(a1 + 8) = 3;
      break;
    case 2:
      v13 = *(double *)a1;
      *(_DWORD *)a1 = emalloc(dword_4AB148 + 33);
      v12 = dword_4AB148;
      v6 = (const char *)sub_473493((int)&unk_4828EC);
      v1 = (_DWORD *)sprintf(*(char *const *)a1, v6, v12, v13);
      *(_DWORD *)(a1 + 4) = v1;
      *(_BYTE *)(a1 + 8) = 3;
      break;
    case 3:
      goto LABEL_13;
    case 4:
      v7 = (char *)sub_473493((int)&unk_4828F4);
      zend_error(8, v7);
      zval_dtor(a1);
      v8 = (void *)sub_473493((int)&unk_482914);
      v1 = estrndup(v8, 5u);
      *(_DWORD *)a1 = v1;
      *(_DWORD *)(a1 + 4) = 5;
      *(_BYTE *)(a1 + 8) = 3;
      break;
    case 5:
      zval_dtor(a1);
      v9 = (void *)sub_473493((int)&unk_48291C);
      *(_DWORD *)a1 = estrndup(v9, 6u);
      *(_DWORD *)(a1 + 4) = 6;
      v10 = (char *)sub_473493((int)&unk_482928);
      LOBYTE(v1) = (unsigned __int8)zend_error(8, v10);
      *(_BYTE *)(a1 + 8) = 3;
      break;
    case 6:
      if ( *(_DWORD *)a1 )
      {
        v1 = estrndup(&unk_4761B8, 1u);
        *(_DWORD *)a1 = v1;
        *(_DWORD *)(a1 + 4) = 1;
      }
      else
      {
        *(_DWORD *)a1 = empty_string;
        *(_DWORD *)(a1 + 4) = 0;
      }
      *(_BYTE *)(a1 + 8) = 3;
      break;
    case 7:
      v2 = *(char **)a1;
      zend_list_delete(*(_DWORD *)a1);
      *(_DWORD *)a1 = emalloc(31);
      v3 = (const char *)sub_473493((int)&unk_4828D4);
      v1 = (_DWORD *)sprintf(*(char *const *)a1, v3, v2);
      *(_DWORD *)(a1 + 4) = v1;
      *(_BYTE *)(a1 + 8) = 3;
      break;
    default:
      LOBYTE(v1) = zval_dtor(a1);
      *(_BYTE *)(a1 + 8) = 6;
      *(_DWORD *)a1 = 0;
LABEL_13:
      *(_BYTE *)(a1 + 8) = 3;
      break;
  }
  return (char)v1;
}
// 4954CC: using guessed type char (*empty_string)[4];
// 4AB148: using guessed type int dword_4AB148;

//----- (0040FFF0) --------------------------------------------------------
int __cdecl zend_binary_strcasecmp(unsigned __int8 *a1, unsigned int a2, unsigned __int8 *a3, unsigned int a4)
{
  int v4; // eax
  int v5; // ecx
  unsigned int v6; // ebp
  int v9; // esi

  v4 = a2;
  v5 = a4;
  v6 = a2;
  if ( a2 >= a4 )
    v6 = a4;
  if ( v6 )
  {
    while ( 1 )
    {
      --v6;
      v9 = tolower(*a1++);
      v5 = tolower(*a3++);
      if ( v9 != v5 )
        break;
      if ( !v6 )
        return a2 - a4;
    }
    v4 = v9;
  }
  return v4 - v5;
}

//----- (00410050) --------------------------------------------------------
int __cdecl mul_function(int a1, int a2, int a3)
{
  int v3; // ebx
  double *v4; // edi
  char v5; // al
  double *v6; // esi
  char v7; // al
  char v8; // al
  int v9; // esi
  int v10; // edi
  double v11; // st7
  int result; // eax
  double v13; // st7
  char *v14; // eax
  double v15; // [esp+18h] [ebp-20h] BYREF
  char v16; // [esp+20h] [ebp-18h]
  double v17; // [esp+28h] [ebp-10h] BYREF
  char v18; // [esp+30h] [ebp-8h]

  v3 = a1;
  v4 = (double *)a2;
  if ( a2 == a1 )
  {
    convert_scalar_to_number(a2);
  }
  else
  {
    switch ( *(_BYTE *)(a2 + 8) )
    {
      case 0:
        LODWORD(v15) = 0;
        goto LABEL_12;
      case 3:
        v5 = sub_40FAA0(*(_DWORD *)a2, *(_DWORD *)(a2 + 4), &v15, &v15);
        v16 = v5;
        if ( !v5 )
          goto LABEL_8;
        if ( (unsigned __int8)v5 <= 2u )
          goto LABEL_9;
        if ( v5 == 10 )
        {
          v3 = a1;
          v16 = 2;
        }
        else
        {
LABEL_8:
          LODWORD(v15) = strtol(*(const char **)a2, 0, 10);
          v16 = 1;
LABEL_9:
          v3 = a1;
        }
LABEL_13:
        v4 = &v15;
        break;
      case 6:
      case 7:
        LODWORD(v15) = *(_DWORD *)a2;
LABEL_12:
        v16 = 1;
        goto LABEL_13;
      default:
        break;
    }
  }
  v6 = (double *)a3;
  if ( a3 == v3 )
  {
    convert_scalar_to_number(a3);
  }
  else
  {
    switch ( *(_BYTE *)(a3 + 8) )
    {
      case 0:
        LODWORD(v17) = 0;
        goto LABEL_25;
      case 3:
        v7 = sub_40FAA0(*(_DWORD *)a3, *(_DWORD *)(a3 + 4), &v17, &v17);
        v18 = v7;
        if ( !v7 )
          goto LABEL_21;
        if ( (unsigned __int8)v7 <= 2u )
          goto LABEL_22;
        if ( v7 == 10 )
        {
          v3 = a1;
          v18 = 2;
        }
        else
        {
LABEL_21:
          LODWORD(v17) = strtol(*(const char **)a3, 0, 10);
          v18 = 1;
LABEL_22:
          v3 = a1;
        }
LABEL_26:
        v6 = &v17;
        break;
      case 6:
      case 7:
        LODWORD(v17) = *(_DWORD *)a3;
LABEL_25:
        v18 = 1;
        goto LABEL_26;
      default:
        break;
    }
  }
  v8 = *((_BYTE *)v4 + 8);
  if ( v8 == 1 && *((_BYTE *)v6 + 8) == 1 )
  {
    v9 = *(_DWORD *)v6;
    v10 = *(_DWORD *)v4;
    v11 = (double)v9 * (double)v10;
    if ( v11 <= 2147483647.0 && v11 >= -2147483648.0 )
    {
      *(_DWORD *)v3 = v10 * v9;
      *(_BYTE *)(v3 + 8) = 1;
      return 0;
    }
LABEL_39:
    *(double *)v3 = v11;
    *(_BYTE *)(v3 + 8) = 2;
    return 0;
  }
  if ( v8 == 2 && *((_BYTE *)v6 + 8) == 1 || v8 == 1 && *((_BYTE *)v6 + 8) == 2 )
  {
    if ( v8 == 1 )
    {
      result = 0;
      v13 = (double)*(int *)v4 * *v6;
      *(_BYTE *)(v3 + 8) = 2;
      *(double *)v3 = v13;
      return result;
    }
    v11 = (double)*(int *)v6 * *v4;
    goto LABEL_39;
  }
  if ( v8 == 2 && *((_BYTE *)v6 + 8) == 2 )
  {
    *(_BYTE *)(v3 + 8) = 2;
    result = 0;
    *(double *)v3 = *v4 * *v6;
  }
  else
  {
    v14 = (char *)sub_473493((int)&unk_482948);
    zend_error(1, v14);
    return -1;
  }
  return result;
}
// 410050: using guessed type double var_20;
// 410050: using guessed type double var_10;

//----- (0041027C) --------------------------------------------------------
_BYTE *__usercall sub_41027C@<eax>(_BYTE *result@<eax>, int a2)
{
  while ( *result )
  {
    if ( (char)*result == a2 )
      return result;
    ++result;
  }
  return 0;
}

//----- (00410291) --------------------------------------------------------
int __usercall sub_410291@<eax>(int a1@<edi>)
{
  int result; // eax
  int v2; // ecx
  int v3; // ebx
  int v4; // ebx
  int *v5; // esi
  int *v6; // edx
  int *v7; // esi
  int *v8; // edx
  int v9; // [esp+4h] [ebp-10h]
  int v10; // [esp+8h] [ebp-Ch]
  int i; // [esp+Ch] [ebp-8h]
  int v12; // [esp+10h] [ebp-4h]
  int v13; // [esp+10h] [ebp-4h]

  result = dword_4A79B8;
  v2 = dword_4A79C0;
  v3 = dword_4A4E24;
  for ( i = dword_4A4E24; i > result; v3 = i )
  {
    if ( result <= v2 )
      break;
    v4 = v3 - result;
    if ( v4 <= result - v2 )
    {
      if ( v4 > 0 )
      {
        v7 = (int *)(a1 + 4 * result);
        v8 = (int *)(a1 + 4 * v2);
        v9 = v4;
        do
        {
          v13 = *v8;
          *v8 = *v7;
          *v7 = v13;
          ++v8;
          ++v7;
          --v9;
        }
        while ( v9 );
      }
      v2 += v4;
    }
    else
    {
      if ( result - v2 > 0 )
      {
        v5 = (int *)(a1 + 4 * (v2 + v4));
        v6 = (int *)(a1 + 4 * v2);
        v10 = result - v2;
        do
        {
          v12 = *v6;
          *v6 = *v5;
          *v5 = v12;
          ++v6;
          ++v5;
          --v10;
        }
        while ( v10 );
      }
      i -= result - v2;
    }
  }
  dword_4A79C0 += dword_4A4E24 - result;
  dword_4A79B8 = dword_4A4E24;
  return result;
}
// 4A4E24: using guessed type int dword_4A4E24;
// 4A79B8: using guessed type int dword_4A79B8;
// 4A79C0: using guessed type int dword_4A79C0;

//----- (00410344) --------------------------------------------------------
char *__usercall sub_410344@<eax>(char *a1@<eax>)
{
  const char *v2; // eax
  char *v3; // eax
  char v4; // cl

  dword_4A79C8 = 0;
  dword_4A79B8 = dword_4A4E24;
  dword_4A79C0 = dword_4A4E24;
  v2 = (const char *)sub_473493((int)&unk_482964);
  v3 = getenv(v2);
  v4 = *a1;
  dword_4A79BC = (int)v3;
  if ( v4 == 45 )
  {
    dword_4A79C4 = 2;
  }
  else
  {
    if ( v4 != 43 )
    {
      dword_4A79C4 = v3 == 0;
      return a1;
    }
    dword_4A79C4 = 0;
  }
  ++a1;
  return a1;
}
// 4A4E24: using guessed type int dword_4A4E24;
// 4A79B8: using guessed type int dword_4A79B8;
// 4A79BC: using guessed type int dword_4A79BC;
// 4A79C0: using guessed type int dword_4A79C0;
// 4A79C4: using guessed type int dword_4A79C4;

//----- (004103A7) --------------------------------------------------------
int __cdecl sub_4103A7(int a1, int *a2, char *a3, int *a4)
{
  int result; // eax
  int v5; // ebx
  char *v6; // eax
  char *v7; // edx
  int v8; // eax
  _BYTE *v9; // eax
  int v10; // ebx
  char *v11; // esi
  char v12; // al
  char v13; // al
  void **v14; // esi
  void **v15; // edi
  int v16; // eax
  unsigned int v17; // eax
  char *v18; // ecx
  FILE *v19; // esi
  const char *v20; // eax
  int v21; // eax
  bool v22; // zf
  char *v23; // eax
  const char *v24; // ecx
  FILE *v25; // ebx
  const char *v26; // eax
  FILE *v27; // ebx
  void **v28; // ebx
  const char *v29; // eax
  char *v30; // edx
  int v31; // eax
  FILE *v32; // edi
  void **v33; // edi
  const char *v34; // eax
  char *v35; // edx
  int v36; // eax
  FILE *v37; // edi
  void **v38; // eax
  const char *v39; // eax
  void **v40; // eax
  const char *v41; // eax
  int v42; // ebx
  int v43; // esi
  char *v44; // edx
  _BYTE *v45; // edi
  char v46; // al
  int v47; // edi
  FILE *v48; // edi
  const char *v49; // eax
  char *v50; // esi
  const char **v51; // ebx
  FILE *v52; // esi
  const char *v53; // eax
  FILE *v54; // esi
  const char *v55; // eax
  int v56; // eax
  FILE *v57; // edi
  void **v58; // edi
  const char *v59; // eax
  FILE *v60; // edi
  const char *v61; // eax
  FILE *v62; // edi
  const char *v63; // eax
  FILE *v64; // edi
  const char *v65; // eax
  int v66; // [esp-10h] [ebp-34h]
  int v67; // [esp-10h] [ebp-34h]
  int v68; // [esp-Ch] [ebp-30h]
  int v69; // [esp-Ch] [ebp-30h]
  int v70; // [esp-Ch] [ebp-30h]
  int v71; // [esp-Ch] [ebp-30h]
  int v72; // [esp-Ch] [ebp-30h]
  int v73; // [esp-Ch] [ebp-30h]
  int v74; // [esp-Ch] [ebp-30h]
  int v75; // [esp-Ch] [ebp-30h]
  int v76; // [esp-Ch] [ebp-30h]
  int v77; // [esp-Ch] [ebp-30h]
  int v78; // [esp-Ch] [ebp-30h]
  int v79; // [esp-Ch] [ebp-30h]
  int v80; // [esp-Ch] [ebp-30h]
  int v81; // [esp-8h] [ebp-2Ch]
  void *v82; // [esp-8h] [ebp-2Ch]
  void *v83; // [esp-8h] [ebp-2Ch]
  int v84; // [esp-8h] [ebp-2Ch]
  char *v85; // [esp-8h] [ebp-2Ch]
  char *v86; // [esp-8h] [ebp-2Ch]
  int v87; // [esp-8h] [ebp-2Ch]
  const char *v88; // [esp-8h] [ebp-2Ch]
  int v89; // [esp-8h] [ebp-2Ch]
  int v91; // [esp+8h] [ebp-1Ch]
  int v92; // [esp+8h] [ebp-1Ch]
  int v93; // [esp+Ch] [ebp-18h]
  int v94; // [esp+Ch] [ebp-18h]
  int v95; // [esp+10h] [ebp-14h]
  int v96; // [esp+10h] [ebp-14h]
  int v97; // [esp+14h] [ebp-10h]
  char *v98; // [esp+18h] [ebp-Ch]
  const char **v99; // [esp+18h] [ebp-Ch]
  BOOL v100; // [esp+1Ch] [ebp-8h]
  char v101; // [esp+23h] [ebp-1h]

  v100 = *a3 != 58;
  if ( a1 < 1 )
    return -1;
  v5 = dword_4A4E24;
  ArgList = 0;
  if ( !dword_4A4E24 )
  {
    dword_4A4E24 = 1;
LABEL_7:
    v6 = sub_410344(a3);
    v5 = dword_4A4E24;
    a3 = v6;
    dword_4AE094 = 1;
    goto LABEL_8;
  }
  if ( !dword_4AE094 )
    goto LABEL_7;
LABEL_8:
  v7 = dword_4A79C8;
  if ( !dword_4A79C8 || !*dword_4A79C8 )
  {
    v8 = dword_4A79B8;
    if ( dword_4A79B8 > v5 )
    {
      v8 = v5;
      dword_4A79B8 = v5;
    }
    if ( dword_4A79C0 > v5 )
      dword_4A79C0 = v5;
    if ( dword_4A79C4 == 1 )
    {
      if ( dword_4A79C0 == v8 )
      {
        if ( v8 != v5 )
          dword_4A79C0 = v5;
      }
      else if ( v8 != v5 )
      {
        sub_410291((int)a2);
      }
      while ( v5 < a1 )
      {
        v9 = (_BYTE *)a2[v5];
        if ( *v9 == 45 )
        {
          if ( v9[1] )
            break;
        }
        dword_4A4E24 = ++v5;
      }
      v8 = v5;
      dword_4A79B8 = v5;
    }
    if ( v5 == a1 )
      goto LABEL_33;
    if ( !strcmp((const char *)a2[v5], "--") )
    {
      v10 = v5 + 1;
      dword_4A4E24 = v10;
      if ( dword_4A79C0 == v8 )
      {
        dword_4A79C0 = v10;
      }
      else if ( v8 != v10 )
      {
        sub_410291((int)a2);
      }
      v8 = a1;
      v5 = a1;
      dword_4A79B8 = a1;
      dword_4A4E24 = a1;
    }
    if ( v5 == a1 )
    {
LABEL_33:
      if ( dword_4A79C0 != v8 )
        dword_4A4E24 = dword_4A79C0;
      return -1;
    }
    v11 = (char *)a2[v5];
    if ( *v11 != 45 || (v12 = v11[1]) == 0 )
    {
      if ( !dword_4A79C4 )
        return -1;
      v42 = v5 + 1;
      ArgList = v11;
      result = 1;
LABEL_198:
      dword_4A4E24 = v42;
      return result;
    }
    v7 = &v11[(v12 == 45) + 1];
    dword_4A79C8 = v7;
  }
  v13 = *v7;
  if ( *(_BYTE *)(a2[v5] + 1) != 45 )
  {
    v43 = v13;
    v101 = *v7;
    dword_4A79C8 = v7 + 1;
    v45 = sub_41027C(a3, v13);
    v46 = *v44;
    if ( !*v44 )
      dword_4A4E24 = ++v5;
    if ( !v45 || v101 == 58 )
    {
      if ( v100 )
      {
        if ( dword_4A79BC )
        {
          if ( Stream )
            v62 = Stream;
          else
            v62 = (FILE *)(sub_44F01A() + 16);
          v79 = *a2;
          v63 = (const char *)sub_473493((int)&unk_482A68);
          fprintf(v62, v63, v79, v43);
        }
        else
        {
          if ( Stream )
            v64 = Stream;
          else
            v64 = (FILE *)(sub_44F01A() + 16);
          v80 = *a2;
          v65 = (const char *)sub_473493((int)&unk_482A84);
          fprintf(v64, v65, v80, v43);
        }
      }
      dword_4A4EC4 = v43;
      return 63;
    }
    if ( *v45 == 87 && v45[1] == 59 )
    {
      v47 = 0;
      v99 = 0;
      v94 = 0;
      v92 = 0;
      v96 = 0;
      if ( !v46 )
      {
        if ( v5 == a1 )
        {
          if ( v100 )
          {
            if ( Stream )
              v48 = Stream;
            else
              v48 = (FILE *)(sub_44F01A() + 16);
            v74 = *a2;
            v49 = (const char *)sub_473493((int)&unk_482AA0);
            fprintf(v48, v49, v74, v43);
          }
          v22 = *a3 == 58;
          dword_4A4EC4 = v43;
          return !v22 ? 63 : 58;
        }
        v44 = (char *)a2[v5];
      }
      v50 = v44;
      dword_4A4E24 = v5 + 1;
      ArgList = v44;
      dword_4A79C8 = v44;
      while ( *v50 && *v50 != 61 )
        ++v50;
      v51 = (const char **)&off_4A5318;
      if ( !off_4A5318 )
        goto LABEL_164;
      while ( 1 )
      {
        if ( !strncmp(*v51, dword_4A79C8, v50 - dword_4A79C8) )
        {
          if ( v50 - dword_4A79C8 == strlen(*v51) )
          {
            v99 = v51;
            v96 = v47;
            v94 = 1;
LABEL_131:
            if ( v92 && !v94 )
            {
              if ( v100 )
              {
                if ( Stream )
                  v52 = Stream;
                else
                  v52 = (FILE *)(sub_44F01A() + 16);
                v87 = a2[dword_4A4E24];
                v75 = *a2;
                v53 = (const char *)sub_473493((int)&unk_482ACC);
                fprintf(v52, v53, v75, v87);
              }
              dword_4A79C8 += strlen(dword_4A79C8);
              ++dword_4A4E24;
              return 63;
            }
            if ( v99 )
            {
              if ( *v50 )
              {
                if ( !v99[1] )
                {
                  if ( v100 )
                  {
                    if ( Stream )
                      v54 = Stream;
                    else
                      v54 = (FILE *)(sub_44F01A() + 16);
                    v88 = *v99;
                    v76 = *a2;
                    v55 = (const char *)sub_473493((int)&unk_482AF0);
                    fprintf(v54, v55, v76, v88);
                  }
                  dword_4A79C8 += strlen(dword_4A79C8);
                  return 63;
                }
                ArgList = v50 + 1;
LABEL_143:
                dword_4A79C8 += strlen(dword_4A79C8);
                if ( a4 )
                  *a4 = v96;
                v23 = (char *)v99[2];
                if ( !v23 )
                  return (int)v99[3];
                v24 = v99[3];
LABEL_147:
                *(_DWORD *)v23 = v24;
                return 0;
              }
              if ( v99[1] != (const char *)1 )
                goto LABEL_143;
              v56 = dword_4A4E24;
              if ( dword_4A4E24 < a1 )
              {
                ArgList = (char *)a2[dword_4A4E24++];
                goto LABEL_143;
              }
              if ( v100 )
              {
                v57 = Stream;
                if ( !Stream )
                {
                  v58 = sub_44F01A();
                  v56 = dword_4A4E24;
                  v57 = (FILE *)(v58 + 16);
                }
                v89 = a2[v56 - 1];
                v77 = *a2;
                v59 = (const char *)sub_473493((int)&unk_4829F8);
                fprintf(v57, v59, v77, v89);
              }
              dword_4A79C8 += strlen(dword_4A79C8);
              return *a3 != 58 ? 63 : 58;
            }
LABEL_164:
            dword_4A79C8 = 0;
            return 87;
          }
          if ( v99 )
          {
            v92 = 1;
          }
          else
          {
            v99 = v51;
            v96 = v47;
          }
        }
        v51 += 4;
        ++v47;
        if ( !*v51 )
          goto LABEL_131;
      }
    }
    if ( v45[1] != 58 )
      return v101;
    if ( v45[2] == 58 )
    {
      if ( !v46 )
      {
        ArgList = 0;
LABEL_180:
        dword_4A79C8 = 0;
        return v101;
      }
    }
    else if ( !v46 )
    {
      if ( v5 == a1 )
      {
        if ( v100 )
        {
          if ( Stream )
            v60 = Stream;
          else
            v60 = (FILE *)(sub_44F01A() + 16);
          v78 = *a2;
          v61 = (const char *)sub_473493((int)&unk_482AA0);
          fprintf(v60, v61, v78, v43);
        }
        v22 = *a3 == 58;
        dword_4A4EC4 = v43;
        v101 = !v22 ? 63 : 58;
        goto LABEL_180;
      }
      ArgList = (char *)a2[v5];
      goto LABEL_179;
    }
    ArgList = v44;
LABEL_179:
    dword_4A4E24 = v5 + 1;
    goto LABEL_180;
  }
  v14 = 0;
  v95 = -1;
  v91 = 0;
  v93 = 0;
  v98 = v7;
  while ( v13 && v13 != 61 )
    v13 = *++v98;
  v15 = &off_4A5318;
  v97 = 0;
  if ( !off_4A5318 )
    goto LABEL_93;
  while ( 1 )
  {
    v16 = strncmp((const char *)*v15, v7, v98 - v7);
    v7 = dword_4A79C8;
    if ( !v16 )
      break;
LABEL_52:
    v15 += 4;
    ++v97;
    if ( !*v15 )
    {
      v18 = v98;
      goto LABEL_55;
    }
  }
  v17 = (unsigned int)*v15 + strlen((const char *)*v15) + 1;
  v18 = v98;
  if ( v98 - dword_4A79C8 != v17 - ((_DWORD)*v15 + 1) )
  {
    if ( v14 )
    {
      if ( v14[1] != v15[1] || v14[2] != v15[2] || v14[3] != v15[3] )
        v93 = 1;
    }
    else
    {
      v14 = v15;
      v95 = v97;
    }
    goto LABEL_52;
  }
  v14 = v15;
  v95 = v97;
  v91 = 1;
LABEL_55:
  if ( v93 && !v91 )
  {
    if ( v100 )
    {
      if ( Stream )
        v19 = Stream;
      else
        v19 = (FILE *)(sub_44F01A() + 16);
      v81 = a2[dword_4A4E24];
      v68 = *a2;
      v20 = (const char *)sub_473493((int)&unk_482978);
      fprintf(v19, v20, v68, v81);
      v7 = dword_4A79C8;
    }
    ++dword_4A4E24;
    dword_4A4EC4 = 0;
    dword_4A79C8 = &v7[strlen(v7)];
    return 63;
  }
  if ( !v14 )
  {
    v5 = dword_4A4E24;
LABEL_93:
    if ( v100 )
    {
      v37 = Stream;
      if ( *(_BYTE *)(a2[v5] + 1) == 45 )
      {
        if ( !Stream )
        {
          v38 = sub_44F01A();
          v7 = dword_4A79C8;
          v37 = (FILE *)(v38 + 16);
        }
        v85 = v7;
        v72 = *a2;
        v39 = (const char *)sub_473493((int)&unk_482A20);
        fprintf(v37, v39, v72, v85);
      }
      else
      {
        if ( !Stream )
        {
          v40 = sub_44F01A();
          v5 = dword_4A4E24;
          v7 = dword_4A79C8;
          v37 = (FILE *)(v40 + 16);
        }
        v86 = v7;
        v73 = *(char *)a2[v5];
        v67 = *a2;
        v41 = (const char *)sub_473493((int)&unk_482A44);
        fprintf(v37, v41, v67, v73, v86);
      }
      v5 = dword_4A4E24;
    }
    v42 = v5 + 1;
    dword_4A4EC4 = 0;
    dword_4A79C8 = (char *)byte_47627C;
    result = 63;
    goto LABEL_198;
  }
  v21 = dword_4A4E24 + 1;
  v22 = *v18 == 0;
  ++dword_4A4E24;
  if ( v22 )
  {
    if ( v14[1] == (void *)1 )
    {
      if ( v21 >= a1 )
      {
        if ( v100 )
        {
          v32 = Stream;
          if ( !Stream )
          {
            v33 = sub_44F01A();
            v21 = dword_4A4E24;
            v32 = (FILE *)(v33 + 16);
          }
          v84 = a2[v21 - 1];
          v71 = *a2;
          v34 = (const char *)sub_473493((int)&unk_4829F8);
          fprintf(v32, v34, v71, v84);
          v7 = dword_4A79C8;
        }
        v35 = &v7[strlen(v7)];
        v36 = (int)v14[3];
        dword_4A79C8 = v35;
        dword_4A4EC4 = v36;
        return *a3 != 58 ? 63 : 58;
      }
      ArgList = (char *)a2[v21];
      dword_4A4E24 = v21 + 1;
    }
LABEL_67:
    dword_4A79C8 += strlen(dword_4A79C8);
    if ( a4 )
      *a4 = v95;
    v23 = (char *)v14[2];
    if ( !v23 )
      return (int)v14[3];
    v24 = (const char *)v14[3];
    goto LABEL_147;
  }
  if ( v14[1] )
  {
    ArgList = v18 + 1;
    goto LABEL_67;
  }
  if ( v100 )
  {
    if ( *(_BYTE *)(a2[v21 - 1] + 1) == 45 )
    {
      if ( Stream )
        v25 = Stream;
      else
        v25 = (FILE *)(sub_44F01A() + 16);
      v82 = *v14;
      v69 = *a2;
      v26 = (const char *)sub_473493((int)&unk_482998);
      fprintf(v25, v26, v69, v82);
    }
    else
    {
      if ( Stream )
      {
        v27 = Stream;
      }
      else
      {
        v28 = sub_44F01A();
        v21 = dword_4A4E24;
        v27 = (FILE *)(v28 + 16);
      }
      v83 = *v14;
      v70 = *(char *)a2[v21 - 1];
      v66 = *a2;
      v29 = (const char *)sub_473493((int)&unk_4829C8);
      fprintf(v27, v29, v66, v70, v83);
    }
    v7 = dword_4A79C8;
  }
  v30 = &v7[strlen(v7)];
  v31 = (int)v14[3];
  dword_4A79C8 = v30;
  dword_4A4EC4 = v31;
  return 63;
}
// 4108B6: variable 'v44' is possibly undefined
// 4A4E24: using guessed type int dword_4A4E24;
// 4A4EC4: using guessed type int dword_4A4EC4;
// 4A5318: using guessed type void *off_4A5318;
// 4A79B8: using guessed type int dword_4A79B8;
// 4A79BC: using guessed type int dword_4A79BC;
// 4A79C0: using guessed type int dword_4A79C0;
// 4A79C4: using guessed type int dword_4A79C4;
// 4AE094: using guessed type int dword_4AE094;

//----- (00410CF0) --------------------------------------------------------
int __usercall sub_410CF0@<eax>(int a1@<eax>, _DWORD *a2)
{
  int v3; // esi
  int v4; // edi
  int v5; // ecx
  int v6; // edx
  unsigned __int8 *v7; // eax
  int *v8; // ebx
  int v9; // ebx
  unsigned int v10; // ebx
  bool v11; // zf
  int v12; // eax
  int v13; // eax
  int v14; // ecx
  int v15; // ecx
  int v16; // edx
  int v17; // edx
  int v18; // esi
  int v19; // edi
  int v20; // esi
  int v21; // edi
  int v22; // eax
  int v23; // edi
  int v24; // ecx
  int v25; // edi
  int v26; // edx
  int v27; // edi
  int v28; // ebx
  int v29; // esi
  int v30; // ebx
  int v31; // eax
  int v32; // edi
  int v33; // ecx
  int v34; // eax
  int v35; // edx
  int v36; // ecx
  int v37; // esi
  int v38; // edx
  int v39; // esi
  int v40; // edi
  int v41; // esi
  int v42; // eax
  int v43; // esi
  int v44; // ecx
  int v45; // esi
  int v46; // ebx
  int v47; // edx
  int v48; // esi
  int v49; // edi
  int v50; // eax
  int v51; // edi
  int v52; // ecx
  int v53; // eax
  int v54; // edx
  int v55; // esi
  int v56; // ecx
  int v57; // edx
  int v58; // ebx
  int v59; // ebp
  int v60; // edi
  int v61; // edx
  int v62; // eax
  int v63; // esi
  int v64; // ecx
  int v65; // edx
  int v66; // ebx
  int v67; // edi
  int v68; // esi
  int v69; // eax
  int v70; // edi
  int v71; // ecx
  int v72; // edx
  int v73; // eax
  int v74; // ecx
  int v75; // ebx
  int v76; // ebp
  int v77; // esi
  int v78; // ecx
  int v79; // edi
  int v80; // edx
  int v81; // eax
  int v82; // ebx
  int v83; // esi
  int v84; // edi
  int v85; // ecx
  int v86; // eax
  int v87; // ebx
  int v88; // ebp
  int v89; // edx
  int v90; // eax
  int v91; // ecx
  int v92; // edi
  int v93; // ecx
  int v94; // ebx
  int v95; // edx
  int v96; // esi
  int v97; // edi
  int v98; // ebx
  int v99; // ebp
  int v100; // ecx
  int v101; // edi
  int v102; // eax
  int v103; // esi
  int v104; // eax
  int v105; // ebx
  int v106; // ecx
  int v107; // edx
  int v108; // edi
  int v109; // esi
  int v110; // esi
  int v111; // eax
  int v112; // esi
  int v113; // edi
  int v114; // edx
  int v115; // edi
  int v116; // ebx
  int v117; // eax
  int v118; // ecx
  int v119; // edx
  int v120; // ebx
  int v121; // ebp
  int v122; // edi
  int v123; // edx
  int v124; // ebx
  int v125; // eax
  int v126; // esi
  int v127; // ecx
  int v128; // esi
  int v129; // ebx
  int v130; // edi
  int v131; // eax
  int v132; // edi
  int v133; // ebx
  int v134; // ecx
  int v136; // [esp+8h] [ebp-130h]
  int *v137; // [esp+8h] [ebp-130h]
  int v138; // [esp+Ch] [ebp-12Ch]
  int v139; // [esp+Ch] [ebp-12Ch]
  int v140; // [esp+Ch] [ebp-12Ch]
  int v141; // [esp+Ch] [ebp-12Ch]
  int v142; // [esp+Ch] [ebp-12Ch]
  int v143; // [esp+Ch] [ebp-12Ch]
  int v144; // [esp+Ch] [ebp-12Ch]
  int v145; // [esp+10h] [ebp-128h]
  int v146; // [esp+10h] [ebp-128h]
  int v147; // [esp+10h] [ebp-128h]
  int v148; // [esp+10h] [ebp-128h]
  int v149; // [esp+10h] [ebp-128h]
  int v150; // [esp+10h] [ebp-128h]
  int v151; // [esp+10h] [ebp-128h]
  int v152; // [esp+10h] [ebp-128h]
  int v153; // [esp+10h] [ebp-128h]
  int v154; // [esp+10h] [ebp-128h]
  int v155; // [esp+10h] [ebp-128h]
  int v156; // [esp+10h] [ebp-128h]
  int v157; // [esp+14h] [ebp-124h]
  int v158; // [esp+14h] [ebp-124h]
  int v159; // [esp+14h] [ebp-124h]
  int v160; // [esp+14h] [ebp-124h]
  int v161; // [esp+14h] [ebp-124h]
  int v162; // [esp+14h] [ebp-124h]
  int v163; // [esp+14h] [ebp-124h]
  int v164; // [esp+14h] [ebp-124h]
  int v165; // [esp+14h] [ebp-124h]
  int v166; // [esp+14h] [ebp-124h]
  int v167; // [esp+14h] [ebp-124h]
  int v168; // [esp+14h] [ebp-124h]
  int v169; // [esp+14h] [ebp-124h]
  int v170; // [esp+18h] [ebp-120h]
  int v171; // [esp+18h] [ebp-120h]
  int v172; // [esp+18h] [ebp-120h]
  int v173; // [esp+18h] [ebp-120h]
  int v174; // [esp+18h] [ebp-120h]
  int v175; // [esp+18h] [ebp-120h]
  int v176; // [esp+18h] [ebp-120h]
  int v177; // [esp+18h] [ebp-120h]
  int v178; // [esp+18h] [ebp-120h]
  int v179; // [esp+18h] [ebp-120h]
  int v180; // [esp+18h] [ebp-120h]
  int v181; // [esp+18h] [ebp-120h]
  int v182; // [esp+18h] [ebp-120h]
  int v183; // [esp+18h] [ebp-120h]
  int v184; // [esp+1Ch] [ebp-11Ch]
  int v185; // [esp+1Ch] [ebp-11Ch]
  int v186; // [esp+1Ch] [ebp-11Ch]
  int v187; // [esp+1Ch] [ebp-11Ch]
  int v188; // [esp+1Ch] [ebp-11Ch]
  int v189; // [esp+1Ch] [ebp-11Ch]
  int v190; // [esp+20h] [ebp-118h]
  int v191; // [esp+20h] [ebp-118h]
  int v192; // [esp+20h] [ebp-118h]
  int v193; // [esp+20h] [ebp-118h]
  int v194; // [esp+20h] [ebp-118h]
  int v195; // [esp+20h] [ebp-118h]
  int v196; // [esp+20h] [ebp-118h]
  int v197; // [esp+24h] [ebp-114h]
  int v198; // [esp+24h] [ebp-114h]
  int v199; // [esp+24h] [ebp-114h]
  int v200; // [esp+24h] [ebp-114h]
  int v201; // [esp+24h] [ebp-114h]
  int v202; // [esp+24h] [ebp-114h]
  int v203; // [esp+28h] [ebp-110h]
  int v204; // [esp+28h] [ebp-110h]
  int v205; // [esp+28h] [ebp-110h]
  int v206; // [esp+28h] [ebp-110h]
  int v207; // [esp+28h] [ebp-110h]
  int v208; // [esp+28h] [ebp-110h]
  int v209; // [esp+28h] [ebp-110h]
  int v210; // [esp+28h] [ebp-110h]
  int v211; // [esp+28h] [ebp-110h]
  int v212; // [esp+28h] [ebp-110h]
  char *v213; // [esp+2Ch] [ebp-10Ch]
  int v214; // [esp+2Ch] [ebp-10Ch]
  char *v215; // [esp+30h] [ebp-108h]
  unsigned int v216; // [esp+30h] [ebp-108h]
  int v217; // [esp+38h] [ebp-100h] BYREF
  int v218; // [esp+3Ch] [ebp-FCh] BYREF
  _DWORD v219[12]; // [esp+40h] [ebp-F8h] BYREF
  int v220[7]; // [esp+70h] [ebp-C8h] BYREF
  int v221; // [esp+8Ch] [ebp-ACh]
  int v222; // [esp+90h] [ebp-A8h]
  int v223; // [esp+94h] [ebp-A4h]
  int v224; // [esp+98h] [ebp-A0h]
  int v225; // [esp+9Ch] [ebp-9Ch]
  int v226; // [esp+A0h] [ebp-98h]
  int v227; // [esp+A4h] [ebp-94h]
  int v228; // [esp+A8h] [ebp-90h]
  int v229; // [esp+ACh] [ebp-8Ch]
  int v230; // [esp+B0h] [ebp-88h]
  int v231; // [esp+B4h] [ebp-84h]
  int v232; // [esp+B8h] [ebp-80h]
  int v233; // [esp+BCh] [ebp-7Ch]
  int v234; // [esp+C0h] [ebp-78h]
  int v235; // [esp+C4h] [ebp-74h]
  int v236; // [esp+C8h] [ebp-70h]
  int v237; // [esp+CCh] [ebp-6Ch]
  int v238; // [esp+D0h] [ebp-68h]
  int v239; // [esp+D4h] [ebp-64h]
  int v240; // [esp+D8h] [ebp-60h]
  int v241; // [esp+DCh] [ebp-5Ch]
  int v242; // [esp+E0h] [ebp-58h]
  int v243; // [esp+E4h] [ebp-54h]
  int v244; // [esp+E8h] [ebp-50h]
  int v245; // [esp+ECh] [ebp-4Ch]
  int v246; // [esp+F0h] [ebp-48h]
  int v247; // [esp+F4h] [ebp-44h]
  int v248; // [esp+F8h] [ebp-40h]
  int v249; // [esp+FCh] [ebp-3Ch]
  int v250; // [esp+100h] [ebp-38h]
  int v251; // [esp+104h] [ebp-34h]
  int v252; // [esp+108h] [ebp-30h]
  int v253; // [esp+10Ch] [ebp-2Ch]
  int v254; // [esp+110h] [ebp-28h]
  int v255; // [esp+114h] [ebp-24h]
  int v256; // [esp+118h] [ebp-20h]
  int v257; // [esp+11Ch] [ebp-1Ch]
  int v258; // [esp+120h] [ebp-18h]
  int v259; // [esp+124h] [ebp-14h]
  int v260; // [esp+128h] [ebp-10h]
  int v261; // [esp+12Ch] [ebp-Ch]
  int v262; // [esp+130h] [ebp-8h]
  int v263; // [esp+134h] [ebp-4h]

  v197 = a2[8];
  v213 = (char *)&v217 - a1 + 2;
  v3 = a2[5];
  v215 = (char *)&v218 - a1 + 2;
  v4 = a2[2];
  v145 = a2[3];
  v5 = a2[7];
  v157 = a2[4];
  v6 = a2[6];
  v203 = a2[9];
  v184 = v6;
  v190 = v5;
  v136 = 0;
  v7 = (unsigned __int8 *)(a1 + 2);
  do
  {
    *(&v217 + v136) = v7[1] | ((*v7 | ((*(v7 - 1) | (*(v7 - 2) << 8)) << 8)) << 8);
    *(_DWORD *)&v213[(_DWORD)v7] = v7[5] | ((v7[4] | ((v7[3] | (v7[2] << 8)) << 8)) << 8);
    *(_DWORD *)&v215[(_DWORD)v7] = v7[9] | ((v7[8] | ((v7[7] | (v7[6] << 8)) << 8)) << 8);
    *(_DWORD *)((char *)v219 + (_DWORD)v7 - a1 + 2) = v7[13] | ((v7[12] | ((v7[11] | (v7[10] << 8)) << 8)) << 8);
    v7 += 16;
    v136 += 4;
  }
  while ( v136 < 16 );
  v8 = v220;
  v137 = v220;
  v214 = 12;
  do
  {
    v9 = *(v137 - 5)
       + *(v137 - 14)
       + (((unsigned int)*v8 >> 10) ^ __ROR4__(*v8, 17) ^ __ROR4__(*v8, 19))
       + (((unsigned int)*(v8 - 13) >> 3) ^ __ROR4__(*(v8 - 13), 7) ^ __ROR4__(*(v8 - 13), 18));
    v137[2] = v9;
    v216 = v9;
    v10 = *(v137 - 4)
        + (((unsigned int)v137[1] >> 10) ^ __ROR4__(v137[1], 17) ^ __ROR4__(v137[1], 19))
        + (((unsigned int)*(v137 - 12) >> 3) ^ __ROR4__(*(v137 - 12), 7) ^ __ROR4__(*(v137 - 12), 18))
        + *(v137 - 13);
    v137[3] = v10;
    v137[4] = *(v137 - 12)
            + *(v137 - 3)
            + ((v216 >> 10) ^ __ROR4__(v216, 17) ^ __ROR4__(v216, 19))
            + (((unsigned int)*(v137 - 11) >> 3) ^ __ROR4__(*(v137 - 11), 7) ^ __ROR4__(*(v137 - 11), 18));
    v11 = v214-- == 1;
    v137[5] = *(v137 - 11)
            + *(v137 - 2)
            + ((v10 >> 10) ^ __ROR4__(v10, 17) ^ __ROR4__(v10, 19))
            + (((unsigned int)*(v137 - 10) >> 3) ^ __ROR4__(*(v137 - 10), 7) ^ __ROR4__(*(v137 - 10), 18));
    v8 = v137 + 4;
    v137 += 4;
  }
  while ( !v11 );
  v12 = v203 + v217 + (__ROR4__(v6, 6) ^ __ROR4__(v6, 11) ^ __ROR4__(v6, 25)) + (v197 ^ v6 & (v197 ^ v5)) + 1116352408;
  v170 = v12 + v3;
  v13 = v12 + (__ROR4__(v4, 2) ^ __ROR4__(v4, 13) ^ __ROR4__(v4, 22)) + (v4 & v145 | v157 & (v4 | v145));
  v14 = v197
      + v218
      + (__ROR4__(v170, 6) ^ __ROR4__(v170, 11) ^ __ROR4__(v170, 25))
      + (v5 ^ v170 & (v6 ^ v5))
      + 1899447441;
  v158 = v14 + v157;
  v15 = v14 + (__ROR4__(v13, 2) ^ __ROR4__(v13, 13) ^ __ROR4__(v13, 22)) + (v13 & v4 | v145 & (v13 | v4));
  v16 = v219[0]
      + (__ROR4__(v158, 6) ^ __ROR4__(v158, 11) ^ __ROR4__(v158, 25))
      + (v6 ^ v158 & (v6 ^ v170))
      + v190
      - 1245643825;
  v146 = v16 + v145;
  v17 = v16 + (__ROR4__(v15, 2) ^ __ROR4__(v15, 13) ^ __ROR4__(v15, 22)) + (v13 & v15 | v4 & (v13 | v15));
  v18 = v219[1]
      + (__ROR4__(v146, 6) ^ __ROR4__(v146, 11) ^ __ROR4__(v146, 25))
      + (v170 ^ v146 & (v158 ^ v170))
      + v184
      - 373957723;
  v19 = v18 + v4;
  v20 = v18 + (__ROR4__(v17, 2) ^ __ROR4__(v17, 13) ^ __ROR4__(v17, 22)) + (v15 & v17 | v13 & (v15 | v17));
  v138 = v19;
  v21 = v219[2]
      + (__ROR4__(v19, 6) ^ __ROR4__(v19, 11) ^ __ROR4__(v19, 25))
      + (v158 ^ v19 & (v146 ^ v158))
      + v170
      + 961987163;
  v22 = v21 + v13;
  v171 = v21 + (__ROR4__(v20, 2) ^ __ROR4__(v20, 13) ^ __ROR4__(v20, 22)) + (v20 & v17 | v15 & (v20 | v17));
  v23 = v219[3]
      + (__ROR4__(v22, 6) ^ __ROR4__(v22, 11) ^ __ROR4__(v22, 25))
      + (v146 ^ v22 & (v138 ^ v146))
      + v158
      + 1508970993;
  v24 = v23 + v15;
  v159 = v23 + (__ROR4__(v171, 2) ^ __ROR4__(v171, 13) ^ __ROR4__(v171, 22)) + (v20 & v171 | v17 & (v20 | v171));
  v25 = v146
      + v219[4]
      + (__ROR4__(v24, 6) ^ __ROR4__(v24, 11) ^ __ROR4__(v24, 25))
      + (v138 ^ v24 & (v22 ^ v138))
      - 1841331548;
  v26 = v25 + v17;
  v27 = v25 + (__ROR4__(v159, 2) ^ __ROR4__(v159, 13) ^ __ROR4__(v159, 22)) + (v159 & v171 | v20 & (v159 | v171));
  v28 = v138
      + v219[5]
      + (__ROR4__(v26, 6) ^ __ROR4__(v26, 11) ^ __ROR4__(v26, 25))
      + (v22 ^ v26 & (v22 ^ v24))
      - 1424204075;
  v29 = v28 + v20;
  v147 = v27;
  v30 = v28 + (__ROR4__(v27, 2) ^ __ROR4__(v27, 13) ^ __ROR4__(v27, 22)) + (v27 & v159 | v171 & (v27 | v159));
  v31 = v22
      + v219[6]
      + (__ROR4__(v29, 6) ^ __ROR4__(v29, 11) ^ __ROR4__(v29, 25))
      + (v24 ^ v29 & (v24 ^ v26))
      - 670586216;
  v172 = v31 + v171;
  v32 = v31 + (__ROR4__(v30, 2) ^ __ROR4__(v30, 13) ^ __ROR4__(v30, 22)) + (v30 & v147 | v159 & (v30 | v147));
  v33 = v24
      + v219[7]
      + (__ROR4__(v172, 6) ^ __ROR4__(v172, 11) ^ __ROR4__(v172, 25))
      + (v26 ^ v172 & (v29 ^ v26))
      + 310598401;
  v160 = v33 + v159;
  v34 = v33 + (__ROR4__(v32, 2) ^ __ROR4__(v32, 13) ^ __ROR4__(v32, 22)) + (v32 & v30 | v147 & (v32 | v30));
  v35 = v219[8]
      + (__ROR4__(v160, 6) ^ __ROR4__(v160, 11) ^ __ROR4__(v160, 25))
      + (v29 ^ v160 & (v29 ^ v172))
      + v26
      + 607225278;
  v148 = v35 + v147;
  v36 = v35 + (__ROR4__(v34, 2) ^ __ROR4__(v34, 13) ^ __ROR4__(v34, 22)) + (v32 & v34 | v30 & (v32 | v34));
  v37 = v219[9]
      + (__ROR4__(v148, 6) ^ __ROR4__(v148, 11) ^ __ROR4__(v148, 25))
      + (v172 ^ v148 & (v160 ^ v172))
      + v29
      + 1426881987;
  v139 = v37 + v30;
  v38 = v37 + (__ROR4__(v36, 2) ^ __ROR4__(v36, 13) ^ __ROR4__(v36, 22)) + (v34 & v36 | v32 & (v34 | v36));
  v39 = v219[10]
      + (__ROR4__(v139, 6) ^ __ROR4__(v139, 11) ^ __ROR4__(v139, 25))
      + (v160 ^ v139 & (v148 ^ v160))
      + v172
      + 1925078388;
  v40 = v39 + v32;
  v173 = v39 + (__ROR4__(v38, 2) ^ __ROR4__(v38, 13) ^ __ROR4__(v38, 22)) + (v38 & v36 | v34 & (v38 | v36));
  v41 = v219[11]
      + (__ROR4__(v40, 6) ^ __ROR4__(v40, 11) ^ __ROR4__(v40, 25))
      + (v148 ^ v40 & (v139 ^ v148))
      + v160
      - 2132889090;
  v42 = v41 + v34;
  v161 = v41 + (__ROR4__(v173, 2) ^ __ROR4__(v173, 13) ^ __ROR4__(v173, 22)) + (v38 & v173 | v36 & (v38 | v173));
  v43 = v148
      + v220[0]
      + (__ROR4__(v42, 6) ^ __ROR4__(v42, 11) ^ __ROR4__(v42, 25))
      + (v139 ^ v42 & (v40 ^ v139))
      - 1680079193;
  v44 = v43 + v36;
  v45 = v43 + (__ROR4__(v161, 2) ^ __ROR4__(v161, 13) ^ __ROR4__(v161, 22)) + (v161 & v173 | v38 & (v161 | v173));
  v46 = v139
      + v220[1]
      + (__ROR4__(v44, 6) ^ __ROR4__(v44, 11) ^ __ROR4__(v44, 25))
      + (v40 ^ v44 & (v40 ^ v42))
      - 1046744716;
  v47 = v46 + v38;
  v149 = v45;
  v48 = v46 + (__ROR4__(v45, 2) ^ __ROR4__(v45, 13) ^ __ROR4__(v45, 22)) + (v45 & v161 | v173 & (v45 | v161));
  v49 = v40
      + v220[2]
      + (__ROR4__(v47, 6) ^ __ROR4__(v47, 11) ^ __ROR4__(v47, 25))
      + (v42 ^ v47 & (v42 ^ v44))
      - 459576895;
  v174 = v49 + v173;
  v204 = v49 + (__ROR4__(v48, 2) ^ __ROR4__(v48, 13) ^ __ROR4__(v48, 22)) + (v48 & v149 | v161 & (v48 | v149));
  v50 = v42
      + v220[3]
      + (__ROR4__(v174, 6) ^ __ROR4__(v174, 11) ^ __ROR4__(v174, 25))
      + (v44 ^ v174 & (v47 ^ v44))
      - 272742522;
  v162 = v50 + v161;
  v51 = v50 + (__ROR4__(v204, 2) ^ __ROR4__(v204, 13) ^ __ROR4__(v204, 22)) + (v204 & v48 | v149 & (v204 | v48));
  v52 = v44
      + v220[4]
      + (__ROR4__(v162, 6) ^ __ROR4__(v162, 11) ^ __ROR4__(v162, 25))
      + (v47 ^ v162 & (v47 ^ v174))
      + 264347078;
  v150 = v52 + v149;
  v53 = v52 + (__ROR4__(v51, 2) ^ __ROR4__(v51, 13) ^ __ROR4__(v51, 22)) + (v204 & v51 | v48 & (v204 | v51));
  v54 = v220[5]
      + (__ROR4__(v150, 6) ^ __ROR4__(v150, 11) ^ __ROR4__(v150, 25))
      + (v174 ^ v150 & (v162 ^ v174))
      + v47
      + 604807628;
  v55 = v54 + v48;
  v56 = v54 + (__ROR4__(v53, 2) ^ __ROR4__(v53, 13) ^ __ROR4__(v53, 22)) + (v51 & v53 | v204 & (v51 | v53));
  v57 = v220[6]
      + (__ROR4__(v55, 6) ^ __ROR4__(v55, 11) ^ __ROR4__(v55, 25))
      + (v162 ^ v55 & (v150 ^ v162))
      + v174
      + 770255983;
  v205 = v57 + v204;
  v175 = v57 + (__ROR4__(v56, 2) ^ __ROR4__(v56, 13) ^ __ROR4__(v56, 22)) + (v56 & v53 | v51 & (v56 | v53));
  v58 = __ROR4__(v205, 11) ^ __ROR4__(v205, 25);
  v59 = __ROR4__(v205, 6);
  v60 = v162 + v221 + (v59 ^ v58) + (v150 ^ v205 & (v55 ^ v150)) + 1249150122 + v51;
  v163 = v162
       + v221
       + (v59 ^ v58)
       + (v150 ^ v205 & (v55 ^ v150))
       + 1249150122
       + (__ROR4__(v175, 2) ^ __ROR4__(v175, 13) ^ __ROR4__(v175, 22))
       + (v56 & v175 | v53 & (v56 | v175));
  v61 = v222
      + (__ROR4__(v60, 6) ^ __ROR4__(v60, 11) ^ __ROR4__(v60, 25))
      + (v55 ^ v60 & (v205 ^ v55))
      + v150
      + 1555081692;
  v62 = v61 + v53;
  v151 = v61 + (__ROR4__(v163, 2) ^ __ROR4__(v163, 13) ^ __ROR4__(v163, 22)) + (v163 & v175 | v56 & (v163 | v175));
  v63 = v55
      + v223
      + (__ROR4__(v62, 6) ^ __ROR4__(v62, 11) ^ __ROR4__(v62, 25))
      + (v205 ^ v62 & (v205 ^ v60))
      + 1996064986;
  v64 = v63 + v56;
  v65 = v63 + (__ROR4__(v151, 2) ^ __ROR4__(v151, 13) ^ __ROR4__(v151, 22)) + (v151 & v163 | v175 & (v151 | v163));
  v66 = v205
      + v224
      + (__ROR4__(v64, 6) ^ __ROR4__(v64, 11) ^ __ROR4__(v64, 25))
      + (v60 ^ v64 & (v60 ^ v62))
      - 1740746414;
  v176 = v66 + v175;
  v206 = v66 + (__ROR4__(v65, 2) ^ __ROR4__(v65, 13) ^ __ROR4__(v65, 22)) + (v65 & v151 | v163 & (v65 | v151));
  v67 = v60
      + v225
      + (__ROR4__(v176, 6) ^ __ROR4__(v176, 11) ^ __ROR4__(v176, 25))
      + (v62 ^ v176 & (v64 ^ v62))
      - 1473132947;
  v164 = v67 + v163;
  v68 = v67 + (__ROR4__(v206, 2) ^ __ROR4__(v206, 13) ^ __ROR4__(v206, 22)) + (v206 & v65 | v151 & (v206 | v65));
  v69 = v62
      + v226
      + (__ROR4__(v164, 6) ^ __ROR4__(v164, 11) ^ __ROR4__(v164, 25))
      + (v64 ^ v164 & (v64 ^ v176))
      - 1341970488;
  v152 = v69 + v151;
  v70 = v69 + (__ROR4__(v68, 2) ^ __ROR4__(v68, 13) ^ __ROR4__(v68, 22)) + (v206 & v68 | v65 & (v206 | v68));
  v71 = v227
      + (__ROR4__(v152, 6) ^ __ROR4__(v152, 11) ^ __ROR4__(v152, 25))
      + (v176 ^ v152 & (v164 ^ v176))
      + v64
      - 1084653625;
  v72 = v71 + v65;
  v73 = v71 + (__ROR4__(v70, 2) ^ __ROR4__(v70, 13) ^ __ROR4__(v70, 22)) + (v68 & v70 | v206 & (v68 | v70));
  v74 = v228
      + (__ROR4__(v72, 6) ^ __ROR4__(v72, 11) ^ __ROR4__(v72, 25))
      + (v164 ^ v72 & (v152 ^ v164))
      + v176
      - 958395405;
  v207 = v74 + v206;
  v177 = v74 + (__ROR4__(v73, 2) ^ __ROR4__(v73, 13) ^ __ROR4__(v73, 22)) + (v73 & v70 | v68 & (v73 | v70));
  v75 = __ROR4__(v207, 11) ^ __ROR4__(v207, 25);
  v76 = __ROR4__(v207, 6);
  v77 = v164 + v229 + (v76 ^ v75) + (v152 ^ v207 & (v72 ^ v152)) - 710438585 + v68;
  v165 = v164
       + v229
       + (v76 ^ v75)
       + (v152 ^ v207 & (v72 ^ v152))
       - 710438585
       + (__ROR4__(v177, 2) ^ __ROR4__(v177, 13) ^ __ROR4__(v177, 22))
       + (v73 & v177 | v70 & (v73 | v177));
  v78 = v230
      + (__ROR4__(v77, 6) ^ __ROR4__(v77, 11) ^ __ROR4__(v77, 25))
      + (v72 ^ v77 & (v207 ^ v72))
      + v152
      + 113926993;
  v79 = v78 + v70;
  v153 = v78 + (__ROR4__(v165, 2) ^ __ROR4__(v165, 13) ^ __ROR4__(v165, 22)) + (v165 & v177 | v73 & (v165 | v177));
  v80 = v72
      + v231
      + (__ROR4__(v79, 6) ^ __ROR4__(v79, 11) ^ __ROR4__(v79, 25))
      + (v207 ^ v79 & (v207 ^ v77))
      + 338241895;
  v81 = v80 + v73;
  v140 = v80 + (__ROR4__(v153, 2) ^ __ROR4__(v153, 13) ^ __ROR4__(v153, 22)) + (v153 & v165 | v177 & (v153 | v165));
  v82 = v207 + v232 + (__ROR4__(v81, 6) ^ __ROR4__(v81, 11) ^ __ROR4__(v81, 25)) + (v77 ^ v81 & (v77 ^ v79)) + 666307205;
  v178 = v82 + v177;
  v208 = v82 + (__ROR4__(v140, 2) ^ __ROR4__(v140, 13) ^ __ROR4__(v140, 22)) + (v140 & v153 | v165 & (v140 | v153));
  v83 = v77
      + v233
      + (__ROR4__(v178, 6) ^ __ROR4__(v178, 11) ^ __ROR4__(v178, 25))
      + (v79 ^ v178 & (v81 ^ v79))
      + 773529912;
  v166 = v83 + v165;
  v198 = v83 + (__ROR4__(v208, 2) ^ __ROR4__(v208, 13) ^ __ROR4__(v208, 22)) + (v208 & v140 | v153 & (v208 | v140));
  v84 = v79
      + v234
      + (__ROR4__(v166, 6) ^ __ROR4__(v166, 11) ^ __ROR4__(v166, 25))
      + (v81 ^ v166 & (v81 ^ v178))
      + 1294757372;
  v85 = v84 + v153;
  v191 = v84 + (__ROR4__(v198, 2) ^ __ROR4__(v198, 13) ^ __ROR4__(v198, 22)) + (v208 & v198 | v140 & (v208 | v198));
  v86 = v235
      + (__ROR4__(v85, 6) ^ __ROR4__(v84 + v153, 11) ^ __ROR4__(v84 + v153, 25))
      + (v178 ^ v85 & (v166 ^ v178))
      + v81
      + 1396182291;
  v141 = v86 + v140;
  v185 = v86 + (__ROR4__(v191, 2) ^ __ROR4__(v191, 13) ^ __ROR4__(v191, 22)) + (v198 & v191 | v208 & (v198 | v191));
  v87 = __ROR4__(v141, 11) ^ __ROR4__(v141, 25);
  v88 = __ROR4__(v141, 6);
  v89 = v178 + v236 + (v88 ^ v87) + (v166 ^ v141 & ((v84 + v153) ^ v166)) + 1695183700 + v208;
  v179 = v178
       + v236
       + (v88 ^ v87)
       + (v166 ^ v141 & ((v84 + v153) ^ v166))
       + 1695183700
       + (__ROR4__(v185, 2) ^ __ROR4__(v185, 13) ^ __ROR4__(v185, 22))
       + (v185 & v191 | v198 & (v185 | v191));
  v90 = v237
      + (__ROR4__(v89, 6) ^ __ROR4__(v89, 11) ^ __ROR4__(v89, 25))
      + (v85 ^ v89 & (v141 ^ v85))
      + v166
      + 1986661051;
  v167 = v90 + (__ROR4__(v179, 2) ^ __ROR4__(v179, 13) ^ __ROR4__(v179, 22)) + (v185 & v179 | v191 & (v185 | v179));
  v91 = v84
      + v153
      + v238
      + (__ROR4__(v90 + v198, 6) ^ __ROR4__(v90 + v198, 11) ^ __ROR4__(v90 + v198, 25))
      + (v141 ^ (v90 + v198) & (v89 ^ v141))
      - 2117940946;
  v92 = v91 + v191;
  v93 = v91 + (__ROR4__(v167, 2) ^ __ROR4__(v167, 13) ^ __ROR4__(v167, 22)) + (v167 & v179 | v185 & (v167 | v179));
  v94 = v141
      + v239
      + (__ROR4__(v92, 6) ^ __ROR4__(v92, 11) ^ __ROR4__(v92, 25))
      + (v89 ^ v92 & (v89 ^ (v90 + v198)))
      - 1838011259;
  v186 = v94 + v185;
  v142 = v94 + (__ROR4__(v93, 2) ^ __ROR4__(v93, 13) ^ __ROR4__(v93, 22)) + (v93 & v167 | v179 & (v93 | v167));
  v95 = v89
      + v240
      + (__ROR4__(v186, 6) ^ __ROR4__(v186, 11) ^ __ROR4__(v186, 25))
      + ((v90 + v198) ^ v186 & ((v90 + v198) ^ v92))
      - 1564481375;
  v180 = v95 + v179;
  v209 = v95 + (__ROR4__(v142, 2) ^ __ROR4__(v142, 13) ^ __ROR4__(v142, 22)) + (v142 & v93 | v167 & (v142 | v93));
  v96 = v241
      + (__ROR4__(v180, 6) ^ __ROR4__(v180, 11) ^ __ROR4__(v180, 25))
      + (v92 ^ v180 & (v186 ^ v92))
      + v90
      + v198
      - 1474664885;
  v199 = v96 + (__ROR4__(v209, 2) ^ __ROR4__(v209, 13) ^ __ROR4__(v209, 22)) + (v209 & v142 | v93 & (v209 | v142));
  v97 = v92
      + v242
      + (__ROR4__(v96 + v167, 6) ^ __ROR4__(v96 + v167, 11) ^ __ROR4__(v96 + v167, 25))
      + (v186 ^ (v96 + v167) & (v186 ^ v180))
      - 1035236496;
  v154 = v97 + v93;
  v192 = v97 + (__ROR4__(v199, 2) ^ __ROR4__(v199, 13) ^ __ROR4__(v199, 22)) + (v209 & v199 | v142 & (v209 | v199));
  v98 = __ROR4__(v97 + v93, 11) ^ __ROR4__(v97 + v93, 25);
  v99 = __ROR4__(v97 + v93, 6);
  v100 = v186 + v243 + (v99 ^ v98) + (v180 ^ (v97 + v93) & ((v96 + v167) ^ v180)) - 949202525 + v142;
  v187 = v186
       + v243
       + (v99 ^ v98)
       + (v180 ^ v154 & ((v96 + v167) ^ v180))
       - 949202525
       + (__ROR4__(v192, 2) ^ __ROR4__(v192, 13) ^ __ROR4__(v192, 22))
       + (v199 & v192 | v209 & (v199 | v192));
  v101 = v244
       + (__ROR4__(v100, 6) ^ __ROR4__(v100, 11) ^ __ROR4__(v100, 25))
       + ((v96 + v167) ^ v100 & (v154 ^ (v96 + v167)))
       + v180
       - 778901479;
  v181 = v101 + (__ROR4__(v187, 2) ^ __ROR4__(v187, 13) ^ __ROR4__(v187, 22)) + (v187 & v192 | v199 & (v187 | v192));
  v102 = v96
       + v167
       + v245
       + (__ROR4__(v101 + v209, 6) ^ __ROR4__(v101 + v209, 11) ^ __ROR4__(v101 + v209, 25))
       + (v154 ^ (v101 + v209) & (v100 ^ v154))
       - 694614492;
  v103 = v102 + v199;
  v104 = v102 + (__ROR4__(v181, 2) ^ __ROR4__(v181, 13) ^ __ROR4__(v181, 22)) + (v187 & v181 | v192 & (v187 | v181));
  v105 = v154
       + v246
       + (__ROR4__(v103, 6) ^ __ROR4__(v103, 11) ^ __ROR4__(v103, 25))
       + (v100 ^ v103 & ((v101 + v209) ^ v100))
       - 200395387;
  v193 = v105 + v192;
  v155 = v105 + (__ROR4__(v104, 2) ^ __ROR4__(v104, 13) ^ __ROR4__(v104, 22)) + (v104 & v181 | v187 & (v104 | v181));
  v106 = v100
       + v247
       + (__ROR4__(v193, 6) ^ __ROR4__(v193, 11) ^ __ROR4__(v193, 25))
       + ((v101 + v209) ^ v193 & ((v101 + v209) ^ v103))
       + 275423344;
  v188 = v106 + v187;
  v143 = v106 + (__ROR4__(v155, 2) ^ __ROR4__(v155, 13) ^ __ROR4__(v155, 22)) + (v155 & v104 | v181 & (v155 | v104));
  v107 = v101
       + v209
       + v248
       + (__ROR4__(v188, 6) ^ __ROR4__(v188, 11) ^ __ROR4__(v188, 25))
       + (v103 ^ v188 & (v103 ^ v193))
       + 430227734;
  v108 = v107 + v181;
  v210 = v107 + (__ROR4__(v143, 2) ^ __ROR4__(v143, 13) ^ __ROR4__(v143, 22)) + (v143 & v155 | v104 & (v143 | v155));
  v109 = v249
       + (__ROR4__(v108, 6) ^ __ROR4__(v107 + v181, 11) ^ __ROR4__(v107 + v181, 25))
       + (v193 ^ v108 & (v188 ^ v193))
       + v103
       + 506948616;
  v168 = v109 + v104;
  v200 = v109 + (__ROR4__(v210, 2) ^ __ROR4__(v210, 13) ^ __ROR4__(v210, 22)) + (v210 & v143 | v155 & (v210 | v143));
  v110 = v250
       + (__ROR4__(v109 + v104, 6) ^ __ROR4__(v109 + v104, 11) ^ __ROR4__(v109 + v104, 25))
       + (v188 ^ (v109 + v104) & (v188 ^ (v107 + v181)))
       + v193
       + 659060556;
  v111 = v110 + v155;
  v194 = v110 + (__ROR4__(v200, 2) ^ __ROR4__(v200, 13) ^ __ROR4__(v200, 22)) + (v210 & v200 | v143 & (v210 | v200));
  v112 = v251
       + (__ROR4__(v111, 6) ^ __ROR4__(v110 + v155, 11) ^ __ROR4__(v110 + v155, 25))
       + (v108 ^ v111 & (v168 ^ v108))
       + v188
       + 883997877;
  v189 = v112 + (__ROR4__(v194, 2) ^ __ROR4__(v194, 13) ^ __ROR4__(v194, 22)) + (v200 & v194 | v210 & (v200 | v194));
  v113 = v107
       + v181
       + v252
       + (__ROR4__(v112 + v143, 6) ^ __ROR4__(v112 + v143, 11) ^ __ROR4__(v112 + v143, 25))
       + (v168 ^ (v112 + v143) & (v111 ^ v168))
       + 958139571;
  v114 = v113 + v210;
  v115 = v113 + (__ROR4__(v189, 2) ^ __ROR4__(v189, 13) ^ __ROR4__(v189, 22)) + (v189 & v194 | v200 & (v189 | v194));
  v116 = v168
       + v253
       + (__ROR4__(v114, 6) ^ __ROR4__(v114, 11) ^ __ROR4__(v114, 25))
       + (v111 ^ v114 & ((v112 + v143) ^ v111))
       + 1322822218;
  v201 = v116 + v200;
  v169 = v116 + (__ROR4__(v115, 2) ^ __ROR4__(v115, 13) ^ __ROR4__(v115, 22)) + (v189 & v115 | v194 & (v189 | v115));
  v117 = v111
       + v254
       + (__ROR4__(v201, 6) ^ __ROR4__(v201, 11) ^ __ROR4__(v201, 25))
       + ((v112 + v143) ^ v201 & (v114 ^ (v112 + v143)))
       + 1537002063;
  v195 = v117 + v194;
  v156 = v117 + (__ROR4__(v169, 2) ^ __ROR4__(v169, 13) ^ __ROR4__(v169, 22)) + (v169 & v115 | v189 & (v169 | v115));
  v118 = v112
       + v143
       + v255
       + (__ROR4__(v195, 6) ^ __ROR4__(v195, 11) ^ __ROR4__(v195, 25))
       + (v114 ^ v195 & (v114 ^ v201))
       + 1747873779;
  v144 = v118 + (__ROR4__(v156, 2) ^ __ROR4__(v156, 13) ^ __ROR4__(v156, 22)) + (v156 & v169 | v115 & (v156 | v169));
  v119 = v114
       + v256
       + (__ROR4__(v118 + v189, 6) ^ __ROR4__(v118 + v189, 11) ^ __ROR4__(v118 + v189, 25))
       + (v201 ^ (v118 + v189) & (v201 ^ v195))
       + 1955562222;
  v182 = v119 + v115;
  v211 = v119 + (__ROR4__(v144, 2) ^ __ROR4__(v144, 13) ^ __ROR4__(v144, 22)) + (v144 & v156 | v169 & (v144 | v156));
  v120 = __ROR4__(v119 + v115, 11) ^ __ROR4__(v119 + v115, 25);
  v121 = __ROR4__(v119 + v115, 6);
  v122 = v201 + v257 + (v121 ^ v120) + (v195 ^ (v119 + v115) & ((v118 + v189) ^ v195)) + 2024104815 + v169;
  v123 = v201
       + v257
       + (v121 ^ v120)
       + (v195 ^ v182 & ((v118 + v189) ^ v195))
       + 2024104815
       + (__ROR4__(v211, 2) ^ __ROR4__(v211, 13) ^ __ROR4__(v211, 22))
       + (v211 & v144 | v156 & (v211 | v144));
  v124 = v195
       + v258
       + (__ROR4__(v122, 6) ^ __ROR4__(v122, 11) ^ __ROR4__(v122, 25))
       + ((v118 + v189) ^ v122 & ((v118 + v189) ^ v182))
       - 2067236844;
  v125 = v124 + v156;
  v196 = v124 + (__ROR4__(v123, 2) ^ __ROR4__(v123, 13) ^ __ROR4__(v123, 22)) + (v211 & v123 | v144 & (v211 | v123));
  v126 = v118
       + v189
       + v259
       + (__ROR4__(v125, 6) ^ __ROR4__(v124 + v156, 11) ^ __ROR4__(v124 + v156, 25))
       + (v182 ^ v125 & (v122 ^ v182))
       - 1933114872;
  v127 = v126 + v144;
  v128 = v126 + (__ROR4__(v196, 2) ^ __ROR4__(v196, 13) ^ __ROR4__(v196, 22)) + (v123 & v196 | v211 & (v123 | v196));
  v129 = v182
       + v260
       + (__ROR4__(v127, 6) ^ __ROR4__(v127, 11) ^ __ROR4__(v127, 25))
       + (v122 ^ v127 & ((v124 + v156) ^ v122))
       - 1866530822;
  v212 = v129 + v211;
  v183 = v129 + (__ROR4__(v128, 2) ^ __ROR4__(v128, 13) ^ __ROR4__(v128, 22)) + (v128 & v196 | v123 & (v128 | v196));
  v130 = v122
       + v261
       + (__ROR4__(v212, 6) ^ __ROR4__(v212, 11) ^ __ROR4__(v212, 25))
       + (v125 ^ v212 & (v127 ^ v125))
       - 1538233109;
  v202 = v130 + v123;
  v131 = v262
       + (__ROR4__(v130 + v123, 6) ^ __ROR4__(v130 + v123, 11) ^ __ROR4__(v130 + v123, 25))
       + (v127 ^ (v130 + v123) & (v212 ^ v127))
       + v125
       - 1090935817;
  v132 = v130 + (__ROR4__(v183, 2) ^ __ROR4__(v183, 13) ^ __ROR4__(v183, 22)) + (v128 & v183 | v196 & (v128 | v183));
  v133 = v131 + (__ROR4__(v132, 2) ^ __ROR4__(v132, 13) ^ __ROR4__(v132, 22)) + (v132 & v183 | v128 & (v132 | v183));
  v134 = v127
       + v263
       + (__ROR4__(v131 + v196, 6) ^ __ROR4__(v131 + v196, 11) ^ __ROR4__(v131 + v196, 25))
       + (v212 ^ (v131 + v196) & (v212 ^ v202))
       - 965641998;
  a2[2] += v134 + (__ROR4__(v133, 2) ^ __ROR4__(v133, 13) ^ __ROR4__(v133, 22)) + (v133 & v132 | v183 & (v133 | v132));
  a2[4] += v132;
  a2[5] += v183;
  a2[6] += v134 + v128;
  a2[7] += v131 + v196;
  a2[3] += v133;
  a2[8] += v202;
  a2[9] += v212;
  return 0;
}

//----- (00412910) --------------------------------------------------------
int __cdecl sub_412910(_DWORD *a1)
{
  a1[10] = 0;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 1779033703;
  a1[3] = -1150833019;
  a1[4] = 1013904242;
  a1[5] = -1521486534;
  a1[6] = 1359893119;
  a1[7] = -1694144372;
  a1[8] = 528734635;
  a1[9] = 1541459225;
  return 0;
}

//----- (00412960) --------------------------------------------------------
int __cdecl sub_412960(_DWORD *a1, char *Src, int a3)
{
  unsigned int v5; // ebx
  int v6; // eax
  int v7; // edx
  size_t v8; // edi
  bool v9; // cf

  if ( a1[10] > 0x40u )
    return 16;
  v5 = a3;
  if ( !a3 )
    return 0;
  while ( 1 )
  {
    v6 = a1[10];
    if ( v6 || v5 < 0x40 )
      break;
    sub_410CF0((int)Src, a1);
    sub_413B90(0x108u);
    if ( v7 )
      return v7;
    *(_QWORD *)a1 += 512i64;
    Src += 64;
    v5 -= 64;
LABEL_13:
    if ( !v5 )
      return 0;
  }
  v8 = 64 - v6;
  if ( v5 < 64 - v6 )
    v8 = v5;
  memcpy((char *)a1 + v6 + 44, Src, v8);
  a1[10] += v8;
  Src += v8;
  v5 -= v8;
  if ( a1[10] != 64 )
    goto LABEL_13;
  sub_410CF0((int)(a1 + 11), a1);
  sub_413B90(0x108u);
  if ( !v7 )
  {
    v9 = __CFADD__(*a1, 512);
    *a1 += 512;
    a1[10] = 0;
    a1[1] += v9;
    goto LABEL_13;
  }
  return v7;
}
// 4129C5: variable 'v7' is possibly undefined

//----- (00412A60) --------------------------------------------------------
int __cdecl sub_412A60(_DWORD *a1, _BYTE *a2)
{
  unsigned int v2; // eax
  bool v4; // cf
  unsigned int v5; // eax
  char v6; // cl
  char v7; // dl
  char v8; // al
  char v9; // cl
  char v10; // al
  char v11; // dl
  char v12; // cl

  v2 = a1[10];
  if ( v2 >= 0x40 )
    return 16;
  v4 = __CFADD__(8 * v2, *a1);
  *a1 += 8 * v2;
  a1[1] += v4;
  *((_BYTE *)a1 + v2 + 44) = 0x80;
  v5 = ++a1[10];
  if ( v5 > 0x38 )
  {
    for ( ; v5 < 0x40; v5 = a1[10] )
    {
      *((_BYTE *)a1 + v5 + 44) = 0;
      ++a1[10];
    }
    sub_410CF0((int)(a1 + 11), a1);
    sub_413B90(0x108u);
    a1[10] = 0;
  }
  for ( ; a1[10] < 0x38u; ++a1[10] )
    *((_BYTE *)a1 + a1[10] + 44) = 0;
  v6 = *((_BYTE *)a1 + 6);
  v7 = *((_BYTE *)a1 + 5);
  *((_BYTE *)a1 + 100) = *((_BYTE *)a1 + 7);
  v8 = *((_BYTE *)a1 + 4);
  *((_BYTE *)a1 + 101) = v6;
  v9 = *((_BYTE *)a1 + 3);
  *((_BYTE *)a1 + 103) = v8;
  v10 = *((_BYTE *)a1 + 1);
  *((_BYTE *)a1 + 102) = v7;
  v11 = *((_BYTE *)a1 + 2);
  *((_BYTE *)a1 + 104) = v9;
  v12 = *(_BYTE *)a1;
  *((_BYTE *)a1 + 106) = v10;
  *((_BYTE *)a1 + 105) = v11;
  *((_BYTE *)a1 + 107) = v12;
  sub_410CF0((int)(a1 + 11), a1);
  sub_413B90(0x108u);
  *a2 = *((_BYTE *)a1 + 11);
  a2[1] = *((_BYTE *)a1 + 10);
  a2[2] = *((_BYTE *)a1 + 9);
  a2[3] = *((_BYTE *)a1 + 8);
  a2[4] = *((_BYTE *)a1 + 15);
  a2[5] = *((_BYTE *)a1 + 14);
  a2[6] = *((_BYTE *)a1 + 13);
  a2[7] = *((_BYTE *)a1 + 12);
  a2[8] = *((_BYTE *)a1 + 19);
  a2[9] = *((_BYTE *)a1 + 18);
  a2[10] = *((_BYTE *)a1 + 17);
  a2[11] = *((_BYTE *)a1 + 16);
  a2[12] = *((_BYTE *)a1 + 23);
  a2[13] = *((_BYTE *)a1 + 22);
  a2[14] = *((_BYTE *)a1 + 21);
  a2[15] = *((_BYTE *)a1 + 20);
  a2[16] = *((_BYTE *)a1 + 27);
  a2[17] = *((_BYTE *)a1 + 26);
  a2[18] = *((_BYTE *)a1 + 25);
  a2[19] = *((_BYTE *)a1 + 24);
  a2[20] = *((_BYTE *)a1 + 31);
  a2[21] = *((_BYTE *)a1 + 30);
  a2[22] = *((_BYTE *)a1 + 29);
  a2[23] = *((_BYTE *)a1 + 28);
  a2[24] = *((_BYTE *)a1 + 35);
  a2[25] = *((_BYTE *)a1 + 34);
  a2[26] = *((_BYTE *)a1 + 33);
  a2[27] = *((_BYTE *)a1 + 32);
  a2[28] = *((_BYTE *)a1 + 39);
  a2[29] = *((_BYTE *)a1 + 38);
  a2[30] = *((_BYTE *)a1 + 37);
  a2[31] = *((_BYTE *)a1 + 36);
  memset(a1, 0, 0xD0u);
  return 0;
}

//----- (00412C50) --------------------------------------------------------
int sub_412C50()
{
  int result; // eax
  int v1; // esi
  unsigned int v2; // edx
  void **v3; // ecx
  int *v4; // ecx

  result = 0;
  v1 = (char *)dword_4A9708 - (char *)&off_480F98;
LABEL_2:
  v2 = 40;
  v3 = &off_480F98;
  while ( v2 >= 4 )
  {
    if ( *(void **)((char *)v3 + v1) != *v3 )
    {
      ++result;
      v1 += 40;
      if ( result < 32 )
        goto LABEL_2;
      result = 0;
      v4 = dword_4A9708;
      while ( *v4 )
      {
        v4 += 10;
        ++result;
        if ( (int)v4 >= (int)&dword_4A9C08 )
          return -1;
      }
      qmemcpy(&dword_4A9708[10 * result], &off_480F98, 0x28u);
      return result;
    }
    v2 -= 4;
    ++v3;
  }
  return result;
}
// 480F98: using guessed type void *off_480F98;
// 4A9708: using guessed type int dword_4A9708[];
// 4A9C08: using guessed type int dword_4A9C08;

//----- (00412CD0) --------------------------------------------------------
int __usercall sub_412CD0@<eax>(_BYTE *a1@<eax>)
{
  int result; // eax
  char *v3; // edi
  unsigned int v4; // edx
  _DWORD *v5; // ecx
  int *v6; // ecx

  result = 0;
  v3 = (char *)((char *)dword_4A8A88 - a1);
LABEL_2:
  v4 = 100;
  v5 = a1;
  while ( v4 >= 4 )
  {
    if ( *(_DWORD *)((char *)v5 + (_DWORD)v3) != *v5 )
    {
      ++result;
      v3 += 100;
      if ( result < 32 )
        goto LABEL_2;
      result = 0;
      v6 = dword_4A8A88;
      while ( *v6 )
      {
        v6 += 25;
        ++result;
        if ( (int)v6 >= (int)dword_4A9708 )
          return -1;
      }
      qmemcpy(&dword_4A8A88[25 * result], a1, 0x64u);
      return result;
    }
    v4 -= 4;
    ++v5;
  }
  return result;
}
// 4A8A88: using guessed type int dword_4A8A88[];
// 4A9708: using guessed type int dword_4A9708[];

//----- (00412D40) --------------------------------------------------------
int __cdecl sub_412D40(int a1, int a2, int a3, int a4)
{
  int v5; // eax
  unsigned int i; // ebx
  int v7; // ecx
  int v8; // eax
  int v9; // edx
  int v10; // eax
  int v11; // edx
  int v12; // ecx
  int v13; // eax
  int v14; // ecx
  int v15; // edx
  int v16; // edx
  int *v17; // ebx
  char *v18; // edx
  int *v19; // eax
  int v20; // esi
  int v21; // ecx
  int *v22; // esi
  int v23; // edi
  __int16 v24; // ax
  int *v25; // esi
  int v26; // edi
  __int16 v27; // ax
  int *v28; // [esp+Ch] [ebp-14h]
  int v29; // [esp+Ch] [ebp-14h]
  int *v30; // [esp+14h] [ebp-Ch] BYREF
  int v31; // [esp+18h] [ebp-8h]

  v30 = (int *)a4;
  if ( (unsigned int)(a2 - 8) > 0x30 )
    return 3;
  if ( a3 && a3 != 16 )
    return 4;
  v5 = 0;
  v28 = (int *)(a4 + 4096);
  for ( i = 0; i < 18; ++i )
  {
    v7 = *(unsigned __int8 *)(v5 + a1);
    v8 = v5 + 1;
    if ( v8 == a2 )
      v8 = 0;
    v9 = *(unsigned __int8 *)(v8 + a1);
    v10 = v8 + 1;
    v11 = (v7 << 8) | v9;
    if ( v10 == a2 )
      v10 = 0;
    v12 = *(unsigned __int8 *)(v10 + a1);
    v13 = v10 + 1;
    v14 = (v11 << 8) | v12;
    if ( v13 == a2 )
      v13 = 0;
    v15 = *(unsigned __int8 *)(v13 + a1);
    v5 = v13 + 1;
    v16 = (v14 << 8) | v15;
    if ( v5 == a2 )
      v5 = 0;
    *v28++ = v16 ^ dword_481010[i];
  }
  v17 = v30;
  v18 = (char *)(&unk_481058 - (_UNKNOWN *)v30);
  v19 = v30;
  v20 = 4;
  do
  {
    v21 = 256;
    do
    {
      *v19 = *(int *)((char *)v19 + (_DWORD)v18);
      ++v19;
      --v21;
    }
    while ( v21 );
    --v20;
  }
  while ( v20 );
  v30 = 0;
  v31 = 0;
  v22 = v17 + 1025;
  v23 = 9;
  do
  {
    sub_412F50(v17, (unsigned __int8 *)&v30, &v30);
    v24 = v31;
    *(v22 - 1) = HIBYTE(v30) | ((BYTE2(v30) | ((BYTE1(v30) | ((unsigned __int8)v30 << 8)) << 8)) << 8);
    *v22 = HIBYTE(v31) | ((BYTE2(v31) | ((HIBYTE(v24) | ((unsigned __int8)v24 << 8)) << 8)) << 8);
    v22 += 2;
    --v23;
  }
  while ( v23 );
  v25 = v17;
  v29 = 4;
  do
  {
    v26 = 128;
    do
    {
      sub_412F50(v17, (unsigned __int8 *)&v30, &v30);
      v27 = v31;
      *v25 = HIBYTE(v30) | ((BYTE2(v30) | ((BYTE1(v30) | ((unsigned __int8)v30 << 8)) << 8)) << 8);
      v25[1] = HIBYTE(v31) | ((BYTE2(v31) | ((HIBYTE(v27) | ((unsigned __int8)v27 << 8)) << 8)) << 8);
      v25 += 2;
      --v26;
    }
    while ( v26 );
    --v29;
  }
  while ( v29 );
  return 0;
}
// 481010: using guessed type int dword_481010[];

//----- (00412F50) --------------------------------------------------------
int __usercall sub_412F50@<eax>(_DWORD *a1@<eax>, unsigned __int8 *a2@<ecx>, _BYTE *a3)
{
  int v4; // eax
  unsigned int v5; // edx
  int v6; // ebp
  _DWORD *v7; // edi
  unsigned int v8; // eax
  _DWORD *v9; // edi
  unsigned int v10; // ecx
  unsigned int v11; // eax
  int v12; // edx
  int result; // eax

  v4 = a2[3] | ((a2[2] | ((a2[1] | (*a2 << 8)) << 8)) << 8);
  v5 = a2[7] | ((a2[6] | ((a2[5] | (a2[4] << 8)) << 8)) << 8);
  v6 = 0;
  v7 = a1 + 1024;
  do
  {
    v8 = *v7 ^ v4;
    v9 = v7 + 2;
    v10 = *(v9++ - 1) ^ v5 ^ (a1[(unsigned __int8)v8 + 768]
                            + (a1[BYTE1(v8) + 512] ^ (a1[HIBYTE(v8)] + a1[BYTE2(v8) + 256])));
    v11 = *(v9 - 1) ^ v8 ^ (a1[(unsigned __int8)v10 + 768]
                          + (a1[BYTE1(v10) + 512] ^ (a1[HIBYTE(v10)] + a1[BYTE2(v10) + 256])));
    v5 = *v9 ^ v10 ^ (a1[(unsigned __int8)v11 + 768] + (a1[BYTE1(v11) + 512] ^ (a1[HIBYTE(v11)] + a1[BYTE2(v11) + 256])));
    v6 += 4;
    v7 = v9 + 1;
    v4 = (a1[(unsigned __int8)v5 + 768] + (a1[BYTE1(v5) + 512] ^ (a1[HIBYTE(v5)] + a1[BYTE2(v5) + 256]))) ^ v11;
  }
  while ( v6 < 16 );
  v12 = a1[1041] ^ v5;
  result = a1[1040] ^ v4;
  *a3 = HIBYTE(v12);
  a3[1] = BYTE2(v12);
  a3[3] = v12;
  a3[2] = BYTE1(v12);
  a3[4] = HIBYTE(result);
  a3[5] = BYTE2(result);
  a3[6] = BYTE1(result);
  a3[7] = result;
  return result;
}

//----- (004130E0) --------------------------------------------------------
int __cdecl sub_4130E0(unsigned __int8 *a1, _BYTE *a2, _DWORD *a3)
{
  return sub_412F50(a3, a1, a2);
}

//----- (00413110) --------------------------------------------------------
unsigned int __usercall sub_413110@<eax>(_DWORD *a1@<eax>, unsigned __int8 *a2@<edx>, _BYTE *a3)
{
  unsigned int v4; // ecx
  int v5; // eax
  int v6; // ebp
  _DWORD *v7; // edi
  unsigned int v8; // eax
  int v9; // edx
  int v10; // eax
  unsigned int v11; // ecx
  _DWORD *v12; // edi
  unsigned int v13; // eax
  int v14; // ecx
  int v15; // edx
  unsigned int result; // eax

  v4 = a1[1041] ^ (a2[3] | ((a2[2] | ((a2[1] | (*a2 << 8)) << 8)) << 8));
  v5 = a1[1040] ^ (a2[7] | ((a2[6] | ((a2[5] | (a2[4] << 8)) << 8)) << 8));
  v6 = 15;
  v7 = a1 + 1039;
  do
  {
    v8 = (a1[(unsigned __int8)v4 + 768] + (a1[BYTE1(v4) + 512] ^ (a1[HIBYTE(v4)] + a1[BYTE2(v4) + 256]))) ^ v5;
    v9 = a1[(unsigned __int8)v8 + 768] + (a1[BYTE1(v8) + 512] ^ (a1[HIBYTE(v8)] + a1[BYTE2(v8) + 256]));
    v10 = *(v7 - 1) ^ v8;
    v11 = v9 ^ *v7 ^ v4;
    v12 = v7 - 1;
    v13 = (a1[(unsigned __int8)v11 + 768] + (a1[BYTE1(v11) + 512] ^ (a1[HIBYTE(v11)] + a1[BYTE2(v11) + 256]))) ^ v10;
    v14 = *--v12 ^ v11;
    v15 = a1[(unsigned __int8)v13 + 768] + (a1[BYTE1(v13) + 512] ^ (a1[HIBYTE(v13)] + a1[BYTE2(v13) + 256]));
    v5 = *(v12 - 1) ^ v13;
    v6 -= 4;
    v4 = v15 ^ v14;
    v7 = v12 - 2;
  }
  while ( v6 > 0 );
  *a3 = HIBYTE(v5);
  a3[1] = BYTE2(v5);
  a3[3] = v5;
  a3[2] = BYTE1(v5);
  a3[4] = HIBYTE(v4);
  result = v4 >> 8;
  a3[5] = BYTE2(v4);
  a3[6] = BYTE1(v4);
  a3[7] = v4;
  return result;
}

//----- (004132A0) --------------------------------------------------------
unsigned int __cdecl sub_4132A0(unsigned __int8 *a1, _BYTE *a2, _DWORD *a3)
{
  return sub_413110(a3, a1, a2);
}

//----- (004132D0) --------------------------------------------------------
int __cdecl sub_4132D0(int *a1)
{
  if ( *a1 < 8 )
    return 3;
  if ( *a1 > 56 )
    *a1 = 56;
  return 0;
}

//----- (004132F0) --------------------------------------------------------
int __usercall sub_4132F0@<eax>(_BYTE *a1@<eax>)
{
  int result; // eax
  _BYTE *v3; // ecx
  int *v4; // ecx

  result = 0;
  v3 = &unk_4A810C;
  while ( !*((_DWORD *)v3 - 1) || *v3 != a1[4] )
  {
    v3 += 76;
    ++result;
    if ( (int)v3 >= (int)&unk_4A8A8C )
    {
      result = 0;
      v4 = dword_4A8108;
      while ( *v4 )
      {
        v4 += 19;
        ++result;
        if ( (int)v4 >= (int)dword_4A8A88 )
          return -1;
      }
      qmemcpy(&dword_4A8108[19 * result], a1, 0x4Cu);
      return result;
    }
  }
  return result;
}
// 4A8108: using guessed type int dword_4A8108[];
// 4A8A88: using guessed type int dword_4A8A88[];

//----- (00413350) --------------------------------------------------------
int __cdecl sub_413350(unsigned int *a1)
{
  unsigned int v1; // eax
  unsigned int v3; // eax

  v1 = sub_4132F0(&off_47C720);
  *a1 = v1;
  if ( v1 > 0x1F || !dword_4A8108[19 * v1] )
    return 10;
  v3 = sub_412CD0(&off_482058);
  a1[1] = v3;
  if ( v3 > 0x1F || !dword_4A8A88[25 * v3] )
    return 11;
  memset(a1 + 2, 0, 0x80u);
  return 0;
}
// 47C720: using guessed type void *off_47C720;
// 482058: using guessed type char (*off_482058)[4];
// 4A8108: using guessed type int dword_4A8108[];
// 4A8A88: using guessed type int dword_4A8A88[];

//----- (004133C0) --------------------------------------------------------
int __cdecl sub_4133C0(int a1, int a2, int a3)
{
  unsigned int v3; // eax
  int result; // eax
  char v5[212]; // [esp+10h] [ebp-D8h] BYREF

  v3 = *(_DWORD *)(a3 + 4);
  if ( v3 > 0x1F || !dword_4A8A88[25 * v3] )
    return 11;
  result = ((int (__cdecl *)(char *))dword_4A8ADC[25 * v3])(v5);
  if ( !result )
  {
    result = ((int (__cdecl *)(char *, int, int))dword_4A8AE0[25 * *(_DWORD *)(a3 + 4)])(
               v5,
               a3 + 8,
               dword_4A8A90[25 * *(_DWORD *)(a3 + 4)]);
    if ( !result )
    {
      result = ((int (__cdecl *)(char *, int, int))dword_4A8AE0[25 * *(_DWORD *)(a3 + 4)])(v5, a1, a2);
      if ( !result )
        return ((int (__cdecl *)(char *, int))dword_4A8AE4[25 * *(_DWORD *)(a3 + 4)])(v5, a3 + 8);
    }
  }
  return result;
}
// 4A8A88: using guessed type int dword_4A8A88[];
// 4A8A90: using guessed type int dword_4A8A90[];
// 4A8ADC: using guessed type int dword_4A8ADC[];
// 4A8AE0: using guessed type int dword_4A8AE0[];
// 4A8AE4: using guessed type int dword_4A8AE4[777];

//----- (004134A0) --------------------------------------------------------
int __cdecl sub_4134A0(unsigned int *a1)
{
  unsigned int *v1; // esi
  unsigned int v2; // ecx
  int result; // eax
  unsigned int v4; // eax
  int (__cdecl *v5)(unsigned int **); // eax

  v1 = a1;
  v2 = a1[1];
  if ( v2 > 0x1F || !dword_4A8A88[25 * v2] )
    return 11;
  v4 = *a1;
  if ( *a1 > 0x1F || !dword_4A8108[19 * v4] )
    return 10;
  v5 = (int (__cdecl *)(unsigned int **))dword_4A8134[19 * v4];
  a1 = (unsigned int *)dword_4A8A90[25 * v2];
  result = v5(&a1);
  if ( !result )
    return sub_4137E0(*v1, (int)(v1 + 2), (int)(v1 + 2), (int)a1, 0, v1 + 34);
  return result;
}
// 4A8108: using guessed type int dword_4A8108[];
// 4A8134: using guessed type int dword_4A8134[];
// 4A8A88: using guessed type int dword_4A8A88[];
// 4A8A90: using guessed type int dword_4A8A90[];

//----- (00413530) --------------------------------------------------------
size_t __cdecl sub_413530(_BYTE *a1, size_t Size, int a3)
{
  if ( Size )
    memset(a1, 0, Size);
  return sub_413640(a1, (int *)a1, Size, (_DWORD *)(a3 + 136)) == 0 ? Size : 0;
}

//----- (00413570) --------------------------------------------------------
int __cdecl sub_413570(int a1)
{
  unsigned int v1; // eax

  v1 = *(_DWORD *)(a1 + 136);
  if ( v1 > 0x1F || !dword_4A8108[19 * v1] )
    return 10;
  ((void (__cdecl *)(int))dword_4A8130[19 * v1])(a1 + 408);
  return 0;
}
// 4A8108: using guessed type int dword_4A8108[];
// 4A8130: using guessed type int dword_4A8130[];

//----- (004135B0) --------------------------------------------------------
int __cdecl sub_4135B0(_BYTE *a1, _DWORD *a2, int a3)
{
  if ( *a2 < 0x40u )
    return 6;
  memset(a1, 0, 0x40u);
  if ( sub_413640(a1, (int *)a1, 0x40u, (_DWORD *)(a3 + 136)) )
    return 9;
  *a2 = 64;
  return 0;
}

//----- (00413600) --------------------------------------------------------
int __cdecl sub_413600(int a1, int a2, unsigned int *a3)
{
  int result; // eax

  if ( a2 != 64 )
    return 16;
  result = sub_413350(a3);
  if ( !result )
    return sub_4133C0(a1, 64, (int)a3);
  return result;
}

//----- (00413640) --------------------------------------------------------
int __cdecl sub_413640(_BYTE *a1, int *a2, unsigned int a3, _DWORD *a4)
{
  int v4; // edx
  unsigned int v6; // ecx
  unsigned int v7; // eax
  int *v8; // ebx
  void (__cdecl *v9)(_BYTE *, int *, unsigned int, _DWORD *, _DWORD, _DWORD *); // edi
  unsigned int v10; // ebp
  int v11; // ecx
  int v12; // eax
  _BYTE *v13; // eax
  bool v14; // zf
  int i; // eax
  int v16; // eax
  int v17; // ecx
  int *v18; // eax
  int v19; // edi
  int v20; // eax

  v4 = *a4;
  if ( *a4 > 0x1Fu || !dword_4A8108[19 * v4] )
    return 10;
  v6 = a4[1];
  if ( v6 > 0x80 )
    return 16;
  v7 = a4[2];
  if ( v7 > 0x80 || (v6 & 3) != 0 )
    return 16;
  v8 = a2;
  if ( v7 == v6
    && (v9 = (void (__cdecl *)(_BYTE *, int *, unsigned int, _DWORD *, _DWORD, _DWORD *))dword_4A8148[19 * v4]) != 0 )
  {
    v10 = a3;
    if ( a3 >= v6 )
    {
      v9(a1, a2, a3 / v6, a4 + 4, a4[3], a4 + 68);
      v10 = a3 % a4[1];
    }
  }
  else
  {
    v10 = a3;
  }
  while ( v10 )
  {
    v11 = a4[2];
    v12 = a4[1];
    if ( v11 == v12 )
    {
      if ( a4[3] )
      {
        for ( i = v12 - 1; i >= 0; --i )
        {
          v14 = (*((_BYTE *)a4 + i + 16))++ == 0xFF;
          if ( !v14 )
            break;
        }
      }
      else if ( v12 > 0 )
      {
        v13 = a4 + 4;
        do
        {
          v14 = (*v13)++ == 0xFF;
          if ( !v14 )
            break;
          ++v13;
        }
        while ( (int)&v13[-16 - (_DWORD)a4] < a4[1] );
      }
      ((void (__cdecl *)(_DWORD *, _DWORD *, _DWORD *))dword_4A8124[19 * *a4])(a4 + 4, a4 + 36, a4 + 68);
      a4[2] = 0;
    }
    else if ( v11 )
    {
      goto LABEL_30;
    }
    v16 = a4[1];
    if ( v10 >= v16 )
    {
      v17 = 0;
      if ( v16 > 0 )
      {
        v18 = v8;
        do
        {
          v19 = a4[v17 / 4u + 36] ^ *(int *)((char *)v18 + a1 - (_BYTE *)v8);
          v17 += 4;
          *v18++ = v19;
        }
        while ( v17 < a4[1] );
      }
      v20 = a4[1];
      a1 += v20;
      v8 = (int *)((char *)v8 + v20);
      v10 -= v20;
      a4[2] = v20;
      continue;
    }
LABEL_30:
    *(_BYTE *)v8 = *a1 ^ *((_BYTE *)a4 + a4[2] + 144);
    ++a4[2];
    v8 = (int *)((char *)v8 + 1);
    ++a1;
    --v10;
  }
  return 0;
}
// 4A8108: using guessed type int dword_4A8108[];
// 4A8124: using guessed type int dword_4A8124[];
// 4A8148: using guessed type int dword_4A8148[592];

//----- (004137E0) --------------------------------------------------------
int __cdecl sub_4137E0(unsigned int a1, int a2, int a3, int a4, int a5, unsigned int *a6)
{
  int result; // eax
  int v7; // ecx

  if ( a1 > 0x1F || !dword_4A8108[19 * a1] )
    return 10;
  result = ((int (__cdecl *)(int, int, int, unsigned int *))dword_4A8120[19 * a1])(a3, a4, a5, a6 + 68);
  if ( !result )
  {
    v7 = dword_4A8118[19 * a1];
    a6[1] = v7;
    *a6 = a1;
    a6[2] = 0;
    a6[3] = 0;
    if ( v7 > 0 )
    {
      do
      {
        *((_BYTE *)a6 + result + 16) = *(_BYTE *)(result + a2);
        ++result;
      }
      while ( result < (int)a6[1] );
    }
    ((void (__cdecl *)(unsigned int *, unsigned int *, unsigned int *))dword_4A8124[19 * *a6])(a6 + 4, a6 + 36, a6 + 68);
    return 0;
  }
  return result;
}
// 4A8108: using guessed type int dword_4A8108[];
// 4A8118: using guessed type int dword_4A8118[];
// 4A8120: using guessed type int dword_4A8120[];
// 4A8124: using guessed type int dword_4A8124[];

//----- (00413880) --------------------------------------------------------
int __cdecl sub_413880(int a1, unsigned int a2, int a3, void (*a4)(void))
{
  int result; // eax
  int v5; // esi
  int v6; // eax
  char v7[256]; // [esp+Ch] [ebp-104h] BYREF

  if ( a2 > 0x1F || !dword_4A9708[10 * a2] )
    return 12;
  if ( (unsigned int)(a1 - 64) > 0x3C0 )
    return 8;
  result = ((int (__cdecl *)(int))dword_4A9710[10 * a2])(a3);
  if ( !result )
  {
    v5 = 2 * (a1 / 8 + ((a1 & 7) != 0));
    v6 = sub_414DD0(v5, v7);
    if ( !v6 )
      v6 = sub_414E60(v7, v5, a4);
    if ( v6 == v5 )
    {
      result = ((int (__cdecl *)(char *, int, int))dword_4A9714[10 * a2])(v7, v5, a3);
      if ( !result )
        return ((int (__cdecl *)(int))dword_4A9718[10 * a2])(a3);
    }
    else
    {
      return 9;
    }
  }
  return result;
}
// 4A9708: using guessed type int dword_4A9708[];
// 4A9710: using guessed type int dword_4A9710[];
// 4A9714: using guessed type int dword_4A9714[];
// 4A9718: using guessed type int dword_4A9718[316];

//----- (004139B0) --------------------------------------------------------
int __cdecl sub_4139B0(const char *a1)
{
  int result; // eax
  const char **v2; // esi

  result = 0;
  v2 = (const char **)dword_4A9708;
  while ( !*v2 || strcmp(*v2, a1) )
  {
    v2 += 10;
    ++result;
    if ( (int)v2 >= (int)&dword_4A9C08 )
      return -1;
  }
  return result;
}
// 4A9708: using guessed type int dword_4A9708[];
// 4A9C08: using guessed type int dword_4A9C08;

//----- (00413A10) --------------------------------------------------------
int __cdecl sub_413A10(unsigned int a1, int a2, int a3, int a4, _DWORD *a5)
{
  void *v6; // eax
  void *v7; // edi
  int v8; // ebx

  if ( a1 > 0x1F || !dword_4A8A88[25 * a1] )
    return 11;
  if ( *a5 < (unsigned int)dword_4A8A90[25 * a1] )
    return 6;
  v6 = malloc(0xD0u);
  v7 = v6;
  if ( !v6 )
    return 13;
  v8 = ((int (__cdecl *)(void *))dword_4A8ADC[25 * a1])(v6);
  if ( !v8 )
  {
    v8 = ((int (__cdecl *)(void *, int, int))dword_4A8AE0[25 * a1])(v7, a2, a3);
    if ( !v8 )
    {
      v8 = ((int (__cdecl *)(void *, int))dword_4A8AE4[25 * a1])(v7, a4);
      *a5 = dword_4A8A90[25 * a1];
    }
  }
  memset(v7, 0, 0xD0u);
  free(v7);
  return v8;
}
// 4A8A88: using guessed type int dword_4A8A88[];
// 4A8A90: using guessed type int dword_4A8A90[];
// 4A8ADC: using guessed type int dword_4A8ADC[];
// 4A8AE0: using guessed type int dword_4A8AE0[];
// 4A8AE4: using guessed type int dword_4A8AE4[777];

//----- (00413AD0) --------------------------------------------------------
int __cdecl sub_413AD0(const char *a1)
{
  int result; // eax
  const char **v2; // esi

  result = 0;
  v2 = (const char **)dword_4A8A88;
  while ( !*v2 || strcmp(*v2, a1) )
  {
    v2 += 25;
    ++result;
    if ( (int)v2 >= (int)dword_4A9708 )
      return -1;
  }
  return result;
}
// 4A8A88: using guessed type int dword_4A8A88[];
// 4A9708: using guessed type int dword_4A9708[];

//----- (00413B30) --------------------------------------------------------
int __cdecl sub_413B30(const char *a1)
{
  int result; // eax
  const char **v2; // esi

  result = 0;
  v2 = (const char **)dword_4A8108;
  while ( !*v2 || strcmp(*v2, a1) )
  {
    v2 += 19;
    ++result;
    if ( (int)v2 >= (int)dword_4A8A88 )
      return -1;
  }
  return result;
}
// 4A8108: using guessed type int dword_4A8108[];
// 4A8A88: using guessed type int dword_4A8A88[];

//----- (00413B90) --------------------------------------------------------
unsigned int __cdecl sub_413B90(unsigned int a1)
{
  unsigned int result; // eax

  result = a1;
  do
    result -= 32;
  while ( result > 0x20 );
  return result;
}

//----- (00413BC0) --------------------------------------------------------
int __cdecl sub_413BC0(unsigned __int8 *a1, int a2, int a3, int *a4)
{
  _DWORD *v5; // esi
  unsigned int v6; // edx
  int v7; // eax
  int v8; // edi
  int v9; // eax
  void **v10; // edi
  unsigned int v11; // edx
  int v12; // eax
  int v13; // edx
  int v14; // eax
  unsigned int v15; // edx
  int v16; // eax
  int v17; // edx
  int v18; // eax
  int v19; // esi
  int v20; // eax
  int *v21; // eax
  _DWORD *v22; // edi
  int v23; // edx
  int v24; // esi
  unsigned int v25; // edx
  int v26; // esi
  int v27; // edx
  int v28; // esi
  unsigned int v29; // edx
  int v30; // eax
  int v31; // edx
  int v32; // eax
  int v33; // esi
  int v34; // eax
  _DWORD *v35; // eax
  _DWORD *v36; // edi
  unsigned int v37; // edx
  int v38; // esi
  int v39; // edx
  int v40; // esi
  int v41; // esi
  unsigned int v42; // edx
  int v43; // esi
  int v44; // edx
  int v45; // esi
  int v46; // eax
  int v47; // edx
  int v48; // edx
  int v49; // edi
  int *v50; // esi
  _DWORD *i; // eax
  unsigned int v52; // edx
  _DWORD *v53; // eax
  int v54; // edx
  _DWORD *v55; // esi
  int v56; // [esp+Ch] [ebp+8h]

  if ( a2 != 16 && a2 != 24 && a2 != 32 )
    return 3;
  if ( a3 && a3 != 2 * (a2 / 8) + 6 )
    return 4;
  a4[128] = 2 * (a2 / 8) + 6;
  *a4 = a1[3] | ((a1[2] | ((a1[1] | (*a1 << 8)) << 8)) << 8);
  a4[1] = a1[7] | ((a1[6] | ((a1[5] | (a1[4] << 8)) << 8)) << 8);
  v5 = a4 + 1;
  a4[2] = a1[11] | ((a1[10] | ((a1[9] | (a1[8] << 8)) << 8)) << 8);
  v6 = a1[15] | ((a1[14] | ((a1[13] | (a1[12] << 8)) << 8)) << 8);
  a4[3] = v6;
  if ( a2 == 16 )
  {
    v56 = 44;
    v7 = *a4 ^ dword_47E770[(unsigned __int8)v6] ^ dword_47EB70[BYTE1(v6)] ^ dword_47EF70[BYTE2(v6)] ^ dword_47E370[HIBYTE(v6)] ^ 0x1000000;
    v8 = v7 ^ *v5;
    a4[4] = v7;
    v9 = v8 ^ a4[2];
    a4[6] = v9;
    a4[5] = v8;
    a4[7] = v6 ^ v9;
    v10 = (void **)&unk_480F74;
    do
    {
      v11 = v5[6];
      v5 += 4;
      v12 = (unsigned int)*v10++ ^ *(v5 - 1) ^ dword_47E770[(unsigned __int8)v11] ^ dword_47EB70[BYTE1(v11)] ^ dword_47EF70[BYTE2(v11)] ^ dword_47E370[HIBYTE(v11)];
      v5[3] = v12;
      v13 = v12 ^ *v5;
      v5[4] = v13;
      v14 = v13 ^ v5[1];
      v5[5] = v14;
      v5[6] = v14 ^ v5[2];
    }
    while ( v10 != &off_480F98 );
  }
  else if ( a2 == 24 )
  {
    a4[4] = a1[19] | ((a1[18] | ((a1[17] | (a1[16] << 8)) << 8)) << 8);
    v15 = a1[23] | ((a1[22] | ((a1[21] | (a1[20] << 8)) << 8)) << 8);
    a4[5] = v15;
    v16 = dword_47E770[(unsigned __int8)v15] ^ dword_47EB70[BYTE1(v15)] ^ dword_47EF70[BYTE2(v15)] ^ dword_47E370[HIBYTE(v15)];
    v17 = a4[3];
    v18 = *a4 ^ v16 ^ 0x1000000;
    v19 = v18 ^ *v5;
    a4[6] = v18;
    v20 = v19 ^ a4[2];
    a4[8] = v20;
    v56 = 52;
    a4[7] = v19;
    a4[9] = v20 ^ v17;
    v21 = a4 + 10;
    v22 = &unk_480F74;
    do
    {
      v23 = *(v21 - 1) ^ *(v21 - 6);
      v24 = v23 ^ *(v21 - 5);
      *v21 = v23;
      v21[1] = v24;
      v21 += 6;
      v25 = a4[(((int)v21 - 40 - (int)a4) >> 2) + 5];
      v26 = *v22++ ^ *(v21 - 10) ^ dword_47E770[(unsigned __int8)v25] ^ dword_47EB70[BYTE1(v25)] ^ dword_47EF70[BYTE2(v25)] ^ dword_47E370[HIBYTE(v25)];
      *(v21 - 4) = v26;
      v27 = v26 ^ *(v21 - 9);
      *(v21 - 3) = v27;
      v28 = v27 ^ *(v21 - 8);
      *(v21 - 2) = v28;
      *(v21 - 1) = v28 ^ *(v21 - 7);
    }
    while ( v22 != (_DWORD *)&unk_480F90 );
  }
  else
  {
    a4[4] = a1[19] | ((a1[18] | ((a1[17] | (a1[16] << 8)) << 8)) << 8);
    a4[5] = a1[23] | ((a1[22] | ((a1[21] | (a1[20] << 8)) << 8)) << 8);
    a4[6] = a1[27] | ((a1[26] | ((a1[25] | (a1[24] << 8)) << 8)) << 8);
    v29 = a1[31] | ((a1[30] | ((a1[29] | (a1[28] << 8)) << 8)) << 8);
    a4[7] = v29;
    v30 = dword_47E770[(unsigned __int8)v29] ^ dword_47EB70[BYTE1(v29)] ^ dword_47EF70[BYTE2(v29)] ^ dword_47E370[HIBYTE(v29)];
    v31 = a4[3];
    v32 = *a4 ^ v30 ^ 0x1000000;
    v33 = v32 ^ *v5;
    a4[8] = v32;
    v34 = v33 ^ a4[2];
    a4[10] = v34;
    v56 = 60;
    a4[9] = v33;
    a4[11] = v34 ^ v31;
    v35 = a4 + 12;
    v36 = &unk_480F74;
    do
    {
      v37 = __ROR4__(*(v35 - 1), 8);
      v35 += 8;
      v38 = *(v35 - 16) ^ dword_47E770[(unsigned __int8)v37] ^ dword_47EB70[BYTE1(v37)] ^ dword_47EF70[BYTE2(v37)] ^ dword_47E370[HIBYTE(v37)];
      ++v36;
      v39 = v38 ^ *(v35 - 15);
      *(v35 - 8) = v38;
      v40 = *(v35 - 14);
      *(v35 - 7) = v39;
      v41 = v39 ^ v40;
      *(v35 - 5) = v41 ^ *(v35 - 13);
      *(v35 - 6) = v41;
      v42 = a4[(((int)v35 - 48 - (int)a4) >> 2) + 7];
      v43 = *(v36 - 1) ^ *(v35 - 12) ^ dword_47E770[(unsigned __int8)v42] ^ dword_47EB70[BYTE1(v42)] ^ dword_47EF70[BYTE2(v42)] ^ dword_47E370[HIBYTE(v42)];
      *(v35 - 4) = v43;
      v44 = v43 ^ *(v35 - 11);
      *(v35 - 3) = v44;
      v45 = v44 ^ *(v35 - 10);
      *(v35 - 2) = v45;
      *(v35 - 1) = v45 ^ *(v35 - 9);
    }
    while ( v36 != (_DWORD *)&unk_480F8C );
  }
  a4[64] = a4[v56 - 4];
  v46 = (int)&a4[v56 - 4];
  v47 = *(_DWORD *)(v46 + 4);
  v46 += 4;
  a4[65] = v47;
  v48 = *(_DWORD *)(v46 + 4);
  v46 += 4;
  a4[66] = v48;
  a4[67] = *(_DWORD *)(v46 + 4);
  v49 = 1;
  v50 = a4 + 64;
  for ( i = (_DWORD *)(v46 - 8);
        v49 < a4[128];
        v50[3] = dword_480B70[(unsigned __int8)i[3]] ^ dword_480770[(unsigned __int8)BYTE1(i[3])] ^ dword_480370[(unsigned __int8)BYTE2(i[3])] ^ dword_47FF70[HIBYTE(i[3])] )
  {
    v52 = *(i - 4);
    i -= 4;
    v50 += 4;
    *v50 = dword_480B70[(unsigned __int8)v52] ^ dword_480770[BYTE1(v52)] ^ dword_480370[BYTE2(v52)] ^ dword_47FF70[HIBYTE(v52)];
    ++v49;
    v50[1] = dword_480B70[(unsigned __int8)i[1]] ^ dword_480770[(unsigned __int8)BYTE1(i[1])] ^ dword_480370[(unsigned __int8)BYTE2(i[1])] ^ dword_47FF70[HIBYTE(i[1])];
    v50[2] = dword_480B70[(unsigned __int8)i[2]] ^ dword_480770[(unsigned __int8)BYTE1(i[2])] ^ dword_480370[(unsigned __int8)BYTE2(i[2])] ^ dword_47FF70[HIBYTE(i[2])];
  }
  v50[4] = *(i - 4);
  v53 = i - 4;
  v54 = v53[1];
  ++v53;
  v55 = v50 + 5;
  *v55++ = v54;
  *v55 = v53[1];
  v55[1] = v53[2];
  return 0;
}
// 413EB8: conditional instruction was optimized away because %arg_4.4==20
// 47E370: using guessed type int dword_47E370[256];
// 47E770: using guessed type int dword_47E770[256];
// 47EB70: using guessed type int dword_47EB70[256];
// 47EF70: using guessed type int dword_47EF70[256];
// 47FF70: using guessed type int dword_47FF70[256];
// 480370: using guessed type int dword_480370[256];
// 480770: using guessed type int dword_480770[256];
// 480B70: using guessed type int dword_480B70[257];
// 480F98: using guessed type void *off_480F98;

//----- (00414210) --------------------------------------------------------
_BYTE *__usercall sub_414210@<eax>(unsigned __int8 *a1@<eax>, int a2@<ecx>, _BYTE *a3)
{
  unsigned int v4; // edx
  unsigned int v5; // esi
  int v6; // ebp
  unsigned int v7; // ecx
  unsigned int v8; // ebx
  unsigned int v9; // edx
  int v10; // ebp
  _DWORD *v11; // esi
  int v12; // eax
  unsigned int v13; // ecx
  unsigned int v14; // eax
  unsigned int v15; // edx
  int v16; // edx
  _BYTE *result; // eax
  int v18; // edx
  unsigned int v19; // [esp+10h] [ebp-1Ch]
  int v20; // [esp+10h] [ebp-1Ch]
  unsigned int v21; // [esp+14h] [ebp-18h]
  unsigned int v22; // [esp+18h] [ebp-14h]
  int v23; // [esp+18h] [ebp-14h]
  int v24; // [esp+1Ch] [ebp-10h]
  unsigned int v25; // [esp+20h] [ebp-Ch]
  int v26; // [esp+20h] [ebp-Ch]
  unsigned int v27; // [esp+24h] [ebp-8h]

  v22 = *(_DWORD *)a2 ^ (a1[3] | ((a1[2] | ((a1[1] | (*a1 << 8)) << 8)) << 8));
  v4 = *(_DWORD *)(a2 + 4) ^ (a1[7] | ((a1[6] | ((a1[5] | (a1[4] << 8)) << 8)) << 8));
  v5 = *(_DWORD *)(a2 + 8) ^ (a1[11] | ((a1[10] | ((a1[9] | (a1[8] << 8)) << 8)) << 8));
  v24 = *(_DWORD *)(a2 + 16) ^ dword_47DF70[(unsigned __int8)(*(_BYTE *)(a2 + 12) ^ a1[15])] ^ dword_47C770[HIBYTE(v22)] ^ dword_47D770[BYTE2(v4)] ^ dword_47DB70[(unsigned __int8)((unsigned __int16)(*(_WORD *)(a2 + 8) ^ (a1[11] | (unsigned __int16)((a1[10] | (unsigned __int16)(_byteswap_ushort(*((_WORD *)a1 + 4)) << 8)) << 8))) >> 8)];
  v6 = dword_47DF70[(unsigned __int8)(*(_BYTE *)a2 ^ a1[3])] ^ dword_47C770[HIBYTE(v4)] ^ dword_47D770[BYTE2(v5)] ^ dword_47DB70[(unsigned __int8)((unsigned __int16)(*(_WORD *)(a2 + 12) ^ (a1[15] | (unsigned __int16)((a1[14] | (unsigned __int16)(_byteswap_ushort(*((_WORD *)a1 + 6)) << 8)) << 8))) >> 8)];
  v27 = *(_DWORD *)(a2 + 12) ^ (a1[15] | ((a1[14] | ((a1[13] | (a1[12] << 8)) << 8)) << 8));
  v7 = v24;
  v8 = *(_DWORD *)(a2 + 24) ^ dword_47DF70[(unsigned __int8)v4] ^ dword_47DB70[BYTE1(v22)] ^ dword_47C770[HIBYTE(v5)] ^ dword_47D770[BYTE2(v27)];
  v21 = *(_DWORD *)(a2 + 20) ^ v6;
  v9 = *(_DWORD *)(a2 + 28) ^ dword_47DF70[(unsigned __int8)v5] ^ dword_47D770[BYTE2(v22)] ^ dword_47DB70[BYTE1(v4)] ^ dword_47C770[HIBYTE(v27)];
  v10 = (*(int *)(a2 + 512) >> 1) - 1;
  v25 = v8;
  v11 = (_DWORD *)(a2 + 32);
  if ( *(int *)(a2 + 512) >> 1 != 1 )
  {
    do
    {
      v12 = dword_47DF70[(unsigned __int8)v9] ^ dword_47C770[HIBYTE(v7)] ^ dword_47D770[BYTE2(v21)] ^ dword_47DB70[BYTE1(v8)];
      v13 = v11[1] ^ dword_47DF70[(unsigned __int8)v24] ^ dword_47C770[HIBYTE(v21)] ^ dword_47D770[BYTE2(v8)] ^ dword_47DB70[BYTE1(v9)];
      v19 = v11[2] ^ dword_47DF70[(unsigned __int8)v21] ^ dword_47DB70[BYTE1(v24)] ^ dword_47C770[HIBYTE(v25)] ^ dword_47D770[BYTE2(v9)];
      v14 = *v11 ^ v12;
      v15 = v11[3] ^ dword_47DF70[(unsigned __int8)v25] ^ dword_47D770[BYTE2(v24)] ^ dword_47DB70[BYTE1(v21)] ^ dword_47C770[HIBYTE(v9)];
      v24 = v11[4] ^ dword_47DF70[(unsigned __int8)v15] ^ dword_47C770[HIBYTE(v14)] ^ dword_47D770[BYTE2(v13)] ^ dword_47DB70[BYTE1(v19)];
      v21 = v11[5] ^ dword_47DF70[(unsigned __int8)v14] ^ dword_47C770[HIBYTE(v13)] ^ dword_47D770[BYTE2(v19)] ^ dword_47DB70[BYTE1(v15)];
      v8 = v11[6] ^ dword_47DF70[(unsigned __int8)v13] ^ dword_47DB70[BYTE1(v14)] ^ dword_47C770[HIBYTE(v19)] ^ dword_47D770[BYTE2(v15)];
      v16 = dword_47DF70[(unsigned __int8)v19] ^ dword_47D770[BYTE2(v14)] ^ dword_47DB70[BYTE1(v13)] ^ dword_47C770[HIBYTE(v15)];
      v7 = v24;
      v9 = v11[7] ^ v16;
      v11 += 8;
      --v10;
      v25 = v8;
    }
    while ( v10 );
  }
  v23 = *v11 ^ dword_47E370[(unsigned __int8)v9] ^ dword_47EF70[HIBYTE(v7)] ^ dword_47EB70[BYTE2(v21)] ^ dword_47E770[BYTE1(v8)];
  *a3 = HIBYTE(v23);
  a3[1] = BYTE2(v23);
  a3[2] = BYTE1(v23);
  a3[3] = v23;
  v26 = v11[1] ^ dword_47E370[(unsigned __int8)v7] ^ dword_47EF70[HIBYTE(v21)] ^ dword_47EB70[BYTE2(v8)] ^ dword_47E770[BYTE1(v9)];
  a3[4] = HIBYTE(v26);
  a3[5] = BYTE2(v26);
  a3[6] = BYTE1(v26);
  a3[7] = v26;
  v20 = v11[2] ^ dword_47E370[(unsigned __int8)v21] ^ dword_47E770[BYTE1(v7)] ^ dword_47EF70[HIBYTE(v8)] ^ dword_47EB70[BYTE2(v9)];
  a3[8] = HIBYTE(v20);
  a3[9] = BYTE2(v20);
  a3[10] = BYTE1(v20);
  a3[11] = v20;
  result = a3;
  v18 = v11[3] ^ dword_47E370[(unsigned __int8)v8] ^ dword_47EB70[BYTE2(v7)] ^ dword_47E770[BYTE1(v21)] ^ dword_47EF70[HIBYTE(v9)];
  a3[12] = HIBYTE(v18);
  a3[13] = BYTE2(v18);
  a3[14] = BYTE1(v18);
  a3[15] = v18;
  return result;
}
// 47C770: using guessed type int dword_47C770[512];
// 47D770: using guessed type int dword_47D770[256];
// 47DB70: using guessed type int dword_47DB70[256];
// 47DF70: using guessed type int dword_47DF70[256];
// 47E370: using guessed type int dword_47E370[256];
// 47E770: using guessed type int dword_47E770[256];
// 47EB70: using guessed type int dword_47EB70[256];
// 47EF70: using guessed type int dword_47EF70[256];

//----- (00414750) --------------------------------------------------------
_BYTE *__cdecl sub_414750(unsigned __int8 *a1, _BYTE *a2, int a3)
{
  return sub_414210(a1, a3, a2);
}

//----- (00414780) --------------------------------------------------------
_BYTE *__cdecl sub_414780(_BYTE *a1, _DWORD *a2)
{
  unsigned __int8 *v2; // ecx
  unsigned int v3; // ebx
  unsigned int v4; // edx
  unsigned int v5; // ecx
  _DWORD *v6; // eax
  int v7; // edi
  unsigned int v8; // edx
  int v9; // esi
  unsigned int v10; // esi
  unsigned int v11; // ebx
  _BYTE *result; // eax
  unsigned int v13; // [esp+10h] [ebp-1Ch]
  unsigned int v14; // [esp+10h] [ebp-1Ch]
  unsigned int v15; // [esp+14h] [ebp-18h]
  unsigned int v16; // [esp+18h] [ebp-14h]
  unsigned int v17; // [esp+1Ch] [ebp-10h]
  unsigned int v18; // [esp+1Ch] [ebp-10h]
  unsigned int v19; // [esp+20h] [ebp-Ch]
  unsigned int v20; // [esp+20h] [ebp-Ch]
  unsigned int v21; // [esp+20h] [ebp-Ch]
  int v22; // [esp+24h] [ebp-8h]
  unsigned int v23; // [esp+28h] [ebp-4h]
  unsigned int v24; // [esp+34h] [ebp+8h]

  v17 = a2[66] ^ (v2[11] | ((v2[10] | ((v2[9] | (v2[8] << 8)) << 8)) << 8));
  v3 = a2[65] ^ (v2[7] | ((v2[6] | ((v2[5] | (v2[4] << 8)) << 8)) << 8));
  v13 = a2[64] ^ (v2[3] | ((v2[2] | ((v2[1] | (*v2 << 8)) << 8)) << 8));
  v19 = a2[67] ^ (v2[15] | ((v2[14] | ((v2[13] | (v2[12] << 8)) << 8)) << 8));
  v15 = a2[68] ^ dword_47FB70[(unsigned __int8)(*((_BYTE *)a2 + 260) ^ v2[7])] ^ dword_47CF70[HIBYTE(v13)] ^ dword_47F770[(unsigned __int8)((unsigned __int16)(*((_WORD *)a2 + 132) ^ (v2[11] | (unsigned __int16)((v2[10] | (unsigned __int16)(_byteswap_ushort(*((_WORD *)v2 + 4)) << 8)) << 8))) >> 8)] ^ dword_47F370[BYTE2(v19)];
  v4 = a2[69] ^ dword_47FB70[(unsigned __int8)(*((_BYTE *)a2 + 264) ^ v2[11])] ^ dword_47F370[BYTE2(v13)] ^ dword_47CF70[HIBYTE(v3)] ^ dword_47F770[BYTE1(v19)];
  BYTE1(v22) = BYTE1(v4);
  v16 = a2[70] ^ dword_47FB70[(unsigned __int8)v19] ^ dword_47F770[(unsigned __int8)((unsigned __int16)(*((_WORD *)a2 + 128) ^ (v2[3] | (unsigned __int16)((v2[2] | (unsigned __int16)(_byteswap_ushort(*(_WORD *)v2) << 8)) << 8))) >> 8)] ^ dword_47F370[BYTE2(v3)] ^ dword_47CF70[HIBYTE(v17)];
  v5 = a2[71] ^ dword_47FB70[(unsigned __int8)(*((_BYTE *)a2 + 256) ^ v2[3])] ^ dword_47F770[(unsigned __int8)((unsigned __int16)(*((_WORD *)a2 + 130) ^ (v2[7] | (unsigned __int16)((v2[6] | (unsigned __int16)(_byteswap_ushort(*((_WORD *)v2 + 2)) << 8)) << 8))) >> 8)] ^ dword_47F370[BYTE2(v17)] ^ dword_47CF70[HIBYTE(v19)];
  v6 = a2 + 72;
  v7 = ((int)a2[128] >> 1) - 1;
  v20 = v5;
  if ( (int)a2[128] >> 1 != 1 )
  {
    do
    {
      v14 = *v6 ^ dword_47FB70[(unsigned __int8)v4] ^ dword_47CF70[HIBYTE(v15)] ^ dword_47F770[BYTE1(v16)] ^ dword_47F370[BYTE2(v5)];
      v23 = v6[1] ^ dword_47FB70[(unsigned __int8)v16] ^ dword_47F370[BYTE2(v15)] ^ dword_47CF70[HIBYTE(v4)] ^ dword_47F770[BYTE1(v5)];
      v8 = v6[2] ^ dword_47FB70[(unsigned __int8)v20] ^ dword_47F770[BYTE1(v15)] ^ dword_47F370[BYTE2(v4)] ^ dword_47CF70[HIBYTE(v16)];
      v21 = v6[3] ^ dword_47FB70[(unsigned __int8)v15] ^ dword_47F770[BYTE1(v22)] ^ dword_47F370[BYTE2(v16)] ^ dword_47CF70[HIBYTE(v20)];
      v15 = v6[4] ^ dword_47FB70[(unsigned __int8)v23] ^ dword_47CF70[HIBYTE(v14)] ^ dword_47F770[BYTE1(v8)] ^ dword_47F370[BYTE2(v21)];
      v22 = v6[5] ^ dword_47FB70[(unsigned __int8)v8] ^ dword_47F370[BYTE2(v14)] ^ dword_47CF70[HIBYTE(v23)] ^ dword_47F770[BYTE1(v21)];
      v16 = v6[6] ^ dword_47FB70[(unsigned __int8)v21] ^ dword_47F770[BYTE1(v14)] ^ dword_47F370[BYTE2(v23)] ^ dword_47CF70[HIBYTE(v8)];
      v6 += 8;
      v9 = dword_47FB70[(unsigned __int8)v14] ^ dword_47F770[BYTE1(v23)] ^ dword_47F370[BYTE2(v8)] ^ dword_47CF70[HIBYTE(v21)];
      v4 = v22;
      --v7;
      v5 = *(v6 - 1) ^ v9;
      v20 = v5;
    }
    while ( v7 );
  }
  v10 = *v6 ^ LOBYTE(dword_47D370[(unsigned __int8)v4]) ^ dword_47D370[HIBYTE(v15)] & 0xFF000000 ^ dword_47D370[BYTE1(v16)] & 0xFF00 ^ dword_47D370[BYTE2(v5)] & 0xFF0000;
  *a1 = HIBYTE(v10);
  a1[1] = BYTE2(v10);
  a1[2] = BYTE1(v10);
  a1[3] = v10;
  v24 = v6[1] ^ LOBYTE(dword_47D370[(unsigned __int8)v16]) ^ dword_47D370[HIBYTE(v4)] & 0xFF000000 ^ dword_47D370[BYTE1(v5)] & 0xFF00 ^ dword_47D370[BYTE2(v15)] & 0xFF0000;
  a1[4] = HIBYTE(v24);
  a1[5] = BYTE2(v24);
  a1[6] = BYTE1(v24);
  a1[7] = v24;
  v18 = v6[2] ^ LOBYTE(dword_47D370[(unsigned __int8)v5]) ^ dword_47D370[BYTE1(v15)] & 0xFF00 ^ dword_47D370[HIBYTE(v16)] & 0xFF000000 ^ dword_47D370[BYTE2(v4)] & 0xFF0000;
  a1[8] = HIBYTE(v18);
  a1[9] = BYTE2(v18);
  a1[10] = BYTE1(v18);
  a1[11] = v18;
  v11 = v6[3] ^ LOBYTE(dword_47D370[(unsigned __int8)v15]) ^ dword_47D370[BYTE1(v4)] & 0xFF00 ^ dword_47D370[HIBYTE(v5)] & 0xFF000000 ^ dword_47D370[BYTE2(v16)] & 0xFF0000;
  result = a1;
  a1[12] = HIBYTE(v11);
  a1[15] = v11;
  a1[13] = BYTE2(v11);
  a1[14] = BYTE1(v11);
  return result;
}
// 4147E2: variable 'v2' is possibly undefined
// 47CF70: using guessed type int dword_47CF70[256];
// 47D370: using guessed type int dword_47D370[256];
// 47F370: using guessed type int dword_47F370[256];
// 47F770: using guessed type int dword_47F770[256];
// 47FB70: using guessed type int dword_47FB70[256];

//----- (00414D60) --------------------------------------------------------
_BYTE *__cdecl sub_414D60(int a1, _BYTE *a2, _DWORD *a3)
{
  return sub_414780(a2, a3);
}

//----- (00414D90) --------------------------------------------------------
int __cdecl sub_414D90(int *a1)
{
  int v1; // eax

  v1 = *a1;
  if ( *a1 < 16 )
    return 3;
  if ( v1 >= 24 )
  {
    if ( v1 >= 32 )
      *a1 = 32;
    else
      *a1 = 24;
    return 0;
  }
  else
  {
    *a1 = 16;
    return 0;
  }
}

//----- (00414DD0) --------------------------------------------------------
int __usercall sub_414DD0@<eax>(int a1@<eax>, _BYTE *a2@<ecx>)
{
  int v4; // edi
  int v5; // eax
  int i; // edi
  int v8[4]; // [esp+Ch] [ebp-14h] BYREF
  int v9; // [esp+1Ch] [ebp-4h]

  v8[0] = 624;
  v8[1] = 625;
  v8[2] = 0;
  v8[3] = -1727483681;
  v9 = 0;
  v4 = rand() << 16;
  v5 = rand();
  sub_472B66(v4 | v5, v8);
  for ( i = a1; a1; ++a2 )
  {
    --a1;
    *a2 = sub_472F28(v8);
  }
  if ( v9 )
    free((void *)(v9 - 16));
  return i;
}

//----- (00414E60) --------------------------------------------------------
int __cdecl sub_414E60(_BYTE *a1, int a2, void (*a3)(void))
{
  int result; // eax
  int v4; // ebp
  int v5; // edi
  char v6; // bl
  clock_t i; // esi
  clock_t j; // esi
  int v9; // [esp+Ch] [ebp-8h]
  int v10; // [esp+10h] [ebp-4h]

  result = a2;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v10 = a2;
  v9 = 8;
  if ( a2 )
  {
    do
    {
      --a2;
      if ( a3 )
        a3();
      do
      {
        --v9;
        do
        {
          for ( i = clock(); i == clock(); v5 ^= 1u )
            ;
          for ( j = clock(); j == clock(); v4 ^= 1u )
            ;
        }
        while ( v5 == v4 );
        v6 = v5 | (2 * v6);
      }
      while ( v9 );
      *a1 = v6;
      v6 = 0;
      ++a1;
      v9 = 8;
    }
    while ( a2 );
    return v10;
  }
  return result;
}

//----- (00414F02) --------------------------------------------------------
int (__cdecl *__cdecl sub_414F02(
        int a1,
        int (__cdecl *a2)(int, char *Format, char ArgList),
        _BYTE *a3))(int, char *Format, char ArgList)
{
  char *v3; // eax

  switch ( a1 )
  {
    case 1300:
      v3 = "invalid hexadecimal character value\n";
      break;
    case 1301:
      v3 = "invalid decimal character value\n";
      break;
    case 1302:
      v3 = "unterminated entity reference %15s\n";
      break;
    case 1303:
      v3 = "string is not in UTF-8\n";
      break;
    default:
      v3 = "unexpected error number\n";
      break;
  }
  return _xmlSimpleError(2, a1, a2, v3, a3);
}

//----- (00414F4F) --------------------------------------------------------
const char *__cdecl xmlBuildQName(const char *a1, const char *Src, char *a3, int a4)
{
  const char *result; // eax
  size_t v5; // ebx
  unsigned int v6; // eax
  char *v7; // edi
  size_t v8; // esi
  char *v9; // esi

  result = a1;
  if ( a1 && Src )
  {
    v5 = strlen(a1);
    v6 = strlen(Src);
    v7 = a3;
    v8 = v6;
    if ( a3 && a4 >= (int)(v6 + v5 + 2) || (v7 = (char *)xmlMallocAtomic(v6 + v5 + 2)) != 0 )
    {
      memcpy(v7, Src, v8);
      v9 = &v7[v8];
      *v9 = 58;
      memcpy(v9 + 1, a1, v5);
      v9[v5 + 1] = 0;
      return v7;
    }
    else
    {
      sub_43279D("building QName");
      return 0;
    }
  }
  return result;
}
// 49B2BC: using guessed type int (__cdecl *xmlMallocAtomic)(size_t Size);

//----- (00414FDF) --------------------------------------------------------
_BYTE *__cdecl xmlSplitQName2(char *Src, _DWORD *a2)
{
  int v2; // ecx
  _BYTE *result; // eax
  char v4; // dl
  char *v5; // esi
  _BYTE *v6; // eax

  v2 = 0;
  if ( !a2 )
    return 0;
  *a2 = 0;
  if ( !Src )
    return 0;
  v4 = *Src;
  if ( *Src == 58 )
    return 0;
  while ( v4 && v4 != 58 )
    v4 = Src[++v2];
  v5 = &Src[v2];
  if ( Src[v2] )
  {
    v6 = xmlStrndup(Src, v2);
    *a2 = v6;
    if ( v6 )
    {
      result = xmlStrdup(v5 + 1);
      if ( result )
        return result;
      sub_43279D("QName split");
      if ( *a2 )
      {
        ((void (__cdecl *)(_DWORD))xmlFree)(*a2);
        *a2 = 0;
      }
    }
    else
    {
      sub_43279D("QName split");
    }
  }
  return 0;
}
// 496494: invalid function type has been ignored

//----- (0041505F) --------------------------------------------------------
int __cdecl xmlSplitQName3(char *a1, _DWORD *a2)
{
  int result; // eax
  int v3; // ecx
  char v4; // dl

  result = (int)a1;
  v3 = 0;
  if ( a1 )
  {
    if ( !a2 )
      return 0;
    v4 = *a1;
    if ( *a1 == 58 )
      return 0;
    while ( v4 && v4 != 58 )
      v4 = a1[++v3];
    if ( a1[v3] )
    {
      *a2 = v3;
      return (int)&a1[v3 + 1];
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (00415099) --------------------------------------------------------
int __cdecl xmlValidateNCName(unsigned __int8 *a1, int a2)
{
  unsigned __int8 *v2; // edi
  unsigned __int8 *v3; // ecx
  unsigned __int8 v5; // al
  unsigned __int8 v6; // al
  unsigned __int8 v7; // al
  unsigned __int8 v8; // al
  int v9; // esi
  int v10; // eax
  int v11; // esi
  int v12; // eax

  v2 = a1;
  v3 = a1;
  if ( !a1 )
    return -1;
  if ( a2 )
  {
    while ( 1 )
    {
      v5 = *v3;
      if ( *v3 != 32 && (v5 < 9u || v5 > 0xAu) && v5 != 13 )
        break;
      ++v3;
    }
  }
  v6 = *v3;
  if ( *v3 >= 0x61u && v6 <= 0x7Au || v6 >= 0x41u && v6 <= 0x5Au || v6 == 95 )
  {
    do
    {
      do
        v7 = *++v3;
      while ( *v3 >= 0x61u && v7 <= 0x7Au );
    }
    while ( v7 >= 0x41u && v7 <= 0x5Au || v7 >= 0x30u && v7 <= 0x39u || v7 == 95 || v7 == 45 || v7 == 46 );
    if ( a2 )
    {
      while ( 1 )
      {
        v8 = *v3;
        if ( *v3 != 32 && (v8 < 9u || v8 > 0xAu) && v8 != 13 )
          break;
        ++v3;
      }
    }
    if ( !*v3 )
      return 0;
  }
  v9 = xmlStringCurrentChar(0, a1, &a1);
  if ( a2 )
  {
    while ( v9 < 256 )
    {
      if ( v9 != 32 && (v9 < 9 || v9 > 10) && v9 != 13 )
        goto LABEL_38;
      v2 = &v2[(_DWORD)a1];
      v9 = xmlStringCurrentChar(0, v2, &a1);
    }
    goto LABEL_59;
  }
LABEL_38:
  if ( v9 >= 256 )
  {
LABEL_59:
    if ( xmlCharInRange(v9, xmlIsBaseCharGroup) )
      goto LABEL_48;
    goto LABEL_60;
  }
  if ( v9 >= 65 && v9 <= 90 || v9 >= 97 && v9 <= 122 || v9 >= 192 && v9 <= 214 || v9 >= 216 && v9 <= 246 || v9 >= 248 )
    goto LABEL_48;
LABEL_60:
  if ( (v9 < 256 || (v9 < 19968 || v9 > 40869) && v9 != 12295 && (v9 < 12321 || v9 > 12329)) && v9 != 95 )
    return 1;
  do
  {
    while ( 1 )
    {
      do
      {
        do
        {
          while ( 1 )
          {
            do
            {
LABEL_48:
              while ( 1 )
              {
                v2 = &v2[(_DWORD)a1];
                v10 = xmlStringCurrentChar(0, v2, &a1);
                v11 = v10;
                if ( v10 < 256 )
                  break;
                if ( !xmlCharInRange(v10, xmlIsBaseCharGroup) )
                  goto LABEL_69;
              }
            }
            while ( v10 >= 65 && v10 <= 90
                 || v10 >= 97 && v10 <= 122
                 || v10 >= 192 && v10 <= 214
                 || v10 >= 216 && v10 <= 246
                 || v10 >= 248 );
LABEL_69:
            if ( v11 >= 256 )
              break;
            if ( (unsigned int)(v11 - 48) > 9 )
              goto LABEL_79;
          }
        }
        while ( v11 >= 19968 && v11 <= 40869
             || v11 == 12295
             || v11 >= 12321 && v11 <= 12329
             || xmlCharInRange(v11, xmlIsDigitGroup) );
LABEL_79:
        ;
      }
      while ( v11 == 46 || v11 == 45 || v11 == 95 );
      if ( v11 < 256 )
        break;
      if ( !xmlCharInRange(v11, xmlIsCombiningGroup) )
      {
        v12 = xmlCharInRange(v11, xmlIsExtenderGroup);
        goto LABEL_86;
      }
    }
    v12 = v11 == 183;
LABEL_86:
    ;
  }
  while ( v12 );
  if ( a2 )
  {
    while ( v11 < 256 && (v11 == 32 || v11 >= 9 && v11 <= 10 || v11 == 13) )
    {
      v2 = &v2[(_DWORD)a1];
      v11 = xmlStringCurrentChar(0, v2, &a1);
    }
  }
  return v11 != 0;
}
// 4152BE: conditional instruction was optimized away because esi.4 is in (100..3006|3008..3020|302A..4DFF|>=9FA6)
// 415319: conditional instruction was optimized away because esi.4 is in (100..3006|3008..3020|302A..4DFF|>=9FA6)
// 47C2A4: using guessed type _DWORD xmlIsBaseCharGroup[2];
// 47C454: using guessed type _DWORD xmlIsCombiningGroup[2];
// 47C49C: using guessed type _DWORD xmlIsDigitGroup[2];
// 47C4D4: using guessed type _DWORD xmlIsExtenderGroup[2];

//----- (0041537F) --------------------------------------------------------
int __cdecl xmlValidateQName(unsigned __int8 *a1, int a2)
{
  unsigned __int8 *v2; // edi
  unsigned __int8 *v3; // ecx
  int v5; // ebx
  unsigned __int8 v6; // al
  unsigned __int8 v7; // al
  unsigned __int8 v8; // al
  unsigned __int8 v9; // al
  unsigned __int8 v10; // al
  unsigned __int8 v11; // al
  int v12; // esi
  int v13; // eax
  int v14; // esi
  int v15; // eax
  int v16; // eax
  int v17; // esi
  int v18; // eax
  int v19; // eax

  v2 = a1;
  v3 = a1;
  if ( !a1 )
    return -1;
  v5 = a2;
  if ( a2 )
  {
    while ( 1 )
    {
      v6 = *v3;
      if ( *v3 != 32 && (v6 < 9u || v6 > 0xAu) && v6 != 13 )
        break;
      ++v3;
    }
  }
  v7 = *v3;
  if ( *v3 >= 0x61u && v7 <= 0x7Au || v7 >= 0x41u && v7 <= 0x5Au || v7 == 95 )
  {
    do
    {
      do
        v8 = *++v3;
      while ( *v3 >= 0x61u && v8 <= 0x7Au );
    }
    while ( v8 >= 0x41u && v8 <= 0x5Au || v8 >= 0x30u && v8 <= 0x39u || v8 == 95 || v8 == 45 || v8 == 46 );
    if ( *v3 == 58 )
    {
      v9 = *++v3;
      if ( (*v3 < 0x61u || v9 > 0x7Au) && (v9 < 0x41u || v9 > 0x5Au) && v9 != 95 )
        goto LABEL_46;
      do
      {
        do
          v10 = *++v3;
        while ( *v3 >= 0x61u && v10 <= 0x7Au );
      }
      while ( v10 >= 0x41u && v10 <= 0x5Au || v10 >= 0x30u && v10 <= 0x39u || v10 == 95 || v10 == 45 || v10 == 46 );
    }
    if ( a2 )
    {
      while ( 1 )
      {
        v11 = *v3;
        if ( *v3 != 32 && (v11 < 9u || v11 > 0xAu) && v11 != 13 )
          break;
        ++v3;
      }
    }
    if ( !*v3 )
      return 0;
  }
LABEL_46:
  v12 = xmlStringCurrentChar(0, a1, &a1);
  if ( v5 )
  {
    while ( v12 < 256 )
    {
      if ( v12 != 32 && (v12 < 9 || v12 > 10) && v12 != 13 )
        goto LABEL_53;
      v2 = &v2[(_DWORD)a1];
      v12 = xmlStringCurrentChar(0, v2, &a1);
    }
    goto LABEL_64;
  }
LABEL_53:
  if ( v12 >= 256 )
  {
LABEL_64:
    if ( xmlCharInRange(v12, xmlIsBaseCharGroup) )
      goto LABEL_72;
    goto LABEL_65;
  }
  if ( v12 >= 65 && v12 <= 90
    || v12 >= 97 && v12 <= 122
    || v12 >= 192 && v12 <= 214
    || v12 >= 216 && v12 <= 246
    || v12 >= 248 )
  {
    goto LABEL_72;
  }
LABEL_65:
  if ( (v12 < 256 || (v12 < 19968 || v12 > 40869) && v12 != 12295 && (v12 < 12321 || v12 > 12329)) && v12 != 95 )
    return 1;
  do
  {
    while ( 1 )
    {
      do
      {
        do
        {
          while ( 1 )
          {
            do
            {
LABEL_72:
              while ( 1 )
              {
                v2 = &v2[(_DWORD)a1];
                v13 = xmlStringCurrentChar(0, v2, &a1);
                v14 = v13;
                if ( v13 < 256 )
                  break;
                if ( !xmlCharInRange(v13, xmlIsBaseCharGroup) )
                  goto LABEL_84;
              }
            }
            while ( v13 >= 65 && v13 <= 90
                 || v13 >= 97 && v13 <= 122
                 || v13 >= 192 && v13 <= 214
                 || v13 >= 216 && v13 <= 246
                 || v13 >= 248 );
LABEL_84:
            if ( v14 >= 256 )
              break;
            if ( (unsigned int)(v14 - 48) > 9 )
              goto LABEL_94;
          }
        }
        while ( v14 >= 19968 && v14 <= 40869
             || v14 == 12295
             || v14 >= 12321 && v14 <= 12329
             || xmlCharInRange(v14, xmlIsDigitGroup) );
LABEL_94:
        ;
      }
      while ( v14 == 46 || v14 == 45 || v14 == 95 );
      if ( v14 < 256 )
        break;
      if ( !xmlCharInRange(v14, xmlIsCombiningGroup) )
      {
        v15 = xmlCharInRange(v14, xmlIsExtenderGroup);
        goto LABEL_101;
      }
    }
    v15 = v14 == 183;
LABEL_101:
    ;
  }
  while ( v15 );
  if ( v14 == 58 )
  {
    v2 = &v2[(_DWORD)a1];
    v16 = xmlStringCurrentChar(0, v2, &a1);
    v17 = v16;
    if ( v16 >= 256 )
    {
      if ( xmlCharInRange(v16, xmlIsBaseCharGroup) )
        goto LABEL_114;
    }
    else if ( v16 >= 65 && v16 <= 90
           || v16 >= 97 && v16 <= 122
           || v16 >= 192 && v16 <= 214
           || v16 >= 216 && v16 <= 246
           || v16 >= 248 )
    {
      goto LABEL_114;
    }
    if ( (v17 < 256 || (v17 < 19968 || v17 > 40869) && v17 != 12295 && (v17 < 12321 || v17 > 12329)) && v17 != 95 )
      return 1;
    while ( 1 )
    {
LABEL_114:
      v2 = &v2[(_DWORD)a1];
      v18 = xmlStringCurrentChar(0, v2, &a1);
      v14 = v18;
      if ( v18 >= 256 )
      {
        if ( xmlCharInRange(v18, xmlIsBaseCharGroup) )
          continue;
      }
      else if ( v18 >= 65 && v18 <= 90
             || v18 >= 97 && v18 <= 122
             || v18 >= 192 && v18 <= 214
             || v18 >= 216 && v18 <= 246
             || v18 >= 248 )
      {
        continue;
      }
      if ( v14 < 256 )
      {
        if ( (unsigned int)(v14 - 48) <= 9 )
          continue;
      }
      else if ( v14 >= 19968 && v14 <= 40869
             || v14 == 12295
             || v14 >= 12321 && v14 <= 12329
             || xmlCharInRange(v14, xmlIsDigitGroup) )
      {
        continue;
      }
      if ( v14 != 46 && v14 != 45 && v14 != 95 )
      {
        if ( v14 < 256 )
        {
          v19 = v14 == 183;
        }
        else
        {
          if ( xmlCharInRange(v14, xmlIsCombiningGroup) )
            continue;
          v19 = xmlCharInRange(v14, xmlIsExtenderGroup);
        }
        if ( !v19 )
          break;
      }
    }
  }
  if ( a2 )
  {
    while ( v14 < 256 && (v14 == 32 || v14 >= 9 && v14 <= 10 || v14 == 13) )
    {
      v2 = &v2[(_DWORD)a1];
      v14 = xmlStringCurrentChar(0, v2, &a1);
    }
  }
  return v14 != 0;
}
// 4155DE: conditional instruction was optimized away because esi.4 is in (100..3006|3008..3020|302A..4DFF|>=9FA6)
// 41561D: conditional instruction was optimized away because esi.4 is in (100..3006|3008..3020|302A..4DFF|>=9FA6)
// 4157BB: conditional instruction was optimized away because esi.4 is in (100..3006|3008..3020|302A..4DFF|>=9FA6)
// 415812: conditional instruction was optimized away because esi.4 is in (100..3006|3008..3020|302A..4DFF|>=9FA6)
// 47C2A4: using guessed type _DWORD xmlIsBaseCharGroup[2];
// 47C454: using guessed type _DWORD xmlIsCombiningGroup[2];
// 47C49C: using guessed type _DWORD xmlIsDigitGroup[2];
// 47C4D4: using guessed type _DWORD xmlIsExtenderGroup[2];

//----- (00415879) --------------------------------------------------------
int __cdecl xmlValidateName(unsigned __int8 *a1, int a2)
{
  unsigned __int8 *v2; // edi
  unsigned __int8 *v3; // ecx
  unsigned __int8 v5; // al
  unsigned __int8 v6; // al
  unsigned __int8 v7; // al
  unsigned __int8 v8; // al
  int v9; // esi
  int v10; // eax
  int v11; // esi
  int v12; // eax

  v2 = a1;
  v3 = a1;
  if ( !a1 )
    return -1;
  if ( a2 )
  {
    while ( 1 )
    {
      v5 = *v3;
      if ( *v3 != 32 && (v5 < 9u || v5 > 0xAu) && v5 != 13 )
        break;
      ++v3;
    }
  }
  v6 = *v3;
  if ( *v3 >= 0x61u && v6 <= 0x7Au || v6 >= 0x41u && v6 <= 0x5Au || v6 == 95 || v6 == 58 )
  {
    do
    {
      do
        v7 = *++v3;
      while ( *v3 >= 0x61u && v7 <= 0x7Au );
    }
    while ( v7 >= 0x41u && v7 <= 0x5Au || v7 >= 0x30u && v7 <= 0x39u || v7 == 95 || v7 == 45 || v7 == 46 || v7 == 58 );
    if ( a2 )
    {
      while ( 1 )
      {
        v8 = *v3;
        if ( *v3 != 32 && (v8 < 9u || v8 > 0xAu) && v8 != 13 )
          break;
        ++v3;
      }
    }
    if ( !*v3 )
      return 0;
  }
  v9 = xmlStringCurrentChar(0, a1, &a1);
  if ( a2 )
  {
    while ( v9 < 256 )
    {
      if ( v9 != 32 && (v9 < 9 || v9 > 10) && v9 != 13 )
        goto LABEL_40;
      v2 = &v2[(_DWORD)a1];
      v9 = xmlStringCurrentChar(0, v2, &a1);
    }
    goto LABEL_61;
  }
LABEL_40:
  if ( v9 >= 256 )
  {
LABEL_61:
    if ( xmlCharInRange(v9, xmlIsBaseCharGroup) )
      goto LABEL_50;
    goto LABEL_62;
  }
  if ( v9 >= 65 && v9 <= 90 || v9 >= 97 && v9 <= 122 || v9 >= 192 && v9 <= 214 || v9 >= 216 && v9 <= 246 || v9 >= 248 )
    goto LABEL_50;
LABEL_62:
  if ( (v9 < 256 || (v9 < 19968 || v9 > 40869) && v9 != 12295 && (v9 < 12321 || v9 > 12329)) && v9 != 95 && v9 != 58 )
    return 1;
  do
  {
    while ( 1 )
    {
      do
      {
        do
        {
          while ( 1 )
          {
            do
            {
LABEL_50:
              while ( 1 )
              {
                v2 = &v2[(_DWORD)a1];
                v10 = xmlStringCurrentChar(0, v2, &a1);
                v11 = v10;
                if ( v10 < 256 )
                  break;
                if ( !xmlCharInRange(v10, xmlIsBaseCharGroup) )
                  goto LABEL_72;
              }
            }
            while ( v10 >= 65 && v10 <= 90
                 || v10 >= 97 && v10 <= 122
                 || v10 >= 192 && v10 <= 214
                 || v10 >= 216 && v10 <= 246
                 || v10 >= 248 );
LABEL_72:
            if ( v11 >= 256 )
              break;
            if ( (unsigned int)(v11 - 48) > 9 )
              goto LABEL_82;
          }
        }
        while ( v11 >= 19968 && v11 <= 40869
             || v11 == 12295
             || v11 >= 12321 && v11 <= 12329
             || xmlCharInRange(v11, xmlIsDigitGroup) );
LABEL_82:
        ;
      }
      while ( v11 == 46 || v11 == 58 || v11 == 45 || v11 == 95 );
      if ( v11 < 256 )
        break;
      if ( !xmlCharInRange(v11, xmlIsCombiningGroup) )
      {
        v12 = xmlCharInRange(v11, xmlIsExtenderGroup);
        goto LABEL_90;
      }
    }
    v12 = v11 == 183;
LABEL_90:
    ;
  }
  while ( v12 );
  if ( a2 )
  {
    while ( v11 < 256 && (v11 == 32 || v11 >= 9 && v11 <= 10 || v11 == 13) )
    {
      v2 = &v2[(_DWORD)a1];
      v11 = xmlStringCurrentChar(0, v2, &a1);
    }
  }
  return v11 != 0;
}
// 415AAF: conditional instruction was optimized away because esi.4 is in (100..3006|3008..3020|302A..4DFF|>=9FA6)
// 415B13: conditional instruction was optimized away because esi.4 is in (100..3006|3008..3020|302A..4DFF|>=9FA6)
// 47C2A4: using guessed type _DWORD xmlIsBaseCharGroup[2];
// 47C454: using guessed type _DWORD xmlIsCombiningGroup[2];
// 47C49C: using guessed type _DWORD xmlIsDigitGroup[2];
// 47C4D4: using guessed type _DWORD xmlIsExtenderGroup[2];

//----- (00415B79) --------------------------------------------------------
int __cdecl xmlValidateNMToken(unsigned __int8 *a1, int a2)
{
  unsigned __int8 *v2; // ecx
  unsigned __int8 v4; // al
  unsigned __int8 v5; // al
  unsigned __int8 v6; // al
  unsigned __int8 v7; // al
  unsigned __int8 *v8; // edi
  int v9; // esi
  int v10; // eax
  int v11; // esi
  int v12; // eax
  int v13; // eax

  v2 = a1;
  if ( !a1 )
    return -1;
  if ( a2 )
  {
    while ( 1 )
    {
      v4 = *v2;
      if ( *v2 != 32 && (v4 < 9u || v4 > 0xAu) && v4 != 13 )
        break;
      ++v2;
    }
  }
  v5 = *v2;
  if ( *v2 >= 0x61u && v5 <= 0x7Au
    || v5 >= 0x41u && v5 <= 0x5Au
    || v5 >= 0x30u && v5 <= 0x39u
    || v5 == 95
    || v5 == 45
    || v5 == 46
    || v5 == 58 )
  {
    do
    {
      do
        v6 = *++v2;
      while ( *v2 >= 0x61u && v6 <= 0x7Au );
    }
    while ( v6 >= 0x41u && v6 <= 0x5Au || v6 >= 0x30u && v6 <= 0x39u || v6 == 95 || v6 == 45 || v6 == 46 || v6 == 58 );
    if ( a2 )
    {
      while ( 1 )
      {
        v7 = *v2;
        if ( *v2 != 32 && (v7 < 9u || v7 > 0xAu) && v7 != 13 )
          break;
        ++v2;
      }
    }
    if ( !*v2 )
      return 0;
  }
  v8 = a1;
  v9 = xmlStringCurrentChar(0, a1, &a1);
  if ( a2 )
  {
    while ( v9 < 256 )
    {
      if ( v9 != 32 && (v9 < 9 || v9 > 10) && v9 != 13 )
        goto LABEL_44;
      v8 = &v8[(_DWORD)a1];
      v9 = xmlStringCurrentChar(0, v8, &a1);
    }
    goto LABEL_65;
  }
LABEL_44:
  if ( v9 >= 256 )
  {
LABEL_65:
    if ( xmlCharInRange(v9, xmlIsBaseCharGroup) )
      goto LABEL_54;
    goto LABEL_66;
  }
  if ( v9 >= 65 && v9 <= 90 || v9 >= 97 && v9 <= 122 || v9 >= 192 && v9 <= 214 || v9 >= 216 && v9 <= 246 || v9 >= 248 )
    goto LABEL_54;
LABEL_66:
  if ( v9 < 256 )
  {
    if ( (unsigned int)(v9 - 48) <= 9 )
      goto LABEL_54;
  }
  else if ( v9 >= 19968 && v9 <= 40869
         || v9 == 12295
         || v9 >= 12321 && v9 <= 12329
         || xmlCharInRange(v9, xmlIsDigitGroup) )
  {
    goto LABEL_54;
  }
  if ( v9 != 46 && v9 != 58 && v9 != 45 && v9 != 95 )
  {
    if ( v9 < 256 )
    {
      v12 = v9 == 183;
    }
    else
    {
      if ( xmlCharInRange(v9, xmlIsCombiningGroup) )
        goto LABEL_54;
      v12 = xmlCharInRange(v9, xmlIsExtenderGroup);
    }
    if ( !v12 )
      return 1;
  }
  do
  {
    while ( 1 )
    {
      do
      {
        do
        {
          while ( 1 )
          {
            do
            {
LABEL_54:
              while ( 1 )
              {
                v8 = &v8[(_DWORD)a1];
                v10 = xmlStringCurrentChar(0, v8, &a1);
                v11 = v10;
                if ( v10 < 256 )
                  break;
                if ( !xmlCharInRange(v10, xmlIsBaseCharGroup) )
                  goto LABEL_87;
              }
            }
            while ( v10 >= 65 && v10 <= 90
                 || v10 >= 97 && v10 <= 122
                 || v10 >= 192 && v10 <= 214
                 || v10 >= 216 && v10 <= 246
                 || v10 >= 248 );
LABEL_87:
            if ( v11 >= 256 )
              break;
            if ( (unsigned int)(v11 - 48) > 9 )
              goto LABEL_97;
          }
        }
        while ( v11 >= 19968 && v11 <= 40869
             || v11 == 12295
             || v11 >= 12321 && v11 <= 12329
             || xmlCharInRange(v11, xmlIsDigitGroup) );
LABEL_97:
        ;
      }
      while ( v11 == 46 || v11 == 58 || v11 == 45 || v11 == 95 );
      if ( v11 < 256 )
        break;
      if ( !xmlCharInRange(v11, xmlIsCombiningGroup) )
      {
        v13 = xmlCharInRange(v11, xmlIsExtenderGroup);
        goto LABEL_105;
      }
    }
    v13 = v11 == 183;
LABEL_105:
    ;
  }
  while ( v13 );
  if ( a2 )
  {
    while ( v11 < 256 && (v11 == 32 || v11 >= 9 && v11 <= 10 || v11 == 13) )
    {
      v8 = &v8[(_DWORD)a1];
      v11 = xmlStringCurrentChar(0, v8, &a1);
    }
  }
  return v11 != 0;
}
// 415D68: conditional instruction was optimized away because esi.4 is in (100..3006|3008..3020|302A..4DFF|>=9FA6)
// 415DC8: conditional instruction was optimized away because esi.4 is in (100..3006|3008..3020|302A..4DFF|>=9FA6)
// 415E41: conditional instruction was optimized away because esi.4 is in (100..3006|3008..3020|302A..4DFF|>=9FA6)
// 415EA1: conditional instruction was optimized away because esi.4 is in (100..3006|3008..3020|302A..4DFF|>=9FA6)
// 47C2A4: using guessed type _DWORD xmlIsBaseCharGroup[2];
// 47C454: using guessed type _DWORD xmlIsCombiningGroup[2];
// 47C49C: using guessed type _DWORD xmlIsDigitGroup[2];
// 47C4D4: using guessed type _DWORD xmlIsExtenderGroup[2];

//----- (00415F07) --------------------------------------------------------
unsigned int __cdecl xmlSetBufferAllocationScheme(unsigned int a1)
{
  unsigned int result; // eax

  result = a1;
  if ( a1 < 2 || a1 == 4 )
    xmlBufferAllocScheme = a1;
  return result;
}
// 4A4B7C: using guessed type int xmlBufferAllocScheme;

//----- (00415F1F) --------------------------------------------------------
int xmlGetBufferAllocationScheme()
{
  return xmlBufferAllocScheme;
}
// 4A4B7C: using guessed type int xmlBufferAllocScheme;

//----- (00415F25) --------------------------------------------------------
_DWORD *__cdecl xmlNewNs(int a1, char *Src, char *a3)
{
  _DWORD *v4; // ebx
  int v5; // eax
  _DWORD *v6; // esi
  char *v7; // eax
  char *v8; // edi

  if ( a1 && *(_DWORD *)(a1 + 4) != 1
    || a3 && xmlStrEqual(a3, "xml") && xmlStrEqual(Src, "http://www.w3.org/XML/1998/namespace") )
  {
    return 0;
  }
  v4 = (_DWORD *)xmlMalloc(24);
  if ( !v4 )
  {
    sub_43279D("building namespace");
    return 0;
  }
  memset(v4, 0, 0x18u);
  v4[1] = 18;
  if ( Src )
    v4[2] = xmlStrdup(Src);
  if ( a3 )
    v4[3] = xmlStrdup(a3);
  if ( !a1 )
    return v4;
  v5 = *(_DWORD *)(a1 + 48);
  if ( !v5 )
  {
    *(_DWORD *)(a1 + 48) = v4;
    return v4;
  }
  v6 = *(_DWORD **)(a1 + 48);
  v7 = *(char **)(v5 + 12);
  if ( v7 || v4[3] )
  {
    v8 = (char *)v4[3];
    while ( !xmlStrEqual(v7, v8) )
    {
      if ( !*v6 )
      {
        *v6 = v4;
        return v4;
      }
      v6 = (_DWORD *)*v6;
      v7 = (char *)v6[3];
      if ( !v7 && !v8 )
        break;
    }
  }
  xmlFreeNs(v4);
  return 0;
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (00416012) --------------------------------------------------------
int __cdecl xmlSetNs(int a1, int a2)
{
  int result; // eax

  result = a1;
  if ( a1 )
    *(_DWORD *)(a1 + 36) = a2;
  return result;
}

//----- (00416022) --------------------------------------------------------
int __cdecl xmlFreeNs(_DWORD *Block)
{
  int result; // eax

  if ( Block )
  {
    if ( Block[2] )
      ((void (__cdecl *)(_DWORD))xmlFree)(Block[2]);
    if ( Block[3] )
      ((void (__cdecl *)(_DWORD))xmlFree)(Block[3]);
    return ((int (__cdecl *)(_DWORD *))xmlFree)(Block);
  }
  return result;
}
// 496494: invalid function type has been ignored

//----- (00416053) --------------------------------------------------------
_DWORD *__cdecl xmlFreeNsList(_DWORD *Block)
{
  _DWORD *result; // eax
  _DWORD *v2; // esi

  result = Block;
  if ( Block )
  {
    do
    {
      v2 = (_DWORD *)*result;
      xmlFreeNs(result);
      result = v2;
    }
    while ( v2 );
  }
  return result;
}

//----- (0041606D) --------------------------------------------------------
_DWORD *__cdecl xmlNewDtd(int a1, _BYTE *Src, _BYTE *a3, _BYTE *a4)
{
  _DWORD *v5; // eax
  _DWORD *v6; // esi

  if ( a1 && *(_DWORD *)(a1 + 48) )
    return 0;
  v5 = (_DWORD *)xmlMalloc(64);
  v6 = v5;
  if ( v5 )
  {
    memset(v5, 0, 0x40u);
    v6[1] = 14;
    if ( Src )
      v6[2] = xmlStrdup(Src);
    if ( a3 )
      v6[13] = xmlStrdup(a3);
    if ( a4 )
      v6[14] = xmlStrdup(a4);
    if ( a1 )
      *(_DWORD *)(a1 + 48) = v6;
    v6[8] = a1;
    if ( dword_4A9C08 )
    {
      if ( xmlRegisterNodeDefaultValue )
        xmlRegisterNodeDefaultValue(v6);
    }
    return v6;
  }
  else
  {
    sub_43279D("building DTD");
    return 0;
  }
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A9C08: using guessed type int dword_4A9C08;
// 4A9CAC: using guessed type int (__cdecl *xmlRegisterNodeDefaultValue)(_DWORD);

//----- (00416112) --------------------------------------------------------
int __cdecl xmlGetIntSubset(int a1)
{
  int result; // eax

  if ( !a1 )
    return 0;
  for ( result = *(_DWORD *)(a1 + 12); result; result = *(_DWORD *)(result + 24) )
  {
    if ( *(_DWORD *)(result + 4) == 14 )
      return result;
  }
  return *(_DWORD *)(a1 + 44);
}

//----- (00416133) --------------------------------------------------------
_DWORD *__cdecl xmlCreateIntSubset(_DWORD *a1, _BYTE *Src, _BYTE *a3, _BYTE *a4)
{
  _DWORD *v5; // eax
  _DWORD *v6; // esi
  _BYTE *v7; // eax
  _BYTE *v8; // eax
  int v9; // eax
  _BYTE *v10; // eax
  _DWORD *v11; // eax
  int v12; // eax
  int v13; // ecx

  if ( a1 && xmlGetIntSubset((int)a1) )
    return 0;
  v5 = (_DWORD *)xmlMalloc(64);
  v6 = v5;
  if ( !v5 )
  {
    sub_43279D("building internal subset");
    return 0;
  }
  memset(v5, 0, 0x40u);
  v6[1] = 14;
  if ( Src )
  {
    v7 = xmlStrdup(Src);
    v6[2] = v7;
    if ( !v7 )
    {
      sub_43279D("building internal subset");
      ((void (__cdecl *)(_DWORD *))xmlFree)(v6);
      return 0;
    }
  }
  if ( a3 )
  {
    v8 = xmlStrdup(a3);
    v6[13] = v8;
    if ( !v8 )
    {
      sub_43279D("building internal subset");
      v9 = v6[2];
LABEL_17:
      if ( v9 )
        ((void (__cdecl *)(int))xmlFree)(v9);
      ((void (__cdecl *)(_DWORD *))xmlFree)(v6);
      return 0;
    }
  }
  if ( a4 )
  {
    v10 = xmlStrdup(a4);
    v6[14] = v10;
    if ( !v10 )
    {
      sub_43279D("building internal subset");
      if ( v6[2] )
        ((void (__cdecl *)(_DWORD))xmlFree)(v6[2]);
      v9 = v6[13];
      goto LABEL_17;
    }
  }
  if ( a1 )
  {
    a1[11] = v6;
    v6[5] = a1;
    v6[8] = a1;
    v11 = (_DWORD *)a1[3];
    if ( v11 )
    {
      if ( a1[1] == 13 )
      {
        v11[7] = v6;
        v6[6] = v11;
        a1[3] = v6;
        goto LABEL_35;
      }
      do
      {
        if ( v11[1] == 1 )
          break;
        v11 = (_DWORD *)v11[6];
      }
      while ( v11 );
      if ( v11 )
      {
        v6[6] = v11;
        v13 = v11[7];
        v6[7] = v13;
        if ( v13 )
          *(_DWORD *)(v13 + 24) = v6;
        else
          a1[3] = v6;
        v11[7] = v6;
        goto LABEL_35;
      }
      v12 = a1[4];
      v6[7] = v12;
      *(_DWORD *)(v12 + 24) = v6;
      v6[6] = 0;
    }
    else
    {
      a1[3] = v6;
    }
    a1[4] = v6;
  }
LABEL_35:
  if ( dword_4A9C08 && xmlRegisterNodeDefaultValue )
    xmlRegisterNodeDefaultValue(v6);
  return v6;
}
// 496494: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A9C08: using guessed type int dword_4A9C08;
// 4A9CAC: using guessed type int (__cdecl *xmlRegisterNodeDefaultValue)(_DWORD);

//----- (0041629D) --------------------------------------------------------
void __cdecl xmlFreeDtd(_DWORD *Block)
{
  int v1; // ebx
  int v2; // eax
  int v3; // edi
  int v4; // eax
  int v5; // edi
  int v6; // edi
  int v7; // edi
  int v8; // [esp+8h] [ebp-4h]

  v1 = 0;
  v8 = 0;
  if ( Block )
  {
    v2 = Block[8];
    if ( v2 )
      v8 = *(_DWORD *)(v2 + 80);
    if ( dword_4A9C08 && xmlDeregisterNodeDefaultValue )
      xmlDeregisterNodeDefaultValue(Block);
    v3 = Block[3];
    if ( v3 )
    {
      do
      {
        v4 = *(_DWORD *)(v3 + 4);
        v1 = *(_DWORD *)(v3 + 24);
        if ( v4 != 12 && v4 != 15 && v4 != 16 && v4 != 17 )
        {
          xmlUnlinkNode(v3);
          xmlFreeNode((char *)v3);
        }
        v3 = v1;
      }
      while ( v1 );
    }
    v5 = Block[2];
    if ( v5 != v1 && (v8 == v1 || !xmlDictOwns(v8, Block[2])) )
      ((void (__cdecl *)(int))xmlFree)(v5);
    v6 = Block[14];
    if ( v6 != v1 && (v8 == v1 || !xmlDictOwns(v8, Block[14])) )
      ((void (__cdecl *)(int))xmlFree)(v6);
    v7 = Block[13];
    if ( v7 != v1 && (v8 == v1 || !xmlDictOwns(v8, Block[13])) )
      ((void (__cdecl *)(int))xmlFree)(v7);
    if ( Block[9] != v1 )
      xmlFreeNotationTable((_DWORD *)Block[9]);
    if ( Block[10] != v1 )
      xmlFreeElementTable((_DWORD *)Block[10]);
    if ( Block[11] != v1 )
      xmlFreeAttributeTable((_DWORD *)Block[11]);
    if ( Block[12] != v1 )
      xmlFreeEntitiesTable((_DWORD *)Block[12]);
    if ( Block[15] != v1 )
      xmlFreeEntitiesTable((_DWORD *)Block[15]);
    ((void (__cdecl *)(_DWORD *))xmlFree)(Block);
  }
}
// 496494: invalid function type has been ignored
// 4A9C08: using guessed type int dword_4A9C08;
// 4A9CB4: using guessed type int (__cdecl *xmlDeregisterNodeDefaultValue)(_DWORD);

//----- (004163C7) --------------------------------------------------------
_DWORD *__cdecl xmlNewDoc(char *Src)
{
  char *v1; // edi
  _DWORD *v2; // eax
  _DWORD *v3; // esi
  _BYTE *v5; // eax
  bool v6; // zf

  v1 = Src;
  if ( !Src )
    v1 = "1.0";
  v2 = (_DWORD *)xmlMalloc(96);
  v3 = v2;
  if ( !v2 )
  {
    sub_43279D("building doc");
    return 0;
  }
  memset(v2, 0, 0x60u);
  v3[1] = 9;
  v5 = xmlStrdup(v1);
  v3[14] = v5;
  if ( !v5 )
  {
    sub_43279D("building doc");
    ((void (__cdecl *)(_DWORD *))xmlFree)(v3);
    return 0;
  }
  v3[10] = -1;
  v3[9] = -1;
  v3[22] = 0;
  v6 = dword_4A9C08 == 0;
  v3[8] = v3;
  v3[23] = 32;
  v3[19] = 1;
  if ( !v6 )
  {
    if ( xmlRegisterNodeDefaultValue )
      xmlRegisterNodeDefaultValue(v3);
  }
  return v3;
}
// 496494: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A9C08: using guessed type int dword_4A9C08;
// 4A9CAC: using guessed type int (__cdecl *xmlRegisterNodeDefaultValue)(_DWORD);

//----- (00416461) --------------------------------------------------------
void __cdecl xmlFreeDoc(void *Block)
{
  _DWORD *v2; // eax
  int v3; // eax
  _DWORD *v4; // ebx
  _DWORD *v5; // edi
  int v6; // edi
  int v7; // edi
  int v8; // edi
  int v9; // edi
  void **Blocka; // [esp+10h] [ebp+8h]

  if ( Block )
  {
    Blocka = (void **)*((_DWORD *)Block + 20);
    if ( dword_4A9C08 && xmlDeregisterNodeDefaultValue )
      xmlDeregisterNodeDefaultValue(Block);
    if ( *((_DWORD *)Block + 16) )
      xmlFreeIDTable(*((_DWORD **)Block + 16));
    v2 = (_DWORD *)*((_DWORD *)Block + 17);
    *((_DWORD *)Block + 16) = 0;
    if ( v2 )
      xmlFreeRefTable(v2);
    v3 = *((_DWORD *)Block + 12);
    v4 = (_DWORD *)*((_DWORD *)Block + 11);
    *((_DWORD *)Block + 17) = 0;
    v5 = (_DWORD *)v3;
    if ( v4 == (_DWORD *)v3 )
      v5 = 0;
    if ( v5 )
    {
      xmlUnlinkNode(v3);
      *((_DWORD *)Block + 12) = 0;
      xmlFreeDtd(v5);
    }
    if ( v4 )
    {
      xmlUnlinkNode(*((_DWORD *)Block + 11));
      *((_DWORD *)Block + 11) = 0;
      xmlFreeDtd(v4);
    }
    if ( *((_DWORD *)Block + 3) )
      xmlFreeNodeList(*((void **)Block + 3));
    if ( *((_DWORD *)Block + 13) )
      xmlFreeNsList(*((_DWORD **)Block + 13));
    v6 = *((_DWORD *)Block + 14);
    if ( v6 && (!Blocka || !xmlDictOwns((int)Blocka, *((_DWORD *)Block + 14))) )
      ((void (__cdecl *)(int))xmlFree)(v6);
    v7 = *((_DWORD *)Block + 2);
    if ( v7 && (!Blocka || !xmlDictOwns((int)Blocka, *((_DWORD *)Block + 2))) )
      ((void (__cdecl *)(int))xmlFree)(v7);
    v8 = *((_DWORD *)Block + 15);
    if ( v8 && (!Blocka || !xmlDictOwns((int)Blocka, *((_DWORD *)Block + 15))) )
      ((void (__cdecl *)(int))xmlFree)(v8);
    v9 = *((_DWORD *)Block + 18);
    if ( v9 && (!Blocka || !xmlDictOwns((int)Blocka, *((_DWORD *)Block + 18))) )
      ((void (__cdecl *)(int))xmlFree)(v9);
    ((void (__cdecl *)(void *))xmlFree)(Block);
    if ( Blocka )
      xmlDictFree(Blocka);
  }
}
// 496494: invalid function type has been ignored
// 4A9C08: using guessed type int dword_4A9C08;
// 4A9CB4: using guessed type int (__cdecl *xmlDeregisterNodeDefaultValue)(_DWORD);

//----- (004165A4) --------------------------------------------------------
_DWORD *__cdecl xmlStringLenGetNodeList(int (__cdecl *a1)(int, char *Format, char ArgList), char *Src, int a3)
{
  char *i; // esi
  char *v4; // edi
  int *Size; // eax
  char *v7; // ebx
  char *v8; // eax
  int v9; // eax
  unsigned __int8 v10; // bl
  unsigned __int8 v11; // bl
  char *v12; // ecx
  _DWORD *DocEntity; // eax
  _DWORD *v14; // edi
  char *v15; // ebx
  char *v16; // eax
  char *v17; // ebx
  char *NodeList; // eax
  char *v19; // esi
  _DWORD *v20; // [esp+10h] [ebp-28h]
  char *Block; // [esp+14h] [ebp-24h]
  int *v22; // [esp+1Ch] [ebp-1Ch]
  char *Sibling; // [esp+20h] [ebp-18h]
  int v24; // [esp+24h] [ebp-14h]
  char v25[12]; // [esp+28h] [ebp-10h] BYREF

  i = Src;
  v4 = &Src[a3];
  v20 = 0;
  Sibling = 0;
  if ( !Src )
    return 0;
  Size = xmlBufferCreateSize(0);
  v22 = Size;
  if ( !Size )
    return 0;
  xmlBufferSetAllocationScheme((int)Size, 4u);
  v7 = Src;
  if ( Src < v4 )
  {
    do
    {
      if ( !*i )
        break;
      if ( *i == 38 )
      {
        v24 = 0;
        if ( i != v7 && xmlBufferAdd(v22, v7, i - v7) )
          goto LABEL_82;
        v8 = i + 2;
        if ( i + 2 < v4 && i[1] == 35 && *v8 == 120 )
        {
          for ( i += 3; ; ++i )
          {
            v10 = i >= v4 ? 0 : *i;
            if ( v10 == 59 )
              break;
            if ( (unsigned __int8)(v10 - 48) > 9u )
            {
              if ( (unsigned __int8)(v10 - 97) > 5u )
              {
                if ( (unsigned __int8)(v10 - 65) > 5u )
                {
                  sub_414F02(1300, a1, 0);
                  goto LABEL_26;
                }
                v9 = 16 * v24 + v10 - 55;
              }
              else
              {
                v9 = 16 * v24 + v10 - 87;
              }
            }
            else
            {
              v9 = v10 + 16 * (v24 - 3);
            }
            v24 = v9;
          }
        }
        else if ( ++i < v4 && *i == 35 )
        {
          for ( i = v8; ; ++i )
          {
            v11 = i >= v4 ? 0 : *i;
            if ( v11 == 59 )
              break;
            if ( (unsigned __int8)(v11 - 48) > 9u )
            {
              sub_414F02(1301, a1, 0);
LABEL_26:
              v24 = 0;
              goto LABEL_65;
            }
            v24 = 10 * v24 + v11 - 48;
          }
        }
        else
        {
          v12 = i;
          if ( i >= v4 )
            goto LABEL_78;
          do
          {
            if ( !*i )
              break;
            if ( *i == 59 )
              break;
            ++i;
          }
          while ( i < v4 );
          if ( i >= v4 || !*i )
          {
LABEL_78:
            sub_414F02(1302, a1, v12);
            goto LABEL_82;
          }
          if ( i != v12 )
          {
            Block = xmlStrndup(v12, i - v12);
            DocEntity = xmlGetDocEntity(a1, Block);
            v14 = DocEntity;
            if ( DocEntity && DocEntity[12] == 6 )
            {
              if ( xmlBufferCat(v22, (_BYTE *)DocEntity[10]) )
                goto LABEL_82;
            }
            else
            {
              if ( v22[1] )
              {
                v15 = (char *)xmlNewDocText((int)a1, 0);
                if ( !v15 )
                  goto LABEL_76;
                *((_DWORD *)v15 + 10) = xmlBufferDetach(v22);
                if ( Sibling )
                {
                  Sibling = xmlAddNextSibling(Sibling, v15);
                }
                else
                {
                  v20 = v15;
                  Sibling = v15;
                }
              }
              v16 = (char *)xmlNewReference(a1, Block);
              v17 = v16;
              if ( !v16 )
              {
LABEL_76:
                if ( Block )
                  ((void (__cdecl *)(char *))xmlFree)(Block);
                goto LABEL_82;
              }
              if ( v14 && !v14[3] )
              {
                NodeList = xmlStringGetNodeList(a1, *((unsigned __int8 **)v16 + 10));
                v14[3] = NodeList;
                v14[17] = 1;
                while ( NodeList )
                {
                  *((_DWORD *)NodeList + 5) = v14;
                  v14[4] = NodeList;
                  NodeList = (char *)*((_DWORD *)NodeList + 6);
                }
              }
              if ( Sibling )
              {
                Sibling = xmlAddNextSibling(Sibling, v17);
              }
              else
              {
                v20 = v17;
                Sibling = v17;
              }
            }
            ((void (__cdecl *)(char *))xmlFree)(Block);
            v4 = &Src[a3];
          }
        }
        ++i;
LABEL_65:
        v7 = i;
        if ( v24 )
        {
          v25[xmlCopyCharMultiByte(v25, v24)] = 0;
          if ( xmlBufferCat(v22, v25) )
            goto LABEL_82;
        }
      }
      else
      {
        ++i;
      }
    }
    while ( i < v4 );
    if ( i != v7 && xmlBufferAdd(v22, v7, i - v7) )
      goto LABEL_82;
  }
  if ( v22[1] )
  {
    v19 = (char *)xmlNewDocText((int)a1, 0);
    if ( v19 )
    {
      *((_DWORD *)v19 + 10) = xmlBufferDetach(v22);
      if ( Sibling )
        xmlAddNextSibling(Sibling, v19);
      else
        v20 = v19;
    }
  }
  else if ( !v20 )
  {
    v20 = xmlNewDocText((int)a1, byte_47627C);
  }
LABEL_82:
  xmlBufferFree(v22);
  return v20;
}
// 496494: invalid function type has been ignored
// 4166C9: conditional instruction was optimized away because bl.1!=3B
// 4165A4: using guessed type char var_10[12];

//----- (0041692B) --------------------------------------------------------
char *__cdecl xmlStringGetNodeList(int (__cdecl *a1)(int, char *Format, char ArgList), unsigned __int8 *Src)
{
  unsigned __int8 *v2; // esi
  int (__cdecl *v3)(int, char *, char); // edi
  int *Size; // eax
  unsigned __int8 *v6; // ebx
  char *v7; // eax
  int v8; // eax
  unsigned __int8 v9; // bl
  char v10; // al
  unsigned __int8 *v11; // ecx
  _BYTE **DocEntity; // eax
  _BYTE **v13; // edi
  char *v14; // ebx
  char *v15; // eax
  char *v16; // ebx
  int NodeList; // eax
  char *v18; // esi
  char *Block; // [esp+10h] [ebp-24h]
  char *v20; // [esp+14h] [ebp-20h]
  int *v21; // [esp+18h] [ebp-1Ch]
  char *Sibling; // [esp+1Ch] [ebp-18h]
  int v23; // [esp+20h] [ebp-14h]
  char v24[12]; // [esp+24h] [ebp-10h] BYREF

  v2 = Src;
  v3 = a1;
  v20 = 0;
  Sibling = 0;
  if ( !Src )
    return 0;
  Size = xmlBufferCreateSize(0);
  v21 = Size;
  if ( !Size )
    return 0;
  xmlBufferSetAllocationScheme((int)Size, 4u);
  v6 = Src;
  if ( *Src )
  {
    do
    {
      if ( *v2 == 38 )
      {
        v23 = 0;
        if ( v2 != v6 && xmlBufferAdd(v21, v6, v2 - v6) )
          goto LABEL_68;
        v7 = (char *)(v2 + 1);
        if ( v2[1] == 35 )
        {
          if ( v2[2] == 120 )
          {
            for ( v2 += 3; ; ++v2 )
            {
              v9 = *v2;
              if ( *v2 == 59 )
                break;
              if ( (unsigned __int8)(v9 - 48) > 9u )
              {
                if ( (unsigned __int8)(v9 - 97) > 5u )
                {
                  if ( (unsigned __int8)(v9 - 65) > 5u )
                  {
                    sub_414F02(1300, v3, 0);
                    goto LABEL_21;
                  }
                  v8 = 16 * v23 + v9 - 55;
                }
                else
                {
                  v8 = 16 * v23 + v9 - 87;
                }
              }
              else
              {
                v8 = v9 + 16 * (v23 - 3);
              }
              v23 = v8;
            }
          }
          else
          {
            for ( v2 += 2; ; ++v2 )
            {
              v9 = *v2;
              if ( *v2 == 59 )
                break;
              if ( (unsigned __int8)(v9 - 48) > 9u )
              {
                sub_414F02(1301, v3, 0);
LABEL_21:
                v23 = 0;
                if ( v9 != 59 )
                  goto LABEL_53;
                break;
              }
              v23 = 10 * v23 + v9 - 48;
            }
          }
        }
        else
        {
          ++v2;
          v10 = *v7;
          v11 = v2;
          if ( !v10 )
            goto LABEL_64;
          do
          {
            if ( v10 == 59 )
              break;
            v10 = *++v2;
          }
          while ( *v2 );
          if ( !*v2 )
          {
LABEL_64:
            sub_414F02(1302, v3, v11);
            goto LABEL_68;
          }
          if ( v2 != v11 )
          {
            Block = xmlStrndup(v11, v2 - v11);
            DocEntity = (_BYTE **)xmlGetDocEntity(v3, Block);
            v13 = DocEntity;
            if ( DocEntity && DocEntity[12] == (_BYTE *)6 )
            {
              if ( xmlBufferCat(v21, DocEntity[10]) )
                goto LABEL_68;
            }
            else
            {
              if ( v21[1] )
              {
                v14 = (char *)xmlNewDocText((int)a1, 0);
                *((_DWORD *)v14 + 10) = xmlBufferDetach(v21);
                if ( Sibling )
                {
                  Sibling = xmlAddNextSibling(Sibling, v14);
                }
                else
                {
                  v20 = v14;
                  Sibling = v14;
                }
              }
              v15 = (char *)xmlNewReference(a1, Block);
              v16 = v15;
              if ( !v15 )
              {
                if ( Block )
                  ((void (__cdecl *)(char *))xmlFree)(Block);
                goto LABEL_68;
              }
              if ( v13 && !v13[3] )
              {
                NodeList = xmlStringGetNodeList(a1, *((void **)v15 + 10));
                v13[3] = (_BYTE *)NodeList;
                v13[17] = (_BYTE *)1;
                while ( NodeList )
                {
                  *(_DWORD *)(NodeList + 20) = v13;
                  NodeList = *(_DWORD *)(NodeList + 24);
                }
              }
              if ( Sibling )
              {
                Sibling = xmlAddNextSibling(Sibling, v16);
              }
              else
              {
                v20 = v16;
                Sibling = v16;
              }
            }
            ((void (__cdecl *)(char *))xmlFree)(Block);
            v3 = a1;
          }
        }
        ++v2;
LABEL_53:
        v6 = v2;
        if ( v23 )
        {
          v24[xmlCopyCharMultiByte(v24, v23)] = 0;
          if ( xmlBufferCat(v21, v24) )
            goto LABEL_68;
        }
      }
      else
      {
        ++v2;
      }
    }
    while ( *v2 );
    if ( v2 == v6 && v20 )
      goto LABEL_61;
  }
  xmlBufferAdd(v21, v6, v2 - v6);
LABEL_61:
  if ( v21[1] )
  {
    v18 = (char *)xmlNewDocText((int)v3, 0);
    *((_DWORD *)v18 + 10) = xmlBufferDetach(v21);
    if ( Sibling )
      xmlAddNextSibling(Sibling, v18);
    else
      v20 = v18;
  }
LABEL_68:
  xmlBufferFree(v21);
  return v20;
}
// 496494: invalid function type has been ignored
// 416A39: conditional instruction was optimized away because cl.1==23
// 41692B: using guessed type char var_10[12];

//----- (00416C48) --------------------------------------------------------
_BYTE *__cdecl xmlNodeListGetString(_DWORD *a1, int Src, int a3)
{
  int v3; // esi
  _BYTE *v4; // ebx
  int v6; // eax
  _DWORD *DocEntity; // eax
  char *String; // eax
  _BYTE *v9; // eax
  _BYTE *v10; // eax
  _BYTE *v11; // eax
  char *v12; // edi
  unsigned __int8 *v13; // [esp-8h] [ebp-10h]

  v3 = Src;
  v4 = 0;
  if ( !Src )
    return 0;
  do
  {
    v6 = *(_DWORD *)(v3 + 4);
    if ( v6 != 3 && v6 != 4 )
    {
      if ( v6 != 5 )
        goto LABEL_17;
      if ( a3 )
      {
        DocEntity = xmlGetDocEntity(a1, *(char **)(v3 + 8));
        if ( DocEntity )
        {
          String = (char *)xmlNodeListGetString(a1, DocEntity[3], 1);
          goto LABEL_15;
        }
        v9 = xmlStrcat(v4, *(_BYTE **)(v3 + 40));
      }
      else
      {
        LOWORD(Src) = 38;
        v10 = xmlStrncat(v4, &Src, 1);
        v11 = xmlStrcat(v10, *(_BYTE **)(v3 + 8));
        LOWORD(Src) = 59;
        v9 = xmlStrncat(v11, &Src, 1);
      }
LABEL_13:
      v4 = v9;
      goto LABEL_17;
    }
    v13 = *(unsigned __int8 **)(v3 + 40);
    if ( a3 )
    {
      v9 = xmlStrcat(v4, v13);
      goto LABEL_13;
    }
    String = xmlEncodeEntitiesReentrant((int)a1, v13);
LABEL_15:
    v12 = String;
    if ( String )
    {
      v4 = xmlStrcat(v4, String);
      ((void (__cdecl *)(char *))xmlFree)(v12);
    }
LABEL_17:
    v3 = *(_DWORD *)(v3 + 24);
  }
  while ( v3 );
  return v4;
}
// 496494: invalid function type has been ignored

//----- (00416D22) --------------------------------------------------------
_BYTE *__cdecl xmlNodeListGetRawString(_DWORD *a1, int Src, int a3)
{
  int v3; // esi
  _BYTE *v4; // ebx
  int v6; // eax
  _DWORD *DocEntity; // eax
  _BYTE *RawString; // eax
  _BYTE *v9; // eax
  _BYTE *v10; // eax
  _BYTE *v11; // eax
  _BYTE *v12; // edi
  char *v13; // [esp-8h] [ebp-10h]

  v3 = Src;
  v4 = 0;
  if ( !Src )
    return 0;
  do
  {
    v6 = *(_DWORD *)(v3 + 4);
    if ( v6 != 3 && v6 != 4 )
    {
      if ( v6 != 5 )
        goto LABEL_17;
      if ( a3 )
      {
        DocEntity = xmlGetDocEntity(a1, *(char **)(v3 + 8));
        if ( DocEntity )
        {
          RawString = (_BYTE *)xmlNodeListGetRawString(a1, DocEntity[3], 1);
          goto LABEL_15;
        }
        v9 = xmlStrcat(v4, *(_BYTE **)(v3 + 40));
      }
      else
      {
        LOWORD(Src) = 38;
        v10 = xmlStrncat(v4, &Src, 1);
        v11 = xmlStrcat(v10, *(_BYTE **)(v3 + 8));
        LOWORD(Src) = 59;
        v9 = xmlStrncat(v11, &Src, 1);
      }
LABEL_13:
      v4 = v9;
      goto LABEL_17;
    }
    v13 = *(char **)(v3 + 40);
    if ( a3 )
    {
      v9 = xmlStrcat(v4, v13);
      goto LABEL_13;
    }
    RawString = xmlEncodeSpecialChars((int)a1, v13);
LABEL_15:
    v12 = RawString;
    if ( RawString )
    {
      v4 = xmlStrcat(v4, RawString);
      ((void (__cdecl *)(_BYTE *))xmlFree)(v12);
    }
LABEL_17:
    v3 = *(_DWORD *)(v3 + 24);
  }
  while ( v3 );
  return v4;
}
// 496494: invalid function type has been ignored

//----- (00416DFC) --------------------------------------------------------
_DWORD *__usercall sub_416DFC@<eax>(_DWORD *a1@<eax>, int a2, char *Block, char *Src, int a5)
{
  int v6; // ebx
  int v7; // edi
  _DWORD *v9; // eax
  _DWORD *v10; // esi
  int v11; // edi
  _DWORD *v12; // eax
  unsigned __int8 *v13; // eax
  _DWORD *v14; // eax
  bool v15; // zf
  int v16; // eax

  v6 = 0;
  if ( !a1 || a1[1] == 1 )
  {
    v9 = (_DWORD *)xmlMalloc(48);
    v10 = v9;
    if ( v9 )
    {
      memset(v9, 0, 0x30u);
      v10[1] = 2;
      v10[5] = a1;
      if ( a1 )
      {
        v6 = a1[8];
        v10[8] = v6;
      }
      v10[9] = a2;
      if ( a5 )
      {
        v13 = (unsigned __int8 *)Block;
      }
      else if ( v6 && (v12 = *(_DWORD **)(v6 + 80)) != 0 )
      {
        v13 = xmlDictLookup(v12, Block, -1);
      }
      else
      {
        v13 = xmlStrdup(Block);
      }
      v10[2] = v13;
      if ( Src )
      {
        if ( !xmlCheckUTF8(Src) )
        {
          sub_414F02(1303, (int (__cdecl *)(int, char *, char))v6, 0);
          if ( v6 )
            *(_DWORD *)(v6 + 60) = xmlStrdup("ISO-8859-1");
        }
        v14 = xmlNewDocText(v6, Src);
        v10[4] = 0;
        v10[3] = v14;
        while ( v14 )
        {
          v15 = v14[6] == 0;
          v14[5] = v10;
          if ( v15 )
            v10[4] = v14;
          v14 = (_DWORD *)v14[6];
        }
      }
      if ( a1 )
      {
        v16 = a1[11];
        if ( v16 )
        {
          while ( *(_DWORD *)(v16 + 24) )
            v16 = *(_DWORD *)(v16 + 24);
          *(_DWORD *)(v16 + 24) = v10;
          v10[7] = v16;
        }
        else
        {
          a1[11] = v10;
        }
      }
      if ( Src && a1 && xmlIsID((_DWORD *)a1[8], (int)a1, (int)v10) == 1 )
        xmlAddID(0, a1[8], (unsigned __int8 *)Src, (int)v10);
      if ( dword_4A9C08 && xmlRegisterNodeDefaultValue )
        xmlRegisterNodeDefaultValue(v10);
      return v10;
    }
    else
    {
      if ( a5 == 1 && (!a1 || (v11 = a1[8]) == 0 || !xmlDictOwns(*(_DWORD *)(v11 + 80), (unsigned int)Block)) )
        ((void (__cdecl *)(char *))xmlFree)(Block);
      sub_43279D("building attribute");
      return 0;
    }
  }
  else
  {
    if ( a5 == 1 )
    {
      v7 = a1[8];
      if ( !v7 || !xmlDictOwns(*(_DWORD *)(v7 + 80), (unsigned int)Block) )
        ((void (__cdecl *)(char *))xmlFree)(Block);
    }
    return 0;
  }
}
// 496494: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A9C08: using guessed type int dword_4A9C08;
// 4A9CAC: using guessed type int (__cdecl *xmlRegisterNodeDefaultValue)(_DWORD);

//----- (00416FA9) --------------------------------------------------------
_DWORD *__cdecl xmlNewProp(_DWORD *a1, char *Block, char *a3)
{
  _DWORD *result; // eax

  result = 0;
  if ( Block )
    return sub_416DFC(a1, 0, Block, a3, 0);
  return result;
}

//----- (00416FC9) --------------------------------------------------------
_DWORD *__cdecl xmlNewNsProp(_DWORD *a1, int a2, char *Block, char *a4)
{
  if ( Block )
    return sub_416DFC(a1, a2, Block, a4, 0);
  else
    return 0;
}

//----- (00416FEE) --------------------------------------------------------
_DWORD *__cdecl xmlNewNsPropEatName(_DWORD *a1, int a2, char *Block, char *a4)
{
  if ( Block )
    return sub_416DFC(a1, a2, Block, a4, 1);
  else
    return 0;
}

//----- (00417013) --------------------------------------------------------
_DWORD *__cdecl xmlNewDocProp(int a1, char *Src, unsigned __int8 *a3)
{
  _DWORD *v4; // eax
  _DWORD *v5; // esi
  _DWORD *v6; // eax
  unsigned __int8 *v7; // eax
  char *NodeList; // eax

  if ( !Src )
    return 0;
  v4 = (_DWORD *)xmlMalloc(48);
  v5 = v4;
  if ( v4 )
  {
    memset(v4, 0, 0x30u);
    v5[1] = 2;
    if ( a1 && (v6 = *(_DWORD **)(a1 + 80)) != 0 )
      v7 = xmlDictLookup(v6, Src, -1);
    else
      v7 = xmlStrdup(Src);
    v5[2] = v7;
    v5[8] = a1;
    if ( a3 )
    {
      NodeList = xmlStringGetNodeList((int (__cdecl *)(int, char *, char))a1, a3);
      v5[3] = NodeList;
      v5[4] = 0;
      while ( NodeList )
      {
        *((_DWORD *)NodeList + 5) = v5;
        if ( !*((_DWORD *)NodeList + 6) )
          v5[4] = NodeList;
        NodeList = (char *)*((_DWORD *)NodeList + 6);
      }
    }
    if ( dword_4A9C08 )
    {
      if ( xmlRegisterNodeDefaultValue )
        xmlRegisterNodeDefaultValue(v5);
    }
    return v5;
  }
  else
  {
    sub_43279D("building attribute");
    return 0;
  }
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A9C08: using guessed type int dword_4A9C08;
// 4A9CAC: using guessed type int (__cdecl *xmlRegisterNodeDefaultValue)(_DWORD);

//----- (004170CE) --------------------------------------------------------
_DWORD *__cdecl xmlFreePropList(_DWORD *Block)
{
  _DWORD *result; // eax
  _DWORD *v2; // esi

  result = Block;
  if ( Block )
  {
    do
    {
      v2 = (_DWORD *)result[6];
      xmlFreeProp(result);
      result = v2;
    }
    while ( v2 );
  }
  return result;
}

//----- (004170E9) --------------------------------------------------------
void __cdecl xmlFreeProp(_DWORD *Block)
{
  int v1; // ebx
  int v2; // eax
  _DWORD *v3; // eax
  int v4; // edi

  v1 = 0;
  if ( Block )
  {
    v2 = Block[8];
    if ( v2 )
      v1 = *(_DWORD *)(v2 + 80);
    if ( dword_4A9C08 && xmlDeregisterNodeDefaultValue )
      xmlDeregisterNodeDefaultValue(Block);
    v3 = (_DWORD *)Block[8];
    if ( v3 && Block[10] == 2 )
      xmlRemoveID(v3, (int)Block);
    if ( Block[3] )
      xmlFreeNodeList((_DWORD *)Block[3]);
    v4 = Block[2];
    if ( v4 && (!v1 || !xmlDictOwns(v1, Block[2])) )
      ((void (__cdecl *)(int))xmlFree)(v4);
    ((void (__cdecl *)(_DWORD *))xmlFree)(Block);
  }
}
// 496494: invalid function type has been ignored
// 4A9C08: using guessed type int dword_4A9C08;
// 4A9CB4: using guessed type int (__cdecl *xmlDeregisterNodeDefaultValue)(_DWORD);

//----- (00417166) --------------------------------------------------------
int __cdecl xmlRemoveProp(_DWORD *Block)
{
  int v1; // edx
  _DWORD *v2; // ecx
  int v3; // ecx
  int v5; // edx

  if ( !Block )
    return -1;
  v1 = Block[5];
  if ( !v1 )
    return -1;
  v2 = *(_DWORD **)(v1 + 44);
  if ( v2 != Block )
  {
    while ( v2 )
    {
      if ( (_DWORD *)v2[6] == Block )
      {
        v5 = Block[6];
        v2[6] = v5;
        if ( v5 )
          *(_DWORD *)(v5 + 28) = v2;
        goto LABEL_6;
      }
      v2 = (_DWORD *)v2[6];
    }
    return -1;
  }
  *(_DWORD *)(v1 + 44) = Block[6];
  v3 = Block[6];
  if ( v3 )
    *(_DWORD *)(v3 + 28) = 0;
LABEL_6:
  xmlFreeProp(Block);
  return 0;
}

//----- (004171B7) --------------------------------------------------------
_DWORD *__cdecl xmlNewDocPI(int a1, char *Src, _BYTE *a3)
{
  _DWORD *v4; // eax
  _DWORD *v5; // esi
  _DWORD *v6; // eax
  unsigned __int8 *v7; // eax
  bool v8; // zf

  if ( !Src )
    return 0;
  v4 = (_DWORD *)xmlMalloc(60);
  v5 = v4;
  if ( v4 )
  {
    memset(v4, 0, 0x3Cu);
    v5[1] = 7;
    if ( a1 && (v6 = *(_DWORD **)(a1 + 80)) != 0 )
      v7 = xmlDictLookup(v6, Src, -1);
    else
      v7 = xmlStrdup(Src);
    v5[2] = v7;
    if ( a3 )
      v5[10] = xmlStrdup(a3);
    v8 = dword_4A9C08 == 0;
    v5[8] = a1;
    if ( !v8 )
    {
      if ( xmlRegisterNodeDefaultValue )
        xmlRegisterNodeDefaultValue(v5);
    }
    return v5;
  }
  else
  {
    sub_43279D("building PI");
    return 0;
  }
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A9C08: using guessed type int dword_4A9C08;
// 4A9CAC: using guessed type int (__cdecl *xmlRegisterNodeDefaultValue)(_DWORD);

//----- (00417253) --------------------------------------------------------
_DWORD *__cdecl xmlNewPI(char *Src, _BYTE *a2)
{
  return xmlNewDocPI(0, Src, a2);
}

//----- (00417266) --------------------------------------------------------
_DWORD *__cdecl xmlNewNode(int a1, _BYTE *Src)
{
  _DWORD *v3; // eax
  _DWORD *v4; // esi
  bool v5; // zf

  if ( !Src )
    return 0;
  v3 = (_DWORD *)xmlMalloc(60);
  v4 = v3;
  if ( v3 )
  {
    memset(v3, 0, 0x3Cu);
    v4[1] = 1;
    v4[2] = xmlStrdup(Src);
    v5 = dword_4A9C08 == 0;
    v4[9] = a1;
    if ( !v5 )
    {
      if ( xmlRegisterNodeDefaultValue )
        xmlRegisterNodeDefaultValue(v4);
    }
    return v4;
  }
  else
  {
    sub_43279D("building node");
    return 0;
  }
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A9C08: using guessed type int dword_4A9C08;
// 4A9CAC: using guessed type int (__cdecl *xmlRegisterNodeDefaultValue)(_DWORD);

//----- (004172D0) --------------------------------------------------------
_DWORD *__cdecl xmlNewNodeEatName(int a1, int a2)
{
  _DWORD *v3; // eax
  _DWORD *v4; // esi
  bool v5; // zf

  if ( !a2 )
    return 0;
  v3 = (_DWORD *)xmlMalloc(60);
  v4 = v3;
  if ( v3 )
  {
    memset(v3, 0, 0x3Cu);
    v5 = dword_4A9C08 == 0;
    v4[1] = 1;
    v4[2] = a2;
    v4[9] = a1;
    if ( !v5 )
    {
      if ( xmlRegisterNodeDefaultValue )
        xmlRegisterNodeDefaultValue(v4);
    }
    return v4;
  }
  else
  {
    sub_43279D("building node");
    return 0;
  }
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A9C08: using guessed type int dword_4A9C08;
// 4A9CAC: using guessed type int (__cdecl *xmlRegisterNodeDefaultValue)(_DWORD);

//----- (00417335) --------------------------------------------------------
_DWORD *__cdecl xmlNewDocNode(int a1, int a2, char *Src, unsigned __int8 *a4)
{
  _DWORD *v4; // eax
  unsigned __int8 *v5; // eax
  _DWORD *v6; // eax
  _DWORD *v7; // esi
  char *NodeList; // eax
  bool v9; // zf

  if ( a1 && (v4 = *(_DWORD **)(a1 + 80)) != 0 )
  {
    v5 = xmlDictLookup(v4, Src, -1);
    v6 = xmlNewNodeEatName(a2, (int)v5);
  }
  else
  {
    v6 = xmlNewNode(a2, Src);
  }
  v7 = v6;
  if ( v6 )
  {
    v6[8] = a1;
    if ( a4 )
    {
      NodeList = xmlStringGetNodeList((int (__cdecl *)(int, char *, char))a1, a4);
      v7[3] = NodeList;
      if ( NodeList )
      {
        while ( 1 )
        {
          v9 = *((_DWORD *)NodeList + 6) == 0;
          *((_DWORD *)NodeList + 5) = v7;
          if ( v9 )
            break;
          NodeList = (char *)*((_DWORD *)NodeList + 6);
        }
        v7[4] = NodeList;
      }
      else
      {
        v7[4] = 0;
      }
    }
  }
  return v7;
}

//----- (004173A9) --------------------------------------------------------
_DWORD *__cdecl xmlNewDocNodeEatName(int a1, int a2, void *Block, unsigned __int8 *a4)
{
  _DWORD *v4; // esi
  char *NodeList; // eax
  bool v6; // zf

  v4 = xmlNewNodeEatName(a2, (int)Block);
  if ( v4 )
  {
    v4[8] = a1;
    if ( a4 )
    {
      NodeList = xmlStringGetNodeList((int (__cdecl *)(int, char *, char))a1, a4);
      v4[3] = NodeList;
      if ( NodeList )
      {
        while ( 1 )
        {
          v6 = *((_DWORD *)NodeList + 6) == 0;
          *((_DWORD *)NodeList + 5) = v4;
          if ( v6 )
            break;
          NodeList = (char *)*((_DWORD *)NodeList + 6);
        }
        v4[4] = NodeList;
      }
      else
      {
        v4[4] = 0;
      }
    }
  }
  else if ( Block && a1 && !xmlDictOwns(*(_DWORD *)(a1 + 80), (unsigned int)Block) )
  {
    ((void (__cdecl *)(void *))xmlFree)(Block);
  }
  return v4;
}
// 496494: invalid function type has been ignored

//----- (0041741E) --------------------------------------------------------
_DWORD *__cdecl xmlNewDocRawNode(int a1, int a2, char *Src, _BYTE *a4)
{
  _DWORD *v4; // eax
  _DWORD *v5; // esi
  _DWORD *v6; // eax
  bool v7; // zf

  v4 = xmlNewDocNode(a1, a2, Src, 0);
  v5 = v4;
  if ( v4 )
  {
    v4[8] = a1;
    if ( a4 )
    {
      v6 = xmlNewDocText(a1, a4);
      v5[3] = v6;
      if ( v6 )
      {
        while ( 1 )
        {
          v7 = v6[6] == 0;
          v6[5] = v5;
          if ( v7 )
            break;
          v6 = (_DWORD *)v6[6];
        }
        v5[4] = v6;
      }
      else
      {
        v5[4] = 0;
      }
    }
  }
  return v5;
}

//----- (00417473) --------------------------------------------------------
_DWORD *__cdecl xmlNewDocFragment(int a1)
{
  _DWORD *v1; // eax
  _DWORD *v2; // esi
  bool v4; // zf

  v1 = (_DWORD *)xmlMalloc(60);
  v2 = v1;
  if ( v1 )
  {
    memset(v1, 0, 0x3Cu);
    v4 = dword_4A9C08 == 0;
    v2[1] = 11;
    v2[8] = a1;
    if ( !v4 )
    {
      if ( xmlRegisterNodeDefaultValue )
        xmlRegisterNodeDefaultValue(v2);
    }
    return v2;
  }
  else
  {
    sub_43279D("building fragment");
    return 0;
  }
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A9C08: using guessed type int dword_4A9C08;
// 4A9CAC: using guessed type int (__cdecl *xmlRegisterNodeDefaultValue)(_DWORD);

//----- (004174C7) --------------------------------------------------------
_DWORD *__cdecl xmlNewText(_BYTE *Src)
{
  _DWORD *v1; // eax
  _DWORD *v2; // esi

  v1 = (_DWORD *)xmlMalloc(60);
  v2 = v1;
  if ( v1 )
  {
    memset(v1, 0, 0x3Cu);
    v2[1] = 3;
    v2[2] = "text";
    if ( Src )
      v2[10] = xmlStrdup(Src);
    if ( dword_4A9C08 )
    {
      if ( xmlRegisterNodeDefaultValue )
        xmlRegisterNodeDefaultValue(v2);
    }
    return v2;
  }
  else
  {
    sub_43279D("building text");
    return 0;
  }
}
// 4A9CAC: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A9C08: using guessed type int dword_4A9C08;
// 4A9CAC: using guessed type int (__cdecl *xmlRegisterNodeDefaultValue)(_DWORD);

//----- (0041752F) --------------------------------------------------------
_DWORD *__cdecl xmlNewTextChild(_DWORD *a1, int a2, char *Src, _BYTE *a4)
{
  _DWORD *result; // eax
  int v5; // eax
  int v6; // ecx
  int v7; // [esp-Ch] [ebp-10h]
  int v8; // [esp-Ch] [ebp-10h]
  char *v9; // [esp-8h] [ebp-Ch]
  _BYTE *v10; // [esp-4h] [ebp-8h]

  if ( !a1 || !Src )
    return 0;
  v5 = a1[1];
  if ( v5 == 1 )
  {
    v10 = a4;
    v9 = Src;
    if ( !a2 )
    {
      v7 = a1[9];
LABEL_7:
      result = xmlNewDocRawNode(a1[8], v7, v9, v10);
      goto LABEL_17;
    }
LABEL_12:
    v7 = a2;
    goto LABEL_7;
  }
  if ( v5 != 9 && v5 != 13 )
  {
    if ( v5 != 11 )
      return 0;
    v10 = a4;
    v9 = Src;
    goto LABEL_12;
  }
  if ( a2 )
    v8 = a2;
  else
    v8 = 0;
  result = xmlNewDocRawNode((int)a1, v8, Src, a4);
LABEL_17:
  if ( !result )
    return 0;
  result[1] = 1;
  result[5] = a1;
  result[8] = a1[8];
  if ( a1[3] )
  {
    v6 = a1[4];
    *(_DWORD *)(v6 + 24) = result;
    result[7] = v6;
  }
  else
  {
    a1[3] = result;
  }
  a1[4] = result;
  return result;
}

//----- (004175BF) --------------------------------------------------------
_DWORD *__cdecl xmlNewCharRef(int a1, char *Src)
{
  _DWORD *v3; // eax
  _DWORD *v4; // esi
  int v5; // eax
  _BYTE *v6; // eax
  bool v7; // zf

  if ( !Src )
    return 0;
  v3 = (_DWORD *)xmlMalloc(60);
  v4 = v3;
  if ( v3 )
  {
    memset(v3, 0, 0x3Cu);
    v4[1] = 5;
    v4[8] = a1;
    if ( *Src == 38 )
    {
      v5 = xmlStrlen(Src + 1);
      if ( Src[v5] == 59 )
        --v5;
      v6 = xmlStrndup(Src + 1, v5);
    }
    else
    {
      v6 = xmlStrdup(Src);
    }
    v7 = dword_4A9C08 == 0;
    v4[2] = v6;
    if ( !v7 )
    {
      if ( xmlRegisterNodeDefaultValue )
        xmlRegisterNodeDefaultValue(v4);
    }
    return v4;
  }
  else
  {
    sub_43279D("building character reference");
    return 0;
  }
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A9C08: using guessed type int dword_4A9C08;
// 4A9CAC: using guessed type int (__cdecl *xmlRegisterNodeDefaultValue)(_DWORD);

//----- (0041764A) --------------------------------------------------------
_DWORD *__cdecl xmlNewReference(_DWORD *a1, char *Src)
{
  _DWORD *v3; // eax
  _DWORD *v4; // esi
  int v5; // eax
  char *v6; // eax
  _DWORD *DocEntity; // eax

  if ( !Src )
    return 0;
  v3 = (_DWORD *)xmlMalloc(60);
  v4 = v3;
  if ( v3 )
  {
    memset(v3, 0, 0x3Cu);
    v4[1] = 5;
    v4[8] = a1;
    if ( *Src == 38 )
    {
      v5 = xmlStrlen(Src + 1);
      if ( Src[v5] == 59 )
        --v5;
      v6 = xmlStrndup(Src + 1, v5);
    }
    else
    {
      v6 = xmlStrdup(Src);
    }
    v4[2] = v6;
    DocEntity = xmlGetDocEntity(a1, v6);
    if ( DocEntity )
    {
      v4[10] = DocEntity[10];
      v4[3] = DocEntity;
      v4[4] = DocEntity;
    }
    if ( dword_4A9C08 )
    {
      if ( xmlRegisterNodeDefaultValue )
        xmlRegisterNodeDefaultValue(v4);
    }
    return v4;
  }
  else
  {
    sub_43279D("building reference");
    return 0;
  }
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A9C08: using guessed type int dword_4A9C08;
// 4A9CAC: using guessed type int (__cdecl *xmlRegisterNodeDefaultValue)(_DWORD);

//----- (004176F0) --------------------------------------------------------
_DWORD *__cdecl xmlNewDocText(int a1, _BYTE *a2)
{
  _DWORD *result; // eax

  result = xmlNewText(a2);
  if ( result )
    result[8] = a1;
  return result;
}

//----- (00417706) --------------------------------------------------------
_DWORD *__cdecl xmlNewTextLen(void *Src, int Size)
{
  _DWORD *v2; // eax
  _DWORD *v3; // esi

  v2 = (_DWORD *)xmlMalloc(60);
  v3 = v2;
  if ( v2 )
  {
    memset(v2, 0, 0x3Cu);
    v3[1] = 3;
    v3[2] = "text";
    if ( Src )
      v3[10] = xmlStrndup(Src, Size);
    if ( dword_4A9C08 )
    {
      if ( xmlRegisterNodeDefaultValue )
        xmlRegisterNodeDefaultValue(v3);
    }
    return v3;
  }
  else
  {
    sub_43279D("building text");
    return 0;
  }
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A9C08: using guessed type int dword_4A9C08;
// 4A9CAC: using guessed type int (__cdecl *xmlRegisterNodeDefaultValue)(_DWORD);

//----- (00417773) --------------------------------------------------------
_DWORD *__cdecl xmlNewDocTextLen(int a1, void *a2, int a3)
{
  _DWORD *result; // eax

  result = xmlNewTextLen(a2, a3);
  if ( result )
    result[8] = a1;
  return result;
}

//----- (0041778E) --------------------------------------------------------
_DWORD *__cdecl xmlNewComment(_BYTE *Src)
{
  _DWORD *v1; // eax
  _DWORD *v2; // esi

  v1 = (_DWORD *)xmlMalloc(60);
  v2 = v1;
  if ( v1 )
  {
    memset(v1, 0, 0x3Cu);
    v2[1] = 8;
    v2[2] = "comment";
    if ( Src )
      v2[10] = xmlStrdup(Src);
    if ( dword_4A9C08 )
    {
      if ( xmlRegisterNodeDefaultValue )
        xmlRegisterNodeDefaultValue(v2);
    }
    return v2;
  }
  else
  {
    sub_43279D("building comment");
    return 0;
  }
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A9C08: using guessed type int dword_4A9C08;
// 4A9CAC: using guessed type int (__cdecl *xmlRegisterNodeDefaultValue)(_DWORD);

//----- (004177F6) --------------------------------------------------------
_DWORD *__cdecl xmlNewCDataBlock(int a1, void *Src, int Size)
{
  _DWORD *v3; // eax
  _DWORD *v4; // esi

  v3 = (_DWORD *)xmlMalloc(60);
  v4 = v3;
  if ( v3 )
  {
    memset(v3, 0, 0x3Cu);
    v4[1] = 4;
    v4[8] = a1;
    if ( Src )
      v4[10] = xmlStrndup(Src, Size);
    if ( dword_4A9C08 )
    {
      if ( xmlRegisterNodeDefaultValue )
        xmlRegisterNodeDefaultValue(v4);
    }
    return v4;
  }
  else
  {
    sub_43279D("building CDATA");
    return 0;
  }
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A9C08: using guessed type int dword_4A9C08;
// 4A9CAC: using guessed type int (__cdecl *xmlRegisterNodeDefaultValue)(_DWORD);

//----- (00417863) --------------------------------------------------------
_DWORD *__cdecl xmlNewDocComment(int a1, _BYTE *a2)
{
  _DWORD *result; // eax

  result = xmlNewComment(a2);
  if ( result )
    result[8] = a1;
  return result;
}

//----- (00417879) --------------------------------------------------------
void __cdecl xmlSetTreeDoc(_DWORD *a1, int a2)
{
  _DWORD *i; // esi
  int v3; // eax
  int v4; // [esp-10h] [ebp-14h]

  if ( a1 && a1[8] != a2 )
  {
    if ( a1[1] == 1 )
    {
      for ( i = (_DWORD *)a1[11]; i; i = (_DWORD *)i[6] )
      {
        v4 = i[3];
        i[8] = a2;
        xmlSetListDoc(v4, a2);
      }
    }
    v3 = a1[3];
    if ( v3 )
      xmlSetListDoc(v3, a2);
    a1[8] = a2;
  }
}

//----- (004178C4) --------------------------------------------------------
int __cdecl xmlSetListDoc(int a1, int a2)
{
  int i; // esi
  int result; // eax

  for ( i = a1; i; i = *(_DWORD *)(i + 24) )
  {
    if ( *(_DWORD *)(i + 32) != a2 )
      result = xmlSetTreeDoc(i, a2);
  }
  return result;
}
// 417879: using guessed type _DWORD __cdecl xmlSetTreeDoc(_DWORD, _DWORD);

//----- (004178EA) --------------------------------------------------------
_DWORD *__cdecl xmlNewChild(_DWORD *a1, int a2, char *Src, unsigned __int8 *a4)
{
  _DWORD *result; // eax
  int v5; // eax
  int v6; // ecx
  int v7; // [esp-Ch] [ebp-10h]
  int v8; // [esp-Ch] [ebp-10h]
  char *v9; // [esp-8h] [ebp-Ch]
  unsigned __int8 *v10; // [esp-4h] [ebp-8h]

  if ( !a1 || !Src )
    return 0;
  v5 = a1[1];
  if ( v5 == 1 )
  {
    v10 = a4;
    v9 = Src;
    if ( !a2 )
    {
      v7 = a1[9];
LABEL_7:
      result = xmlNewDocNode(a1[8], v7, v9, v10);
      goto LABEL_17;
    }
LABEL_12:
    v7 = a2;
    goto LABEL_7;
  }
  if ( v5 != 9 && v5 != 13 )
  {
    if ( v5 != 11 )
      return 0;
    v10 = a4;
    v9 = Src;
    goto LABEL_12;
  }
  if ( a2 )
    v8 = a2;
  else
    v8 = 0;
  result = xmlNewDocNode((int)a1, v8, Src, a4);
LABEL_17:
  if ( !result )
    return 0;
  result[1] = 1;
  result[5] = a1;
  result[8] = a1[8];
  if ( a1[3] )
  {
    v6 = a1[4];
    *(_DWORD *)(v6 + 24) = result;
    result[7] = v6;
  }
  else
  {
    a1[3] = result;
  }
  a1[4] = result;
  return result;
}

//----- (0041797A) --------------------------------------------------------
int __usercall sub_41797A@<eax>(int a1@<ebx>, _DWORD *a2@<edi>, int a3@<esi>)
{
  int v4; // eax
  int HasNsProp; // eax
  int v6; // eax
  int v7; // eax
  _DWORD *Block; // [esp+0h] [ebp-4h]

  if ( a2[1] != 2 )
    return 0;
  v4 = *(_DWORD *)(a3 + 36);
  if ( v4 )
    HasNsProp = xmlHasNsProp(a2[5], *(char **)(a3 + 8), *(char **)(v4 + 8));
  else
    HasNsProp = xmlHasNsProp(a2[5], *(char **)(a3 + 8), 0);
  Block = (_DWORD *)HasNsProp;
  if ( *(_DWORD *)(a3 + 32) != a2[8] )
    xmlSetTreeDoc((_DWORD *)a3, a2[8]);
  *(_DWORD *)(a3 + 20) = a2[5];
  *(_DWORD *)(a3 + 28) = a1;
  if ( a1 )
  {
    *(_DWORD *)(a3 + 24) = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 24) = a3;
    v6 = *(_DWORD *)(a3 + 24);
    if ( v6 )
      *(_DWORD *)(v6 + 28) = a3;
  }
  else
  {
    *(_DWORD *)(a3 + 24) = a2;
    a2[7] = a3;
  }
  if ( !*(_DWORD *)(a3 + 28) )
  {
    v7 = *(_DWORD *)(a3 + 20);
    if ( v7 )
      *(_DWORD *)(v7 + 44) = a3;
  }
  if ( Block )
  {
    if ( Block[1] != 16 )
      xmlRemoveProp(Block);
  }
  return a3;
}

//----- (00417A07) --------------------------------------------------------
char *__cdecl xmlAddNextSibling(char *a1, char *Block)
{
  int v3; // eax
  int v4; // eax
  _BYTE *v5; // eax
  _BYTE *v6; // ebx
  int v7; // eax
  int v8; // eax

  if ( !a1 )
    return 0;
  if ( !Block || a1 == Block )
    return 0;
  xmlUnlinkNode((int)Block);
  v3 = *((_DWORD *)Block + 1);
  if ( v3 == 3 )
  {
    if ( *((_DWORD *)a1 + 1) == 3 )
    {
      xmlNodeAddContent((int)a1, *((_BYTE **)Block + 10));
      xmlFreeNode(Block);
      return a1;
    }
    v4 = *((_DWORD *)a1 + 6);
    if ( v4 && *(_DWORD *)(v4 + 4) == 3 && *((_DWORD *)a1 + 2) == *(_DWORD *)(v4 + 8) )
    {
      v5 = xmlStrdup(*((_BYTE **)Block + 10));
      v6 = xmlStrcat(v5, *(_BYTE **)(*((_DWORD *)a1 + 6) + 40));
      xmlNodeSetContent(*((_DWORD *)a1 + 6), v6);
      ((void (__cdecl *)(_BYTE *))xmlFree)(v6);
      xmlFreeNode(Block);
      return (char *)*((_DWORD *)a1 + 6);
    }
  }
  else if ( v3 == 2 )
  {
    return (char *)sub_41797A((int)a1, a1, (int)Block);
  }
  if ( *((_DWORD *)Block + 8) != *((_DWORD *)a1 + 8) )
    xmlSetTreeDoc(Block, *((_DWORD *)a1 + 8));
  *((_DWORD *)Block + 5) = *((_DWORD *)a1 + 5);
  *((_DWORD *)Block + 7) = a1;
  *((_DWORD *)Block + 6) = *((_DWORD *)a1 + 6);
  *((_DWORD *)a1 + 6) = Block;
  v7 = *((_DWORD *)Block + 6);
  if ( v7 )
    *(_DWORD *)(v7 + 28) = Block;
  v8 = *((_DWORD *)Block + 5);
  if ( v8 )
  {
    if ( *(char **)(v8 + 16) == a1 )
      *(_DWORD *)(v8 + 16) = Block;
  }
  return Block;
}
// 496494: invalid function type has been ignored

//----- (00417AF2) --------------------------------------------------------
char *__cdecl xmlAddPrevSibling(int a1, char *Block)
{
  int v3; // eax
  _BYTE *v4; // eax
  _BYTE *v5; // ebx
  int v6; // eax
  int v7; // eax
  int v8; // eax

  if ( !a1 )
    return 0;
  if ( !Block || (char *)a1 == Block )
    return 0;
  xmlUnlinkNode((int)Block);
  v3 = *((_DWORD *)Block + 1);
  if ( v3 == 3 )
  {
    if ( *(_DWORD *)(a1 + 4) == 3 )
    {
      v4 = xmlStrdup(*((_BYTE **)Block + 10));
      v5 = xmlStrcat(v4, *(_BYTE **)(a1 + 40));
      xmlNodeSetContent(a1, v5);
      ((void (__cdecl *)(_BYTE *))xmlFree)(v5);
      xmlFreeNode(Block);
      return (char *)a1;
    }
    v6 = *(_DWORD *)(a1 + 28);
    if ( v6 && *(_DWORD *)(v6 + 4) == 3 && *(_DWORD *)(a1 + 8) == *(_DWORD *)(v6 + 8) )
    {
      xmlNodeAddContent(v6, *((_BYTE **)Block + 10));
      xmlFreeNode(Block);
      return *(char **)(a1 + 28);
    }
  }
  else if ( v3 == 2 )
  {
    return (char *)sub_41797A(*(_DWORD *)(a1 + 28), (_DWORD *)a1, (int)Block);
  }
  if ( *((_DWORD *)Block + 8) != *(_DWORD *)(a1 + 32) )
    xmlSetTreeDoc(Block, *(_DWORD *)(a1 + 32));
  *((_DWORD *)Block + 5) = *(_DWORD *)(a1 + 20);
  *((_DWORD *)Block + 6) = a1;
  *((_DWORD *)Block + 7) = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 28) = Block;
  v7 = *((_DWORD *)Block + 7);
  if ( v7 )
    *(_DWORD *)(v7 + 24) = Block;
  v8 = *((_DWORD *)Block + 5);
  if ( v8 )
  {
    if ( *(_DWORD *)(v8 + 12) == a1 )
      *(_DWORD *)(v8 + 12) = Block;
  }
  return Block;
}
// 496494: invalid function type has been ignored

//----- (00417BD6) --------------------------------------------------------
char *__cdecl xmlAddSibling(char *a1, char *Block)
{
  char *v2; // edi
  int v4; // eax
  char *v5; // eax
  int v6; // eax

  v2 = a1;
  if ( !a1 )
    return 0;
  if ( !Block || a1 == Block )
    return 0;
  if ( *((_DWORD *)a1 + 1) != 2
    && (v4 = *((_DWORD *)a1 + 5)) != 0
    && *(_DWORD *)(v4 + 12)
    && (v5 = *(char **)(v4 + 16)) != 0
    && !*((_DWORD *)v5 + 6) )
  {
    v2 = v5;
  }
  else
  {
    while ( *((_DWORD *)v2 + 6) )
      v2 = (char *)*((_DWORD *)v2 + 6);
  }
  xmlUnlinkNode((int)Block);
  if ( *((_DWORD *)v2 + 1) == 3 && *((_DWORD *)Block + 1) == 3 && *((_DWORD *)v2 + 2) == *((_DWORD *)Block + 2) )
  {
    xmlNodeAddContent((int)v2, *((_BYTE **)Block + 10));
    xmlFreeNode(Block);
    return v2;
  }
  else if ( *((_DWORD *)Block + 1) == 2 )
  {
    return (char *)sub_41797A((int)v2, v2, (int)Block);
  }
  else
  {
    if ( *((_DWORD *)Block + 8) != *((_DWORD *)v2 + 8) )
      xmlSetTreeDoc(Block, *((_DWORD *)v2 + 8));
    v6 = *((_DWORD *)v2 + 5);
    *((_DWORD *)Block + 7) = v2;
    *((_DWORD *)Block + 6) = 0;
    *((_DWORD *)Block + 5) = v6;
    *((_DWORD *)v2 + 6) = Block;
    if ( v6 )
      *(_DWORD *)(v6 + 16) = Block;
    return Block;
  }
}

//----- (00417C95) --------------------------------------------------------
_DWORD *__cdecl xmlAddChildList(_DWORD *a1, _BYTE **Block)
{
  _DWORD *v3; // esi
  int v4; // eax
  int v5; // eax
  bool v6; // zf
  int v7; // eax

  if ( !a1 )
    return 0;
  v3 = Block;
  if ( !Block )
    return 0;
  if ( a1[3] )
  {
    if ( Block[1] == (_BYTE *)3 )
    {
      v4 = a1[4];
      if ( *(_DWORD *)(v4 + 4) == 3 && Block[2] == *(_BYTE **)(v4 + 8) )
      {
        xmlNodeAddContent(v4, Block[10]);
        if ( !Block[6] )
        {
          xmlFreeNode((char *)Block);
          return (_DWORD *)a1[4];
        }
        v3 = Block[6];
        xmlFreeNode((char *)Block);
      }
    }
    v5 = a1[4];
    *(_DWORD *)(v5 + 24) = v3;
    v3[7] = v5;
  }
  else
  {
    a1[3] = Block;
  }
  while ( 1 )
  {
    v6 = v3[6] == 0;
    v3[5] = a1;
    v7 = a1[8];
    if ( v6 )
      break;
    if ( v3[8] != v7 )
      xmlSetTreeDoc(v3, a1[8]);
    v3 = (_DWORD *)v3[6];
  }
  if ( v3[8] != v7 )
    xmlSetTreeDoc(v3, a1[8]);
  a1[4] = v3;
  return v3;
}

//----- (00417D3B) --------------------------------------------------------
char *__cdecl xmlAddChild(char *a1, char *Block)
{
  char *v3; // edx
  void *v4; // ebx
  int v5; // eax
  int v6; // edx
  char *v7; // ebx
  int v8; // eax
  int v9; // eax
  void *v10; // edx
  int v11; // eax
  char *HasNsProp; // eax
  char *v13; // ebx
  int v14; // eax
  int v15; // eax

  if ( !a1 )
    return 0;
  if ( !Block || a1 == Block )
    return 0;
  if ( *((_DWORD *)Block + 1) == 3 )
  {
    if ( *((_DWORD *)a1 + 1) == 3 && *((_DWORD *)a1 + 10) && *((_DWORD *)a1 + 2) == *((_DWORD *)Block + 2) )
      goto LABEL_22;
    v3 = (char *)*((_DWORD *)a1 + 4);
    if ( v3 && *((_DWORD *)v3 + 1) == 3 && *((_DWORD *)v3 + 2) == *((_DWORD *)Block + 2) && v3 != Block )
    {
      v4 = (void *)*((_DWORD *)Block + 10);
      if ( v4 )
      {
        v5 = xmlStrlen(*((_BYTE **)Block + 10));
        xmlNodeAddContentLen(v6, v4, v5);
      }
      xmlFreeNode(Block);
      return (char *)*((_DWORD *)a1 + 4);
    }
  }
  v7 = (char *)*((_DWORD *)Block + 5);
  *((_DWORD *)Block + 5) = a1;
  if ( *((_DWORD *)Block + 8) != *((_DWORD *)a1 + 8) )
    xmlSetTreeDoc(Block, *((_DWORD *)a1 + 8));
  if ( v7 == a1 )
    return Block;
  v8 = *((_DWORD *)a1 + 1);
  if ( v8 != 3 || !*((_DWORD *)a1 + 10) )
  {
    if ( *((_DWORD *)Block + 1) != 2 )
    {
      if ( *((_DWORD *)a1 + 3) )
      {
        v15 = *((_DWORD *)a1 + 4);
        *(_DWORD *)(v15 + 24) = Block;
        *((_DWORD *)Block + 7) = v15;
      }
      else
      {
        *((_DWORD *)a1 + 3) = Block;
      }
      *((_DWORD *)a1 + 4) = Block;
      return Block;
    }
    if ( v8 != 1 )
      return 0;
    if ( !*((_DWORD *)a1 + 11) )
      goto LABEL_37;
    v11 = *((_DWORD *)Block + 9);
    if ( v11 )
      HasNsProp = (char *)xmlHasNsProp((int)a1, *((char **)Block + 2), *(char **)(v11 + 8));
    else
      HasNsProp = (char *)xmlHasNsProp((int)a1, *((char **)Block + 2), 0);
    v13 = HasNsProp;
    if ( HasNsProp )
    {
      if ( HasNsProp == Block )
        return Block;
      if ( *((_DWORD *)HasNsProp + 1) != 16 )
      {
        xmlUnlinkNode((int)HasNsProp);
        xmlFreeProp(v13);
      }
    }
    if ( v13 != Block )
    {
LABEL_37:
      v14 = *((_DWORD *)a1 + 11);
      if ( v14 )
      {
        while ( *(_DWORD *)(v14 + 24) )
          v14 = *(_DWORD *)(v14 + 24);
        *(_DWORD *)(v14 + 24) = Block;
        *((_DWORD *)Block + 7) = v14;
      }
      else
      {
        *((_DWORD *)a1 + 11) = Block;
      }
    }
    return Block;
  }
LABEL_22:
  if ( *((_DWORD *)Block + 10) )
  {
    v9 = xmlStrlen(*((_BYTE **)Block + 10));
    xmlNodeAddContentLen(a1, v10, v9);
  }
  xmlFreeNode(Block);
  return a1;
}
// 417DA1: variable 'v6' is possibly undefined
// 417DF6: variable 'v10' is possibly undefined
// 4199A2: using guessed type _DWORD __cdecl xmlNodeAddContentLen(_DWORD, void *Src, size_t Size);

//----- (00417E95) --------------------------------------------------------
int __cdecl xmlGetLastChild(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
    return *(_DWORD *)(a1 + 16);
  return result;
}

//----- (00417EA2) --------------------------------------------------------
int __cdecl xmlChildElementCount(int a1)
{
  int result; // eax
  int i; // ecx

  result = 0;
  if ( !a1
    || *(_DWORD *)(a1 + 4) != 1 && *(_DWORD *)(a1 + 4) != 6 && *(_DWORD *)(a1 + 4) != 9 && *(_DWORD *)(a1 + 4) != 13 )
  {
    return 0;
  }
  for ( i = *(_DWORD *)(a1 + 12); i; i = *(_DWORD *)(i + 24) )
  {
    if ( *(_DWORD *)(i + 4) == 1 )
      ++result;
  }
  return result;
}

//----- (00417ED8) --------------------------------------------------------
int __cdecl xmlFirstElementChild(int a1)
{
  int result; // eax

  if ( a1
    && (*(_DWORD *)(a1 + 4) == 1 || *(_DWORD *)(a1 + 4) == 6 || *(_DWORD *)(a1 + 4) == 9 || *(_DWORD *)(a1 + 4) == 13) )
  {
    for ( result = *(_DWORD *)(a1 + 12); result; result = *(_DWORD *)(result + 24) )
    {
      if ( *(_DWORD *)(result + 4) == 1 )
        return result;
    }
  }
  return 0;
}

//----- (00417F0A) --------------------------------------------------------
int __cdecl xmlLastElementChild(int a1)
{
  int result; // eax

  if ( a1
    && (*(_DWORD *)(a1 + 4) == 1 || *(_DWORD *)(a1 + 4) == 6 || *(_DWORD *)(a1 + 4) == 9 || *(_DWORD *)(a1 + 4) == 13) )
  {
    for ( result = *(_DWORD *)(a1 + 16); result; result = *(_DWORD *)(result + 28) )
    {
      if ( *(_DWORD *)(result + 4) == 1 )
        return result;
    }
  }
  return 0;
}

//----- (00417F3C) --------------------------------------------------------
int __cdecl xmlPreviousElementSibling(int a1)
{
  int v1; // eax
  int result; // eax

  if ( a1 )
  {
    v1 = *(_DWORD *)(a1 + 4);
    if ( v1 == 1 || v1 > 2 && (v1 <= 8 || v1 > 18 && v1 <= 20) )
    {
      for ( result = *(_DWORD *)(a1 + 28); result; result = *(_DWORD *)(result + 28) )
      {
        if ( *(_DWORD *)(result + 4) == 1 )
          return result;
      }
    }
  }
  return 0;
}

//----- (00417F75) --------------------------------------------------------
int __cdecl xmlNextElementSibling(int a1)
{
  int v1; // eax
  int result; // eax

  if ( a1 )
  {
    v1 = *(_DWORD *)(a1 + 4);
    if ( v1 == 1 || v1 > 2 && (v1 <= 8 || v1 == 14 || v1 > 18 && v1 <= 20) )
    {
      for ( result = *(_DWORD *)(a1 + 24); result; result = *(_DWORD *)(result + 24) )
      {
        if ( *(_DWORD *)(result + 4) == 1 )
          return result;
      }
    }
  }
  return 0;
}

//----- (00417FB3) --------------------------------------------------------
void __cdecl xmlFreeNodeList(_DWORD *Block)
{
  _DWORD *v1; // esi
  int v2; // ebx
  int v3; // eax
  int v4; // eax
  _DWORD *v5; // ebp
  int v6; // eax
  _DWORD *v7; // eax
  _DWORD *v8; // edi
  int v9; // eax
  _DWORD *v10; // edi
  int v11; // eax
  int v12; // edi
  int v13; // eax

  v1 = Block;
  v2 = 0;
  if ( Block )
  {
    v3 = Block[1];
    if ( v3 == 18 )
    {
      xmlFreeNsList(Block);
    }
    else if ( v3 == 9 || v3 == 13 )
    {
      xmlFreeDoc(Block);
    }
    else
    {
      v4 = Block[8];
      if ( v4 )
        v2 = *(_DWORD *)(v4 + 80);
      do
      {
        v5 = (_DWORD *)v1[6];
        if ( v1[1] != 14 )
        {
          if ( dword_4A9C08 && xmlDeregisterNodeDefaultValue )
            xmlDeregisterNodeDefaultValue(v1);
          if ( v1[3] && v1[1] != 5 )
            xmlFreeNodeList((void *)v1[3]);
          v6 = v1[1];
          if ( v6 == 1 || v6 == 19 || v6 == 20 )
          {
            v7 = (_DWORD *)v1[11];
            if ( v7 )
            {
              do
              {
                v8 = (_DWORD *)v7[6];
                xmlFreeProp(v7);
                v7 = v8;
              }
              while ( v8 );
            }
          }
          v9 = v1[1];
          if ( v9 != 1 && v9 != 19 && v9 != 20 && v9 != 5 )
          {
            v10 = (_DWORD *)v1[10];
            if ( v10 != v1 + 11 && v10 && (!v2 || !xmlDictOwns(v2, v1[10])) )
              ((void (__cdecl *)(_DWORD *))xmlFree)(v10);
          }
          v11 = v1[1];
          if ( (v11 == 1 || v11 == 19 || v11 == 20) && v1[12] )
            xmlFreeNsList((_DWORD *)v1[12]);
          v12 = v1[2];
          if ( v12 )
          {
            v13 = v1[1];
            if ( v13 != 3 && v13 != 8 && (!v2 || !xmlDictOwns(v2, v1[2])) )
              ((void (__cdecl *)(int))xmlFree)(v12);
          }
          ((void (__cdecl *)(_DWORD *))xmlFree)(v1);
        }
        v1 = v5;
      }
      while ( v5 );
    }
  }
}
// 496494: invalid function type has been ignored
// 4A9C08: using guessed type int dword_4A9C08;
// 4A9CB4: using guessed type int (__cdecl *xmlDeregisterNodeDefaultValue)(_DWORD);

//----- (004180FF) --------------------------------------------------------
void __cdecl xmlFreeNode(char *Block)
{
  int v1; // ebx
  int v2; // eax
  int v3; // eax
  int v4; // edi
  int v5; // edi
  int v6; // eax
  int v7; // eax
  char *v8; // edi
  int v9; // edi
  int v10; // eax
  int v11; // eax

  v1 = 0;
  if ( Block )
  {
    v2 = *((_DWORD *)Block + 1);
    switch ( v2 )
    {
      case 14:
        xmlFreeDtd(Block);
        break;
      case 18:
        xmlFreeNs(Block);
        break;
      case 2:
        xmlFreeProp(Block);
        break;
      default:
        if ( dword_4A9C08 && xmlDeregisterNodeDefaultValue )
          xmlDeregisterNodeDefaultValue(Block);
        v3 = *((_DWORD *)Block + 8);
        if ( v3 )
          v1 = *(_DWORD *)(v3 + 80);
        if ( *((_DWORD *)Block + 1) == 17 )
        {
          v4 = *((_DWORD *)Block + 14);
          if ( v4 && (!v1 || !xmlDictOwns(v1, *((_DWORD *)Block + 14))) )
            ((void (__cdecl *)(int))xmlFree)(v4);
          v5 = *((_DWORD *)Block + 13);
          if ( v5 && (!v1 || !xmlDictOwns(v1, *((_DWORD *)Block + 13))) )
            ((void (__cdecl *)(int))xmlFree)(v5);
        }
        if ( *((_DWORD *)Block + 3) && *((_DWORD *)Block + 1) != 5 )
          xmlFreeNodeList(*((void **)Block + 3));
        v6 = *((_DWORD *)Block + 1);
        if ( (v6 == 1 || v6 == 19 || v6 == 20) && *((_DWORD *)Block + 11) )
          xmlFreePropList(*((_DWORD **)Block + 11));
        v7 = *((_DWORD *)Block + 1);
        if ( v7 != 1 )
        {
          v8 = (char *)*((_DWORD *)Block + 10);
          if ( v8 )
          {
            if ( v7 != 5
              && v7 != 20
              && v7 != 19
              && v8 != Block + 44
              && (!v1 || !xmlDictOwns(v1, *((_DWORD *)Block + 10))) )
            {
              ((void (__cdecl *)(char *))xmlFree)(v8);
            }
          }
        }
        v9 = *((_DWORD *)Block + 2);
        if ( v9 )
        {
          v10 = *((_DWORD *)Block + 1);
          if ( v10 != 3 && v10 != 8 && (!v1 || !xmlDictOwns(v1, *((_DWORD *)Block + 2))) )
            ((void (__cdecl *)(int))xmlFree)(v9);
        }
        v11 = *((_DWORD *)Block + 1);
        if ( v11 == 1 || v11 == 19 || v11 == 20 )
        {
          if ( *((_DWORD *)Block + 12) )
            xmlFreeNsList(*((_DWORD **)Block + 12));
        }
        ((void (__cdecl *)(char *))xmlFree)(Block);
        break;
    }
  }
}
// 4A9CB4: invalid function type has been ignored
// 496494: invalid function type has been ignored
// 4A9C08: using guessed type int dword_4A9C08;
// 4A9CB4: using guessed type int (__cdecl *xmlDeregisterNodeDefaultValue)(_DWORD);

//----- (00418273) --------------------------------------------------------
void __cdecl xmlUnlinkNode(int a1)
{
  int v2; // eax
  int v3; // edi
  int v4; // eax
  int v5; // eax
  _DWORD *v6; // edi
  _DWORD *v7; // eax
  int v8; // eax
  int v9; // eax
  _DWORD *v10; // [esp+10h] [ebp+8h]
  _DWORD *v11; // [esp+10h] [ebp+8h]
  _DWORD *v12; // [esp+10h] [ebp+8h]

  if ( a1 )
  {
    if ( *(_DWORD *)(a1 + 4) == 14 )
    {
      v2 = *(_DWORD *)(a1 + 32);
      if ( v2 )
      {
        if ( *(_DWORD *)(v2 + 44) == a1 )
          *(_DWORD *)(v2 + 44) = 0;
        if ( *(_DWORD *)(v2 + 48) == a1 )
          *(_DWORD *)(v2 + 48) = 0;
      }
    }
    if ( *(_DWORD *)(a1 + 4) == 17 )
    {
      v3 = *(_DWORD *)(a1 + 32);
      if ( v3 )
      {
        v4 = *(_DWORD *)(v3 + 44);
        if ( v4 )
        {
          v10 = *(_DWORD **)(v4 + 48);
          if ( xmlHashLookup3(v10, *(char **)(a1 + 8), 0, 0) == a1 )
            xmlHashRemoveEntry(v10, *(char **)(a1 + 8), 0);
          v11 = *(_DWORD **)(*(_DWORD *)(v3 + 44) + 60);
          if ( xmlHashLookup3(v11, *(char **)(a1 + 8), 0, 0) == a1 )
            xmlHashRemoveEntry(v11, *(char **)(a1 + 8), 0);
        }
        v5 = *(_DWORD *)(v3 + 48);
        if ( v5 )
        {
          v12 = *(_DWORD **)(v5 + 48);
          if ( xmlHashLookup3(v12, *(char **)(a1 + 8), 0, 0) == a1 )
            xmlHashRemoveEntry(v12, *(char **)(a1 + 8), 0);
          v6 = *(_DWORD **)(*(_DWORD *)(v3 + 48) + 60);
          if ( xmlHashLookup3(v6, *(char **)(a1 + 8), 0, 0) == a1 )
            xmlHashRemoveEntry(v6, *(char **)(a1 + 8), 0);
        }
      }
    }
    v7 = *(_DWORD **)(a1 + 20);
    if ( v7 )
    {
      if ( *(_DWORD *)(a1 + 4) == 2 )
      {
        if ( v7[11] == a1 )
          v7[11] = *(_DWORD *)(a1 + 24);
      }
      else
      {
        if ( v7[3] == a1 )
          v7[3] = *(_DWORD *)(a1 + 24);
        if ( v7[4] == a1 )
          v7[4] = *(_DWORD *)(a1 + 28);
      }
      *(_DWORD *)(a1 + 20) = 0;
    }
    v8 = *(_DWORD *)(a1 + 24);
    if ( v8 )
      *(_DWORD *)(v8 + 28) = *(_DWORD *)(a1 + 28);
    v9 = *(_DWORD *)(a1 + 28);
    if ( v9 )
      *(_DWORD *)(v9 + 24) = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 24) = 0;
  }
}

//----- (004183BF) --------------------------------------------------------
_DWORD *__cdecl xmlReplaceNode(_DWORD *a1, _DWORD *a2)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax

  if ( a1 != a2 && a1 && a1[5] )
  {
    if ( !a2 )
    {
      xmlUnlinkNode((int)a1);
      return a1;
    }
    v3 = a1[1];
    if ( v3 == 2 )
    {
      if ( a2[1] != 2 )
        return a1;
    }
    else if ( a2[1] != 2 )
    {
      goto LABEL_12;
    }
    if ( v3 != 2 )
      return a1;
LABEL_12:
    xmlUnlinkNode((int)a2);
    xmlSetTreeDoc(a2, a1[8]);
    a2[5] = a1[5];
    v4 = a1[6];
    a2[6] = v4;
    if ( v4 )
      *(_DWORD *)(v4 + 28) = a2;
    v5 = a1[7];
    a2[7] = v5;
    if ( v5 )
      *(_DWORD *)(v5 + 24) = a2;
    v6 = a2[5];
    if ( v6 )
    {
      if ( a2[1] == 2 )
      {
        if ( *(_DWORD **)(v6 + 44) == a1 )
          *(_DWORD *)(v6 + 44) = a2;
      }
      else
      {
        if ( *(_DWORD **)(v6 + 12) == a1 )
          *(_DWORD *)(v6 + 12) = a2;
        v7 = a2[5];
        if ( *(_DWORD **)(v7 + 16) == a1 )
          *(_DWORD *)(v7 + 16) = a2;
      }
    }
    a1[7] = 0;
    a1[6] = 0;
    a1[5] = 0;
    return a1;
  }
  return 0;
}

//----- (00418480) --------------------------------------------------------
_DWORD *__cdecl xmlCopyNamespace(int a1)
{
  if ( a1 && *(_DWORD *)(a1 + 4) == 18 )
    return xmlNewNs(0, *(char **)(a1 + 8), *(char **)(a1 + 12));
  else
    return 0;
}

//----- (004184A2) --------------------------------------------------------
_DWORD *__cdecl xmlCopyNamespaceList(_DWORD *a1)
{
  _DWORD *v2; // ebx
  _DWORD *v3; // esi
  _DWORD *v4; // eax

  v2 = 0;
  v3 = 0;
  while ( a1 )
  {
    v4 = xmlCopyNamespace((int)a1);
    if ( v3 )
      *v3 = v4;
    else
      v2 = v4;
    a1 = (_DWORD *)*a1;
    v3 = v4;
  }
  return v2;
}

//----- (004184CE) --------------------------------------------------------
_DWORD *__cdecl sub_4184CE(int a1, _DWORD *a2, int *a3)
{
  int *v3; // esi
  _DWORD *v5; // edi
  _DWORD *v6; // ebx
  _DWORD *v7; // eax
  int v8; // eax
  int v9; // eax
  _DWORD *v10; // eax
  int v11; // edx
  int v12; // ecx
  int v13; // eax
  _DWORD *v14; // eax
  int v15; // eax
  _DWORD *v16; // eax
  int v17; // ecx
  unsigned __int8 *String; // eax
  unsigned __int8 *v19; // esi
  char *v20; // [esp-10h] [ebp-20h]
  int v21; // [esp+4h] [ebp-Ch]
  _DWORD *v22; // [esp+8h] [ebp-8h]
  _DWORD *v23; // [esp+8h] [ebp-8h]
  _DWORD *v24; // [esp+Ch] [ebp-4h]

  v3 = a3;
  if ( !a3 )
    return 0;
  v5 = a2;
  v20 = (char *)a3[2];
  if ( a2 )
  {
    v6 = xmlNewDocProp(a2[8], v20, 0);
    v24 = v6;
  }
  else
  {
    if ( a1 )
    {
      v7 = xmlNewDocProp(a1, v20, 0);
    }
    else
    {
      v8 = a3[5];
      if ( v8 || (v8 = a3[3]) != 0 )
        v7 = xmlNewDocProp(*(_DWORD *)(v8 + 32), v20, 0);
      else
        v7 = xmlNewDocProp(0, v20, 0);
    }
    v6 = v7;
    v24 = v7;
  }
  if ( !v6 )
    return 0;
  v6[5] = a2;
  v9 = a3[9];
  if ( !v9 || !a2 )
  {
    v6[9] = 0;
    goto LABEL_29;
  }
  v10 = xmlSearchNs(a2[8], a2, *(char **)(v9 + 12));
  v22 = v10;
  if ( v10 )
  {
    v21 = a3[9];
    if ( !xmlStrEqual((char *)v10[2], *(char **)(v21 + 8)) )
    {
      v3 = a3;
      v24[9] = sub_419F60(a2[8], a2, v21);
      v6 = v24;
      goto LABEL_29;
    }
    v14 = v22;
    goto LABEL_26;
  }
  v23 = xmlSearchNs(a3[8], (_DWORD *)a3[5], *(char **)(a3[9] + 12));
  if ( v23 )
  {
    v11 = a2[5];
    v12 = (int)a2;
    v13 = 0;
    while ( v11 )
    {
      v13 = v12;
      v12 = v11;
      v11 = *(_DWORD *)(v11 + 20);
    }
    if ( v12 == a2[8] )
      v12 = v13;
    v14 = xmlNewNs(v12, (char *)v23[2], (char *)v23[3]);
LABEL_26:
    v6[9] = v14;
  }
LABEL_29:
  if ( v3[3] )
  {
    v15 = sub_41894F(v6);
    v6[4] = 0;
    v6[3] = v15;
    while ( v15 )
    {
      if ( !*(_DWORD *)(v15 + 24) )
        v6[4] = v15;
      v15 = *(_DWORD *)(v15 + 24);
    }
    v5 = a2;
  }
  if ( v5 )
  {
    if ( v5[8] )
    {
      v16 = (_DWORD *)v3[8];
      if ( v16 )
      {
        if ( v16[16] )
        {
          v17 = v3[5];
          if ( v17 )
          {
            if ( xmlIsID(v16, v17, (int)v3) )
            {
              String = xmlNodeListGetString((_DWORD *)v3[8], v3[3], 1);
              v19 = String;
              if ( String )
              {
                xmlAddID(0, v5[8], String, (int)v6);
                ((void (__cdecl *)(unsigned __int8 *))xmlFree)(v19);
              }
            }
          }
        }
      }
    }
  }
  return v6;
}
// 496494: invalid function type has been ignored
// 41894F: using guessed type _DWORD __cdecl sub_41894F(_DWORD);

//----- (00418677) --------------------------------------------------------
_DWORD *__cdecl xmlCopyProp(_DWORD *a1, int *a2)
{
  return sub_4184CE(0, a1, a2);
}

//----- (0041868A) --------------------------------------------------------
_DWORD *__cdecl xmlCopyPropList(_DWORD *a1, int *a2)
{
  _DWORD *v3; // ebx
  _DWORD *i; // esi
  _DWORD *v5; // eax

  v3 = 0;
  for ( i = 0; ; i = v5 )
  {
    if ( !a2 )
      return v3;
    v5 = xmlCopyProp(a1, a2);
    if ( !v5 )
      break;
    if ( i )
    {
      i[6] = v5;
      v5[7] = i;
    }
    else
    {
      v3 = v5;
    }
    a2 = (int *)a2[6];
  }
  return 0;
}

//----- (004186C8) --------------------------------------------------------
char *__cdecl sub_4186C8(int a1, int a2, char *a3, int a4)
{
  int v4; // edi
  char *result; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  char *v9; // eax
  char *v10; // ebx
  _DWORD *v11; // esi
  char *v12; // ecx
  const char *v13; // eax
  _DWORD *v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // eax
  _DWORD *v18; // eax
  _DWORD *v19; // eax
  int v20; // edx
  int v21; // ecx
  int v22; // eax
  _DWORD *DocEntity; // eax
  bool v24; // zf

  v4 = a1;
  if ( !a1 )
    return 0;
  v6 = *(_DWORD *)(a1 + 4);
  if ( v6 <= 12 )
  {
    if ( v6 == 12 )
      return 0;
    v7 = v6 - 2;
    if ( !v7 )
      return (char *)sub_4184CE(a2, a3, (int *)a1);
    v8 = v7 - 7;
    if ( v8 )
    {
      if ( v8 != 1 )
        goto LABEL_8;
      return 0;
    }
    return (char *)xmlCopyDoc(a1, a4);
  }
  if ( v6 == 13 )
    return (char *)xmlCopyDoc(a1, a4);
  if ( v6 <= 17 )
    return 0;
  if ( v6 == 18 )
    return (char *)xmlCopyNamespaceList((_DWORD *)a1);
LABEL_8:
  v9 = (char *)xmlMalloc(60);
  v10 = v9;
  if ( !v9 )
  {
    sub_43279D("copying node");
    return 0;
  }
  memset(v9, 0, 0x3Cu);
  v11 = (_DWORD *)a2;
  *((_DWORD *)v10 + 1) = *(_DWORD *)(a1 + 4);
  *((_DWORD *)v10 + 5) = a3;
  *((_DWORD *)v10 + 8) = a2;
  v12 = *(char **)(a1 + 8);
  v13 = "text";
  if ( v12 != "text" )
  {
    v13 = "textnoenc";
    if ( v12 != "textnoenc" )
    {
      v13 = "comment";
      if ( v12 != "comment" )
      {
        if ( !v12 )
          goto LABEL_24;
        if ( a2 && (v14 = *(_DWORD **)(a2 + 80)) != 0 )
          v13 = (const char *)xmlDictLookup(v14, v12, -1);
        else
          v13 = xmlStrdup(*(_BYTE **)(a1 + 8));
      }
    }
  }
  *((_DWORD *)v10 + 2) = v13;
LABEL_24:
  v15 = *(_DWORD *)(a1 + 4);
  if ( v15 == 1 )
  {
    *((_WORD *)v10 + 28) = *(_WORD *)(a1 + 56);
  }
  else if ( *(_DWORD *)(a1 + 40) && v15 != 5 && v15 != 20 && v15 != 19 )
  {
    *((_DWORD *)v10 + 10) = xmlStrdup(*(_BYTE **)(a1 + 40));
  }
  if ( !a3 )
    goto LABEL_37;
  if ( dword_4A9C08 && xmlRegisterNodeDefaultValue )
    xmlRegisterNodeDefaultValue(v10);
  result = xmlAddChild(a3, v10);
  if ( result == v10 )
  {
LABEL_37:
    if ( !a4 )
      goto LABEL_68;
    v16 = *(_DWORD *)(a1 + 4);
    if ( (v16 == 1 || v16 == 19) && *(_DWORD *)(a1 + 48) )
      *((_DWORD *)v10 + 12) = xmlCopyNamespaceList(*(_DWORD **)(a1 + 48));
    v17 = *(_DWORD *)(a1 + 36);
    if ( v17 )
    {
      v18 = xmlSearchNs(a2, v10, *(char **)(v17 + 12));
      if ( v18 )
      {
LABEL_49:
        *((_DWORD *)v10 + 9) = v18;
        goto LABEL_50;
      }
      v19 = xmlSearchNs(*(_DWORD *)(a1 + 32), (_DWORD *)a1, *(char **)(*(_DWORD *)(a1 + 36) + 12));
      if ( v19 )
      {
        v20 = *((_DWORD *)v10 + 5);
        v21 = (int)v10;
        while ( v20 )
        {
          v21 = v20;
          v20 = *(_DWORD *)(v20 + 20);
        }
        v18 = xmlNewNs(v21, (char *)v19[2], (char *)v19[3]);
        goto LABEL_49;
      }
      v11 = (_DWORD *)a2;
      v4 = a1;
      *((_DWORD *)v10 + 9) = sub_419F60(a2, v10, *(_DWORD *)(a1 + 36));
    }
LABEL_50:
    v22 = *(_DWORD *)(v4 + 4);
    if ( (v22 == 1 || v22 == 19) && *(_DWORD *)(v4 + 44) )
      *((_DWORD *)v10 + 11) = xmlCopyPropList(v10, *(int **)(v4 + 44));
    if ( *(_DWORD *)(v4 + 4) == 5 )
    {
      if ( v11 && *(_DWORD **)(v4 + 32) == v11 )
        DocEntity = *(_DWORD **)(v4 + 12);
      else
        DocEntity = xmlGetDocEntity(v11, *((char **)v10 + 2));
      *((_DWORD *)v10 + 3) = DocEntity;
    }
    else
    {
      if ( !*(_DWORD *)(v4 + 12) || a4 == 2 )
        goto LABEL_68;
      DocEntity = (_DWORD *)sub_41894F(v10);
      *((_DWORD *)v10 + 3) = DocEntity;
      if ( !DocEntity )
      {
        *((_DWORD *)v10 + 4) = 0;
        goto LABEL_68;
      }
      while ( 1 )
      {
        v24 = DocEntity[6] == 0;
        DocEntity[5] = v10;
        if ( v24 )
          break;
        DocEntity = (_DWORD *)DocEntity[6];
      }
    }
    *((_DWORD *)v10 + 4) = DocEntity;
LABEL_68:
    if ( !a3 && dword_4A9C08 )
    {
      if ( xmlRegisterNodeDefaultValue )
        xmlRegisterNodeDefaultValue(v10);
    }
    return v10;
  }
  return result;
}
// 418734: conditional instruction was optimized away because eax.4>=E
// 4187DC: conditional instruction was optimized away because eax.4!=1
// 41894F: using guessed type _DWORD __cdecl sub_41894F(_DWORD);
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A9C08: using guessed type int dword_4A9C08;
// 4A9CAC: using guessed type int (__cdecl *xmlRegisterNodeDefaultValue)(_DWORD);

//----- (0041894F) --------------------------------------------------------
char *__usercall sub_41894F@<eax>(int a1@<eax>, int a2@<edi>, char *a3)
{
  int i; // ebx
  char *v4; // esi
  char *v6; // [esp+4h] [ebp-8h]
  char *v7; // [esp+8h] [ebp-4h]

  v6 = 0;
  v7 = 0;
  for ( i = a1; i; i = *(_DWORD *)(i + 24) )
  {
    if ( *(_DWORD *)(i + 4) == 14 )
    {
      if ( !a2 )
        continue;
      v4 = *(char **)(a2 + 44);
      if ( v4 )
      {
        xmlAddChild(a3, *(char **)(a2 + 44));
      }
      else
      {
        v4 = (char *)xmlCopyDtd(i);
        *((_DWORD *)v4 + 8) = a2;
        *((_DWORD *)v4 + 5) = a3;
        *(_DWORD *)(a2 + 44) = v4;
        xmlAddChild(a3, v4);
      }
    }
    else
    {
      v4 = sub_4186C8(i, a2, a3, 1);
    }
    if ( !v6 )
    {
      *((_DWORD *)v4 + 7) = 0;
      v6 = v4;
LABEL_12:
      v7 = v4;
      continue;
    }
    if ( v7 != v4 )
    {
      *((_DWORD *)v7 + 6) = v4;
      *((_DWORD *)v4 + 7) = v7;
      goto LABEL_12;
    }
  }
  return v6;
}

//----- (004189E1) --------------------------------------------------------
int __cdecl xmlCopyNode(int a1, int a2)
{
  return sub_4186C8(a1, 0, 0, a2);
}
// 4186C8: using guessed type _DWORD __cdecl sub_4186C8(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004189F6) --------------------------------------------------------
char *__cdecl xmlDocCopyNode(int a1, int a2, int a3)
{
  return sub_4186C8(a1, a2, 0, a3);
}

//----- (00418A0D) --------------------------------------------------------
char *__cdecl xmlDocCopyNodeList(int a1, int a2)
{
  return sub_41894F(a2, a1, 0);
}

//----- (00418A20) --------------------------------------------------------
char *__cdecl xmlCopyNodeList(int a1)
{
  return sub_41894F(a1, 0, 0);
}

//----- (00418A31) --------------------------------------------------------
_DWORD *__cdecl xmlCopyDtd(int a1)
{
  _DWORD *v1; // ebp
  _DWORD *v3; // edi
  int i; // esi
  int v5; // eax
  int v6; // eax
  _DWORD *v7; // eax
  _DWORD *DtdQElementDesc; // eax

  v1 = 0;
  if ( !a1 )
    return 0;
  v3 = xmlNewDtd(0, *(_BYTE **)(a1 + 8), *(_BYTE **)(a1 + 52), *(_BYTE **)(a1 + 56));
  if ( !v3 )
    return 0;
  if ( *(_DWORD *)(a1 + 48) )
    v3[12] = xmlCopyEntitiesTable(*(_DWORD **)(a1 + 48));
  if ( *(_DWORD *)(a1 + 36) )
    v3[9] = xmlCopyNotationTable(*(_DWORD **)(a1 + 36));
  if ( *(_DWORD *)(a1 + 40) )
    v3[10] = xmlCopyElementTable(*(_DWORD **)(a1 + 40));
  if ( *(_DWORD *)(a1 + 44) )
    v3[11] = xmlCopyAttributeTable(*(_DWORD **)(a1 + 44));
  if ( *(_DWORD *)(a1 + 60) )
    v3[15] = xmlCopyEntitiesTable(*(_DWORD **)(a1 + 60));
  for ( i = *(_DWORD *)(a1 + 12); i; i = *(_DWORD *)(i + 24) )
  {
    v5 = *(_DWORD *)(i + 4);
    switch ( v5 )
    {
      case 17:
        v6 = *(_DWORD *)(i + 48);
        if ( v6 <= 0 )
          continue;
        if ( v6 <= 3 )
        {
          v7 = (_DWORD *)v3[12];
        }
        else
        {
          if ( v6 > 5 )
            continue;
          v7 = (_DWORD *)v3[15];
        }
        if ( v7 )
          DtdQElementDesc = (_DWORD *)xmlHashLookup3(v7, *(char **)(i + 8), 0, 0);
        else
          DtdQElementDesc = 0;
        break;
      case 15:
        DtdQElementDesc = (_DWORD *)xmlGetDtdQElementDesc((int)v3, *(char **)(i + 8), *(char **)(i + 48));
        break;
      case 16:
        DtdQElementDesc = (_DWORD *)xmlGetDtdQAttrDesc(
                                      (int)v3,
                                      *(char **)(i + 60),
                                      *(char **)(i + 8),
                                      *(char **)(i + 56));
        break;
      case 8:
        DtdQElementDesc = (_DWORD *)xmlCopyNode(i, 0);
        break;
      default:
        continue;
    }
    if ( DtdQElementDesc )
    {
      if ( v1 )
        v1[6] = DtdQElementDesc;
      else
        v3[3] = DtdQElementDesc;
      DtdQElementDesc[7] = v1;
      DtdQElementDesc[5] = v3;
      DtdQElementDesc[6] = 0;
      v3[4] = DtdQElementDesc;
      v1 = DtdQElementDesc;
    }
  }
  return v3;
}

//----- (00418B6B) --------------------------------------------------------
_DWORD *__cdecl xmlCopyDoc(int a1, int a2)
{
  _DWORD *v3; // edi
  _DWORD *v4; // eax
  int v5; // eax

  if ( !a1 )
    return 0;
  v3 = xmlNewDoc(*(char **)(a1 + 56));
  if ( !v3 )
    return 0;
  if ( *(_DWORD *)(a1 + 8) )
    v3[2] = xmlMemStrdup(*(void **)(a1 + 8));
  if ( *(_DWORD *)(a1 + 60) )
    v3[15] = xmlStrdup(*(_BYTE **)(a1 + 60));
  if ( *(_DWORD *)(a1 + 72) )
    v3[18] = xmlStrdup(*(_BYTE **)(a1 + 72));
  v3[19] = *(_DWORD *)(a1 + 76);
  v3[9] = *(_DWORD *)(a1 + 36);
  v3[10] = *(_DWORD *)(a1 + 40);
  if ( a2 )
  {
    v3[4] = 0;
    v3[3] = 0;
    if ( *(_DWORD *)(a1 + 44) )
    {
      v4 = xmlCopyDtd(*(_DWORD *)(a1 + 44));
      v3[11] = v4;
      xmlSetTreeDoc(v4, (int)v3);
      *(_DWORD *)(v3[11] + 20) = v3;
    }
    if ( *(_DWORD *)(a1 + 52) )
      v3[13] = xmlCopyNamespaceList(*(_DWORD **)(a1 + 52));
    if ( *(_DWORD *)(a1 + 12) )
    {
      v5 = sub_41894F(v3);
      v3[3] = v5;
      v3[4] = 0;
      while ( v5 )
      {
        if ( !*(_DWORD *)(v5 + 24) )
          v3[4] = v5;
        v5 = *(_DWORD *)(v5 + 24);
      }
    }
  }
  return v3;
}
// 41894F: using guessed type _DWORD __cdecl sub_41894F(_DWORD);
// 4A4B74: using guessed type int (__cdecl *xmlMemStrdup)(void *Src);

//----- (00418C43) --------------------------------------------------------
int __cdecl xmlGetLineNo(int a1)
{
  int result; // eax
  int v2; // edx
  int v3; // esi
  int v4; // edx
  int v5; // ecx

  result = -1;
  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 4);
    if ( v2 == 1 || v2 == 3 || v2 == 8 || v2 == 7 )
    {
      return *(unsigned __int16 *)(a1 + 56);
    }
    else
    {
      v3 = *(_DWORD *)(a1 + 28);
      if ( v3 && ((v4 = *(_DWORD *)(v3 + 4), v4 == 1) || v4 == 3 || v4 == 8 || v4 == 7) )
      {
        return xmlGetLineNo(*(_DWORD *)(a1 + 28));
      }
      else
      {
        v5 = *(_DWORD *)(a1 + 20);
        if ( v5 )
        {
          if ( *(_DWORD *)(v5 + 4) == 1 )
            return xmlGetLineNo(v5);
        }
      }
    }
  }
  return result;
}

//----- (00418CA3) --------------------------------------------------------
char *__cdecl xmlGetNodePath(int a1)
{
  int v1; // esi
  char *v3; // ebx
  int v4; // eax
  int v5; // eax
  int v6; // ebx
  const char *v7; // eax
  int v8; // edi
  int v9; // eax
  int v10; // ecx
  int v11; // edi
  int v12; // eax
  int v13; // ecx
  int v14; // eax
  int v15; // esi
  int v16; // edi
  int v17; // edi
  int v18; // eax
  const char *v19; // ecx
  const char *v20; // eax
  int v21; // eax
  int v22; // ecx
  int v23; // eax
  int v24; // esi
  int v25; // eax
  int v26; // eax
  char *v27; // [esp+4h] [ebp-84h]
  size_t BufferCount; // [esp+8h] [ebp-80h]
  int v29; // [esp+Ch] [ebp-7Ch]
  const char *v30; // [esp+10h] [ebp-78h]
  char *Block; // [esp+14h] [ebp-74h]
  char *v32; // [esp+18h] [ebp-70h]
  int v33; // [esp+1Ch] [ebp-6Ch]
  char Buffer[99]; // [esp+20h] [ebp-68h] BYREF
  char v35; // [esp+83h] [ebp-5h]

  v1 = a1;
  if ( !a1 )
    return 0;
  BufferCount = 500;
  v3 = (char *)xmlMallocAtomic(0x1F4u);
  v27 = v3;
  if ( !v3 )
  {
    sub_43279D("getting node path");
    return 0;
  }
  Block = (char *)xmlMallocAtomic(0x1F4u);
  if ( !Block )
  {
    sub_43279D("getting node path");
    ((void (__cdecl *)(char *))xmlFree)(v3);
    return 0;
  }
  *v3 = 0;
  while ( 1 )
  {
    v4 = *(_DWORD *)(v1 + 4);
    v32 = (char *)byte_47627C;
    v30 = "?";
    v33 = 0;
    if ( v4 == 9 || v4 == 13 )
    {
      if ( *v3 == 47 )
        goto LABEL_97;
      v30 = "/";
      v29 = 0;
    }
    else if ( v4 == 1 )
    {
      v5 = *(_DWORD *)(v1 + 36);
      v30 = "/";
      v6 = 0;
      v32 = *(char **)(v1 + 8);
      if ( v5 )
      {
        v7 = *(const char **)(v5 + 12);
        if ( v7 )
        {
          _snprintf(Buffer, 0x63u, "%s:%s", v7, *(const char **)(v1 + 8));
          v35 = 0;
          v32 = Buffer;
        }
        else
        {
          v6 = 1;
          v32 = "*";
        }
      }
      v8 = *(_DWORD *)(v1 + 28);
      v29 = *(_DWORD *)(v1 + 20);
      if ( v8 )
      {
        do
        {
          if ( *(_DWORD *)(v8 + 4) == 1 )
          {
            if ( v6
              || xmlStrEqual(*(char **)(v1 + 8), *(char **)(v8 + 8))
              && ((v9 = *(_DWORD *)(v8 + 36), v10 = *(_DWORD *)(v1 + 36), v9 == v10)
               || v9 && v10 && xmlStrEqual(*(char **)(v10 + 12), *(char **)(v9 + 12))) )
            {
              ++v33;
            }
          }
          v8 = *(_DWORD *)(v8 + 28);
        }
        while ( v8 );
        if ( v33 )
          goto LABEL_68;
      }
      v11 = *(_DWORD *)(v1 + 24);
      if ( v11 )
      {
        while ( !v33 )
        {
          if ( *(_DWORD *)(v11 + 4) == 1 )
          {
            if ( v6
              || xmlStrEqual(*(char **)(v1 + 8), *(char **)(v11 + 8))
              && ((v12 = *(_DWORD *)(v11 + 36), v13 = *(_DWORD *)(v1 + 36), v12 == v13)
               || v12 && v13 && xmlStrEqual(*(char **)(v13 + 12), *(char **)(v12 + 12))) )
            {
              v33 = 1;
            }
          }
          v11 = *(_DWORD *)(v11 + 24);
          if ( !v11 )
          {
            if ( !v33 )
              goto LABEL_89;
            break;
          }
        }
        v33 = 1;
      }
    }
    else if ( v4 == 8 )
    {
      v29 = *(_DWORD *)(v1 + 20);
      v14 = *(_DWORD *)(v1 + 28);
      v30 = "/";
      v32 = "comment()";
      if ( v14 )
      {
        do
        {
          if ( *(_DWORD *)(v14 + 4) == 8 )
            ++v33;
          v14 = *(_DWORD *)(v14 + 28);
        }
        while ( v14 );
        if ( v33 )
          goto LABEL_68;
      }
      v15 = *(_DWORD *)(v1 + 24);
      if ( v15 )
      {
        while ( !v33 )
        {
          v33 = *(_DWORD *)(v15 + 4) == 8;
          v15 = *(_DWORD *)(v15 + 24);
          if ( !v15 )
          {
            if ( !v33 )
              goto LABEL_89;
            break;
          }
        }
LABEL_50:
        v33 = 1;
      }
    }
    else if ( v4 == 3 || v4 == 4 )
    {
      v29 = *(_DWORD *)(v1 + 20);
      v21 = *(_DWORD *)(v1 + 28);
      v30 = "/";
      v32 = "text()";
      if ( v21 )
      {
        do
        {
          v22 = *(_DWORD *)(v21 + 4);
          if ( v22 == 3 || v22 == 4 )
            ++v33;
          v21 = *(_DWORD *)(v21 + 28);
        }
        while ( v21 );
        if ( v33 )
        {
LABEL_68:
          ++v33;
          goto LABEL_89;
        }
      }
      while ( 1 )
      {
        v1 = *(_DWORD *)(v1 + 24);
        if ( !v1 )
          break;
        v23 = *(_DWORD *)(v1 + 4);
        if ( v23 == 3 || v23 == 4 )
          goto LABEL_50;
      }
    }
    else if ( v4 == 7 )
    {
      v30 = "/";
      _snprintf(Buffer, 0x63u, "processing-instruction('%s')", *(const char **)(v1 + 8));
      v35 = 0;
      v16 = *(_DWORD *)(v1 + 28);
      v32 = Buffer;
      v29 = *(_DWORD *)(v1 + 20);
      if ( v16 )
      {
        do
        {
          if ( *(_DWORD *)(v16 + 4) == 7 && xmlStrEqual(*(char **)(v1 + 8), *(char **)(v16 + 8)) )
            ++v33;
          v16 = *(_DWORD *)(v16 + 28);
        }
        while ( v16 );
        if ( v33 )
          goto LABEL_68;
      }
      v17 = *(_DWORD *)(v1 + 24);
      if ( v17 )
      {
        while ( !v33 )
        {
          if ( *(_DWORD *)(v17 + 4) == 7 && xmlStrEqual(*(char **)(v1 + 8), *(char **)(v17 + 8)) )
            v33 = 1;
          v17 = *(_DWORD *)(v17 + 24);
          if ( !v17 )
          {
            if ( !v33 )
              goto LABEL_89;
            break;
          }
        }
        v33 = 1;
      }
    }
    else
    {
      if ( v4 == 2 )
      {
        v18 = *(_DWORD *)(v1 + 36);
        v19 = *(const char **)(v1 + 8);
        v30 = "/@";
        v32 = (char *)v19;
        if ( v18 )
        {
          v20 = *(const char **)(v18 + 12);
          if ( v20 )
            _snprintf(Buffer, 0x63u, "%s:%s", v20, v19);
          else
            _snprintf(Buffer, 0x63u, "%s", v19);
          v35 = 0;
          v32 = Buffer;
        }
      }
      v29 = *(_DWORD *)(v1 + 20);
    }
LABEL_89:
    v3 = v27;
    v24 = BufferCount;
    if ( xmlStrlen(v27) + 120 > BufferCount )
      break;
LABEL_93:
    if ( v33 )
      _snprintf(Block, v24, "%s%s[%d]%s", v30, v32, v33, v3);
    else
      _snprintf(Block, v24, "%s%s%s", v30, v32, v3);
    _snprintf(v3, v24, "%s", Block);
    v1 = v29;
    if ( !v29 )
    {
LABEL_97:
      ((void (__cdecl *)(char *))xmlFree)(Block);
      return v3;
    }
  }
  v24 = xmlStrlen(v27) + 2 * BufferCount + 120;
  BufferCount = v24;
  v25 = xmlRealloc(v27, v24);
  if ( v25 )
  {
    v3 = (char *)v25;
    v27 = (char *)v25;
    v26 = xmlRealloc(Block, v24);
    if ( v26 )
    {
      Block = (char *)v26;
      goto LABEL_93;
    }
  }
  sub_43279D("getting node path");
  ((void (__cdecl *)(char *))xmlFree)(Block);
  ((void (__cdecl *)(char *))xmlFree)(v3);
  return 0;
}
// 496494: invalid function type has been ignored
// 49B2BC: using guessed type int (__cdecl *xmlMallocAtomic)(size_t Size);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);

//----- (00419131) --------------------------------------------------------
int __cdecl xmlDocGetRootElement(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    for ( result = *(_DWORD *)(a1 + 12); result && *(_DWORD *)(result + 4) != 1; result = *(_DWORD *)(result + 24) )
      ;
  }
  return result;
}

//----- (0041914D) --------------------------------------------------------
char *__cdecl xmlDocSetRootElement(int a1, char *a2)
{
  char *v3; // eax
  char *v4; // ebx

  if ( !a1 )
    return 0;
  if ( !a2 )
    return 0;
  xmlUnlinkNode((int)a2);
  xmlSetTreeDoc(a2, a1);
  *((_DWORD *)a2 + 5) = a1;
  v3 = *(char **)(a1 + 12);
  v4 = v3;
  if ( !v3 )
    goto LABEL_9;
  do
  {
    if ( *((_DWORD *)v4 + 1) == 1 )
      break;
    v4 = (char *)*((_DWORD *)v4 + 6);
  }
  while ( v4 );
  if ( v4 )
  {
    xmlReplaceNode(v4, a2);
  }
  else
  {
LABEL_9:
    if ( v3 )
    {
      xmlAddSibling(v3, a2);
    }
    else
    {
      *(_DWORD *)(a1 + 12) = a2;
      *(_DWORD *)(a1 + 16) = a2;
    }
  }
  return v4;
}

//----- (004191B9) --------------------------------------------------------
void __cdecl xmlNodeSetLang(_DWORD *a1, char *a2)
{
  int v2; // eax
  int **v3; // eax

  if ( a1 )
  {
    v2 = a1[1];
    if ( v2 < 3 || v2 > 20 )
    {
      v3 = xmlSearchNsByHref(a1[8], a1, "http://www.w3.org/XML/1998/namespace");
      if ( v3 )
        xmlSetNsProp((int)a1, (int)v3, "lang", a2);
    }
  }
}

//----- (004191F9) --------------------------------------------------------
_BYTE *__cdecl xmlNodeGetLang(int a1)
{
  _BYTE *result; // eax

  while ( a1 )
  {
    result = xmlGetNsProp(a1, "lang", "http://www.w3.org/XML/1998/namespace");
    if ( result )
      return result;
    a1 = *(_DWORD *)(a1 + 20);
  }
  return 0;
}

//----- (00419222) --------------------------------------------------------
void __cdecl xmlNodeSetSpacePreserve(_DWORD *a1, int a2)
{
  int v2; // eax
  int **v3; // eax

  if ( a1 )
  {
    v2 = a1[1];
    if ( v2 < 3 || v2 > 20 )
    {
      v3 = xmlSearchNsByHref(a1[8], a1, "http://www.w3.org/XML/1998/namespace");
      if ( v3 )
      {
        if ( a2 )
        {
          if ( a2 == 1 )
            xmlSetNsProp((int)a1, (int)v3, "space", "preserve");
        }
        else
        {
          xmlSetNsProp((int)a1, (int)v3, "space", "default");
        }
      }
    }
  }
}

//----- (00419276) --------------------------------------------------------
int __cdecl xmlNodeGetSpacePreserve(int a1)
{
  char *NsProp; // eax
  char *v3; // edi
  int v5; // esi

  while ( 1 )
  {
    if ( !a1 )
      return -1;
    NsProp = xmlGetNsProp(a1, "space", "http://www.w3.org/XML/1998/namespace");
    v3 = NsProp;
    if ( NsProp )
      break;
LABEL_6:
    a1 = *(_DWORD *)(a1 + 20);
  }
  if ( xmlStrEqual(NsProp, "preserve") )
  {
    v5 = 1;
    goto LABEL_10;
  }
  if ( !xmlStrEqual(v3, "default") )
  {
    ((void (__cdecl *)(char *))xmlFree)(v3);
    goto LABEL_6;
  }
  v5 = 0;
LABEL_10:
  ((void (__cdecl *)(char *))xmlFree)(v3);
  return v5;
}
// 496494: invalid function type has been ignored

//----- (004192E1) --------------------------------------------------------
void __cdecl xmlNodeSetName(_DWORD *a1, char *Src)
{
  int v2; // eax
  int v3; // eax
  _DWORD *v4; // ebx
  int v5; // edi
  unsigned __int8 *v6; // eax

  if ( a1 )
  {
    if ( Src )
    {
      v2 = a1[1];
      if ( v2 < 3 || v2 > 4 && v2 != 8 && (v2 <= 9 || v2 > 13 && (unsigned int)(v2 - 18) > 2) )
      {
        v3 = a1[8];
        if ( v3 )
          v4 = *(_DWORD **)(v3 + 80);
        else
          v4 = 0;
        if ( v4 )
        {
          v5 = a1[2];
          if ( v5 )
          {
            if ( !xmlDictOwns((int)v4, a1[2]) )
              ((void (__cdecl *)(int))xmlFree)(v5);
          }
          v6 = xmlDictLookup(v4, Src, -1);
        }
        else
        {
          if ( a1[2] )
            ((void (__cdecl *)(_DWORD))xmlFree)(a1[2]);
          v6 = xmlStrdup(Src);
        }
        a1[2] = v6;
      }
    }
  }
}
// 496494: invalid function type has been ignored

//----- (0041937E) --------------------------------------------------------
void __cdecl xmlNodeSetBase(_DWORD *a1, char *Src)
{
  int **v2; // ebx
  char *v3; // eax
  char *v4; // edi

  if ( a1 )
  {
    switch ( a1[1] )
    {
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 0xA:
      case 0xB:
      case 0xC:
      case 0xE:
      case 0xF:
      case 0x10:
      case 0x11:
      case 0x12:
      case 0x13:
      case 0x14:
        return;
      case 9:
      case 0xD:
        if ( a1[18] )
          ((void (__cdecl *)(_DWORD))xmlFree)(a1[18]);
        if ( Src )
          a1[18] = xmlPathToURI(Src);
        else
          a1[18] = 0;
        break;
      default:
        v2 = xmlSearchNsByHref(a1[8], a1, "http://www.w3.org/XML/1998/namespace");
        if ( v2 )
        {
          v3 = xmlPathToURI(Src);
          v4 = v3;
          if ( v3 )
          {
            xmlSetNsProp((int)a1, (int)v2, "base", v3);
            ((void (__cdecl *)(char *))xmlFree)(v4);
          }
          else
          {
            xmlSetNsProp((int)a1, (int)v2, "base", Src);
          }
        }
        break;
    }
  }
}
// 496494: invalid function type has been ignored

//----- (00419444) --------------------------------------------------------
unsigned __int8 *__cdecl xmlNodeGetBase(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // esi
  unsigned __int8 *v3; // ebx
  _DWORD *i; // esi
  unsigned __int8 *v6; // edi
  int v7; // eax
  unsigned __int8 *NsProp; // eax
  unsigned __int8 *v9; // edi
  unsigned __int8 *v10; // ebx
  int v11; // eax
  _BYTE *v12; // eax
  void *v13; // esi
  _BYTE *v14; // [esp-4h] [ebp-14h]
  unsigned __int8 *Block; // [esp+Ch] [ebp-4h]

  v2 = a2;
  v3 = 0;
  Block = 0;
  if ( !a2 )
  {
    if ( !a1 )
      return 0;
    goto LABEL_6;
  }
  if ( a1 || (a1 = (_DWORD *)a2[8]) != 0 )
  {
LABEL_6:
    if ( a1[1] != 13 )
      goto LABEL_30;
    for ( i = (_DWORD *)a1[3]; ; i = (_DWORD *)i[3] )
    {
      while ( 1 )
      {
        if ( !i )
          return 0;
        v6 = (unsigned __int8 *)i[2];
        if ( !v6 )
          return 0;
        if ( i[1] == 1 )
          break;
LABEL_14:
        i = (_DWORD *)i[6];
      }
      if ( xmlStrcasecmp(v6, "html") && xmlStrcasecmp(v6, "head") )
      {
        if ( !xmlStrcasecmp(v6, "base") )
          return xmlGetProp((int)i, "href");
        goto LABEL_14;
      }
    }
  }
LABEL_30:
  while ( v2 )
  {
    v7 = v2[1];
    if ( v7 == 17 )
    {
      v14 = (_BYTE *)v2[16];
      return xmlStrdup(v14);
    }
    if ( v7 == 1 )
    {
      NsProp = xmlGetNsProp((int)v2, "base", "http://www.w3.org/XML/1998/namespace");
      v9 = NsProp;
      if ( NsProp )
      {
        if ( v3 )
        {
          v10 = (unsigned __int8 *)xmlBuildURI(v3, NsProp);
          ((void (__cdecl *)(unsigned __int8 *))xmlFree)(Block);
          ((void (__cdecl *)(unsigned __int8 *))xmlFree)(v9);
          if ( !v10 )
            return 0;
          Block = v10;
          v11 = xmlStrncmp(v10, "http://", 7);
        }
        else
        {
          Block = NsProp;
          v11 = xmlStrncmp(NsProp, "http://", 7);
        }
        if ( !v11 || !xmlStrncmp(Block, "ftp://", 6) || !xmlStrncmp(Block, "urn:", 4) )
          return Block;
        v3 = Block;
      }
    }
    v2 = (_DWORD *)v2[5];
  }
  if ( a1 )
  {
    v12 = (_BYTE *)a1[18];
    if ( v12 )
    {
      v14 = (_BYTE *)a1[18];
      if ( v3 )
      {
        v13 = xmlBuildURI(v3, v12);
        ((void (__cdecl *)(unsigned __int8 *))xmlFree)(v3);
        return (unsigned __int8 *)v13;
      }
      return xmlStrdup(v14);
    }
  }
  return v3;
}
// 496494: invalid function type has been ignored

//----- (004195D9) --------------------------------------------------------
int __cdecl xmlNodeBufGetContent(int *a1, int a2)
{
  int v2; // eax
  _DWORD *DocEntity; // eax
  int k; // esi
  int j; // esi
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // esi
  int v10; // eax
  int v11; // eax
  int i; // esi
  int v13; // eax

  if ( !a2 || !a1 )
    return -1;
  v2 = *(_DWORD *)(a2 + 4);
  if ( v2 > 8 )
  {
    v6 = v2 - 9;
    if ( v6 )
    {
      v7 = v6 - 2;
      if ( !v7 )
        goto LABEL_28;
      v8 = v7 - 2;
      if ( v8 )
      {
        if ( v8 == 5 )
          xmlBufferCat(a1, *(_BYTE **)(a2 + 8));
        return 0;
      }
    }
    for ( i = *(_DWORD *)(a2 + 12); i; i = *(_DWORD *)(i + 24) )
    {
      v13 = *(_DWORD *)(i + 4);
      if ( v13 == 1 || v13 == 3 || v13 == 4 )
        xmlNodeBufGetContent(a1, i);
    }
    return 0;
  }
  if ( v2 >= 7 )
    goto LABEL_15;
  if ( v2 == 1 )
  {
LABEL_28:
    v9 = a2;
    while ( 1 )
    {
      v10 = *(_DWORD *)(v9 + 4);
      if ( v10 >= 3 )
      {
        if ( v10 <= 4 )
        {
          if ( *(_DWORD *)(v9 + 40) )
            xmlBufferCat(a1, *(_BYTE **)(v9 + 40));
        }
        else if ( v10 == 5 )
        {
          xmlNodeBufGetContent(a1, v9);
        }
      }
      v11 = *(_DWORD *)(v9 + 12);
      if ( !v11 || *(_DWORD *)(v11 + 4) == 17 )
      {
        if ( v9 == a2 )
          return 0;
        v11 = *(_DWORD *)(v9 + 24);
        if ( !v11 )
          break;
      }
      v9 = v11;
LABEL_44:
      if ( !v9 )
        return 0;
    }
    while ( 1 )
    {
      v9 = *(_DWORD *)(v9 + 20);
      if ( !v9 || v9 == a2 )
        return 0;
      if ( *(_DWORD *)(v9 + 24) )
      {
        v9 = *(_DWORD *)(v9 + 24);
        goto LABEL_44;
      }
    }
  }
  if ( v2 == 2 )
  {
    for ( j = *(_DWORD *)(a2 + 12); j; j = *(_DWORD *)(j + 24) )
    {
      if ( *(_DWORD *)(j + 4) == 3 )
        xmlBufferCat(a1, *(_BYTE **)(j + 40));
      else
        xmlNodeBufGetContent(a1, j);
    }
    return 0;
  }
  if ( v2 <= 2 )
    return 0;
  if ( v2 <= 4 )
  {
LABEL_15:
    xmlBufferCat(a1, *(_BYTE **)(a2 + 40));
    return 0;
  }
  if ( v2 != 5 )
    return 0;
  DocEntity = xmlGetDocEntity(*(_DWORD **)(a2 + 32), *(char **)(a2 + 8));
  if ( DocEntity )
  {
    for ( k = DocEntity[3]; k; k = *(_DWORD *)(k + 24) )
      xmlNodeBufGetContent(a1, k);
    return 0;
  }
  return -1;
}

//----- (00419741) --------------------------------------------------------
_BYTE *__cdecl xmlNodeGetContent(int a1)
{
  _BYTE *result; // eax
  int *Size; // eax
  int *v3; // edi
  int v4; // esi
  _BYTE *v5; // esi
  int v6; // eax
  int v7; // eax
  int v8; // edx

  if ( !a1 )
    return 0;
  switch ( *(_DWORD *)(a1 + 4) )
  {
    case 1:
    case 0xB:
      Size = xmlBufferCreateSize(64);
      goto LABEL_7;
    case 2:
      v6 = *(_DWORD *)(a1 + 4);
      if ( v6 == 2 )
      {
        v7 = *(_DWORD *)(a1 + 12);
        if ( !v7 )
          goto LABEL_21;
        if ( !*(_DWORD *)(v7 + 24) )
        {
          v8 = *(_DWORD *)(v7 + 4);
          if ( v8 == 3 || v8 == 4 )
            return xmlStrdup(*(_BYTE **)(v7 + 40));
        }
        result = xmlNodeListGetString(*(_DWORD **)(a1 + 32), v7, 1);
        if ( !result )
LABEL_21:
          result = xmlStrdup(byte_47627C);
      }
      else if ( v6 == 16 )
      {
        result = xmlStrdup(*(_BYTE **)(a1 + 48));
      }
      else
      {
        result = 0;
      }
      break;
    case 3:
    case 4:
    case 7:
    case 8:
      v5 = *(_BYTE **)(a1 + 40);
      if ( !v5 )
        return 0;
      return xmlStrdup(v5);
    case 5:
      if ( xmlGetDocEntity(*(_DWORD **)(a1 + 32), *(char **)(a1 + 8)) )
        goto LABEL_6;
      return 0;
    case 9:
    case 0xD:
LABEL_6:
      Size = xmlBufferCreate();
LABEL_7:
      v3 = Size;
      if ( !Size )
        return 0;
      xmlNodeBufGetContent(Size, a1);
      v4 = *v3;
      *v3 = 0;
      xmlBufferFree(v3);
      return (_BYTE *)v4;
    case 0x12:
      return xmlStrdup(*(_BYTE **)(a1 + 8));
    default:
      return 0;
  }
  return result;
}
// 41A523: conditional instruction was optimized away because ecx.4!=0

//----- (004197F9) --------------------------------------------------------
void __cdecl xmlNodeSetContent(int a1, _BYTE *Src)
{
  int v2; // eax
  int NodeList; // eax
  int v4; // edi
  int v5; // eax
  int v6; // eax
  bool v7; // zf

  if ( !a1 )
    return;
  v2 = *(_DWORD *)(a1 + 4);
  if ( v2 <= 0 )
    return;
  if ( v2 <= 2 )
    goto LABEL_6;
  if ( v2 > 8 )
  {
    if ( v2 != 11 )
      return;
LABEL_6:
    if ( *(_DWORD *)(a1 + 12) )
      xmlFreeNodeList(*(_DWORD **)(a1 + 12));
    NodeList = xmlStringGetNodeList(*(_DWORD *)(a1 + 32), Src);
    *(_DWORD *)(a1 + 12) = NodeList;
    if ( NodeList )
    {
      while ( 1 )
      {
        v7 = *(_DWORD *)(NodeList + 24) == 0;
        *(_DWORD *)(NodeList + 20) = a1;
        if ( v7 )
          break;
        NodeList = *(_DWORD *)(NodeList + 24);
      }
      *(_DWORD *)(a1 + 16) = NodeList;
    }
    else
    {
      *(_DWORD *)(a1 + 16) = 0;
    }
    return;
  }
  v4 = *(_DWORD *)(a1 + 40);
  if ( v4 )
  {
    if ( v4 != a1 + 44 )
    {
      v5 = *(_DWORD *)(a1 + 32);
      if ( !v5 || (v6 = *(_DWORD *)(v5 + 80)) == 0 || !xmlDictOwns(v6, *(_DWORD *)(a1 + 40)) )
        ((void (__cdecl *)(int))xmlFree)(v4);
    }
  }
  if ( *(_DWORD *)(a1 + 12) )
    xmlFreeNodeList(*(_DWORD **)(a1 + 12));
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  if ( Src )
    *(_DWORD *)(a1 + 40) = xmlStrdup(Src);
  else
    *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 48) = 0;
}
// 496494: invalid function type has been ignored
// 41692B: using guessed type _DWORD __cdecl xmlStringGetNodeList(_DWORD, void *Src);

//----- (004198C7) --------------------------------------------------------
void __cdecl xmlNodeSetContentLen(int a1, void *Src, int Size)
{
  int v3; // eax
  int v4; // edi
  int v5; // eax
  int v6; // eax
  _DWORD *NodeList; // eax
  bool v8; // zf

  if ( !a1 )
    return;
  v3 = *(_DWORD *)(a1 + 4);
  if ( v3 <= 0 )
    return;
  if ( v3 > 2 )
  {
    if ( v3 <= 8 )
    {
LABEL_7:
      v4 = *(_DWORD *)(a1 + 40);
      if ( v4 )
      {
        if ( v4 != a1 + 44 )
        {
          v5 = *(_DWORD *)(a1 + 32);
          if ( !v5 || (v6 = *(_DWORD *)(v5 + 80)) == 0 || !xmlDictOwns(v6, *(_DWORD *)(a1 + 40)) )
            ((void (__cdecl *)(int))xmlFree)(v4);
        }
      }
      if ( *(_DWORD *)(a1 + 12) )
        xmlFreeNodeList(*(_DWORD **)(a1 + 12));
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      if ( Src )
        *(_DWORD *)(a1 + 40) = xmlStrndup(Src, Size);
      else
        *(_DWORD *)(a1 + 40) = 0;
      *(_DWORD *)(a1 + 44) = 0;
      *(_DWORD *)(a1 + 48) = 0;
      return;
    }
    if ( v3 != 11 )
    {
      if ( v3 != 12 )
        return;
      goto LABEL_7;
    }
  }
  if ( *(_DWORD *)(a1 + 12) )
    xmlFreeNodeList(*(_DWORD **)(a1 + 12));
  NodeList = xmlStringLenGetNodeList(*(int (__cdecl **)(int, char *, char))(a1 + 32), (char *)Src, Size);
  *(_DWORD *)(a1 + 12) = NodeList;
  if ( NodeList )
  {
    while ( 1 )
    {
      v8 = NodeList[6] == 0;
      NodeList[5] = a1;
      if ( v8 )
        break;
      NodeList = (_DWORD *)NodeList[6];
    }
    *(_DWORD *)(a1 + 16) = NodeList;
  }
  else
  {
    *(_DWORD *)(a1 + 16) = 0;
  }
}
// 496494: invalid function type has been ignored

//----- (004199A2) --------------------------------------------------------
void __cdecl xmlNodeAddContentLen(int a1, _BYTE *Src, signed int Size)
{
  int v3; // eax
  _BYTE *v4; // ebx
  int v5; // eax
  int v6; // eax
  char *v7; // eax
  int v8; // edi
  char *v9; // eax
  char *v10; // ebx

  if ( !a1 || Size <= 0 )
    return;
  v3 = *(_DWORD *)(a1 + 4);
  if ( v3 != 1 )
  {
    if ( v3 <= 2 )
      return;
    if ( v3 <= 8 )
    {
LABEL_8:
      if ( Src )
      {
        v4 = *(_BYTE **)(a1 + 40);
        if ( v4 == (_BYTE *)(a1 + 44)
          || (v5 = *(_DWORD *)(a1 + 32)) != 0
          && (v6 = *(_DWORD *)(v5 + 80)) != 0
          && xmlDictOwns(v6, *(_DWORD *)(a1 + 40)) )
        {
          v7 = xmlStrncatNew(v4, Src, Size);
          *(_DWORD *)(a1 + 44) = 0;
          *(_DWORD *)(a1 + 48) = 0;
          *(_DWORD *)(a1 + 40) = v7;
        }
        else
        {
          *(_DWORD *)(a1 + 40) = xmlStrncat(v4, Src, Size);
        }
      }
      return;
    }
    if ( v3 != 11 )
    {
      if ( v3 != 12 )
        return;
      goto LABEL_8;
    }
  }
  v8 = *(_DWORD *)(a1 + 16);
  v9 = (char *)xmlNewTextLen(Src, Size);
  v10 = v9;
  if ( v9 && xmlAddChild((char *)a1, v9) == v9 && v8 && *(char **)(v8 + 24) == v10 )
    xmlTextMerge(v8, v10);
}

//----- (00419A79) --------------------------------------------------------
void __cdecl xmlNodeAddContent(int a1, _BYTE *a2)
{
  int v2; // eax

  if ( a1 )
  {
    if ( a2 )
    {
      v2 = xmlStrlen(a2);
      xmlNodeAddContentLen(a1, a2, v2);
    }
  }
}

//----- (00419AA1) --------------------------------------------------------
char *__cdecl xmlTextMerge(int a1, char *Block)
{
  int v3; // eax
  void *v4; // edx

  if ( !a1 )
    return Block;
  if ( Block && *(_DWORD *)(a1 + 4) == 3 && *((_DWORD *)Block + 1) == 3 && *((_DWORD *)Block + 2) == *(_DWORD *)(a1 + 8) )
  {
    if ( *((_DWORD *)Block + 10) )
    {
      v3 = xmlStrlen(*((_BYTE **)Block + 10));
      xmlNodeAddContentLen(a1, v4, v3);
    }
    xmlUnlinkNode((int)Block);
    xmlFreeNode(Block);
  }
  return (char *)a1;
}
// 419ADD: variable 'v4' is possibly undefined
// 4199A2: using guessed type _DWORD __cdecl xmlNodeAddContentLen(_DWORD, void *Src, size_t Size);

//----- (00419AF8) --------------------------------------------------------
_DWORD *__cdecl xmlGetNsList(int a1, int a2)
{
  _DWORD *v2; // esi
  int v3; // edi
  int v4; // eax
  _DWORD *v5; // ebx
  int v6; // eax
  char *v7; // eax
  int v8; // eax
  int v10; // [esp+Ch] [ebp-8h]
  int v11; // [esp+10h] [ebp-4h]

  v2 = 0;
  v3 = 0;
  v10 = 10;
  if ( !a2 )
    return v2;
  while ( 1 )
  {
    v4 = a2;
    if ( *(_DWORD *)(a2 + 4) == 1 )
    {
      v5 = *(_DWORD **)(a2 + 48);
      if ( v5 )
        break;
    }
LABEL_17:
    a2 = *(_DWORD *)(v4 + 20);
    if ( !a2 )
      return v2;
  }
  while ( 1 )
  {
    if ( !v2 )
    {
      v6 = xmlMalloc(4 * v10 + 4);
      v2 = (_DWORD *)v6;
      if ( !v6 )
        goto LABEL_19;
      *(_DWORD *)(v6 + 4 * v3) = 0;
    }
    v11 = 0;
    if ( v3 <= 0 )
      break;
    do
    {
      v7 = (char *)v5[3];
      if ( v7 == *(char **)(v2[v11] + 12) )
        break;
      if ( xmlStrEqual(v7, *(char **)(v2[v11] + 12)) )
        break;
      ++v11;
    }
    while ( v11 < v3 );
    if ( v11 >= v3 )
      break;
LABEL_15:
    v5 = (_DWORD *)*v5;
    if ( !v5 )
    {
      v4 = a2;
      goto LABEL_17;
    }
  }
  v8 = v10;
  if ( v3 < v10 || (v10 *= 2, (v2 = (_DWORD *)xmlRealloc(v2, 8 * v8 + 4)) != 0) )
  {
    v2[v3++] = v5;
    v2[v3] = 0;
    goto LABEL_15;
  }
LABEL_19:
  sub_43279D("getting namespace list");
  return 0;
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);

//----- (00419BDE) --------------------------------------------------------
_DWORD *__usercall sub_419BDE@<eax>(int a1@<ebx>)
{
  _DWORD *result; // eax
  _DWORD *v2; // esi

  if ( !a1 )
    return 0;
  result = *(_DWORD **)(a1 + 52);
  if ( !result )
  {
    v2 = (_DWORD *)xmlMalloc(24);
    if ( v2 )
    {
      memset(v2, 0, 0x18u);
      v2[1] = 18;
      v2[2] = xmlStrdup("http://www.w3.org/XML/1998/namespace");
      v2[3] = xmlStrdup("xml");
      *(_DWORD *)(a1 + 52) = v2;
      return v2;
    }
    else
    {
      sub_43279D("allocating the XML namespace");
      return 0;
    }
  }
  return result;
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (00419C41) --------------------------------------------------------
_DWORD *__cdecl xmlSearchNs(int a1, _DWORD *a2, char *a3)
{
  _DWORD *v3; // ebx
  _DWORD *result; // eax
  int v5; // ecx
  _DWORD *i; // esi
  int v7; // eax
  char *v8; // eax
  char *v9; // eax

  v3 = a2;
  if ( !a2 )
    return 0;
  if ( !a3 || !xmlStrEqual(a3, "xml") )
  {
    while ( 1 )
    {
      v7 = v3[1];
      if ( v7 == 5 || v7 == 6 || v7 == 17 )
        break;
      if ( v7 == 1 )
      {
        for ( i = (_DWORD *)v3[12]; i; i = (_DWORD *)*i )
        {
          v8 = (char *)i[3];
          if ( v8 )
          {
            if ( a3 && i[2] && xmlStrEqual(v8, a3) )
              return i;
          }
          else if ( !a3 && i[2] )
          {
            return i;
          }
        }
        if ( a2 != v3 )
        {
          i = (_DWORD *)v3[9];
          if ( i )
          {
            v9 = (char *)i[3];
            if ( v9 )
            {
              if ( a3 && i[2] && xmlStrEqual(v9, a3) )
                return i;
            }
            else if ( !a3 && i[2] )
            {
              return i;
            }
          }
        }
      }
      v3 = (_DWORD *)v3[5];
      if ( !v3 )
        return 0;
    }
    return 0;
  }
  v5 = a1;
  if ( a1 )
  {
LABEL_14:
    result = *(_DWORD **)(v5 + 52);
    if ( !result )
      return sub_419BDE(v5);
    return result;
  }
  if ( a2[1] != 1 )
  {
    v5 = a2[8];
    if ( !v5 )
      return 0;
    goto LABEL_14;
  }
  i = (_DWORD *)xmlMalloc(24);
  if ( !i )
  {
    sub_43279D("searching namespace");
    return 0;
  }
  memset(i, 0, 0x18u);
  i[1] = 18;
  i[2] = xmlStrdup("http://www.w3.org/XML/1998/namespace");
  i[3] = xmlStrdup("xml");
  *i = a2[12];
  a2[12] = i;
  return i;
}
// 419D20: conditional instruction was optimized away because eax.4==0
// 419D64: conditional instruction was optimized away because eax.4==0
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (00419D93) --------------------------------------------------------
int __usercall sub_419D93@<eax>(_DWORD *a1@<eax>, _DWORD *a2, char *a3)
{
  int v4; // eax
  _DWORD *i; // esi
  char *v6; // eax

  while ( a1 )
  {
    if ( a1 == a2 )
      return 1;
    v4 = a1[1];
    if ( v4 == 5 || v4 == 6 || v4 == 17 )
      return -1;
    if ( v4 == 1 )
    {
      for ( i = (_DWORD *)a1[12]; i; i = (_DWORD *)*i )
      {
        v6 = (char *)i[3];
        if ( v6 )
        {
          if ( a3 && xmlStrEqual(v6, a3) )
            return 0;
        }
        else if ( !a3 )
        {
          return 0;
        }
      }
    }
    a1 = (_DWORD *)a1[5];
  }
  if ( !a2 )
    return 1;
  return -1;
}
// 419DCB: conditional instruction was optimized away because eax.4==0

//----- (00419E04) --------------------------------------------------------
int **__cdecl xmlSearchNsByHref(int a1, _DWORD *a2, char *a3)
{
  _DWORD *v3; // esi
  int v5; // ebx
  _DWORD *v6; // ebx
  int **result; // eax
  int v8; // eax
  int **i; // edi
  char *v10; // eax
  char *v11; // eax
  BOOL v12; // [esp+1Ch] [ebp+Ch]

  v3 = a2;
  if ( !a2 || !a3 )
    return 0;
  if ( !xmlStrEqual(a3, "http://www.w3.org/XML/1998/namespace") )
  {
    v12 = a2[1] == 2;
    do
    {
      v8 = v3[1];
      if ( v8 == 5 || v8 == 6 || v8 == 17 )
        break;
      if ( v8 == 1 )
      {
        for ( i = (int **)v3[12]; i; i = (int **)*i )
        {
          v10 = (char *)i[2];
          if ( v10 && xmlStrEqual(v10, a3) && (!v12 || i[3]) && sub_419D93(a2, v3, (char *)i[3]) == 1 )
            return i;
        }
        if ( a2 != v3 )
        {
          i = (int **)v3[9];
          if ( i )
          {
            v11 = (char *)i[2];
            if ( v11 )
            {
              if ( xmlStrEqual(v11, a3) && (!v12 || i[3]) && sub_419D93(a2, v3, (char *)i[3]) == 1 )
                return i;
            }
          }
        }
      }
      v3 = (_DWORD *)v3[5];
    }
    while ( v3 );
    return 0;
  }
  v5 = a1;
  if ( !a1 )
  {
    if ( a2[1] == 1 )
    {
      v6 = (_DWORD *)xmlMalloc(24);
      if ( v6 )
      {
        memset(v6, 0, 0x18u);
        v6[1] = 18;
        v6[2] = xmlStrdup("http://www.w3.org/XML/1998/namespace");
        v6[3] = xmlStrdup("xml");
        *v6 = a2[12];
        a2[12] = v6;
        return (int **)v6;
      }
      sub_43279D("searching namespace");
      return 0;
    }
    v5 = a2[8];
    if ( !v5 )
      return 0;
  }
  result = *(int ***)(v5 + 52);
  if ( !result )
    return (int **)sub_419BDE(v5);
  return result;
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (00419F60) --------------------------------------------------------
int **__usercall sub_419F60@<eax>(int a1@<ebx>, _DWORD *a2@<edi>, int a3@<esi>)
{
  int **result; // eax
  const char *v4; // eax
  int v5; // [esp+0h] [ebp-3Ch]
  char Buffer[52]; // [esp+4h] [ebp-38h] BYREF

  v5 = 1;
  if ( !a2 || !a3 || *(_DWORD *)(a3 + 4) != 18 )
    return 0;
  result = xmlSearchNsByHref(a1, a2, *(char **)(a3 + 8));
  if ( !result )
  {
    if ( *(_DWORD *)(a3 + 12) )
      _snprintf(Buffer, 0x32u, "%.20s", *(const char **)(a3 + 12));
    else
      _snprintf(Buffer, 0x32u, "default");
    while ( xmlSearchNs(a1, a2, Buffer) )
    {
      if ( v5 > 1000 )
        return 0;
      v4 = *(const char **)(a3 + 12);
      if ( v4 )
        _snprintf(Buffer, 0x32u, "%.20s%d", v4, v5);
      else
        _snprintf(Buffer, 0x32u, "default%d", v5);
      ++v5;
    }
    return (int **)xmlNewNs((int)a2, *(char **)(a3 + 8), Buffer);
  }
  return result;
}

//----- (0041A049) --------------------------------------------------------
int __cdecl xmlReconciliateNs(int a1, _DWORD *a2)
{
  _DWORD *v2; // edi
  _DWORD *v3; // esi
  int v4; // eax
  int **v5; // esi
  SIZE_T v6; // ebx
  int v7; // ecx
  int v8; // ebx
  int v9; // eax
  bool v10; // zf
  int **v11; // esi
  SIZE_T v12; // ebx
  int v13; // ecx
  _DWORD *v14; // eax
  SIZE_T v16; // [esp-4h] [ebp-24h]
  SIZE_T v17; // [esp-4h] [ebp-24h]
  int v18; // [esp+Ch] [ebp-14h]
  int v19; // [esp+10h] [ebp-10h]
  _DWORD *v20; // [esp+14h] [ebp-Ch]
  int v21; // [esp+18h] [ebp-8h]
  _DWORD *Block; // [esp+1Ch] [ebp-4h]

  v2 = a2;
  v3 = a2;
  Block = 0;
  v20 = 0;
  v19 = 0;
  v21 = 0;
  if ( !a2 || a2[1] != 1 || !a1 || *(_DWORD *)(a1 + 4) != 9 || a2[8] != a1 )
    return -1;
  do
  {
    if ( v3[9] )
    {
      if ( !v19 )
      {
        v19 = 10;
        Block = (_DWORD *)xmlMalloc(40);
        if ( !Block )
        {
LABEL_68:
          sub_43279D("fixing namespaces");
          return -1;
        }
        v20 = (_DWORD *)xmlMalloc(40);
        if ( !v20 )
        {
LABEL_70:
          sub_43279D("fixing namespaces");
          ((void (__cdecl *)(_DWORD *))xmlFree)(Block);
          return -1;
        }
      }
      v4 = 0;
      if ( v21 > 0 )
      {
        while ( Block[v4] != v3[9] )
        {
          if ( ++v4 >= v21 )
            goto LABEL_15;
        }
        v3[9] = v20[v4];
      }
LABEL_15:
      if ( v4 == v21 )
      {
        v5 = sub_419F60(a1, v2, v3[9]);
        if ( v5 )
        {
          if ( v19 <= v21 )
          {
            v6 = 8 * v19;
            v16 = 8 * v19;
            v19 *= 2;
            Block = (_DWORD *)xmlRealloc(Block, v16);
            if ( !Block )
            {
LABEL_71:
              sub_43279D("fixing namespaces");
              ((void (__cdecl *)(_DWORD *))xmlFree)(v20);
              return -1;
            }
            v20 = (_DWORD *)xmlRealloc(v20, v6);
            if ( !v20 )
              goto LABEL_70;
          }
          v7 = v21++;
          v20[v7] = v5;
          Block[v7] = a2[9];
          a2[9] = v5;
        }
        v3 = a2;
      }
    }
    if ( v3[1] == 1 )
    {
      v8 = v3[11];
      v18 = v8;
      if ( v8 )
      {
        while ( 1 )
        {
          if ( *(_DWORD *)(v8 + 36) )
          {
            if ( !v19 )
            {
              v19 = 10;
              Block = (_DWORD *)xmlMalloc(40);
              if ( !Block )
                goto LABEL_68;
              v20 = (_DWORD *)xmlMalloc(40);
              if ( !v20 )
                goto LABEL_70;
            }
            v9 = 0;
            v10 = v21 == 0;
            if ( v21 > 0 )
            {
              while ( Block[v9] != *(_DWORD *)(v8 + 36) )
              {
                if ( ++v9 >= v21 )
                  goto LABEL_35;
              }
              *(_DWORD *)(v8 + 36) = v20[v9];
LABEL_35:
              v10 = v9 == v21;
            }
            if ( v10 )
            {
              v11 = sub_419F60(a1, v2, *(_DWORD *)(v8 + 36));
              if ( v11 )
              {
                if ( v19 <= v21 )
                {
                  v12 = 8 * v19;
                  v17 = 8 * v19;
                  v19 *= 2;
                  Block = (_DWORD *)xmlRealloc(Block, v17);
                  if ( !Block )
                    goto LABEL_71;
                  v20 = (_DWORD *)xmlRealloc(v20, v12);
                  if ( !v20 )
                    goto LABEL_70;
                }
                v13 = v21++;
                v20[v13] = v11;
                Block[v13] = *(_DWORD *)(v18 + 36);
                *(_DWORD *)(v18 + 36) = v11;
              }
              v8 = v18;
              v3 = a2;
            }
          }
          v18 = *(_DWORD *)(v8 + 24);
          if ( !v18 )
            break;
          v8 = *(_DWORD *)(v8 + 24);
        }
      }
    }
    v14 = (_DWORD *)v3[3];
    if ( v14 && v3[1] != 5 )
      goto LABEL_46;
    if ( v3 == v2 )
      break;
    v14 = (_DWORD *)v3[6];
    if ( v14 )
    {
LABEL_46:
      a2 = v14;
LABEL_61:
      v3 = a2;
      continue;
    }
    while ( 1 )
    {
      if ( v3[5] )
      {
        a2 = (_DWORD *)v3[5];
        v3 = a2;
      }
      if ( v3 != v2 && v3[6] )
      {
        a2 = (_DWORD *)v3[6];
        goto LABEL_58;
      }
      if ( !v3[5] )
        break;
      if ( v3 == v2 )
        goto LABEL_59;
    }
    a2 = 0;
LABEL_58:
    v3 = a2;
LABEL_59:
    if ( v3 == v2 )
    {
      a2 = 0;
      goto LABEL_61;
    }
  }
  while ( v3 );
  if ( Block )
    ((void (__cdecl *)(_DWORD *))xmlFree)(Block);
  if ( v20 )
    ((void (__cdecl *)(_DWORD *))xmlFree)(v20);
  return 0;
}
// 496494: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);

//----- (0041A331) --------------------------------------------------------
int __usercall sub_41A331@<eax>(int a1@<eax>, char *a2, char *a3, int a4)
{
  int v5; // esi
  int result; // eax
  int v7; // ebx
  char *v8; // ebx
  int v9; // ebx
  int v10; // eax
  _BYTE *Src; // eax
  _BYTE *v12; // eax
  _BYTE *v13; // eax
  char *v14; // eax
  int v15; // ebx
  _DWORD *NsList; // eax
  _DWORD *v17; // edi
  int v18; // esi
  char *v19; // esi
  int v20; // eax
  int *i; // [esp+10h] [ebp-10h]
  int DtdQAttrDesc; // [esp+14h] [ebp-Ch]
  char *Block; // [esp+18h] [ebp-8h]
  char *v24; // [esp+1Ch] [ebp-4h]

  if ( !a1 || *(_DWORD *)(a1 + 4) != 1 || !a2 )
    return 0;
  v5 = *(_DWORD *)(a1 + 44);
  if ( !v5 )
  {
LABEL_16:
    if ( !a4 )
      return 0;
    v9 = *(_DWORD *)(a1 + 32);
    if ( !v9 || !*(_DWORD *)(v9 + 44) )
      return 0;
    v10 = *(_DWORD *)(a1 + 36);
    DtdQAttrDesc = 0;
    Block = 0;
    if ( v10 && (Src = *(_BYTE **)(v10 + 12)) != 0 )
    {
      v12 = xmlStrdup(Src);
      v13 = xmlStrcat(v12, ":");
      v14 = xmlStrcat(v13, *(_BYTE **)(a1 + 8));
      Block = v14;
      if ( !v14 )
        return 0;
    }
    else
    {
      v14 = *(char **)(a1 + 8);
    }
    v24 = v14;
    if ( a3 )
    {
      NsList = xmlGetNsList(*(_DWORD *)(a1 + 32), a1);
      v17 = NsList;
      if ( !NsList )
      {
        if ( Block )
          ((void (__cdecl *)(char *))xmlFree)(Block);
        return 0;
      }
      v18 = *NsList;
      for ( i = NsList; v18; v18 = *i )
      {
        if ( xmlStrEqual(*(char **)(v18 + 8), a3) )
        {
          v19 = *(char **)(v18 + 12);
          DtdQAttrDesc = xmlGetDtdQAttrDesc(*(_DWORD *)(v9 + 44), v24, a2, v19);
          if ( DtdQAttrDesc )
            break;
          v20 = *(_DWORD *)(v9 + 48);
          if ( v20 )
          {
            DtdQAttrDesc = xmlGetDtdQAttrDesc(v20, v24, a2, v19);
            if ( DtdQAttrDesc )
              break;
          }
        }
        ++i;
      }
      ((void (__cdecl *)(_DWORD *))xmlFree)(v17);
    }
    else
    {
      DtdQAttrDesc = xmlGetDtdQAttrDesc(*(_DWORD *)(v9 + 44), v14, a2, 0);
      if ( !DtdQAttrDesc )
      {
        v15 = *(_DWORD *)(v9 + 48);
        if ( v15 )
          DtdQAttrDesc = xmlGetDtdQAttrDesc(v15, v24, a2, 0);
      }
    }
    if ( Block )
      ((void (__cdecl *)(char *))xmlFree)(Block);
    result = DtdQAttrDesc;
    if ( DtdQAttrDesc && *(_DWORD *)(DtdQAttrDesc + 48) )
      return result;
    return 0;
  }
  if ( a3 )
  {
    while ( 1 )
    {
      v7 = *(_DWORD *)(v5 + 36);
      if ( v7 )
      {
        if ( xmlStrEqual(*(char **)(v5 + 8), a2) )
        {
          v8 = *(char **)(v7 + 8);
          if ( v8 == a3 || xmlStrEqual(v8, a3) )
            break;
        }
      }
      v5 = *(_DWORD *)(v5 + 24);
      if ( !v5 )
        goto LABEL_16;
    }
  }
  else
  {
    while ( *(_DWORD *)(v5 + 36) || !xmlStrEqual(*(char **)(v5 + 8), a2) )
    {
      v5 = *(_DWORD *)(v5 + 24);
      if ( !v5 )
        goto LABEL_16;
    }
  }
  return v5;
}
// 496494: invalid function type has been ignored

//----- (0041A577) --------------------------------------------------------
int __cdecl xmlHasProp(int a1, char *a2)
{
  int i; // edi
  int v3; // edi
  int v4; // eax
  int result; // eax
  int v6; // edi

  if ( !a1 || *(_DWORD *)(a1 + 4) != 1 || !a2 )
    return 0;
  for ( i = *(_DWORD *)(a1 + 44); i; i = *(_DWORD *)(i + 24) )
  {
    if ( xmlStrEqual(*(char **)(i + 8), a2) )
      return i;
  }
  v3 = *(_DWORD *)(a1 + 32);
  if ( !v3 )
    return 0;
  v4 = *(_DWORD *)(v3 + 44);
  if ( !v4 )
    return 0;
  result = xmlGetDtdAttrDesc(v4, *(char **)(a1 + 8), a2);
  if ( !result )
  {
    v6 = *(_DWORD *)(v3 + 48);
    if ( !v6 )
      return 0;
    result = xmlGetDtdAttrDesc(v6, *(char **)(a1 + 8), a2);
    if ( !result )
      return 0;
  }
  if ( !*(_DWORD *)(result + 48) )
    return 0;
  return result;
}

//----- (0041A5F2) --------------------------------------------------------
int __cdecl xmlHasNsProp(int a1, char *a2, char *a3)
{
  return sub_41A331(a1, a2, a3, 1);
}

//----- (0041A609) --------------------------------------------------------
_BYTE *__cdecl xmlGetProp(int a1, char *a2)
{
  int v2; // eax
  int v3; // eax
  int v4; // edx
  _BYTE *result; // eax
  _BYTE *v6; // ecx

  result = (_BYTE *)xmlHasProp(a1, a2);
  if ( result )
  {
    v6 = result;
    v2 = *((_DWORD *)result + 1);
    if ( v2 == 2 )
    {
      v3 = *((_DWORD *)v6 + 3);
      if ( !v3 )
        return xmlStrdup(byte_47627C);
      if ( !*(_DWORD *)(v3 + 24) )
      {
        v4 = *(_DWORD *)(v3 + 4);
        if ( v4 == 3 || v4 == 4 )
          return xmlStrdup(*(_BYTE **)(v3 + 40));
      }
      result = xmlNodeListGetString(*((_DWORD **)v6 + 8), v3, 1);
      if ( !result )
        return xmlStrdup(byte_47627C);
    }
    else if ( v2 == 16 )
    {
      return xmlStrdup(*((_BYTE **)v6 + 12));
    }
    else
    {
      return 0;
    }
  }
  return result;
}
// 41A523: conditional instruction was optimized away because eax.4!=0

//----- (0041A624) --------------------------------------------------------
_BYTE *__cdecl xmlGetNoNsProp(int a1, char *a2)
{
  int v2; // eax
  int v3; // eax
  int v4; // edx
  _BYTE *result; // eax
  _BYTE *v6; // ecx

  result = (_BYTE *)sub_41A331(a1, a2, 0, 1);
  if ( result )
  {
    v6 = result;
    v2 = *((_DWORD *)result + 1);
    if ( v2 == 2 )
    {
      v3 = *((_DWORD *)v6 + 3);
      if ( !v3 )
        return xmlStrdup(byte_47627C);
      if ( !*(_DWORD *)(v3 + 24) )
      {
        v4 = *(_DWORD *)(v3 + 4);
        if ( v4 == 3 || v4 == 4 )
          return xmlStrdup(*(_BYTE **)(v3 + 40));
      }
      result = xmlNodeListGetString(*((_DWORD **)v6 + 8), v3, 1);
      if ( !result )
        return xmlStrdup(byte_47627C);
    }
    else if ( v2 == 16 )
    {
      return xmlStrdup(*((_BYTE **)v6 + 12));
    }
    else
    {
      return 0;
    }
  }
  return result;
}
// 41A523: conditional instruction was optimized away because eax.4!=0

//----- (0041A644) --------------------------------------------------------
_BYTE *__cdecl xmlGetNsProp(int a1, char *a2, char *a3)
{
  int v3; // eax
  int v4; // eax
  int v5; // edx
  _BYTE *result; // eax
  _BYTE *v7; // ecx

  result = (_BYTE *)sub_41A331(a1, a2, a3, 1);
  if ( result )
  {
    v7 = result;
    v3 = *((_DWORD *)result + 1);
    if ( v3 == 2 )
    {
      v4 = *((_DWORD *)v7 + 3);
      if ( !v4 )
        return xmlStrdup(byte_47627C);
      if ( !*(_DWORD *)(v4 + 24) )
      {
        v5 = *(_DWORD *)(v4 + 4);
        if ( v5 == 3 || v5 == 4 )
          return xmlStrdup(*(_BYTE **)(v4 + 40));
      }
      result = xmlNodeListGetString(*((_DWORD **)v7 + 8), v4, 1);
      if ( !result )
        return xmlStrdup(byte_47627C);
    }
    else if ( v3 == 16 )
    {
      return xmlStrdup(*((_BYTE **)v7 + 12));
    }
    else
    {
      return 0;
    }
  }
  return result;
}
// 41A523: conditional instruction was optimized away because eax.4!=0

//----- (0041A666) --------------------------------------------------------
int __cdecl xmlUnsetProp(int a1, char *a2)
{
  int v2; // eax
  _DWORD *v3; // esi

  v2 = sub_41A331(a1, a2, 0, 0);
  v3 = (_DWORD *)v2;
  if ( !v2 )
    return -1;
  xmlUnlinkNode(v2);
  xmlFreeProp(v3);
  return 0;
}

//----- (0041A698) --------------------------------------------------------
int __cdecl xmlUnsetNsProp(int a1, int a2, char *a3)
{
  char *v3; // eax
  int v4; // eax
  _DWORD *v5; // esi

  if ( a2 )
    v3 = *(char **)(a2 + 8);
  else
    v3 = 0;
  v4 = sub_41A331(a1, a3, v3, 0);
  v5 = (_DWORD *)v4;
  if ( !v4 )
    return -1;
  xmlUnlinkNode(v4);
  xmlFreeProp(v5);
  return 0;
}

//----- (0041A6D8) --------------------------------------------------------
_DWORD *__cdecl xmlSetProp(int Size, char *Src, char *a3)
{
  _DWORD *v3; // esi
  char *v4; // edi
  _DWORD *v5; // ebx
  char *Block; // [esp+8h] [ebp-4h]

  v3 = (_DWORD *)Size;
  if ( !Size || !Src || *(_DWORD *)(Size + 4) != 1 )
    return 0;
  Block = (char *)xmlSplitQName3(Src, &Size);
  if ( !Block )
    return xmlSetNsProp((int)v3, 0, Src, a3);
  v4 = xmlStrndup(Src, Size);
  v5 = xmlSearchNs(v3[8], v3, v4);
  if ( v4 )
    ((void (__cdecl *)(char *))xmlFree)(v4);
  if ( v5 )
    return xmlSetNsProp((int)v3, (int)v5, Block, a3);
  else
    return xmlSetNsProp((int)v3, 0, Src, a3);
}
// 496494: invalid function type has been ignored

//----- (0041A756) --------------------------------------------------------
_DWORD *__cdecl xmlSetNsProp(int a1, int a2, char *Block, char *Src)
{
  char *v4; // eax
  int v6; // eax
  int v7; // esi
  _DWORD *v8; // eax

  if ( a2 )
  {
    v4 = *(char **)(a2 + 8);
    if ( !v4 )
      return 0;
  }
  else
  {
    v4 = 0;
  }
  v6 = sub_41A331(a1, Block, v4, 0);
  v7 = v6;
  if ( !v6 )
    return sub_416DFC((_DWORD *)a1, a2, Block, Src, 0);
  if ( *(_DWORD *)(v6 + 40) == 2 )
  {
    xmlRemoveID(*(_DWORD **)(a1 + 32), v6);
    *(_DWORD *)(v7 + 40) = 2;
  }
  if ( *(_DWORD *)(v7 + 12) )
    xmlFreeNodeList(*(_DWORD **)(v7 + 12));
  *(_DWORD *)(v7 + 12) = 0;
  *(_DWORD *)(v7 + 16) = 0;
  *(_DWORD *)(v7 + 36) = a2;
  if ( Src )
  {
    if ( !xmlCheckUTF8(Src) )
    {
      sub_414F02(1303, *(int (__cdecl **)(int, char *, char))(a1 + 32), 0);
      if ( *(_DWORD *)(a1 + 32) )
        *(_DWORD *)(*(_DWORD *)(a1 + 32) + 60) = xmlStrdup("ISO-8859-1");
    }
    v8 = xmlNewDocText(*(_DWORD *)(a1 + 32), Src);
    *(_DWORD *)(v7 + 12) = v8;
    *(_DWORD *)(v7 + 16) = 0;
    while ( v8 )
    {
      v8[5] = v7;
      if ( !v8[6] )
        *(_DWORD *)(v7 + 16) = v8;
      v8 = (_DWORD *)v8[6];
    }
  }
  if ( *(_DWORD *)(v7 + 40) == 2 )
    xmlAddID(0, *(_DWORD *)(a1 + 32), (unsigned __int8 *)Src, v7);
  return (_DWORD *)v7;
}

//----- (0041A856) --------------------------------------------------------
BOOL __cdecl xmlNodeIsText(int a1)
{
  BOOL result; // eax

  result = a1;
  if ( a1 )
    return *(_DWORD *)(a1 + 4) == 3;
  return result;
}

//----- (0041A86B) --------------------------------------------------------
int __cdecl xmlIsBlankNode(int a1)
{
  int v2; // ecx
  unsigned __int8 *v3; // ecx
  unsigned __int8 v4; // al

  if ( !a1 )
    return 0;
  v2 = *(_DWORD *)(a1 + 4);
  if ( v2 != 3 && v2 != 4 )
    return 0;
  v3 = *(unsigned __int8 **)(a1 + 40);
  if ( v3 )
  {
    while ( 1 )
    {
      v4 = *v3;
      if ( !*v3 )
        break;
      if ( v4 != 32 && (v4 < 9u || v4 > 0xAu) && v4 != 13 )
        return 0;
      ++v3;
    }
  }
  return 1;
}

//----- (0041A8A7) --------------------------------------------------------
int __cdecl xmlTextConcat(_DWORD *a1, _BYTE *Src, signed int Size)
{
  int v4; // eax
  _BYTE *v5; // edi
  int v6; // eax
  int v7; // eax
  char *v8; // eax

  if ( !a1 )
    return -1;
  v4 = a1[1];
  if ( v4 != 3 && v4 != 4 && v4 != 8 && v4 != 7 )
    return -1;
  v5 = (_BYTE *)a1[10];
  if ( v5 == (_BYTE *)(a1 + 11) || (v6 = a1[8]) != 0 && (v7 = *(_DWORD *)(v6 + 80)) != 0 && xmlDictOwns(v7, a1[10]) )
    v8 = xmlStrncatNew(v5, Src, Size);
  else
    v8 = xmlStrncat(v5, Src, Size);
  a1[11] = 0;
  a1[10] = v8;
  return (a1[10] != 0) - 1;
}

//----- (0041A926) --------------------------------------------------------
_DWORD *xmlBufferCreate()
{
  _DWORD *v0; // eax
  _DWORD *v1; // esi
  _BYTE *v3; // eax
  size_t v4; // [esp-4h] [ebp-8h]

  v0 = (_DWORD *)xmlMalloc(20);
  v1 = v0;
  if ( !v0 )
  {
    sub_43279D("creating buffer");
    return 0;
  }
  v0[1] = 0;
  v0[2] = xmlDefaultBufferSize;
  v4 = v0[2];
  v0[3] = xmlBufferAllocScheme;
  v3 = (_BYTE *)xmlMallocAtomic(v4);
  *v1 = v3;
  if ( !v3 )
  {
    sub_43279D("creating buffer");
    ((void (__cdecl *)(_DWORD *))xmlFree)(v1);
    return 0;
  }
  *v3 = 0;
  v1[4] = 0;
  return v1;
}
// 496494: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 49B2BC: using guessed type int (__cdecl *xmlMallocAtomic)(size_t Size);
// 4A4B7C: using guessed type int xmlBufferAllocScheme;
// 4A4B84: using guessed type int xmlDefaultBufferSize;

//----- (0041A988) --------------------------------------------------------
_DWORD *__cdecl xmlBufferCreateSize(int a1)
{
  int v1; // eax
  _DWORD *v2; // esi
  size_t v4; // eax
  _BYTE *v5; // eax

  v1 = xmlMalloc(20);
  v2 = (_DWORD *)v1;
  if ( !v1 )
  {
    sub_43279D("creating buffer");
    return 0;
  }
  *(_DWORD *)(v1 + 4) = 0;
  *(_DWORD *)(v1 + 12) = xmlBufferAllocScheme;
  v4 = a1 != 0 ? a1 + 2 : 0;
  v2[2] = v4;
  if ( v4 )
  {
    v5 = (_BYTE *)xmlMallocAtomic(v4);
    *v2 = v5;
    if ( !v5 )
    {
      sub_43279D("creating buffer");
      ((void (__cdecl *)(_DWORD *))xmlFree)(v2);
      return 0;
    }
    *v5 = 0;
  }
  else
  {
    *v2 = 0;
  }
  v2[4] = 0;
  return v2;
}
// 496494: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 49B2BC: using guessed type int (__cdecl *xmlMallocAtomic)(size_t Size);
// 4A4B7C: using guessed type int xmlBufferAllocScheme;

//----- (0041A9F7) --------------------------------------------------------
int __cdecl xmlBufferDetach(int *a1)
{
  int result; // eax

  if ( !a1 || a1[3] == 2 )
    return 0;
  result = *a1;
  *a1 = 0;
  a1[2] = 0;
  a1[1] = 0;
  return result;
}

//----- (0041AA15) --------------------------------------------------------
_DWORD *__cdecl xmlBufferCreateStatic(int a1, int a2)
{
  _DWORD *result; // eax

  if ( !a1 || !a2 )
    return 0;
  result = (_DWORD *)xmlMalloc(20);
  if ( !result )
  {
    sub_43279D("creating buffer");
    return 0;
  }
  result[1] = a2;
  result[2] = a2;
  result[3] = 2;
  *result = a1;
  return result;
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (0041AA55) --------------------------------------------------------
void __cdecl xmlBufferSetAllocationScheme(int a1, unsigned int a2)
{
  int v2; // eax

  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 12);
    if ( v2 != 2 && v2 != 3 && (a2 < 2 || a2 == 4 || a2 == 2) )
      *(_DWORD *)(a1 + 12) = a2;
  }
}

//----- (0041AA85) --------------------------------------------------------
void __cdecl xmlBufferFree(int *Block)
{
  int v1; // ecx
  int v2; // eax

  if ( Block )
  {
    v1 = Block[3];
    if ( v1 == 3 && (v2 = Block[4]) != 0 || (v2 = *Block) != 0 && v1 != 2 )
      ((void (__cdecl *)(int))xmlFree)(v2);
    ((void (__cdecl *)(int *))xmlFree)(Block);
  }
}
// 496494: invalid function type has been ignored

//----- (0041AABA) --------------------------------------------------------
int __cdecl xmlBufferEmpty(int a1)
{
  int result; // eax
  _BYTE *v2; // ecx
  int v3; // edx
  _BYTE *v4; // edx

  result = a1;
  if ( a1 )
  {
    v2 = *(_BYTE **)a1;
    if ( *(_DWORD *)a1 )
    {
      v3 = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 4) = 0;
      if ( v3 == 2 )
      {
        *(_DWORD *)a1 = byte_47627C;
      }
      else if ( v3 == 3 && (v4 = *(_BYTE **)(a1 + 16)) != 0 )
      {
        *(_DWORD *)(a1 + 8) += v2 - v4;
        *(_DWORD *)a1 = v4;
        *v4 = 0;
      }
      else
      {
        *v2 = 0;
      }
    }
  }
  return result;
}

//----- (0041AAF6) --------------------------------------------------------
int __cdecl xmlBufferShrink(int a1, unsigned int a2)
{
  unsigned int v3; // edx
  int v4; // eax
  size_t v5; // edx
  _BYTE *v6; // ecx
  _BYTE *v7; // eax
  int v8; // edi
  int v9; // eax
  int v10; // ecx

  if ( !a1 )
    return -1;
  if ( !a2 )
    return 0;
  v3 = *(_DWORD *)(a1 + 4);
  if ( a2 > v3 )
    return -1;
  v4 = *(_DWORD *)(a1 + 12);
  v5 = v3 - a2;
  *(_DWORD *)(a1 + 4) = v5;
  if ( v4 == 2 || v4 == 3 && *(_DWORD *)(a1 + 16) )
  {
    *(_DWORD *)a1 += a2;
    *(_DWORD *)(a1 + 8) -= a2;
    v6 = *(_BYTE **)a1;
    if ( v4 == 3 )
    {
      v7 = *(_BYTE **)(a1 + 16);
      if ( v7 )
      {
        v8 = v6 - v7;
        if ( (unsigned int)(v6 - v7) >= *(_DWORD *)(a1 + 8) )
        {
          memcpy_0(v7, v6, v5);
          v9 = *(_DWORD *)(a1 + 16);
          v10 = *(_DWORD *)(a1 + 4);
          *(_DWORD *)a1 = v9;
          *(_BYTE *)(v9 + v10) = 0;
          *(_DWORD *)(a1 + 8) += v8;
        }
      }
    }
  }
  else
  {
    memcpy_0(*(void **)a1, (const void *)(*(_DWORD *)a1 + a2), v5);
    *(_BYTE *)(*(_DWORD *)(a1 + 4) + *(_DWORD *)a1) = 0;
  }
  return a2;
}

//----- (0041AB8D) --------------------------------------------------------
int __cdecl xmlBufferGrow(int a1, unsigned int a2)
{
  int result; // eax
  int v3; // edx
  unsigned int v4; // ebx
  unsigned int v5; // eax
  SIZE_T v6; // ebx
  void *v7; // eax
  int v8; // edi
  int v9; // eax
  int v10; // eax

  if ( !a1 )
    return -1;
  v3 = *(_DWORD *)(a1 + 12);
  if ( v3 == 2 )
    return 0;
  v4 = *(_DWORD *)(a1 + 4) + a2;
  v5 = *(_DWORD *)(a1 + 8);
  if ( v4 < v5 )
    return 0;
  if ( v5 <= a2 )
    v6 = v4 + 100;
  else
    v6 = 2 * v5;
  if ( v3 != 3 || (v7 = *(void **)(a1 + 16)) == 0 )
  {
    v10 = xmlRealloc(*(LPVOID *)a1, v6);
    if ( v10 )
      goto LABEL_14;
LABEL_17:
    sub_43279D("growing buffer");
    return -1;
  }
  v8 = *(_DWORD *)a1 - (_DWORD)v7;
  v9 = xmlRealloc(v7, v8 + v6);
  if ( !v9 )
    goto LABEL_17;
  *(_DWORD *)(a1 + 16) = v9;
  v10 = v8 + v9;
LABEL_14:
  *(_DWORD *)a1 = v10;
  result = v6 - *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a1 + 8) = v6;
  return result;
}
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);

//----- (0041AC1D) --------------------------------------------------------
size_t __cdecl xmlBufferDump(FILE *Stream, int a2)
{
  FILE *v3; // eax

  if ( !a2 || !*(_DWORD *)a2 )
    return 0;
  v3 = Stream;
  if ( !Stream )
    v3 = (FILE *)(sub_44F01A() + 8);
  return fwrite(*(const void **)a2, 1u, *(_DWORD *)(a2 + 4), v3);
}

//----- (0041AC51) --------------------------------------------------------
int __cdecl xmlBufferContent(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
    return *(_DWORD *)a1;
  return result;
}

//----- (0041AC5D) --------------------------------------------------------
int __cdecl xmlBufferLength(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
    return *(_DWORD *)(a1 + 4);
  return result;
}

//----- (0041AC6A) --------------------------------------------------------
int __cdecl xmlBufferResize(_DWORD *a1, size_t Size)
{
  int v3; // edi
  size_t v4; // edx
  size_t i; // ebx
  void *v6; // eax
  unsigned int v7; // edi
  int v8; // eax
  int v9; // ecx
  int v10; // eax
  _BYTE *v11; // edi
  int v12; // eax
  _BYTE *v13; // eax

  if ( !a1 )
    return 0;
  v3 = a1[3];
  if ( v3 == 2 )
    return 0;
  v4 = a1[2];
  if ( Size < v4 )
    return 1;
  if ( v3 )
  {
    if ( v3 == 1 )
      goto LABEL_18;
    if ( v3 != 3 )
    {
      if ( v3 == 4 )
      {
        if ( a1[1] >= 0x1000u )
        {
          for ( i = 2 * v4; Size > i; i *= 2 )
          {
            if ( i > 0x7FFFFFFF )
              goto LABEL_41;
          }
        }
        else
        {
          i = Size;
        }
        goto LABEL_24;
      }
LABEL_18:
      i = Size + 10;
      goto LABEL_24;
    }
  }
  i = 2 * v4;
  if ( !v4 )
    i = Size + 10;
  while ( Size > i )
  {
    if ( i > 0x7FFFFFFF )
      goto LABEL_41;
    i *= 2;
  }
LABEL_24:
  if ( v3 != 3 || (v6 = (void *)a1[4]) == 0 )
  {
    if ( *a1 )
    {
      if ( v4 - a1[1] >= 0x64 )
      {
        v13 = (_BYTE *)xmlMallocAtomic(i);
        v11 = v13;
        if ( !v13 )
          goto LABEL_41;
        memcpy(v13, (const void *)*a1, a1[1]);
        ((void (__cdecl *)(_DWORD))xmlFree)(*a1);
        v11[a1[1]] = 0;
        goto LABEL_40;
      }
      v12 = xmlRealloc((LPVOID)*a1, i);
    }
    else
    {
      v12 = xmlMallocAtomic(i);
    }
    v11 = (_BYTE *)v12;
LABEL_40:
    if ( v11 )
      goto LABEL_30;
    goto LABEL_41;
  }
  v7 = *a1 - (_DWORD)v6;
  if ( v7 <= i )
  {
    v10 = xmlRealloc(v6, v7 + i);
    if ( v10 )
    {
      a1[4] = v10;
      v11 = (_BYTE *)(v10 + v7);
LABEL_30:
      *a1 = v11;
      goto LABEL_31;
    }
LABEL_41:
    sub_43279D("growing buffer");
    return 0;
  }
  memcpy_0(v6, (const void *)*a1, a1[1]);
  v8 = a1[4];
  v9 = a1[1];
  *a1 = v8;
  *(_BYTE *)(v8 + v9) = 0;
  a1[2] += v7;
LABEL_31:
  a1[2] = i;
  return 1;
}
// 496494: invalid function type has been ignored
// 49B2BC: using guessed type int (__cdecl *xmlMallocAtomic)(size_t Size);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);

//----- (0041ADAC) --------------------------------------------------------
int __cdecl xmlBufferAdd(int *a1, _BYTE *Src, int a3)
{
  int v3; // edi
  bool v5; // zf
  int v6; // ecx

  if ( !Src )
    return -1;
  if ( !a1 )
    return -1;
  if ( a1[3] == 2 )
    return -1;
  v3 = a3;
  if ( a3 < -1 )
    return -1;
  if ( !a3 )
    return 0;
  if ( a3 >= 0 )
  {
    v5 = a3 == 0;
  }
  else
  {
    v3 = xmlStrlen(Src);
    v5 = v3 == 0;
    if ( v3 < 0 )
      return -1;
  }
  if ( v5 )
    return 0;
  if ( a1[1] + v3 + 2 <= (unsigned int)a1[2] || xmlBufferResize(a1, a1[1] + v3 + 2) )
  {
    memcpy_0((void *)(a1[1] + *a1), Src, v3);
    v6 = *a1;
    a1[1] += v3;
    *(_BYTE *)(a1[1] + v6) = 0;
    return 0;
  }
  sub_43279D("growing buffer");
  return 2;
}

//----- (0041AE39) --------------------------------------------------------
int __cdecl xmlBufferAddHead(const void **a1, _BYTE *Src, signed int Size)
{
  int result; // eax
  const void *v4; // edx
  int v5; // edi
  _BYTE *v6; // ecx
  char *v7; // eax
  _BYTE *v8; // ecx

  if ( !a1 )
    return -1;
  v4 = a1[3];
  if ( v4 == (const void *)2 )
    return -1;
  result = -1;
  if ( Src )
  {
    v5 = Size;
    if ( Size >= -1 )
    {
      if ( Size )
      {
        if ( Size < 0 )
          v5 = xmlStrlen(Src);
        if ( v5 <= 0 )
          return -1;
        if ( v4 == (const void *)3 && (v6 = a1[4]) != 0 && (v7 = (char *)*a1, (_BYTE *)*a1 - v6 > (unsigned int)v5) )
        {
          *a1 = &v7[-v5];
          memcpy_0(&v7[-v5], Src, v5);
          a1[1] = (char *)a1[1] + v5;
          a1[2] = (char *)a1[2] + v5;
        }
        else
        {
          if ( (char *)a1[1] + v5 + 2 > a1[2] && !xmlBufferResize(a1, (size_t)a1[1] + v5 + 2) )
          {
            sub_43279D("growing buffer");
            return 2;
          }
          memcpy_0((char *)*a1 + v5, *a1, (size_t)a1[1]);
          memcpy_0((void *)*a1, Src, v5);
          v8 = *a1;
          a1[1] = (char *)a1[1] + v5;
          v8[(_DWORD)a1[1]] = 0;
        }
      }
      return 0;
    }
  }
  return result;
}
// 41AE8B: variable 'v4' is possibly undefined

//----- (0041AF0A) --------------------------------------------------------
int __cdecl xmlBufferCat(int *a1, _BYTE *Src)
{
  if ( a1 && a1[3] != 2 && Src )
    return xmlBufferAdd(a1, Src, -1);
  else
    return -1;
}

//----- (0041AF33) --------------------------------------------------------
int __cdecl xmlBufferCCat(_DWORD *a1, _BYTE *a2)
{
  _BYTE *v3; // edi

  if ( !a1 || a1[3] == 2 )
    return -1;
  v3 = a2;
  if ( !a2 )
    return -1;
  while ( 1 )
  {
    if ( !*v3 )
    {
      *(_BYTE *)(a1[1] + *a1) = 0;
      return 0;
    }
    if ( (unsigned int)(a1[1] + 10) >= a1[2] && !xmlBufferResize(a1, a1[1] + 10) )
      break;
    *(_BYTE *)(a1[1] + *a1) = *v3;
    ++a1[1];
    ++v3;
  }
  sub_43279D("growing buffer");
  return 2;
}

//----- (0041AF9E) --------------------------------------------------------
int *__cdecl xmlBufferWriteCHAR(int *a1, _BYTE *Src)
{
  int *result; // eax

  result = a1;
  if ( a1 )
  {
    if ( a1[3] != 2 )
      return (int *)xmlBufferCat(a1, Src);
  }
  return result;
}

//----- (0041AFB9) --------------------------------------------------------
int __cdecl xmlBufferWriteChar(_DWORD *a1, _BYTE *a2)
{
  int result; // eax

  result = (int)a1;
  if ( a1 )
  {
    if ( a1[3] != 2 )
      return xmlBufferCCat(a1, a2);
  }
  return result;
}

//----- (0041AFD4) --------------------------------------------------------
void __cdecl xmlBufferWriteQuotedString(int *a1, _BYTE *Src)
{
  _BYTE *v2; // esi
  _BYTE *v3; // eax
  char *v4; // edi

  if ( !a1 || a1[3] == 2 )
    return;
  v2 = Src;
  if ( !xmlStrchr(Src, 34) )
  {
    v4 = "\"";
    goto LABEL_17;
  }
  if ( !xmlStrchr(Src, 39) )
  {
    v4 = "'";
LABEL_17:
    xmlBufferCCat(a1, v4);
    xmlBufferCat(a1, Src);
    xmlBufferCCat(a1, v4);
    return;
  }
  xmlBufferCCat(a1, "\"");
  v3 = Src;
  if ( *Src )
  {
    do
    {
      if ( *v2 == 34 )
      {
        if ( v3 != v2 )
          xmlBufferAdd(a1, v3, v2 - v3);
        xmlBufferAdd(a1, "&quot;", 6);
        v3 = ++v2;
      }
      else
      {
        ++v2;
      }
    }
    while ( *v2 );
    if ( v3 != v2 )
      xmlBufferAdd(a1, v3, v2 - v3);
  }
  xmlBufferCCat(a1, "\"");
}

//----- (0041B099) --------------------------------------------------------
int __cdecl xmlGetDocCompressMode(int a1)
{
  if ( a1 )
    return *(_DWORD *)(a1 + 36);
  else
    return -1;
}

//----- (0041B0A9) --------------------------------------------------------
int __cdecl xmlSetDocCompressMode(int a1, int a2)
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    if ( a2 >= 0 )
    {
      if ( a2 <= 9 )
        *(_DWORD *)(a1 + 36) = a2;
      else
        *(_DWORD *)(a1 + 36) = 9;
    }
    else
    {
      *(_DWORD *)(a1 + 36) = 0;
    }
  }
  return result;
}

//----- (0041B0CD) --------------------------------------------------------
int xmlGetCompressMode()
{
  return dword_4A9C0C;
}
// 4A9C0C: using guessed type int dword_4A9C0C;

//----- (0041B0D3) --------------------------------------------------------
int __cdecl xmlSetCompressMode(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 >= 0 )
  {
    dword_4A9C0C = 9;
    if ( a1 <= 9 )
      dword_4A9C0C = a1;
  }
  else
  {
    dword_4A9C0C = 0;
  }
  return result;
}
// 4A9C0C: using guessed type int dword_4A9C0C;

//----- (0041B0F6) --------------------------------------------------------
int __usercall sub_41B0F6@<eax>(int a1@<edi>)
{
  _DWORD *v1; // esi
  _DWORD *v2; // eax
  _DWORD *v3; // esi
  _DWORD *v4; // eax
  int result; // eax

  if ( a1 )
  {
    v1 = *(_DWORD **)(a1 + 8);
    while ( v1 )
    {
      v2 = v1;
      v1 = (_DWORD *)*v1;
      ((void (__cdecl *)(_DWORD *))xmlFree)(v2);
    }
    v3 = *(_DWORD **)a1;
    while ( v3 )
    {
      v4 = v3;
      v3 = (_DWORD *)*v3;
      ((void (__cdecl *)(_DWORD *))xmlFree)(v4);
    }
    return ((int (__cdecl *)(int))xmlFree)(a1);
  }
  return result;
}
// 496494: invalid function type has been ignored

//----- (0041B12E) --------------------------------------------------------
_DWORD *__usercall sub_41B12E@<eax>(_DWORD **a1@<ebx>, int a2, int a3, int a4, int a5)
{
  _DWORD *v6; // esi
  _DWORD *v7; // edx

  if ( !a1 || a2 != -1 && a2 )
    return 0;
  v6 = *a1;
  if ( !*a1 )
  {
    v6 = (_DWORD *)xmlMalloc(12);
    if ( !v6 )
    {
      sub_43279D("allocating namespace map");
      return 0;
    }
    *v6 = 0;
    v6[1] = 0;
    v6[2] = 0;
    *a1 = v6;
  }
  v7 = (_DWORD *)v6[2];
  if ( v7 )
  {
    v6[2] = *v7;
  }
  else
  {
    v7 = (_DWORD *)xmlMalloc(24);
    if ( !v7 )
    {
      sub_43279D("allocating namespace map item");
      return 0;
    }
  }
  memset(v7, 0, 0x18u);
  if ( !*v6 )
  {
    v6[1] = v7;
LABEL_19:
    *v6 = v7;
    goto LABEL_20;
  }
  if ( a2 != -1 )
  {
    *(_DWORD *)(*v6 + 4) = v7;
    *v7 = *v6;
    goto LABEL_19;
  }
  v7[1] = v6[1];
  *(_DWORD *)v6[1] = v7;
  v6[1] = v7;
LABEL_20:
  v7[4] = -1;
  v7[2] = a3;
  v7[3] = a4;
  v7[5] = a5;
  return v7;
}
// 41B1C6: conditional instruction was optimized away because %arg_0.4==0
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (0041B1EE) --------------------------------------------------------
_DWORD *__usercall sub_41B1EE@<eax>(_DWORD *result@<eax>, char *a2, char *a3)
{
  _DWORD *v3; // esi
  char *v4; // eax
  _DWORD *v5; // eax

  if ( result )
  {
    v3 = sub_419BDE((int)result);
    if ( v3 )
    {
      while ( 1 )
      {
        v5 = (_DWORD *)*v3;
        if ( !*v3 )
          break;
        v3 = (_DWORD *)*v3;
        if ( !v5 )
          return 0;
        v4 = (char *)v5[3];
        if ( (v4 == a3 || xmlStrEqual(v4, a3)) && xmlStrEqual((char *)v3[2], a2) )
          return v3;
      }
      result = xmlNewNs(0, a2, a3);
      *v3 = result;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (0041B258) --------------------------------------------------------
_DWORD *xmlDOMWrapNewCtxt()
{
  _DWORD *result; // eax

  result = (_DWORD *)xmlMalloc(16);
  if ( result )
  {
    *result = 0;
    result[1] = 0;
    result[2] = 0;
    result[3] = 0;
  }
  else
  {
    sub_43279D("allocating DOM-wrapper context");
    return 0;
  }
  return result;
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (0041B282) --------------------------------------------------------
int __cdecl xmlDOMWrapFreeCtxt(_DWORD *Block)
{
  int v1; // edi
  int result; // eax

  if ( Block )
  {
    v1 = Block[2];
    if ( v1 )
      sub_41B0F6(v1);
    return ((int (__cdecl *)(_DWORD *))xmlFree)(Block);
  }
  return result;
}
// 496494: invalid function type has been ignored

//----- (0041B2A3) --------------------------------------------------------
int __usercall sub_41B2A3@<eax>(_DWORD *a1@<eax>, _DWORD **a2)
{
  _DWORD **v2; // ebx
  _DWORD *v3; // esi
  _DWORD *v4; // edi
  _DWORD *v5; // eax
  _DWORD *v6; // esi
  char *v7; // ebx
  _DWORD *v8; // eax
  int v10; // [esp+Ch] [ebp-8h]
  _DWORD *v11; // [esp+10h] [ebp-4h]

  v2 = a2;
  v3 = a1;
  if ( !a2 || *a2 )
    return -1;
  v11 = a1;
  if ( a1 )
  {
    while ( v3 != (_DWORD *)v3[8] )
    {
      if ( v3[1] == 1 && v3[12] )
      {
        v4 = (_DWORD *)v3[12];
        do
        {
          v5 = *v2;
          v10 = 0;
          if ( *v2 && *v5 )
          {
            v6 = (_DWORD *)*v5;
            if ( *v5 )
            {
              v7 = (char *)v4[3];
              while ( v7 != *(char **)(v6[3] + 12) && !xmlStrEqual(v7, *(char **)(v6[3] + 12)) )
              {
                v6 = (_DWORD *)*v6;
                if ( !v6 )
                  goto LABEL_19;
              }
              v10 = 1;
            }
LABEL_19:
            v3 = v11;
          }
          v2 = a2;
          v8 = sub_41B12E(a2, 0, 0, (int)v4, -1);
          if ( !v8 )
            return -1;
          if ( v10 )
            v8[4] = 0;
          v4 = (_DWORD *)*v4;
        }
        while ( v4 );
      }
      v11 = (_DWORD *)v3[5];
      if ( !v11 )
        return 0;
      v3 = (_DWORD *)v3[5];
    }
  }
  return 0;
}

//----- (0041B36A) --------------------------------------------------------
int __usercall sub_41B36A@<eax>(int *a1@<ebx>, int *a2@<edi>, void **a3@<esi>, int a4, int a5)
{
  void *v5; // ecx
  int v6; // eax
  int v8; // eax
  _DWORD *v9; // ecx
  int v10; // eax
  int v11; // eax

  v5 = *a3;
  if ( *a3 )
  {
    if ( *a2 >= *a1 )
    {
      v10 = 2 * *a1;
      *a1 = v10;
      v11 = xmlRealloc(v5, 8 * v10);
      *a3 = (void *)v11;
      if ( !v11 )
      {
        sub_43279D("realloc ns map item");
        return -1;
      }
    }
  }
  else
  {
    v6 = xmlMalloc(24);
    *a3 = (void *)v6;
    if ( !v6 )
    {
      sub_43279D("alloc ns map item");
      return -1;
    }
    *a2 = 0;
    *a1 = 3;
  }
  v8 = *a2;
  v9 = (char *)*a3 + 8 * *a2;
  *v9 = a4;
  *a2 = v8 + 1;
  v9[1] = a5;
  return 0;
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);

//----- (0041B3D5) --------------------------------------------------------
int __cdecl xmlDOMWrapRemoveNode(int a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // esi
  int v5; // eax
  int v6; // eax
  int v7; // ecx
  int v8; // edx
  int *v9; // ecx
  int *v10; // eax
  _DWORD *v11; // eax
  int v12; // [esp+Ch] [ebp-10h] BYREF
  int v13; // [esp+10h] [ebp-Ch] BYREF
  int *v14; // [esp+14h] [ebp-8h]
  void *Block; // [esp+18h] [ebp-4h] BYREF

  Block = 0;
  v3 = a3;
  if ( !a3 || !a2 || (_DWORD *)a3[8] != a2 )
    return -1;
  if ( !a3[5] )
    return 0;
  v5 = a3[1];
  if ( v5 <= 0 )
    return 1;
  if ( v5 > 2 )
  {
    if ( v5 <= 5 || (unsigned int)(v5 - 7) <= 1 )
    {
      xmlUnlinkNode((int)a3);
      return 0;
    }
    return 1;
  }
  xmlUnlinkNode((int)a3);
  while ( v3[1] != 1 )
  {
    if ( v3[1] != 2 )
      goto LABEL_35;
LABEL_21:
    v6 = v3[9];
    if ( !v6 )
      goto LABEL_31;
    if ( !Block || (v7 = 0, v8 = 0, v13 <= 0) )
    {
LABEL_26:
      v9 = 0;
      if ( !a1 )
      {
        v10 = sub_41B1EE(a2, *(char **)(v6 + 8), *(char **)(v6 + 12));
        v14 = v10;
        if ( !v10 || sub_41B36A(&v12, &v13, &Block, v3[9], (int)v10) == -1 )
          goto LABEL_42;
        v3 = a3;
        v9 = v14;
      }
      v3[9] = v9;
LABEL_31:
      if ( v3[1] != 1 )
        goto LABEL_35;
      v11 = (_DWORD *)v3[11];
      if ( v11 )
        goto LABEL_40;
      goto LABEL_33;
    }
    while ( v6 != *((_DWORD *)Block + v7) )
    {
      ++v8;
      v7 += 2;
      if ( v8 >= v13 )
        goto LABEL_26;
    }
    v3[9] = *((_DWORD *)Block + v7 + 1);
LABEL_33:
    if ( v3[1] != 1 || (v11 = (_DWORD *)v3[3]) == 0 )
    {
LABEL_35:
      while ( v3 )
      {
        if ( v3[6] )
        {
          v11 = (_DWORD *)v3[6];
          goto LABEL_40;
        }
        v3 = (_DWORD *)v3[5];
      }
LABEL_45:
      if ( Block )
        ((void (__cdecl *)(void *))xmlFree)(Block);
      return 0;
    }
LABEL_40:
    a3 = v11;
    if ( !v11 )
      goto LABEL_45;
    v3 = v11;
  }
  if ( a1 || !v3[12] )
    goto LABEL_21;
  v14 = (int *)v3[12];
  while ( sub_41B36A(&v12, &v13, &Block, (int)v14, (int)v14) != -1 )
  {
    v14 = (int *)*v14;
    if ( !v14 )
    {
      v3 = a3;
      goto LABEL_21;
    }
  }
LABEL_42:
  if ( Block )
    ((void (__cdecl *)(void *))xmlFree)(Block);
  return -1;
}
// 496494: invalid function type has been ignored

//----- (0041B56C) --------------------------------------------------------
int __usercall sub_41B56C@<eax>(int a1@<eax>, _DWORD *a2, char *a3, int ***a4)
{
  int **v5; // eax
  _DWORD *v7; // ecx
  int v8; // eax
  int **v9; // ebx
  char *v10; // edi
  _DWORD *v11; // esi
  char *v12; // eax
  int v13; // eax
  _DWORD *v14; // eax
  _DWORD *v15; // [esp+Ch] [ebp-Ch]
  _DWORD *v16; // [esp+10h] [ebp-8h]
  _DWORD *v17; // [esp+14h] [ebp-4h]

  v17 = 0;
  v15 = 0;
  if ( a1 && a3 && a4 )
  {
    *a4 = 0;
    if ( xmlStrEqual(a3, "http://www.w3.org/XML/1998/namespace") )
    {
      v5 = (int **)sub_419BDE(a1);
      *a4 = v5;
      return 2 * (v5 != 0) - 1;
    }
    v16 = a2;
    while ( 1 )
    {
      v7 = v16;
      v8 = v16[1];
      if ( v8 == 1 )
      {
        v9 = (int **)v16[12];
        if ( v9 )
        {
          while ( 1 )
          {
            v10 = (char *)v9[3];
            if ( v10 )
            {
              if ( v17 )
              {
                v11 = (_DWORD *)v17[12];
                while ( 1 )
                {
                  v12 = (char *)v11[3];
                  if ( v12 == v10 || v12 && xmlStrEqual(v12, v10) )
                    break;
                  v11 = (_DWORD *)*v11;
                  if ( !v11 )
                    goto LABEL_16;
                }
              }
              else
              {
LABEL_16:
                if ( a3 == (char *)v9[2] || xmlStrEqual(a3, (char *)v9[2]) )
                {
                  if ( !v15 )
                    goto LABEL_28;
                  v13 = sub_419D93(a2, v17, v10);
                  if ( v13 < 0 )
                    return -1;
                  if ( v13 )
                  {
LABEL_28:
                    *a4 = v9;
                    return 1;
                  }
                }
              }
            }
            v9 = (int **)*v9;
            if ( !v9 )
            {
              v7 = v16;
              v15 = v17;
              v17 = v16;
              break;
            }
          }
        }
      }
      else if ( v8 == 6 || v8 == 17 )
      {
        return 0;
      }
      v14 = (_DWORD *)v7[5];
      v16 = v14;
      if ( !v14 || (_DWORD *)v14[8] == v14 )
        return 0;
    }
  }
  return -1;
}

//----- (0041B68A) --------------------------------------------------------
int __usercall sub_41B68A@<eax>(_DWORD *a1@<eax>, char *a2@<ebx>, int a3)
{
  _DWORD *v3; // edi
  int v5; // eax
  int **i; // esi

  v3 = a1;
  if ( a3 && a1 )
  {
    if ( a2 && *a2 == 120 && a2[1] == 109 && a2[2] == 108 && !a2[3] )
      return 1;
    while ( 1 )
    {
      v5 = v3[1];
      if ( v5 == 1 )
      {
        for ( i = (int **)v3[12]; i; i = (int **)*i )
        {
          if ( a2 == (char *)i[3] || xmlStrEqual(a2, (char *)i[3]) )
            return i[2] != 0;
        }
      }
      else if ( v5 == 6 || v5 == 17 )
      {
        return 0;
      }
      v3 = (_DWORD *)v3[5];
      if ( !v3 || (_DWORD *)v3[8] == v3 )
        return 0;
    }
  }
  return -1;
}

//----- (0041B70C) --------------------------------------------------------
_DWORD *__usercall sub_41B70C@<eax>(const char *a1@<ecx>, int a2@<edi>, int a3, char *a4, int a5)
{
  char *i; // ebx
  int **j; // esi
  _DWORD *v7; // eax
  _DWORD *result; // eax
  _DWORD *v9; // ecx
  int v11; // [esp+10h] [ebp-3Ch]
  char Buffer[52]; // [esp+14h] [ebp-38h] BYREF

  v11 = 0;
  for ( i = (char *)a1; ; i = Buffer )
  {
    for ( j = *(int ***)(a2 + 48); j; j = (int **)*j )
    {
      if ( i == (char *)j[3] || xmlStrEqual(i, (char *)j[3]) )
        goto LABEL_11;
    }
    if ( !a5 )
      break;
    v7 = *(_DWORD **)(a2 + 20);
    if ( !v7 || (_DWORD *)v7[8] == v7 || sub_41B68A(v7, i, a3) != 1 )
      break;
LABEL_11:
    if ( ++v11 > 1000 )
      return 0;
    if ( a1 )
      _snprintf(Buffer, 0x32u, "%.30s_%d", a1, v11);
    else
      _snprintf(Buffer, 0x32u, "ns_%d", v11);
  }
  result = xmlNewNs(0, a4, i);
  if ( !result )
    return 0;
  v9 = *(_DWORD **)(a2 + 48);
  if ( v9 )
  {
    while ( *v9 )
      v9 = (_DWORD *)*v9;
    *v9 = result;
  }
  else
  {
    *(_DWORD *)(a2 + 48) = result;
  }
  return result;
}

//----- (0041B7E6) --------------------------------------------------------
int __cdecl sub_41B7E6(_DWORD *a1, int a2, int a3, _DWORD *a4, _DWORD **a5, int a6, int a7)
{
  int v7; // ecx
  int v8; // ebx
  _DWORD *v9; // eax
  _DWORD *v11; // eax
  _DWORD *v12; // edi
  int v13; // eax
  char *v14; // ecx
  _DWORD *v15; // esi
  _DWORD *v16; // ebx
  _DWORD *v17; // eax
  int v18; // eax
  _DWORD *v19; // edx
  _DWORD *v20; // ebx
  _DWORD *i; // edi
  char *v22; // eax
  _DWORD *v23; // eax

  if ( !a1 )
    return -1;
  v7 = a3;
  if ( !a3 || !a4 || !a5 )
    return -1;
  v8 = *(_DWORD *)(a3 + 12);
  *a4 = 0;
  if ( v8 && *(_BYTE *)v8 == 120 && *(_BYTE *)(v8 + 1) == 109 && *(_BYTE *)(v8 + 2) == 108 && !*(_BYTE *)(v8 + 3) )
  {
    v9 = sub_419BDE((int)a1);
    *a4 = v9;
    return (v9 != 0) - 1;
  }
  v11 = *a5;
  if ( *a5 )
  {
    if ( *v11 )
    {
      v12 = (_DWORD *)*v11;
      if ( *v11 )
      {
        while ( 1 )
        {
          if ( (int)v12[5] >= -1 && v12[4] == -1 )
          {
            v13 = v12[3];
            v14 = *(char **)(v13 + 8);
            if ( v14 )
            {
              if ( *v14
                && (!a7 || *(_DWORD *)(v13 + 12))
                && (v14 == *(char **)(a3 + 8) || xmlStrEqual(v14, *(char **)(a3 + 8))) )
              {
                break;
              }
            }
          }
          v12 = (_DWORD *)*v12;
          if ( !v12 )
          {
            v7 = a3;
            goto LABEL_24;
          }
        }
        v18 = v12[3];
        v12[2] = a3;
        *a4 = v18;
        return 0;
      }
    }
  }
LABEL_24:
  if ( a2 )
  {
    v15 = sub_41B70C((const char *)v8, a2, (int)a1, *(char **)(v7 + 8), 0);
    if ( !v15 )
      return -1;
    v20 = *a5;
    if ( !*a5 )
      goto LABEL_54;
    for ( i = (_DWORD *)*v20; i; i = (_DWORD *)*i )
    {
      if ( i[5] < a6 && i[4] == -1 )
      {
        v22 = *(char **)(a3 + 12);
        if ( v22 == *(char **)(i[3] + 12) || xmlStrEqual(v22, *(char **)(i[3] + 12)) )
        {
          i[4] = a6;
          break;
        }
      }
    }
    if ( !v20 )
    {
LABEL_54:
      v23 = (_DWORD *)xmlMalloc(12);
      v20 = v23;
      if ( !v23 )
        goto LABEL_28;
      *v23 = 0;
      v23[1] = 0;
      v23[2] = 0;
      *a5 = v23;
    }
    v19 = (_DWORD *)v20[2];
    if ( v19 )
    {
      v20[2] = *v19;
    }
    else
    {
      v19 = (_DWORD *)xmlMalloc(24);
      if ( !v19 )
        goto LABEL_39;
    }
    memset(v19, 0, 0x18u);
    if ( *v20 )
    {
      v19[1] = v20[1];
      *(_DWORD *)v20[1] = v19;
    }
    else
    {
      *v20 = v19;
    }
    v20[1] = v19;
    v19[2] = a3;
    v19[5] = a6;
    goto LABEL_63;
  }
  v15 = sub_41B1EE(a1, *(char **)(v7 + 8), (char *)v8);
  if ( !v15 )
    return -1;
  v16 = *a5;
  if ( !*a5 )
  {
    v17 = (_DWORD *)xmlMalloc(12);
    v16 = v17;
    if ( !v17 )
    {
LABEL_28:
      sub_43279D("allocating namespace map");
LABEL_29:
      xmlFreeNs(v15);
      return -1;
    }
    *v17 = 0;
    v17[1] = 0;
    v17[2] = 0;
    *a5 = v17;
  }
  v19 = (_DWORD *)v16[2];
  if ( !v19 )
  {
    v19 = (_DWORD *)xmlMalloc(24);
    if ( v19 )
      goto LABEL_36;
LABEL_39:
    sub_43279D("allocating namespace map item");
    goto LABEL_29;
  }
  v16[2] = *v19;
LABEL_36:
  memset(v19, 0, 0x18u);
  if ( *v16 )
  {
    v19[1] = v16[1];
    *(_DWORD *)v16[1] = v19;
  }
  else
  {
    *v16 = v19;
  }
  v16[1] = v19;
  v19[2] = a3;
  v19[5] = -3;
LABEL_63:
  v19[4] = -1;
  v19[3] = v15;
  *a4 = v15;
  return 0;
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (0041BA48) --------------------------------------------------------
int __cdecl xmlDOMWrapReconcileNamespaces(int a1, _DWORD *a2, char a3)
{
  int v3; // ebx
  _DWORD *v4; // esi
  _DWORD *v5; // ecx
  _DWORD *v6; // eax
  int v7; // ebx
  _DWORD *v8; // eax
  _DWORD *j; // esi
  int v10; // edi
  char *v11; // edi
  int v12; // eax
  _DWORD *v13; // edi
  _DWORD *k; // esi
  _DWORD *v15; // esi
  _DWORD *v16; // edx
  int v17; // eax
  _DWORD *v18; // eax
  int v19; // eax
  _DWORD *m; // eax
  _DWORD *v21; // eax
  _DWORD *v22; // eax
  int v23; // edx
  _DWORD *v24; // eax
  _DWORD *v25; // edi
  _DWORD *n; // eax
  bool v27; // zf
  _DWORD **v28; // esi
  int v29; // edi
  _DWORD *v31; // [esp+8h] [ebp-30h]
  int v32; // [esp+Ch] [ebp-2Ch] BYREF
  int v33; // [esp+10h] [ebp-28h]
  _DWORD *v34; // [esp+14h] [ebp-24h]
  _DWORD *v35; // [esp+18h] [ebp-20h]
  int v36; // [esp+1Ch] [ebp-1Ch]
  int v37; // [esp+20h] [ebp-18h] BYREF
  int v38; // [esp+24h] [ebp-14h]
  void *Block; // [esp+28h] [ebp-10h] BYREF
  int v40; // [esp+2Ch] [ebp-Ch]
  _DWORD *i; // [esp+30h] [ebp-8h] BYREF
  _DWORD *v42; // [esp+34h] [ebp-4h] BYREF
  _DWORD *v43; // [esp+48h] [ebp+10h]
  int v44; // [esp+48h] [ebp+10h]

  v40 = -1;
  v3 = 0;
  v4 = a2;
  v5 = 0;
  v38 = 0;
  v34 = 0;
  v42 = 0;
  v33 = a3 & 1;
  Block = 0;
  v32 = 0;
  v37 = 0;
  if ( !a2 )
    return -1;
  v31 = (_DWORD *)a2[8];
  if ( !v31 || a2[1] != 1 )
    return -1;
  v43 = a2;
  while ( 1 )
  {
    if ( v4[1] == 1 )
    {
      v6 = (_DWORD *)v4[12];
      ++v40;
      v36 = 1;
      v34 = v4;
      if ( v6 )
      {
        v35 = 0;
        v7 = (int)v6;
        for ( i = v6; ; v7 = (int)i )
        {
          if ( !v38 )
          {
            v8 = (_DWORD *)a2[5];
            if ( v8 && (_DWORD *)v8[8] != v8 && sub_41B2A3(v8, &v42) == -1 )
              goto LABEL_113;
            v38 = 1;
          }
          if ( v33 && v42 && *v42 )
          {
            for ( j = (_DWORD *)*v42; j; j = (_DWORD *)*j )
            {
              if ( (int)j[5] >= -1 && j[4] == -1 )
              {
                v10 = j[3];
                if ( *(_DWORD *)(v7 + 12) == *(_DWORD *)(v10 + 12)
                  || xmlStrEqual(*(char **)(v7 + 12), *(char **)(v10 + 12)) )
                {
                  v11 = *(char **)(v10 + 8);
                  if ( *(char **)(v7 + 8) == v11 || xmlStrEqual(*(char **)(v7 + 8), v11) )
                  {
                    if ( sub_41B36A(&v32, &v37, &Block, v7, j[3]) == -1 )
                      goto LABEL_113;
                    v7 = (int)i;
                    if ( v35 )
                      *v35 = *i;
                    else
                      v43[12] = *i;
                    goto LABEL_56;
                  }
                }
              }
            }
          }
          v12 = v43[9];
          if ( v12 && v36 && v12 == v7 )
            v36 = 0;
          v13 = v42;
          if ( v42 && *v42 )
          {
            for ( k = (_DWORD *)*v42; k; k = (_DWORD *)*k )
            {
              if ( (int)k[5] >= -1
                && k[4] == -1
                && (*(_DWORD *)(v7 + 12) == *(_DWORD *)(k[3] + 12)
                 || xmlStrEqual(*(char **)(v7 + 12), *(char **)(k[3] + 12))) )
              {
                k[4] = v40;
              }
            }
          }
          v15 = v13;
          if ( !v13 )
          {
            v15 = (_DWORD *)xmlMalloc(12);
            if ( !v15 )
            {
              sub_43279D("allocating namespace map");
              goto LABEL_113;
            }
            *v15 = 0;
            v15[1] = 0;
            v15[2] = 0;
            v42 = v15;
          }
          v16 = (_DWORD *)v15[2];
          if ( v16 )
          {
            v15[2] = *v16;
          }
          else
          {
            v16 = (_DWORD *)xmlMalloc(24);
            if ( !v16 )
            {
              sub_43279D("allocating namespace map item");
              goto LABEL_113;
            }
          }
          memset(v16, 0, 0x18u);
          if ( *v15 )
          {
            v16[1] = v15[1];
            *(_DWORD *)v15[1] = v16;
          }
          else
          {
            *v15 = v16;
          }
          v17 = v40;
          v15[1] = v16;
          v16[4] = -1;
          v16[2] = v7;
          v16[3] = v7;
          v16[5] = v17;
          v35 = (_DWORD *)v7;
LABEL_56:
          v3 = *(_DWORD *)v7;
          i = (_DWORD *)v3;
          if ( !v3 )
            break;
        }
        v5 = v42;
        v4 = v43;
        if ( !v36 )
          goto LABEL_81;
      }
    }
    else if ( v4[1] != 2 )
    {
      break;
    }
    if ( v4[9] )
    {
      if ( !v38 )
      {
        v18 = (_DWORD *)a2[5];
        if ( v18 && (_DWORD *)v18[8] != v18 )
        {
          if ( sub_41B2A3(v18, &v42) == -1 )
            goto LABEL_113;
          v5 = v42;
        }
        v38 = 1;
      }
      if ( Block )
      {
        v19 = 0;
        v44 = 0;
        if ( v37 > 0 )
        {
          while ( v4[9] != *((_DWORD *)Block + v19) )
          {
            ++v44;
            v19 += 2;
            v3 = 0;
            if ( v44 >= v37 )
              goto LABEL_71;
          }
          v4[9] = *((_DWORD *)Block + v19 + 1);
        }
      }
LABEL_71:
      if ( v5 && *v5 )
      {
        for ( m = (_DWORD *)*v5; m; m = (_DWORD *)*m )
        {
          if ( m[4] == -1 && v4[9] == m[2] )
          {
            v21 = (_DWORD *)m[3];
            goto LABEL_80;
          }
        }
      }
      if ( sub_41B7E6(v31, (int)v34, v4[9], &i, &v42, v40, v4[1] == 2) == -1 )
      {
LABEL_113:
        v3 = -1;
        goto LABEL_114;
      }
      v21 = i;
      v5 = v42;
LABEL_80:
      v4[9] = v21;
    }
LABEL_81:
    if ( v4[1] != 1 )
      break;
    v22 = (_DWORD *)v4[11];
    if ( !v22 )
    {
LABEL_83:
      if ( v4[1] != 1 || !v4[3] )
        break;
      v22 = (_DWORD *)v4[3];
    }
LABEL_109:
    v43 = v22;
    if ( !v22 )
      goto LABEL_114;
    v4 = v22;
  }
  v23 = v40;
  while ( v4 != a2 )
  {
    if ( v4[1] == 1 )
    {
      if ( v5 && *v5 )
      {
        while ( v5[1] )
        {
          v24 = (_DWORD *)v5[1];
          if ( v24[5] < v23 )
            break;
          v25 = (_DWORD *)v24[1];
          v5[1] = v25;
          if ( v25 )
            *v25 = 0;
          else
            *v5 = 0;
          *v24 = v5[2];
          v5[2] = v24;
        }
        for ( n = (_DWORD *)*v5; n; n = (_DWORD *)*n )
        {
          if ( n[4] >= v23 )
            n[4] = -1;
        }
      }
      v40 = --v23;
    }
    if ( v4[6] )
    {
      v22 = (_DWORD *)v4[6];
      goto LABEL_109;
    }
    v27 = v4[1] == 2;
    v4 = (_DWORD *)v4[5];
    if ( v27 )
      goto LABEL_83;
  }
LABEL_114:
  v28 = (_DWORD **)Block;
  if ( Block )
  {
    v29 = v37;
    if ( v37 > 0 )
    {
      do
      {
        xmlFreeNs(*v28);
        v28 += 2;
        --v29;
      }
      while ( v29 );
    }
    ((void (__cdecl *)(void *))xmlFree)(Block);
  }
  if ( v42 )
    sub_41B0F6((int)v42);
  return v3;
}
// 496494: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (0041BE42) --------------------------------------------------------
int __cdecl sub_41BE42(int a1, _DWORD *a2, int a3, _DWORD *a4, _DWORD *a5)
{
  _DWORD *v5; // edx
  int v6; // eax
  _DWORD *v7; // ebx
  _DWORD *v8; // ecx
  int v9; // esi
  int v10; // eax
  char *v11; // edi
  int v12; // eax
  _DWORD *v13; // eax
  unsigned __int8 *v14; // eax
  int v15; // edx
  int v16; // eax
  int v17; // edi
  _DWORD *v18; // eax
  _DWORD *v19; // ebx
  _DWORD *v20; // ebx
  _DWORD *v21; // edx
  int *v22; // eax
  _DWORD *v23; // eax
  int (__cdecl *v24)(int, int, _DWORD, _DWORD); // ecx
  int v25; // eax
  _DWORD *v26; // ebx
  _DWORD *v27; // edx
  int v28; // eax
  char *v29; // ebx
  _DWORD *v30; // eax
  _DWORD *v31; // edi
  int v32; // eax
  int v33; // eax
  int v34; // eax
  _DWORD *DocEntity; // eax
  char *v37; // ebx
  _DWORD *v38; // eax
  _DWORD *v39; // edi
  int v40; // eax
  int v41; // eax
  char *v42; // ebx
  int v43; // eax
  _DWORD *v44; // eax
  unsigned __int8 *v45; // eax
  _DWORD *v46; // eax
  _DWORD *v47; // ebx
  _DWORD *i; // eax
  int v49; // eax
  int v50; // [esp+Ch] [ebp-20h]
  int v51; // [esp+10h] [ebp-1Ch]
  int v52; // [esp+14h] [ebp-18h]
  int v53; // [esp+18h] [ebp-14h]
  BOOL v54; // [esp+1Ch] [ebp-10h]
  int v55; // [esp+20h] [ebp-Ch]
  int *v56; // [esp+24h] [ebp-8h] BYREF
  _DWORD *v57; // [esp+28h] [ebp-4h] BYREF

  v5 = a2;
  v55 = -1;
  v6 = a1;
  v7 = a4;
  v8 = 0;
  v51 = 0;
  v52 = 0;
  v57 = 0;
  v56 = 0;
  if ( !a2 || (v53 = 0, a2[20] != a4[20]) )
    v53 = 1;
  if ( a1 )
  {
    v8 = *(_DWORD **)(a1 + 8);
    v57 = v8;
  }
  v54 = !a5 || a1 && *(_DWORD *)(a1 + 12);
  v9 = a3;
  if ( !a3 )
    goto LABEL_167;
  while ( 1 )
  {
    if ( *(_DWORD **)(v9 + 32) != v5 )
    {
      if ( !*(_DWORD *)(v9 + 24) )
        goto LABEL_32;
      do
        v9 = *(_DWORD *)(v9 + 24);
      while ( *(_DWORD *)(v9 + 4) != 20 && *(_DWORD *)(v9 + 32) != *(_DWORD *)(a3 + 32) && *(_DWORD *)(v9 + 24) );
      if ( *(_DWORD *)(v9 + 32) != *(_DWORD *)(a3 + 32) )
        goto LABEL_32;
    }
    v10 = *(_DWORD *)(v9 + 4);
    *(_DWORD *)(v9 + 32) = v7;
    if ( v10 > 5 )
    {
      if ( v10 == 7 )
      {
        if ( v53 )
        {
          v37 = *(char **)(v9 + 8);
          if ( v37 )
          {
            v38 = (_DWORD *)a4[20];
            if ( v38 )
            {
              v39 = a2;
              *(_DWORD *)(v9 + 8) = xmlDictLookup(v38, v37, -1);
              if ( !a2 || (v40 = a2[20]) == 0 || !xmlDictOwns(v40, (unsigned int)v37) )
                ((void (__cdecl *)(char *))xmlFree)(v37);
            }
            else
            {
              v39 = a2;
              if ( a2 )
              {
                v41 = a2[20];
                if ( v41 )
                {
                  if ( xmlDictOwns(v41, *(_DWORD *)(v9 + 8)) )
                    *(_DWORD *)(v9 + 8) = xmlStrdup(v37);
                }
              }
            }
          }
          else
          {
            v39 = a2;
          }
          v42 = *(char **)(v9 + 40);
          if ( v42 )
          {
            if ( v39 )
            {
              v43 = v39[20];
              if ( v43 )
              {
                if ( xmlDictOwns(v43, *(_DWORD *)(v9 + 40)) )
                {
                  v44 = (_DWORD *)a4[20];
                  if ( v44 )
                    v45 = xmlDictLookup(v44, v42, -1);
                  else
                    v45 = xmlStrdup(v42);
                  *(_DWORD *)(v9 + 40) = v45;
                }
              }
            }
          }
        }
      }
      else if ( v10 != 8 )
      {
        if ( (unsigned int)(v10 - 19) <= 1 )
          return -1;
        goto LABEL_165;
      }
      goto LABEL_142;
    }
    if ( v10 == 5 )
    {
      *(_DWORD *)(v9 + 40) = 0;
      *(_DWORD *)(v9 + 12) = 0;
      *(_DWORD *)(v9 + 16) = 0;
      if ( v7[11] || v7[12] )
      {
        DocEntity = xmlGetDocEntity(v7, *(char **)(v9 + 8));
        if ( DocEntity )
        {
          *(_DWORD *)(v9 + 40) = DocEntity[10];
          *(_DWORD *)(v9 + 12) = DocEntity;
          *(_DWORD *)(v9 + 16) = DocEntity;
        }
      }
      goto LABEL_32;
    }
    if ( v10 != 1 )
      break;
    ++v55;
    v52 = v9;
    if ( *(_DWORD *)(v9 + 48) && (!a1 || !*(_DWORD *)(a1 + 12)) )
    {
      if ( !v54 )
      {
        if ( sub_41B2A3(a5, &v57) == -1 )
          goto LABEL_165;
        v54 = 1;
      }
      v17 = *(_DWORD *)(v9 + 48);
      v56 = (int *)v17;
      if ( v17 )
      {
        while ( 1 )
        {
          v18 = v57;
          if ( v57 )
          {
            if ( *v57 )
            {
              v19 = (_DWORD *)*v57;
              if ( *v57 )
              {
                do
                {
                  if ( (int)v19[5] >= -1
                    && v19[4] == -1
                    && (*(_DWORD *)(v17 + 12) == *(_DWORD *)(v19[3] + 12)
                     || xmlStrEqual(*(char **)(v17 + 12), *(char **)(v19[3] + 12))) )
                  {
                    v19[4] = v55;
                  }
                  v19 = (_DWORD *)*v19;
                }
                while ( v19 );
                v18 = v57;
              }
            }
          }
          v20 = v18;
          if ( !v18 )
          {
            v20 = (_DWORD *)xmlMalloc(12);
            if ( !v20 )
              goto LABEL_164;
            *v20 = 0;
            v20[1] = 0;
            v20[2] = 0;
            v57 = v20;
          }
          v21 = (_DWORD *)v20[2];
          if ( v21 )
          {
            v20[2] = *v21;
          }
          else
          {
            v21 = (_DWORD *)xmlMalloc(24);
            if ( !v21 )
              goto LABEL_174;
          }
          memset(v21, 0, 0x18u);
          if ( *v20 )
          {
            v21[1] = v20[1];
            *(_DWORD *)v20[1] = v21;
          }
          else
          {
            *v20 = v21;
          }
          v22 = v56;
          v20[1] = v21;
          v21[4] = -1;
          v21[2] = v22;
          v21[3] = v22;
          v21[5] = v55;
          v56 = (int *)*v22;
          if ( !v56 )
            break;
          v17 = (int)v56;
        }
      }
    }
LABEL_69:
    if ( *(_DWORD *)(v9 + 36) )
    {
      if ( !v54 )
      {
        if ( sub_41B2A3(a5, &v57) == -1 )
          goto LABEL_165;
        v54 = 1;
      }
      v23 = v57;
      if ( v57 && *v57 )
      {
        while ( 1 )
        {
          v23 = (_DWORD *)*v23;
          if ( !v23 )
            break;
          if ( v23[4] == -1 && *(_DWORD *)(v9 + 36) == v23[2] )
          {
            v28 = v23[3];
            goto LABEL_94;
          }
        }
      }
      if ( a1 && (v24 = *(int (__cdecl **)(int, int, _DWORD, _DWORD))(a1 + 12)) != 0 )
      {
        v25 = v24(a1, v9, *(_DWORD *)(*(_DWORD *)(v9 + 36) + 8), *(_DWORD *)(*(_DWORD *)(v9 + 36) + 12));
        v26 = v57;
        v56 = (int *)v25;
        v50 = *(_DWORD *)(v9 + 36);
        if ( !v57 )
        {
          v26 = (_DWORD *)xmlMalloc(12);
          if ( !v26 )
          {
LABEL_164:
            sub_43279D("allocating namespace map");
            goto LABEL_165;
          }
          *v26 = 0;
          v26[1] = 0;
          v26[2] = 0;
          v57 = v26;
        }
        v27 = (_DWORD *)v26[2];
        if ( v27 )
        {
          v26[2] = *v27;
        }
        else
        {
          v27 = (_DWORD *)xmlMalloc(24);
          if ( !v27 )
          {
LABEL_174:
            sub_43279D("allocating namespace map item");
            goto LABEL_165;
          }
        }
        memset(v27, 0, 0x18u);
        if ( *v26 )
        {
          v27[1] = v26[1];
          *(_DWORD *)v26[1] = v27;
        }
        else
        {
          *v26 = v27;
        }
        v26[1] = v27;
        v27[4] = -1;
        v27[2] = v50;
        v28 = (int)v56;
        v27[3] = v56;
        v27[5] = -4;
      }
      else
      {
        if ( sub_41B7E6(a4, a5 != 0 ? v52 : 0, *(_DWORD *)(v9 + 36), &v56, &v57, v55, *(_DWORD *)(v9 + 4) == 2) == -1 )
          goto LABEL_165;
        v28 = (int)v56;
      }
LABEL_94:
      *(_DWORD *)(v9 + 36) = v28;
    }
    if ( v53 && (v29 = *(char **)(v9 + 8)) != 0 )
    {
      v30 = (_DWORD *)a4[20];
      if ( v30 )
      {
        v31 = a2;
        *(_DWORD *)(v9 + 8) = xmlDictLookup(v30, v29, -1);
        if ( !a2 || (v32 = a2[20]) == 0 || !xmlDictOwns(v32, (unsigned int)v29) )
          ((void (__cdecl *)(char *))xmlFree)(v29);
      }
      else
      {
        v31 = a2;
        if ( a2 )
        {
          v33 = a2[20];
          if ( v33 )
          {
            if ( xmlDictOwns(v33, *(_DWORD *)(v9 + 8)) )
              *(_DWORD *)(v9 + 8) = xmlStrdup(v29);
          }
        }
      }
    }
    else
    {
      v31 = a2;
    }
    if ( *(_DWORD *)(v9 + 4) == 1 )
    {
      *(_DWORD *)(v9 + 52) = 0;
      *(_WORD *)(v9 + 56) = 0;
      *(_WORD *)(v9 + 58) = 0;
      v34 = *(_DWORD *)(v9 + 44);
      if ( v34 )
        goto LABEL_143;
    }
    else
    {
      if ( v31 && *(_DWORD *)(v9 + 40) == 2 )
        xmlRemoveID(v31, v9);
      *(_DWORD *)(v9 + 40) = 0;
      *(_DWORD *)(v9 + 44) = 0;
    }
LABEL_142:
    v34 = *(_DWORD *)(v9 + 12);
    if ( !v34 )
      goto LABEL_32;
LABEL_143:
    v8 = v57;
    v9 = v34;
LABEL_162:
    if ( !v9 )
      goto LABEL_166;
    v5 = a2;
    v7 = a4;
  }
  if ( v10 == 2 )
    goto LABEL_69;
  if ( v10 <= 2 )
  {
LABEL_165:
    v51 = -1;
    v8 = v57;
    goto LABEL_166;
  }
  if ( v53 )
  {
    v11 = *(char **)(v9 + 40);
    if ( v11 )
    {
      if ( a2 )
      {
        v12 = a2[20];
        if ( v12 )
        {
          if ( xmlDictOwns(v12, *(_DWORD *)(v9 + 40)) )
          {
            v13 = (_DWORD *)a4[20];
            if ( v13 )
              v14 = xmlDictLookup(v13, v11, -1);
            else
              v14 = xmlStrdup(v11);
            *(_DWORD *)(v9 + 40) = v14;
          }
        }
      }
    }
  }
LABEL_32:
  v15 = v55;
  v8 = v57;
  while ( v9 != a3 )
  {
    v16 = *(_DWORD *)(v9 + 4);
    if ( v16 == 1 || v16 == 19 || v16 == 20 )
    {
      if ( v8 && *v8 )
      {
        while ( v8[1] )
        {
          v46 = (_DWORD *)v8[1];
          if ( v46[5] < v15 )
            break;
          v47 = (_DWORD *)v46[1];
          v8[1] = v47;
          if ( v47 )
            *v47 = 0;
          else
            *v8 = 0;
          *v46 = v8[2];
          v8[2] = v46;
        }
        for ( i = (_DWORD *)*v8; i; i = (_DWORD *)*i )
        {
          if ( i[4] >= v15 )
            i[4] = -1;
        }
      }
      v55 = --v15;
    }
    if ( *(_DWORD *)(v9 + 24) )
    {
      v9 = *(_DWORD *)(v9 + 24);
      goto LABEL_162;
    }
    if ( *(_DWORD *)(v9 + 4) == 2 )
    {
      v49 = *(_DWORD *)(v9 + 20);
      if ( *(_DWORD *)(v49 + 12) )
      {
        v9 = *(_DWORD *)(v49 + 12);
        goto LABEL_162;
      }
    }
    v9 = *(_DWORD *)(v9 + 20);
  }
LABEL_166:
  v6 = a1;
LABEL_167:
  if ( v8 )
  {
    if ( v6 && *(_DWORD **)(v6 + 8) == v8 )
    {
      if ( *v8 )
      {
        if ( v8[2] )
          *(_DWORD *)v8[1] = v8[2];
        v8[2] = *v8;
        *v8 = 0;
      }
    }
    else
    {
      sub_41B0F6((int)v57);
    }
  }
  return v51;
}
// 496494: invalid function type has been ignored
// 41BF10: conditional instruction was optimized away because eax.4 is in (3..4)
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (0041C4A3) --------------------------------------------------------
int __cdecl xmlDOMWrapCloneNode(int a1, _DWORD *a2, int a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, int a7)
{
  int v7; // esi
  int result; // eax
  _DWORD *v9; // ecx
  int v10; // eax
  _DWORD *v11; // eax
  _DWORD *v12; // ebx
  _DWORD *v13; // ecx
  _DWORD *v14; // eax
  char *v15; // edi
  const char *v16; // eax
  int v17; // eax
  _DWORD *DocEntity; // eax
  char *v19; // edi
  unsigned __int8 *v20; // eax
  int j; // eax
  _DWORD *v22; // eax
  _DWORD *v23; // edx
  int v24; // eax
  _DWORD *v25; // eax
  _DWORD *v26; // edi
  _DWORD *v27; // eax
  _DWORD *v28; // edx
  int v29; // eax
  _DWORD *v30; // edi
  _DWORD *i; // eax
  int (__cdecl *v32)(int, int, _DWORD, _DWORD); // ecx
  _DWORD *v33; // eax
  _DWORD *v34; // edx
  int v35; // eax
  int v36; // eax
  unsigned __int8 *String; // eax
  unsigned __int8 *v38; // edi
  int v39; // eax
  _DWORD *v40; // eax
  _DWORD *v41; // ecx
  _DWORD *v42; // edi
  int v43; // eax
  _DWORD *v44; // eax
  _BYTE *v45; // [esp-4h] [ebp-40h]
  _BYTE *v46; // [esp-4h] [ebp-40h]
  int v47; // [esp+Ch] [ebp-30h]
  int v48; // [esp+10h] [ebp-2Ch]
  _DWORD *v49; // [esp+14h] [ebp-28h]
  int v50; // [esp+14h] [ebp-28h]
  int v51; // [esp+18h] [ebp-24h]
  _DWORD *v52; // [esp+1Ch] [ebp-20h]
  _DWORD *v53; // [esp+20h] [ebp-1Ch]
  _DWORD *v54; // [esp+20h] [ebp-1Ch]
  _DWORD *v55; // [esp+20h] [ebp-1Ch]
  _DWORD *v56; // [esp+24h] [ebp-18h]
  _DWORD *v57; // [esp+28h] [ebp-14h]
  int v58; // [esp+2Ch] [ebp-10h]
  _DWORD *v59; // [esp+30h] [ebp-Ch] BYREF
  int v60; // [esp+34h] [ebp-8h]
  int v61; // [esp+38h] [ebp-4h] BYREF

  v7 = a3;
  v47 = 0;
  v48 = 0;
  v59 = 0;
  v58 = -1;
  v51 = 0;
  v52 = 0;
  v56 = 0;
  v53 = 0;
  if ( !a3 || !a4 || !a5 )
    return -1;
  result = 1;
  if ( *(_DWORD *)(a3 + 4) != 1 )
    return result;
  v9 = *(_DWORD **)(a3 + 32);
  if ( v9 )
  {
    if ( !a2 )
      goto LABEL_9;
    if ( v9 != a2 )
      return -1;
  }
  if ( !a2 )
  {
LABEL_9:
    a2 = *(_DWORD **)(a3 + 32);
    if ( v9 )
      goto LABEL_10;
    return -1;
  }
LABEL_10:
  v60 = a5[20];
  if ( a1 )
    v59 = *(_DWORD **)(a1 + 8);
  *a4 = 0;
  while ( 1 )
  {
    if ( !v7 )
      goto LABEL_172;
    if ( *(_DWORD **)(v7 + 32) != a2 )
      goto LABEL_171;
    v10 = *(_DWORD *)(v7 + 4);
    if ( v10 != 1 )
    {
      if ( v10 == 2 )
      {
        v14 = (_DWORD *)xmlMalloc(48);
        v12 = v14;
        if ( !v14 )
        {
          sub_43279D("xmlDOMWrapCloneNode(): allocating an attr-node");
          goto LABEL_171;
        }
        memset(v14, 0, 0x30u);
        if ( !v52 )
        {
LABEL_29:
          v52 = v12;
          goto LABEL_30;
        }
        v13 = v53;
        v12[5] = v56;
        if ( !v53 )
        {
          v56[11] = v12;
          goto LABEL_30;
        }
LABEL_27:
        v13[6] = v12;
        v12[7] = v13;
        goto LABEL_30;
      }
      if ( v10 <= 2 || v10 > 8 && v10 != 11 )
        goto LABEL_171;
    }
    v11 = (_DWORD *)xmlMalloc(60);
    v12 = v11;
    if ( !v11 )
    {
      sub_43279D("xmlDOMWrapCloneNode(): allocating a node");
      goto LABEL_171;
    }
    memset(v11, 0, 0x3Cu);
    if ( !v52 )
      goto LABEL_29;
    v13 = v53;
    v12[5] = v56;
    if ( v53 )
      goto LABEL_27;
    v56[3] = v12;
LABEL_30:
    v12[1] = *(_DWORD *)(v7 + 4);
    v12[8] = a5;
    v15 = *(char **)(v7 + 8);
    v16 = "text";
    if ( v15 != "text" )
    {
      v16 = "textnoenc";
      if ( v15 != "textnoenc" )
      {
        v16 = "comment";
        if ( v15 != "comment" )
        {
          if ( !v15 )
            goto LABEL_40;
          v45 = *(_BYTE **)(v7 + 8);
          if ( v60 )
          {
            if ( xmlDictOwns(v60, (unsigned int)v45) )
            {
              v12[2] = v15;
              goto LABEL_40;
            }
            v16 = (const char *)xmlDictLookup((_DWORD *)v60, v15, -1);
          }
          else
          {
            v16 = xmlStrdup(v45);
          }
        }
      }
    }
    v12[2] = v16;
LABEL_40:
    v17 = *(_DWORD *)(v7 + 4);
    if ( v17 > 6 )
    {
      if ( v17 == 7 || v17 == 8 )
      {
LABEL_53:
        v19 = *(char **)(v7 + 40);
        if ( !v19 )
          goto LABEL_138;
        v46 = *(_BYTE **)(v7 + 40);
        if ( v60 )
        {
          if ( xmlDictOwns(v60, (unsigned int)v46) )
          {
            v12[10] = v19;
            goto LABEL_138;
          }
          v20 = xmlDictLookup((_DWORD *)v60, v19, -1);
        }
        else
        {
          v20 = xmlStrdup(v46);
        }
        v12[10] = v20;
        goto LABEL_138;
      }
      if ( (unsigned int)(v17 - 19) <= 1 )
        return -1;
LABEL_171:
      v47 = -1;
LABEL_172:
      v44 = v59;
      if ( v59 )
      {
        if ( a1 && *(_DWORD **)(a1 + 8) == v59 )
        {
          if ( *v59 )
          {
            if ( v59[2] )
              *(_DWORD *)v59[1] = v59[2];
            v44[2] = *v44;
            *v44 = 0;
          }
        }
        else
        {
          sub_41B0F6((int)v59);
        }
      }
      *a4 = v52;
      return v47;
    }
    if ( v17 == 6 )
      goto LABEL_138;
    if ( v17 == 1 )
      break;
    if ( v17 != 2 )
    {
      if ( v17 > 2 )
      {
        if ( v17 > 4 )
        {
          if ( a2 == a5 )
          {
            v12[10] = *(_DWORD *)(v7 + 40);
            v12[3] = *(_DWORD *)(v7 + 12);
            DocEntity = *(_DWORD **)(v7 + 16);
          }
          else
          {
            if ( !a5[11] && !a5[12] )
              goto LABEL_138;
            DocEntity = xmlGetDocEntity(a5, *(char **)(v7 + 8));
            if ( !DocEntity )
              goto LABEL_138;
            v12[10] = DocEntity[10];
            v12[3] = DocEntity;
          }
          v12[4] = DocEntity;
          goto LABEL_138;
        }
        goto LABEL_53;
      }
      goto LABEL_171;
    }
LABEL_94:
    if ( *(_DWORD *)(v7 + 36) )
    {
      if ( !v51 )
      {
        if ( a6 && !a1 && sub_41B2A3(a6, &v59) == -1 )
          goto LABEL_171;
        v51 = 1;
      }
      v30 = v59;
      if ( v59 && *v59 )
      {
        for ( i = (_DWORD *)*v59; ; i = (_DWORD *)*i )
        {
          if ( !i )
            goto LABEL_107;
          if ( i[4] == -1 && *(_DWORD *)(v7 + 36) == i[2] )
            break;
        }
        v35 = i[3];
      }
      else
      {
LABEL_107:
        if ( a1 && (v32 = *(int (__cdecl **)(int, int, _DWORD, _DWORD))(a1 + 12)) != 0 )
        {
          v61 = v32(a1, v7, *(_DWORD *)(*(_DWORD *)(v7 + 36) + 8), *(_DWORD *)(*(_DWORD *)(v7 + 36) + 12));
          v50 = *(_DWORD *)(v7 + 36);
          v55 = v30;
          if ( !v30 )
          {
            v33 = (_DWORD *)xmlMalloc(12);
            v55 = v33;
            if ( !v33 )
            {
LABEL_167:
              sub_43279D("allocating namespace map");
              goto LABEL_171;
            }
            *v33 = 0;
            v33[1] = 0;
            v33[2] = 0;
            v59 = v33;
          }
          v34 = (_DWORD *)v55[2];
          if ( v34 )
          {
            v55[2] = *v34;
          }
          else
          {
            v34 = (_DWORD *)xmlMalloc(24);
            if ( !v34 )
            {
LABEL_168:
              sub_43279D("allocating namespace map item");
              goto LABEL_171;
            }
          }
          memset(v34, 0, 0x18u);
          if ( *v55 )
          {
            v34[1] = v55[1];
            *(_DWORD *)v55[1] = v34;
          }
          else
          {
            *v55 = v34;
          }
          v55[1] = v34;
          v34[4] = -1;
          v34[2] = v50;
          v35 = v61;
          v34[3] = v61;
          v34[5] = -4;
        }
        else
        {
          if ( sub_41B7E6(a5, a6 != 0 ? v48 : 0, *(_DWORD *)(v7 + 36), &v61, &v59, v58, *(_DWORD *)(v7 + 4) == 2) == -1 )
            goto LABEL_171;
          v35 = v61;
        }
      }
      v12[9] = v35;
    }
    if ( v12[1] == 2 )
    {
      v36 = v12[5];
      if ( v36 )
      {
        if ( xmlIsID(a5, v36, (int)v12) )
        {
          String = xmlNodeListGetString(*(_DWORD **)(v7 + 32), *(_DWORD *)(v7 + 12), 1);
          v38 = String;
          if ( String )
          {
            if ( !xmlAddID(0, (int)a5, String, v7) )
            {
              ((void (__cdecl *)(unsigned __int8 *))xmlFree)(v38);
              goto LABEL_171;
            }
            ((void (__cdecl *)(unsigned __int8 *))xmlFree)(v38);
          }
        }
      }
    }
    if ( *(_DWORD *)(v7 + 4) == 1 && *(_DWORD *)(v7 + 44) )
    {
      v53 = 0;
      v56 = v12;
      v7 = *(_DWORD *)(v7 + 44);
    }
    else
    {
LABEL_162:
      if ( *(_DWORD *)(v7 + 12) && (a7 || *(_DWORD *)(v7 + 4) == 2) )
      {
        v53 = 0;
        v7 = *(_DWORD *)(v7 + 12);
        v56 = v12;
      }
      else
      {
        while ( 1 )
        {
LABEL_138:
          if ( v7 == a3 )
            goto LABEL_172;
          v39 = *(_DWORD *)(v7 + 4);
          if ( v39 == 1 || v39 == 19 || v39 == 20 )
          {
            v40 = v59;
            if ( v59 && *v59 )
            {
              while ( v40[1] )
              {
                v41 = (_DWORD *)v40[1];
                if ( v41[5] < v58 )
                  break;
                v42 = (_DWORD *)v41[1];
                v40[1] = v42;
                if ( v42 )
                  *v42 = 0;
                else
                  *v40 = 0;
                *v41 = v40[2];
                v40[2] = v41;
              }
              while ( 1 )
              {
                v40 = (_DWORD *)*v40;
                if ( !v40 )
                  break;
                if ( v40[4] >= v58 )
                  v40[4] = -1;
              }
            }
            --v58;
          }
          if ( *(_DWORD *)(v7 + 24) )
            break;
          if ( *(_DWORD *)(v7 + 4) == 2 )
          {
            v12 = (_DWORD *)v12[5];
            v7 = *(_DWORD *)(v7 + 20);
            v56 = (_DWORD *)v12[5];
            goto LABEL_162;
          }
          v43 = v12[5];
          if ( v43 )
            *(_DWORD *)(v43 + 16) = v12;
          v12 = (_DWORD *)v12[5];
          v7 = *(_DWORD *)(v7 + 20);
          v56 = (_DWORD *)v12[5];
        }
        v7 = *(_DWORD *)(v7 + 24);
        v53 = v12;
      }
    }
  }
  ++v58;
  v48 = v7;
  if ( !*(_DWORD *)(v7 + 48) )
    goto LABEL_94;
  if ( !v51 )
  {
    if ( a6 && !a1 && sub_41B2A3(a6, &v59) == -1 )
      goto LABEL_171;
    v51 = 1;
  }
  v49 = v12 + 12;
  for ( j = *(_DWORD *)(v7 + 48); ; j = *(_DWORD *)v61 )
  {
    v61 = j;
    if ( !j )
      goto LABEL_94;
    v22 = (_DWORD *)xmlMalloc(24);
    v57 = v22;
    if ( !v22 )
      break;
    v23 = v22;
    memset(v22, 0, 0x18u);
    v24 = v61;
    v57[1] = 18;
    if ( *(_DWORD *)(v24 + 8) )
    {
      v57[2] = xmlStrdup(*(_BYTE **)(v24 + 8));
      v23 = v57;
    }
    if ( *(_DWORD *)(v61 + 12) )
    {
      v57[3] = xmlStrdup(*(_BYTE **)(v61 + 12));
      v23 = v57;
    }
    *v49 = v23;
    v49 = v23;
    if ( !a1 || !*(_DWORD *)(a1 + 12) )
    {
      v25 = v59;
      if ( v59 )
      {
        if ( *v59 )
        {
          v26 = (_DWORD *)*v59;
          if ( *v59 )
          {
            do
            {
              if ( (int)v26[5] >= -1
                && v26[4] == -1
                && (*(_DWORD *)(v61 + 12) == *(_DWORD *)(v26[3] + 12)
                 || xmlStrEqual(*(char **)(v61 + 12), *(char **)(v26[3] + 12))) )
              {
                v26[4] = v58;
              }
              v26 = (_DWORD *)*v26;
            }
            while ( v26 );
            v25 = v59;
          }
        }
      }
      v54 = v25;
      if ( !v25 )
      {
        v27 = (_DWORD *)xmlMalloc(12);
        v54 = v27;
        if ( !v27 )
          goto LABEL_167;
        *v27 = 0;
        v27[1] = 0;
        v27[2] = 0;
        v59 = v27;
      }
      v28 = (_DWORD *)v54[2];
      if ( v28 )
      {
        v54[2] = *v28;
      }
      else
      {
        v28 = (_DWORD *)xmlMalloc(24);
        if ( !v28 )
          goto LABEL_168;
      }
      memset(v28, 0, 0x18u);
      if ( *v54 )
      {
        v28[1] = v54[1];
        *(_DWORD *)v54[1] = v28;
      }
      else
      {
        *v54 = v28;
      }
      v54[1] = v28;
      v29 = v61;
      v28[4] = -1;
      v28[2] = v29;
      v28[3] = v57;
      v28[5] = v58;
    }
  }
  sub_43279D("xmlDOMWrapCloneNode(): allocating namespace");
  return -1;
}
// 496494: invalid function type has been ignored
// 41C674: conditional instruction was optimized away because eax.4==5
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (0041CC04) --------------------------------------------------------
int __usercall sub_41CC04@<eax>(_DWORD *a1@<eax>, unsigned int *a2@<esi>, int a3, int a4, _DWORD *a5)
{
  _DWORD *v5; // ebx
  unsigned int v8; // eax
  char *v9; // ecx
  int **v10; // eax
  char *v11; // edi
  _DWORD *v12; // eax
  int v13; // eax
  int v14; // eax
  unsigned int v15; // edi
  int v16; // eax
  _DWORD *DocEntity; // eax
  char *v18; // ebx
  int v19; // eax
  _DWORD *v20; // eax
  unsigned __int8 *v21; // eax
  int **v22; // [esp+8h] [ebp-4h] BYREF

  v5 = a5;
  if ( !a5 )
    return -1;
  v8 = a2[9];
  a2[8] = (unsigned int)a5;
  if ( v8 )
  {
    v9 = *(char **)(v8 + 12);
    v22 = 0;
    if ( v9 && *v9 == 120 && v9[1] == 109 && v9[2] == 108 && !v9[3] )
    {
      v10 = (int **)sub_419BDE((int)a5);
    }
    else if ( a1 )
    {
      if ( sub_41B56C((int)a5, a1, *(char **)(v8 + 8), &v22) == -1 )
        return -1;
      v10 = v22;
      if ( v22 )
      {
LABEL_16:
        a2[9] = (unsigned int)v10;
        goto LABEL_17;
      }
      v10 = (int **)sub_41B70C(*(const char **)(a2[9] + 12), (int)a1, (int)a5, *(char **)(a2[9] + 8), 1);
    }
    else
    {
      v10 = (int **)sub_41B1EE(a5, *(char **)(v8 + 8), v9);
    }
    if ( v10 )
      goto LABEL_16;
    return -1;
  }
LABEL_17:
  v11 = (char *)a2[2];
  if ( v11 )
  {
    v12 = (_DWORD *)a5[20];
    if ( v12 )
    {
      a2[2] = (unsigned int)xmlDictLookup(v12, v11, -1);
      if ( !a4 || (v13 = *(_DWORD *)(a4 + 80)) == 0 || !xmlDictOwns(v13, (unsigned int)v11) )
        ((void (__cdecl *)(char *))xmlFree)(v11);
    }
    else if ( a4 )
    {
      v14 = *(_DWORD *)(a4 + 80);
      if ( v14 )
      {
        if ( xmlDictOwns(v14, a2[2]) )
          a2[2] = (unsigned int)xmlStrdup(v11);
      }
    }
  }
  v15 = a2[3];
  a2[10] = 0;
  a2[11] = 0;
LABEL_50:
  while ( v15 )
  {
    v16 = *(_DWORD *)(v15 + 4);
    *(_DWORD *)(v15 + 32) = v5;
    if ( v16 >= 3 )
    {
      if ( v16 <= 4 )
      {
        v18 = *(char **)(v15 + 40);
        if ( v18 )
        {
          if ( a4 )
          {
            v19 = *(_DWORD *)(a4 + 80);
            if ( v19 )
            {
              if ( xmlDictOwns(v19, *(_DWORD *)(v15 + 40)) )
              {
                v20 = (_DWORD *)a5[20];
                if ( v20 )
                  v21 = xmlDictLookup(v20, v18, -1);
                else
                  v21 = xmlStrdup(v18);
                *(_DWORD *)(v15 + 40) = v21;
              }
            }
          }
        }
        v5 = a5;
      }
      else if ( v16 == 5 )
      {
        *(_DWORD *)(v15 + 40) = 0;
        *(_DWORD *)(v15 + 12) = 0;
        *(_DWORD *)(v15 + 16) = 0;
        if ( v5[11] || v5[12] )
        {
          DocEntity = xmlGetDocEntity(v5, *(char **)(v15 + 8));
          if ( DocEntity )
          {
            *(_DWORD *)(v15 + 40) = DocEntity[10];
            *(_DWORD *)(v15 + 12) = DocEntity;
            *(_DWORD *)(v15 + 16) = DocEntity;
          }
        }
      }
    }
    if ( !*(_DWORD *)(v15 + 12) )
    {
      while ( (unsigned int *)v15 != a2 )
      {
        if ( *(_DWORD *)(v15 + 24) )
        {
          v15 = *(_DWORD *)(v15 + 24);
          goto LABEL_50;
        }
        v15 = *(_DWORD *)(v15 + 20);
      }
      return 0;
    }
    v15 = *(_DWORD *)(v15 + 12);
  }
  return 0;
}
// 496494: invalid function type has been ignored

//----- (0041CDD4) --------------------------------------------------------
int __cdecl xmlDOMWrapAdoptNode(int a1, _DWORD *a2, void *Block, _DWORD *a4, int a5)
{
  _DWORD *v6; // eax
  _DWORD *v7; // ecx
  _DWORD *v8; // edi
  int v9; // ecx
  int v11; // ecx
  int v12; // ecx
  char *v13; // ebx
  _DWORD *v14; // eax
  int v15; // eax
  int v16; // eax
  char *v17; // ebx
  int v18; // edi
  _DWORD *v19; // eax
  unsigned __int8 *v20; // eax
  _DWORD *DocEntity; // eax
  char *v22; // eax
  _DWORD *v23; // ebx
  int v24; // edi
  int v25; // edi
  int v26; // edi
  _DWORD *v27; // ebx
  int Blocka; // [esp+1Ch] [ebp+10h]
  char *Blockb; // [esp+1Ch] [ebp+10h]

  if ( !Block )
    return -1;
  if ( !a4 )
    return -1;
  v6 = (_DWORD *)a5;
  if ( a5 )
  {
    if ( *(_DWORD **)(a5 + 32) != a4 )
      return -1;
  }
  v7 = (_DWORD *)*((_DWORD *)Block + 8);
  v8 = a2;
  if ( !v7 )
    goto LABEL_8;
  if ( a2 )
  {
    if ( v7 != a2 )
      return -1;
LABEL_8:
    if ( a2 )
      goto LABEL_10;
  }
  v8 = (_DWORD *)*((_DWORD *)Block + 8);
LABEL_10:
  if ( v8 != a4 )
  {
    v9 = *((_DWORD *)Block + 1);
    if ( v9 > 0 )
    {
      if ( v9 <= 5 )
        goto LABEL_17;
      if ( v9 > 6 )
      {
        if ( v9 > 8 )
        {
          if ( v9 == 11 )
            return 2;
          return 1;
        }
LABEL_17:
        v11 = *((_DWORD *)Block + 5);
        if ( v11 && a5 != v11 )
        {
          xmlUnlinkNode((int)Block);
          v6 = (_DWORD *)a5;
        }
        v12 = *((_DWORD *)Block + 1);
        if ( v12 == 1 )
          return sub_41BE42(a1, v8, (int)Block, a4, v6);
        if ( v12 == 2 )
          return sub_41CC04(v6, (unsigned int *)Block, a1, (int)v8, a4);
        Blocka = 1;
        *((_DWORD *)Block + 8) = a4;
        if ( v8 && v8[20] == a4[20] )
          Blocka = 0;
        if ( v12 < 3 )
          return 0;
        if ( v12 <= 4 )
        {
          if ( !Blocka )
            return 0;
          if ( !*((_DWORD *)Block + 10) )
            return 0;
          if ( !v8 )
            return 0;
          v26 = v8[20];
          if ( !v26 || !xmlDictOwns(v26, *((_DWORD *)Block + 10)) )
            return 0;
          v27 = (_DWORD *)a4[20];
          if ( v27 )
            v20 = xmlDictLookup(v27, *((char **)Block + 10), -1);
          else
            v20 = xmlStrdup(*((_BYTE **)Block + 10));
        }
        else
        {
          if ( v12 == 5 )
          {
            *((_DWORD *)Block + 10) = 0;
            *((_DWORD *)Block + 3) = 0;
            *((_DWORD *)Block + 4) = 0;
            if ( a4[11] || a4[12] )
            {
              DocEntity = xmlGetDocEntity(a4, *((char **)Block + 2));
              if ( DocEntity )
              {
                *((_DWORD *)Block + 10) = DocEntity[10];
                *((_DWORD *)Block + 3) = DocEntity;
                *((_DWORD *)Block + 4) = DocEntity;
              }
            }
            if ( Blocka )
            {
              v22 = (char *)*((_DWORD *)Block + 2);
              Blockb = v22;
              if ( v22 )
              {
                v23 = (_DWORD *)a4[20];
                if ( v23 )
                {
                  *((_DWORD *)Block + 2) = xmlDictLookup(v23, v22, -1);
                  if ( !v8 || (v24 = v8[20]) == 0 || !xmlDictOwns(v24, (unsigned int)Blockb) )
                    ((void (__cdecl *)(char *))xmlFree)(Blockb);
                }
                else if ( v8 )
                {
                  v25 = v8[20];
                  if ( v25 )
                  {
                    if ( xmlDictOwns(v25, (unsigned int)v22) )
                      *((_DWORD *)Block + 2) = xmlStrdup(Blockb);
                  }
                }
              }
            }
            return 0;
          }
          if ( v12 != 7 || !Blocka )
            return 0;
          v13 = (char *)*((_DWORD *)Block + 2);
          if ( v13 )
          {
            v14 = (_DWORD *)a4[20];
            if ( v14 )
            {
              *((_DWORD *)Block + 2) = xmlDictLookup(v14, v13, -1);
              if ( !v8 || (v15 = v8[20]) == 0 || !xmlDictOwns(v15, (unsigned int)v13) )
                ((void (__cdecl *)(char *))xmlFree)(v13);
            }
            else if ( v8 )
            {
              v16 = v8[20];
              if ( v16 )
              {
                if ( xmlDictOwns(v16, *((_DWORD *)Block + 2)) )
                  *((_DWORD *)Block + 2) = xmlStrdup(v13);
              }
            }
          }
          v17 = (char *)*((_DWORD *)Block + 10);
          if ( !v17 )
            return 0;
          if ( !v8 )
            return 0;
          v18 = v8[20];
          if ( !v18 || !xmlDictOwns(v18, *((_DWORD *)Block + 10)) )
            return 0;
          v19 = (_DWORD *)a4[20];
          if ( v19 )
            v20 = xmlDictLookup(v19, v17, -1);
          else
            v20 = xmlStrdup(v17);
        }
        *((_DWORD *)Block + 10) = v20;
        return 0;
      }
    }
    return 1;
  }
  return -1;
}
// 496494: invalid function type has been ignored

//----- (0041D090) --------------------------------------------------------
int __cdecl xmlIsXHTML(char *a1, char *a2)
{
  if ( a1 )
  {
    if ( !a2 )
      return a1
          && (xmlStrEqual(a1, "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd")
           || xmlStrEqual(a1, "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd")
           || xmlStrEqual(a1, "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"));
  }
  else if ( !a2 )
  {
    return -1;
  }
  if ( xmlStrEqual(a2, "-//W3C//DTD XHTML 1.0 Strict//EN")
    || xmlStrEqual(a2, "-//W3C//DTD XHTML 1.0 Frameset//EN")
    || xmlStrEqual(a2, "-//W3C//DTD XHTML 1.0 Transitional//EN") )
  {
    return 1;
  }
  return a1
      && (xmlStrEqual(a1, "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd")
       || xmlStrEqual(a1, "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd")
       || xmlStrEqual(a1, "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"));
}

//----- (0041D125) --------------------------------------------------------
int (__cdecl *__cdecl sub_41D125(_BYTE *a1))(int, char *Format, char ArgList)
{
  return _xmlSimpleError(7, 2, 0, 0, a1);
}

//----- (0041D13A) --------------------------------------------------------
int (__cdecl *__cdecl sub_41D13A(
        int a1,
        int (__cdecl *a2)(int, char *Format, char ArgList),
        _BYTE *a3))(int, char *Format, char ArgList)
{
  char *v3; // eax

  switch ( a1 )
  {
    case 1400:
      v3 = "string is not in UTF-8\n";
      break;
    case 1401:
      v3 = "invalid character value\n";
      break;
    case 1402:
      v3 = "document has no DOCTYPE\n";
      break;
    case 1403:
      v3 = "unknown encoding %s\n";
      break;
    default:
      v3 = "unexpected error number\n";
      break;
  }
  return _xmlSimpleError(7, a1, a2, v3, a3);
}

//----- (0041D187) --------------------------------------------------------
_BYTE *__usercall sub_41D187@<eax>(int a1@<eax>, _BYTE *a2@<ecx>)
{
  _BYTE *v2; // ecx
  int v3; // esi
  _BYTE *v4; // ecx
  _BYTE *v5; // eax
  _BYTE *result; // eax

  *a2 = 38;
  v2 = a2 + 1;
  *v2++ = 35;
  v3 = a1;
  *v2 = 120;
  v4 = v2 + 1;
  if ( a1 >= 16 )
  {
    if ( a1 >= 256 )
    {
      if ( a1 >= 4096 )
      {
        if ( a1 >= 0x10000 )
        {
          if ( a1 >= 0x100000 )
            v4 += 5;
          else
            v4 += 4;
        }
        else
        {
          v4 += 3;
        }
      }
      else
      {
        v4 += 2;
      }
    }
    else
    {
      ++v4;
    }
  }
  v5 = v4 + 1;
  while ( v3 > 0 )
  {
    switch ( v3 & 0xF )
    {
      case 1:
        *v4 = 49;
        break;
      case 2:
        *v4 = 50;
        break;
      case 3:
        *v4 = 51;
        break;
      case 4:
        *v4 = 52;
        break;
      case 5:
        *v4 = 53;
        break;
      case 6:
        *v4 = 54;
        break;
      case 7:
        *v4 = 55;
        break;
      case 8:
        *v4 = 56;
        break;
      case 9:
        *v4 = 57;
        break;
      case 0xA:
        *v4 = 65;
        break;
      case 0xB:
        *v4 = 66;
        break;
      case 0xC:
        *v4 = 67;
        break;
      case 0xD:
        *v4 = 68;
        break;
      case 0xE:
        *v4 = 69;
        break;
      case 0xF:
        *v4 = 70;
        break;
      default:
        *v4 = 48;
        break;
    }
    --v4;
    v3 >>= 4;
  }
  *v5 = 59;
  result = v5 + 1;
  *result = 0;
  return result;
}

//----- (0041D287) --------------------------------------------------------
int __cdecl sub_41D287(char *a1, _DWORD *a2, char *a3, _DWORD *a4)
{
  char *v4; // esi
  char *v5; // edi
  unsigned int v6; // ecx
  unsigned int v7; // edx
  int v8; // ebx
  char v9; // al
  _BYTE *v10; // esi
  _BYTE *v11; // esi
  _BYTE *v12; // esi
  int v13; // eax
  char *v14; // eax
  char *v15; // eax
  unsigned int v19; // [esp+1Ch] [ebp+8h]
  unsigned int v20; // [esp+24h] [ebp+10h]

  v4 = a1;
  v5 = a3;
  v6 = (unsigned int)&a3[*a4];
  v7 = (unsigned int)&a1[*a2];
  v19 = v7;
  v20 = v6;
  if ( (unsigned int)a3 < v6 )
  {
    v8 = v6 - (_DWORD)v5;
    while ( 1 )
    {
      if ( (unsigned int)v4 >= v7 )
        goto LABEL_48;
      v9 = *v5;
      if ( *v5 == 60 )
        break;
      if ( v9 == 62 )
      {
        if ( (int)(v7 - (_DWORD)v4) < 4 )
          goto LABEL_48;
        *v4 = 38;
        v10 = v4 + 1;
        *v10 = 103;
        goto LABEL_7;
      }
      if ( v9 == 38 )
      {
        if ( (int)(v7 - (_DWORD)v4) < 5 )
          goto LABEL_48;
        *v4 = 38;
        v12 = v4 + 1;
        *v12++ = 97;
        *v12 = 109;
        v11 = v12 + 1;
        *v11 = 112;
        goto LABEL_8;
      }
      if ( v9 > 31 || v9 == 10 || v9 == 9 )
      {
        *v4 = v9;
LABEL_45:
        ++v4;
LABEL_46:
        ++v5;
        --v8;
        goto LABEL_47;
      }
      if ( (unsigned __int8)v9 < 0x80u )
      {
        if ( v9 != 13 )
        {
          xmlGenericError(xmlGenericErrorContext, "xmlEscapeEntities : char out of range\n");
          goto LABEL_51;
        }
        if ( (int)(v7 - (_DWORD)v4) < 6 )
          goto LABEL_48;
        v15 = sub_41D187(13, v4);
        v7 = v19;
        v6 = v20;
        v4 = v15;
        goto LABEL_46;
      }
      if ( (int)(v7 - (_DWORD)v4) < 11 )
        goto LABEL_48;
      if ( (unsigned __int8)v9 < 0xC0u )
      {
        sub_41D13A(1400, 0, 0);
        goto LABEL_51;
      }
      if ( (unsigned __int8)v9 >= 0xE0u )
      {
        if ( (unsigned __int8)v9 >= 0xF0u )
        {
          if ( (unsigned __int8)v9 >= 0xF8u )
            goto LABEL_35;
          if ( v8 < 4 )
            goto LABEL_48;
          v13 = v5[3] & 0x3F | ((v5[2] & 0x3F | ((v5[1] & 0x3F | ((v9 & 7) << 6)) << 6)) << 6);
          v5 += 4;
          v8 -= 4;
        }
        else
        {
          if ( v8 < 3 )
            goto LABEL_48;
          v13 = v5[2] & 0x3F | ((v5[1] & 0x3F | ((v9 & 0xF) << 6)) << 6);
          v5 += 3;
          v8 -= 3;
        }
      }
      else
      {
        if ( v8 < 2 )
          goto LABEL_48;
        v13 = v5[1] & 0x3F | ((v9 & 0x1F) << 6);
        v5 += 2;
        v8 -= 2;
      }
      if ( v13 >= 256 )
      {
        if ( v13 > 55295 && (v13 < 57344 || v13 > 65533) && (unsigned int)(v13 - 0x10000) > 0xFFFFF )
        {
LABEL_35:
          sub_41D13A(1401, 0, 0);
LABEL_51:
          *a2 = v4 - a1;
          *a4 = v5 + 1 - a3;
          return -1;
        }
      }
      else if ( (v13 < 9 || v13 > 10) && v13 != 13 && v13 < 32 )
      {
        goto LABEL_35;
      }
      v14 = sub_41D187(v13, v4);
      v7 = v19;
      v6 = v20;
      v4 = v14;
LABEL_47:
      if ( (unsigned int)v5 >= v6 )
        goto LABEL_48;
    }
    if ( (int)(v7 - (_DWORD)v4) < 4 )
      goto LABEL_48;
    *v4 = 38;
    v10 = v4 + 1;
    *v10 = 108;
LABEL_7:
    v11 = v10 + 1;
    *v11 = 116;
LABEL_8:
    v4 = v11 + 1;
    *v4 = 59;
    goto LABEL_45;
  }
LABEL_48:
  *a2 = v4 - a1;
  *a4 = v5 - a3;
  return 0;
}
// 41D455: conditional instruction was optimized away because al.1 is in (B..1F)
// 41D45D: conditional instruction was optimized away because al.1 is in (<9u|B..C|E..1F)
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);

//----- (0041D4DA) --------------------------------------------------------
void __usercall sub_41D4DA(_DWORD *a1@<esi>)
{
  int v1; // eax
  int v2; // edx
  int v3; // edi

  if ( a1 )
  {
    if ( !a1[4] && !a1[29] )
      a1[29] = sub_41D287;
    v1 = xmlStrlen(xmlTreeIndentString);
    if ( v2 && v1 )
    {
      v3 = 0;
      a1[28] = v1;
      for ( a1[27] = 60 / v1; v3 < a1[27]; ++v3 )
        memcpy((char *)a1 + v3 * a1[28] + 44, xmlTreeIndentString, a1[28]);
      *((_BYTE *)a1 + a1[27] * a1[28] + 44) = 0;
    }
    else
    {
      memset(a1 + 11, 0, 0x3Du);
    }
    if ( xmlSaveNoEmptyTags )
      a1[8] |= 4u;
  }
}
// 41D507: variable 'v2' is possibly undefined
// 4A9CE4: using guessed type int xmlSaveNoEmptyTags;

//----- (0041D56B) --------------------------------------------------------
int __usercall sub_41D56B@<eax>(int a1@<esi>)
{
  int result; // eax

  if ( a1 )
  {
    if ( *(_DWORD *)(a1 + 16) )
      ((void (__cdecl *)(_DWORD))xmlFree)(*(_DWORD *)(a1 + 16));
    if ( *(_DWORD *)(a1 + 24) )
      xmlOutputBufferClose(*(_DWORD **)(a1 + 24));
    return ((int (__cdecl *)(int))xmlFree)(a1);
  }
  return result;
}
// 496494: invalid function type has been ignored

//----- (0041D595) --------------------------------------------------------
int __usercall sub_41D595@<eax>(char *a1@<edi>, int a2)
{
  void *v2; // eax
  int v3; // esi
  int CharEncodingHandler; // eax
  _BYTE *v6; // eax
  int v7; // eax

  v2 = (void *)xmlMalloc(124);
  v3 = (int)v2;
  if ( !v2 )
  {
    sub_41D125("creating saving context");
    return 0;
  }
  memset(v2, 0, 0x7Cu);
  if ( a1 )
  {
    CharEncodingHandler = xmlFindCharEncodingHandler(a1);
    *(_DWORD *)(v3 + 20) = CharEncodingHandler;
    if ( !CharEncodingHandler )
    {
      sub_41D13A(1403, 0, a1);
      sub_41D56B(v3);
      return 0;
    }
    v6 = xmlStrdup(a1);
    *(_DWORD *)(v3 + 116) = 0;
    *(_DWORD *)(v3 + 16) = v6;
  }
  sub_41D4DA((_DWORD *)v3);
  v7 = a2;
  if ( (*(_BYTE *)(v3 + 32) & 4) != 0 && (a2 & 4) == 0 )
    v7 = a2 | 4;
  *(_DWORD *)(v3 + 32) = v7;
  if ( (v7 & 1) != 0 )
  {
    *(_DWORD *)(v3 + 40) = 1;
  }
  else if ( (v7 & 0x80u) != 0 )
  {
    *(_DWORD *)(v3 + 40) = 2;
  }
  return v3;
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (0041D62A) --------------------------------------------------------
void __usercall sub_41D62A(int a1@<ebx>, int a2@<edi>)
{
  int i; // esi
  int v3; // eax
  _BYTE *v4; // edx

  for ( i = *(_DWORD *)(a1 + 12); i; i = *(_DWORD *)(i + 24) )
  {
    if ( *(_DWORD *)(i + 4) == 3 )
    {
      xmlAttrSerializeTxtContent(
        *(int **)(a2 + 16),
        *(_DWORD *)(a1 + 32),
        (int (__cdecl *)(int, char *, char))a1,
        *(unsigned __int8 **)(i + 40));
    }
    else if ( *(_DWORD *)(i + 4) == 5 )
    {
      xmlBufferAdd(*(int **)(a2 + 16), "&", 1);
      v3 = xmlStrlen(*(_BYTE **)(i + 8));
      xmlBufferAdd(*(int **)(a2 + 16), v4, v3);
      xmlBufferAdd(*(int **)(a2 + 16), ";", 1);
    }
  }
}
// 41D659: variable 'v4' is possibly undefined

//----- (0041D68D) --------------------------------------------------------
int __usercall sub_41D68D@<eax>(int a1@<eax>, char *a2)
{
  int v2; // esi
  int CharEncodingHandler; // eax
  _DWORD *v5; // eax

  v2 = *(_DWORD *)(a1 + 24);
  if ( a2 && !*(_DWORD *)(v2 + 12) && !*(_DWORD *)(v2 + 20) )
  {
    CharEncodingHandler = xmlFindCharEncodingHandler(a2);
    *(_DWORD *)(v2 + 12) = CharEncodingHandler;
    if ( !CharEncodingHandler )
    {
      sub_41D13A(1403, 0, a2);
      return -1;
    }
    v5 = xmlBufferCreate();
    *(_DWORD *)(v2 + 20) = v5;
    if ( !v5 )
    {
      xmlCharEncCloseFunc(*(_DWORD **)(v2 + 12));
      sub_41D125("creating encoding buffer");
      return -1;
    }
    xmlCharEncOutFunc(*(_DWORD *)(v2 + 12), v5, 0);
  }
  return 0;
}

//----- (0041D701) --------------------------------------------------------
void __usercall sub_41D701(int a1@<edi>, int a2@<esi>)
{
  _DWORD *v2; // eax
  int v3; // eax
  int v4; // ecx
  int v5; // eax
  int v6; // [esp+0h] [ebp-4h]

  if ( a2 )
  {
    v2 = *(_DWORD **)(a2 + 24);
    if ( v2 )
    {
      xmlOutputBufferWrite(v2, 1, "\n");
      v3 = *(_DWORD *)(a2 + 36);
      v6 = 0;
      if ( v3 + a1 > 0 )
      {
        v4 = *(_DWORD *)(a2 + 108);
        do
        {
          v5 = a1 + v3 - v6;
          if ( v5 <= v4 )
            v4 = v5;
          xmlOutputBufferWrite(*(_DWORD **)(a2 + 24), v4 * *(_DWORD *)(a2 + 112), (char *)(a2 + 44));
          v4 = *(_DWORD *)(a2 + 108);
          v3 = *(_DWORD *)(a2 + 36);
          v6 += v4;
        }
        while ( v6 < v3 + a1 );
      }
    }
  }
}

//----- (0041D767) --------------------------------------------------------
void __usercall sub_41D767(int a1@<eax>, int a2@<ebx>, _DWORD *a3)
{
  _DWORD *v4; // edi

  if ( a2 )
  {
    v4 = a3;
    if ( a3 )
    {
      if ( *(_DWORD *)(a2 + 4) == 18 && *(_DWORD *)(a2 + 8) && !xmlStrEqual(*(char **)(a2 + 12), "xml") )
      {
        if ( a1 && *(_DWORD *)(a1 + 40) == 2 )
        {
          sub_41D701(2, a1);
          v4 = a3;
        }
        else
        {
          xmlOutputBufferWrite(a3, 1, " ");
        }
        if ( *(_DWORD *)(a2 + 12) )
        {
          xmlOutputBufferWrite(v4, 6, "xmlns:");
          xmlOutputBufferWriteString(v4, *(char **)(a2 + 12));
        }
        else
        {
          xmlOutputBufferWrite(v4, 5, "xmlns");
        }
        xmlOutputBufferWrite(v4, 1, "=");
        xmlBufferWriteQuotedString((int *)v4[4], *(_BYTE **)(a2 + 8));
      }
    }
  }
}

//----- (0041D81D) --------------------------------------------------------
int __usercall sub_41D81D@<eax>(int result@<eax>, int a2@<edi>)
{
  _DWORD *v2; // esi
  int v3; // ebx
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // [esp+4h] [ebp-Ch]
  int v8; // [esp+8h] [ebp-8h]
  int v9; // [esp+Ch] [ebp-4h]

  v2 = (_DWORD *)result;
  if ( a2 )
  {
    if ( result )
    {
      v3 = *(_DWORD *)(result + 24);
      if ( v3 )
      {
        xmlOutputBufferWrite((_DWORD *)v3, 10, "<!DOCTYPE ");
        xmlOutputBufferWriteString((_DWORD *)v3, *(char **)(a2 + 8));
        if ( *(_DWORD *)(a2 + 52) )
        {
          xmlOutputBufferWrite((_DWORD *)v3, 8, " PUBLIC ");
          xmlBufferWriteQuotedString(*(int **)(v3 + 16), *(_BYTE **)(a2 + 52));
          xmlOutputBufferWrite((_DWORD *)v3, 1, " ");
          xmlBufferWriteQuotedString(*(int **)(v3 + 16), *(_BYTE **)(a2 + 56));
        }
        else if ( *(_DWORD *)(a2 + 56) )
        {
          xmlOutputBufferWrite((_DWORD *)v3, 8, " SYSTEM ");
          xmlBufferWriteQuotedString(*(int **)(v3 + 16), *(_BYTE **)(a2 + 56));
        }
        if ( *(_DWORD *)(a2 + 48)
          || *(_DWORD *)(a2 + 40)
          || *(_DWORD *)(a2 + 44)
          || *(_DWORD *)(a2 + 36)
          || *(_DWORD *)(a2 + 60) )
        {
          xmlOutputBufferWrite((_DWORD *)v3, 3, " [\n");
          if ( *(_DWORD *)(a2 + 36) )
          {
            v4 = *(_DWORD *)(a2 + 32);
            if ( !v4 || *(_DWORD *)(v4 + 44) == a2 )
              xmlDumpNotationTable(*(_DWORD *)(v3 + 16), *(_DWORD **)(a2 + 36));
          }
          v5 = v2[10];
          v2[10] = 0;
          v9 = v5;
          v6 = v2[9];
          v2[9] = -1;
          v8 = v6;
          v7 = v2[7];
          v2[7] = *(_DWORD *)(a2 + 32);
          sub_41D9DF(*(_DWORD *)(a2 + 12), (int)v2);
          v2[10] = v9;
          v2[9] = v8;
          v2[7] = v7;
          return xmlOutputBufferWrite((_DWORD *)v3, 2, "]>");
        }
        else
        {
          return xmlOutputBufferWrite((_DWORD *)v3, 1, ">");
        }
      }
    }
  }
  return result;
}

//----- (0041D957) --------------------------------------------------------
int __usercall sub_41D957@<eax>(int result@<eax>, int a2@<ecx>)
{
  int v2; // ebx
  _DWORD *v3; // ebp
  int v4; // eax
  char *v5; // eax

  v2 = result;
  if ( result )
  {
    v3 = *(_DWORD **)(a2 + 24);
    if ( v3 )
    {
      if ( *(_DWORD *)(a2 + 40) == 2 )
        sub_41D701(2, a2);
      else
        xmlOutputBufferWrite(v3, 1, " ");
      v4 = *(_DWORD *)(v2 + 36);
      if ( v4 )
      {
        v5 = *(char **)(v4 + 12);
        if ( v5 )
        {
          xmlOutputBufferWriteString(v3, v5);
          xmlOutputBufferWrite(v3, 1, ":");
        }
      }
      xmlOutputBufferWriteString(v3, *(char **)(v2 + 8));
      xmlOutputBufferWrite(v3, 2, "=\"");
      sub_41D62A(v2, (int)v3);
      return xmlOutputBufferWrite(v3, 1, "\"");
    }
  }
  return result;
}

//----- (0041D9DF) --------------------------------------------------------
int __usercall sub_41D9DF@<eax>(int result@<eax>, int a2@<esi>)
{
  _DWORD *v2; // edi
  int v3; // eax
  int v4; // eax
  _DWORD *v5; // [esp+4h] [ebp-4h]

  v2 = (_DWORD *)result;
  if ( result )
  {
    v5 = *(_DWORD **)(a2 + 24);
    do
    {
      if ( *(_DWORD *)(a2 + 40) == 1 )
      {
        if ( xmlIndentTreeOutput )
        {
          v3 = v2[1];
          if ( v3 == 1 || v3 == 8 || v3 == 7 )
          {
            v4 = *(_DWORD *)(a2 + 36);
            if ( v4 > *(_DWORD *)(a2 + 108) )
              v4 = *(_DWORD *)(a2 + 108);
            xmlOutputBufferWrite(v5, v4 * *(_DWORD *)(a2 + 112), (char *)(a2 + 44));
          }
        }
      }
      result = sub_41DA5E(a2, v2);
      if ( *(_DWORD *)(a2 + 40) == 1 )
        result = xmlOutputBufferWrite(v5, 1, "\n");
      v2 = (_DWORD *)v2[6];
    }
    while ( v2 );
  }
  return result;
}
// 41DA5E: using guessed type _DWORD __cdecl sub_41DA5E(_DWORD, void *Src);
// 4A4BA4: using guessed type int xmlIndentTreeOutput;

//----- (0041DA5E) --------------------------------------------------------
void __cdecl sub_41DA5E(int a1, void *Src)
{
  void *v2; // ebx
  int v3; // eax
  int v4; // edi
  const char *v5; // eax
  char *v6; // ebx
  char *v7; // esi
  char v8; // al
  int i; // eax
  int v10; // ecx
  int v11; // eax
  char *v12; // eax
  _DWORD *v13; // ebx
  int j; // edi
  _DWORD *v15; // edi
  const char *v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // eax
  char *v21; // eax
  char *v22; // [esp-20h] [ebp-2Ch]
  int v23; // [esp+4h] [ebp-8h]
  _DWORD *v24; // [esp+8h] [ebp-4h]
  char *Srca; // [esp+18h] [ebp+Ch]

  v2 = Src;
  if ( !Src )
    return;
  v3 = *((_DWORD *)Src + 1);
  v4 = *(_DWORD *)(a1 + 24);
  v24 = (_DWORD *)v4;
  switch ( v3 )
  {
    case 19:
    case 20:
      return;
    case 9:
    case 13:
      sub_41DEDF(a1, Src);
      return;
    case 14:
      sub_41D81D(a1, (int)Src);
      return;
    case 11:
      sub_41D9DF(*((_DWORD *)Src + 3), a1);
      return;
    case 15:
      xmlDumpElementDecl(*(int **)(v4 + 16), (int)Src);
      return;
    case 16:
      xmlDumpAttributeDecl(*(int **)(v4 + 16), (int)Src);
      return;
    case 17:
      xmlDumpEntityDecl(*(int **)(v4 + 16), (int)Src);
      return;
    case 3:
      v5 = (const char *)*((_DWORD *)Src + 10);
      if ( v5 )
      {
        if ( *((char **)Src + 2) == "textnoenc" )
          xmlOutputBufferWriteString((_DWORD *)v4, *((char **)Src + 10));
        else
          xmlOutputBufferWriteEscape(v4, v5, *(int (__cdecl **)(_BYTE *, int *, char *, int *))(a1 + 116));
      }
      return;
    case 7:
      if ( *((_DWORD *)Src + 10) )
      {
        xmlOutputBufferWrite((_DWORD *)v4, 2, "<?");
        xmlOutputBufferWriteString((_DWORD *)v4, *((char **)Src + 2));
        if ( *((_DWORD *)Src + 10) )
        {
          if ( *(_DWORD *)(a1 + 40) == 2 )
            sub_41D701(0, a1);
          else
            xmlOutputBufferWrite((_DWORD *)v4, 1, " ");
          xmlOutputBufferWriteString((_DWORD *)v4, *((char **)Src + 10));
        }
      }
      else
      {
        xmlOutputBufferWrite((_DWORD *)v4, 2, "<?");
        xmlOutputBufferWriteString((_DWORD *)v4, *((char **)Src + 2));
        if ( *(_DWORD *)(a1 + 40) == 2 )
          sub_41D701(0, a1);
      }
      xmlOutputBufferWrite((_DWORD *)v4, 2, "?>");
      return;
    case 8:
      if ( !*((_DWORD *)Src + 10) )
        return;
      xmlOutputBufferWrite((_DWORD *)v4, 4, "<!--");
      xmlOutputBufferWriteString((_DWORD *)v4, *((char **)Src + 10));
      v22 = "-->";
      goto LABEL_47;
    case 5:
      xmlOutputBufferWrite((_DWORD *)v4, 1, "&");
      xmlOutputBufferWriteString((_DWORD *)v4, *((char **)Src + 2));
      xmlOutputBufferWrite((_DWORD *)v4, 1, ";");
      return;
    case 4:
      v6 = (char *)*((_DWORD *)Src + 10);
      if ( !v6 || !*v6 )
      {
        xmlOutputBufferWrite((_DWORD *)v4, 12, "<![CDATA[]]>");
        return;
      }
      v7 = (char *)*((_DWORD *)Src + 10);
      v8 = *v6;
      Srca = v7;
      if ( *v6 )
      {
        do
        {
          if ( v8 == 93 && v7[1] == 93 && v7[2] == 62 )
          {
            v7 += 2;
            xmlOutputBufferWrite((_DWORD *)v4, 9, "<![CDATA[");
            xmlOutputBufferWrite((_DWORD *)v4, v7 - Srca, Srca);
            xmlOutputBufferWrite((_DWORD *)v4, 3, "]]>");
            Srca = v7;
          }
          v8 = *++v7;
        }
        while ( *v7 );
        if ( Srca != v7 )
        {
          xmlOutputBufferWrite((_DWORD *)v4, 9, "<![CDATA[");
          xmlOutputBufferWriteString((_DWORD *)v4, Srca);
          v22 = "]]>";
LABEL_47:
          xmlOutputBufferWrite((_DWORD *)v4, 3, v22);
        }
      }
      break;
    case 2:
      sub_41D957((int)Src, a1);
      break;
    case 18:
      sub_41D767(a1, (int)Src, (_DWORD *)v4);
      break;
    default:
      v23 = *(_DWORD *)(a1 + 40);
      if ( v23 == 1 )
      {
        for ( i = *((_DWORD *)Src + 3); i; i = *(_DWORD *)(i + 24) )
        {
          v10 = *(_DWORD *)(i + 4);
          if ( v10 == 3 || v10 == 4 || v10 == 5 )
          {
            *(_DWORD *)(a1 + 40) = 0;
            break;
          }
        }
      }
      xmlOutputBufferWrite((_DWORD *)v4, 1, "<");
      v11 = *((_DWORD *)Src + 9);
      if ( v11 )
      {
        v12 = *(char **)(v11 + 12);
        if ( v12 )
        {
          xmlOutputBufferWriteString((_DWORD *)v4, v12);
          xmlOutputBufferWrite((_DWORD *)v4, 1, ":");
        }
      }
      xmlOutputBufferWriteString((_DWORD *)v4, *((char **)Src + 2));
      if ( *((_DWORD *)Src + 12) )
      {
        v13 = (_DWORD *)*((_DWORD *)Src + 12);
        do
        {
          sub_41D767(a1, (int)v13, *(_DWORD **)(a1 + 24));
          v13 = (_DWORD *)*v13;
        }
        while ( v13 );
        v2 = Src;
      }
      for ( j = *((_DWORD *)v2 + 11); j; j = *(_DWORD *)(j + 24) )
        sub_41D957(j, a1);
      if ( *((_DWORD *)v2 + 1) != 1 && *((_DWORD *)v2 + 10) || *((_DWORD *)v2 + 3) || (*(_BYTE *)(a1 + 32) & 4) != 0 )
      {
        if ( *(_DWORD *)(a1 + 40) == 2 )
          sub_41D701(1, a1);
        v15 = v24;
        xmlOutputBufferWrite(v24, 1, ">");
        if ( *((_DWORD *)v2 + 1) != 1 )
        {
          v16 = (const char *)*((_DWORD *)v2 + 10);
          if ( v16 )
            xmlOutputBufferWriteEscape((int)v24, v16, *(int (__cdecl **)(_BYTE *, int *, char *, int *))(a1 + 116));
        }
        if ( *((_DWORD *)v2 + 3) )
        {
          if ( *(_DWORD *)(a1 + 40) == 1 )
            xmlOutputBufferWrite(v24, 1, "\n");
          v17 = *(_DWORD *)(a1 + 36);
          if ( v17 >= 0 )
            *(_DWORD *)(a1 + 36) = v17 + 1;
          sub_41D9DF(*((_DWORD *)v2 + 3), a1);
          v18 = *(_DWORD *)(a1 + 36);
          if ( v18 > 0 )
            *(_DWORD *)(a1 + 36) = v18 - 1;
          if ( xmlIndentTreeOutput && *(_DWORD *)(a1 + 40) == 1 )
          {
            v19 = *(_DWORD *)(a1 + 36);
            if ( v19 > *(_DWORD *)(a1 + 108) )
              v19 = *(_DWORD *)(a1 + 108);
            xmlOutputBufferWrite(v24, v19 * *(_DWORD *)(a1 + 112), (char *)(a1 + 44));
          }
        }
        xmlOutputBufferWrite(v24, 2, "</");
        v20 = *((_DWORD *)v2 + 9);
        if ( v20 )
        {
          v21 = *(char **)(v20 + 12);
          if ( v21 )
          {
            xmlOutputBufferWriteString(v24, v21);
            xmlOutputBufferWrite(v24, 1, ":");
          }
        }
        xmlOutputBufferWriteString(v24, *((char **)v2 + 2));
        if ( *(_DWORD *)(a1 + 40) == 2 )
        {
          sub_41D701(0, a1);
          v15 = v24;
        }
        xmlOutputBufferWrite(v15, 1, ">");
      }
      else
      {
        if ( *(_DWORD *)(a1 + 40) == 2 )
          sub_41D701(0, a1);
        xmlOutputBufferWrite(v24, 2, "/>");
      }
      *(_DWORD *)(a1 + 40) = v23;
      break;
  }
}
// 4A4BA4: using guessed type int xmlIndentTreeOutput;

//----- (0041DEDF) --------------------------------------------------------
int __cdecl sub_41DEDF(int a1, _DWORD *Src)
{
  int v4; // edi
  int v5; // ecx
  int result; // eax
  int v7; // eax
  const char *CharEncodingName; // eax
  int v9; // eax
  unsigned int v10; // eax
  int v11; // eax
  _DWORD *i; // edi
  int v13; // edi
  int v14; // [esp+Ch] [ebp-14h]
  int v15; // [esp+10h] [ebp-10h]
  _DWORD *v16; // [esp+14h] [ebp-Ch]
  int v17; // [esp+18h] [ebp-8h]
  char *v18; // [esp+1Ch] [ebp-4h]
  int v19; // [esp+28h] [ebp+8h]
  char *Srca; // [esp+2Ch] [ebp+Ch]

  v19 = 0;
  v17 = Src[15];
  v18 = *(char **)(a1 + 16);
  Srca = v18;
  v4 = *(_DWORD *)(a1 + 24);
  v15 = *(_DWORD *)(a1 + 116);
  v14 = *(_DWORD *)(a1 + 120);
  v16 = (_DWORD *)v4;
  xmlInitParser();
  v5 = Src[1];
  if ( v5 != 13 && v5 != 9 )
    return -1;
  v7 = *(_DWORD *)(a1 + 16);
  if ( v7 )
  {
    Src[15] = v7;
    goto LABEL_10;
  }
  CharEncodingName = (const char *)Src[15];
  if ( !CharEncodingName )
  {
    if ( Src[19] == 1 )
      goto LABEL_10;
    CharEncodingName = xmlGetCharEncodingName(Src[19]);
  }
  Srca = (char *)CharEncodingName;
LABEL_10:
  if ( v5 == 13 && (*(_BYTE *)(a1 + 32) & 0x30) == 0 )
    return -1;
  v9 = *(_DWORD *)(a1 + 32);
  if ( (v9 & 0x40) != 0 )
    return -1;
  if ( v5 != 9 && (v9 & 0x30) == 0 )
    goto LABEL_47;
  v10 = xmlParseCharEncoding((int)Srca);
  if ( !Srca || v18 || *(_DWORD *)(v4 + 12) || *(_DWORD *)(v4 + 20) )
    goto LABEL_30;
  if ( (*(_BYTE *)(a1 + 32) & 2) != 0 )
  {
LABEL_41:
    for ( i = (_DWORD *)Src[3]; i; i = (_DWORD *)i[6] )
    {
      *(_DWORD *)(a1 + 36) = 0;
      sub_41DA5E(a1, i);
      xmlOutputBufferWrite(v16, 1, "\n");
    }
    if ( v19 )
    {
      if ( !v18 )
      {
        v13 = *(_DWORD *)(a1 + 24);
        xmlOutputBufferFlush((_DWORD *)v13);
        xmlCharEncCloseFunc(*(_DWORD **)(v13 + 12));
        xmlBufferFree(*(int **)(v13 + 20));
        *(_DWORD *)(v13 + 12) = 0;
        *(_DWORD *)(v13 + 20) = 0;
        *(_DWORD *)(a1 + 116) = v15;
        *(_DWORD *)(a1 + 120) = v14;
      }
    }
LABEL_47:
    result = 0;
    goto LABEL_24;
  }
  if ( v10 < 2 || v10 == 22 )
  {
LABEL_26:
    if ( *(int (__cdecl **)(char *, _DWORD *, char *, _DWORD *))(a1 + 116) == sub_41D287 )
      *(_DWORD *)(a1 + 116) = 0;
    if ( *(int (__cdecl **)(char *, _DWORD *, char *, _DWORD *))(a1 + 120) == sub_41D287 )
      *(_DWORD *)(a1 + 120) = 0;
LABEL_30:
    if ( (*(_BYTE *)(a1 + 32) & 2) == 0 )
    {
      xmlOutputBufferWrite((_DWORD *)v4, 14, "<?xml version=");
      if ( Src[14] )
        xmlBufferWriteQuotedString(*(int **)(v4 + 16), (_BYTE *)Src[14]);
      else
        xmlOutputBufferWrite((_DWORD *)v4, 5, "\"1.0\"");
      if ( Srca )
      {
        xmlOutputBufferWrite((_DWORD *)v4, 10, " encoding=");
        xmlBufferWriteQuotedString(*(int **)(v4 + 16), Srca);
      }
      v11 = Src[10];
      if ( v11 )
      {
        if ( v11 == 1 )
          xmlOutputBufferWrite((_DWORD *)v4, 17, " standalone=\"yes\"");
      }
      else
      {
        xmlOutputBufferWrite((_DWORD *)v4, 16, " standalone=\"no\"");
      }
      xmlOutputBufferWrite((_DWORD *)v4, 3, "?>\n");
    }
    goto LABEL_41;
  }
  if ( sub_41D68D(a1, Srca) >= 0 )
  {
    v19 = 1;
    goto LABEL_26;
  }
  result = -1;
LABEL_24:
  Src[15] = v17;
  return result;
}
// 41DF57: variable 'v5' is possibly undefined

//----- (0041E0E2) --------------------------------------------------------
int __cdecl xmlSaveToFd(int a1, char *a2, int a3)
{
  int v3; // eax
  int v4; // esi
  _DWORD *Fd; // eax

  v3 = sub_41D595(a2, a3);
  v4 = v3;
  if ( !v3 )
    return 0;
  Fd = xmlOutputBufferCreateFd(a1, *(_DWORD *)(v3 + 20));
  *(_DWORD *)(v4 + 24) = Fd;
  if ( !Fd )
  {
    sub_41D56B(v4);
    return 0;
  }
  return v4;
}

//----- (0041E11D) --------------------------------------------------------
int __cdecl xmlSaveToFilename(char *a1, char *a2, int a3)
{
  int v3; // eax
  int v4; // esi
  _DWORD *Filename; // eax

  v3 = sub_41D595(a2, a3);
  v4 = v3;
  if ( !v3 )
    return 0;
  Filename = xmlOutputBufferCreateFilename(a1, *(_DWORD *)(v3 + 20));
  *(_DWORD *)(v4 + 24) = Filename;
  if ( !Filename )
  {
    sub_41D56B(v4);
    return 0;
  }
  return v4;
}

//----- (0041E15B) --------------------------------------------------------
int __cdecl xmlSaveToBuffer(int a1, char *a2, int a3)
{
  int result; // eax
  int v4; // ebx
  _DWORD *CharEncodingHandler; // esi
  _DWORD *Buffer; // eax

  result = sub_41D595(a2, a3);
  v4 = result;
  if ( result )
  {
    if ( a2 )
    {
      CharEncodingHandler = (_DWORD *)xmlFindCharEncodingHandler(a2);
      if ( !CharEncodingHandler )
      {
        ((void (__cdecl *)(int))xmlFree)(v4);
        return 0;
      }
    }
    else
    {
      CharEncodingHandler = 0;
    }
    Buffer = xmlOutputBufferCreateBuffer(a1, (int)CharEncodingHandler);
    if ( !Buffer )
    {
      ((void (__cdecl *)(int))xmlFree)(v4);
      if ( CharEncodingHandler )
        xmlCharEncCloseFunc(CharEncodingHandler);
      return 0;
    }
    *(_DWORD *)(v4 + 24) = Buffer;
    return v4;
  }
  return result;
}
// 496494: invalid function type has been ignored

//----- (0041E1BE) --------------------------------------------------------
int __cdecl xmlSaveToIO(int a1, int a2, int a3, char *a4, int a5)
{
  int v5; // eax
  int v6; // esi
  _DWORD *IO; // eax

  v5 = sub_41D595(a4, a5);
  v6 = v5;
  if ( !v5 )
    return 0;
  IO = xmlOutputBufferCreateIO(a1, a2, a3, *(_DWORD *)(v5 + 20));
  *(_DWORD *)(v6 + 24) = IO;
  if ( !IO )
  {
    sub_41D56B(v6);
    return 0;
  }
  return v6;
}

//----- (0041E201) --------------------------------------------------------
int __cdecl xmlSaveDoc(int a1, _DWORD *Src)
{
  if ( a1 && Src )
    return (sub_41DEDF(a1, Src) >= 0) - 1;
  else
    return -1;
}

//----- (0041E22D) --------------------------------------------------------
int __cdecl xmlSaveTree(int a1, void *a2)
{
  if ( !a1 || !a2 )
    return -1;
  sub_41DA5E(a1, a2);
  return 0;
}

//----- (0041E251) --------------------------------------------------------
int __cdecl xmlSaveFlush(int a1)
{
  _DWORD *v2; // eax

  if ( a1 && (v2 = *(_DWORD **)(a1 + 24)) != 0 )
    return xmlOutputBufferFlush(v2);
  else
    return -1;
}

//----- (0041E26C) --------------------------------------------------------
int __cdecl xmlSaveClose(int a1)
{
  int v2; // edi

  if ( !a1 )
    return -1;
  v2 = xmlSaveFlush(a1);
  sub_41D56B(a1);
  return v2;
}

//----- (0041E28E) --------------------------------------------------------
int __cdecl xmlSaveSetEscape(int a1, int a2)
{
  if ( !a1 )
    return -1;
  *(_DWORD *)(a1 + 116) = a2;
  return 0;
}

//----- (0041E2A4) --------------------------------------------------------
int __cdecl xmlSaveSetAttrEscape(int a1, int a2)
{
  if ( !a1 )
    return -1;
  *(_DWORD *)(a1 + 120) = a2;
  return 0;
}

//----- (0041E2BA) --------------------------------------------------------
unsigned __int8 *__cdecl xmlAttrSerializeTxtContent(
        int *a1,
        int a2,
        int (__cdecl *a3)(int, char *Format, char ArgList),
        unsigned __int8 *Src)
{
  unsigned __int8 *result; // eax
  int v5; // edi
  unsigned __int8 *v6; // esi
  unsigned __int8 v7; // cl
  unsigned __int8 v8; // al
  unsigned __int8 v9; // cl
  int v10; // eax
  int v11; // eax
  int v12; // edi
  int v13; // [esp-8h] [ebp-28h]
  char v14[12]; // [esp+10h] [ebp-10h] BYREF

  result = Src;
  v5 = a2;
  if ( Src )
  {
    v6 = Src;
    if ( *Src )
    {
      while ( 1 )
      {
        v7 = *v6;
        if ( *v6 == 10 )
        {
          if ( result != v6 )
            xmlBufferAdd(a1, result, v6 - result);
          xmlBufferAdd(a1, "&#10;", 5);
        }
        else
        {
          switch ( v7 )
          {
            case 0xDu:
              if ( result != v6 )
                xmlBufferAdd(a1, result, v6 - result);
              xmlBufferAdd(a1, "&#13;", 5);
              break;
            case 9u:
              if ( result != v6 )
                xmlBufferAdd(a1, result, v6 - result);
              xmlBufferAdd(a1, "&#9;", 4);
              break;
            case 0x22u:
              if ( result != v6 )
                xmlBufferAdd(a1, result, v6 - result);
              xmlBufferAdd(a1, "&quot;", 6);
              break;
            case 0x3Cu:
              if ( result != v6 )
                xmlBufferAdd(a1, result, v6 - result);
              xmlBufferAdd(a1, "&lt;", 4);
              break;
            case 0x3Eu:
              if ( result != v6 )
                xmlBufferAdd(a1, result, v6 - result);
              xmlBufferAdd(a1, "&gt;", 4);
              break;
            case 0x26u:
              if ( result != v6 )
                xmlBufferAdd(a1, result, v6 - result);
              xmlBufferAdd(a1, "&amp;", 5);
              break;
            default:
              if ( v7 < 0x80u || v5 && *(_DWORD *)(v5 + 60) )
              {
                ++v6;
                goto LABEL_61;
              }
              if ( result != v6 )
                xmlBufferAdd(a1, result, v6 - result);
              v8 = *v6;
              if ( *v6 < 0xC0u )
              {
                sub_41D13A(1400, a3, 0);
LABEL_39:
                if ( v5 )
                  *(_DWORD *)(v5 + 60) = xmlStrdup("ISO-8859-1");
                sub_41D187(*v6, v14);
                xmlBufferAdd(a1, v14, -1);
                break;
              }
              if ( v8 < 0xE0u )
              {
                v9 = v6[1];
                v10 = v8 & 0x1F;
                v13 = 2;
                goto LABEL_48;
              }
              if ( v8 < 0xF0u )
              {
                v10 = v6[1] & 0x3F | ((v8 & 0xF) << 6);
                v9 = v6[2];
                v13 = 3;
                goto LABEL_48;
              }
              if ( v8 < 0xF8u )
              {
                v10 = v6[2] & 0x3F | ((v6[1] & 0x3F | ((v8 & 7) << 6)) << 6);
                v9 = v6[3];
                v13 = 4;
LABEL_48:
                v11 = v9 & 0x3F | (v10 << 6);
                v12 = v13;
                if ( v11 >= 256 )
                {
                  if ( v11 <= 55295 || v11 >= 57344 && v11 <= 65533 || (unsigned int)(v11 - 0x10000) <= 0xFFFFF )
                  {
LABEL_59:
                    sub_41D187(v11, v14);
                    xmlBufferAdd(a1, v14, -1);
                    v6 += v12;
                    v5 = a2;
                    result = v6;
                    goto LABEL_61;
                  }
                }
                else if ( v11 >= 9 && v11 <= 10 || v11 == 13 || v11 >= 32 )
                {
                  goto LABEL_59;
                }
                v5 = a2;
              }
              sub_41D13A(1401, a3, 0);
              goto LABEL_39;
          }
        }
        result = ++v6;
LABEL_61:
        if ( !*v6 )
        {
          if ( result != v6 )
            return (unsigned __int8 *)xmlBufferAdd(a1, result, v6 - result);
          return result;
        }
      }
    }
  }
  return result;
}

//----- (0041E555) --------------------------------------------------------
int __cdecl xmlNodeDump(int a1, int a2, void *a3, int a4, int a5)
{
  _DWORD *v6; // esi
  int v7; // edi

  xmlInitParser();
  if ( !a3 )
    return -1;
  if ( !a1 )
    return -1;
  v6 = (_DWORD *)xmlMalloc(32);
  if ( v6 )
  {
    memset(v6, 0, 0x20u);
    v6[4] = a1;
    v6[3] = 0;
    v6[1] = 0;
    v6[2] = 0;
    *v6 = 0;
    v6[6] = 0;
    v7 = *(_DWORD *)(a1 + 4);
    xmlNodeDumpOutput((int)v6, a2, a3, a4, a5, 0);
    ((void (__cdecl *)(_DWORD *))xmlFree)(v6);
    return *(_DWORD *)(a1 + 4) - v7;
  }
  else
  {
    sub_41D125("creating buffer");
    return -1;
  }
}
// 496494: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (0041E5DA) --------------------------------------------------------
_DWORD *__cdecl xmlElemDump(int a1, int a2, int (__cdecl *a3)(int, char *Format, char ArgList))
{
  _DWORD *result; // eax
  _DWORD *v4; // edi

  result = (_DWORD *)xmlInitParser();
  if ( a3 )
  {
    result = xmlOutputBufferCreateFile(a1, 0);
    v4 = result;
    if ( result )
    {
      if ( a2 && *(_DWORD *)(a2 + 4) == 13 )
        sub_41D13A(1, a3, "HTML support not compiled in\n");
      else
        xmlNodeDumpOutput((int)result, a2, a3, 0, 1, 0);
      return (_DWORD *)xmlOutputBufferClose(v4);
    }
  }
  return result;
}

//----- (0041E639) --------------------------------------------------------
void __cdecl xmlNodeDumpOutput(int a1, int a2, void *a3, int a4, int a5, const char *a6)
{
  const char *v6; // esi
  int v7[31]; // [esp+10h] [ebp-80h] BYREF

  v6 = a6;
  xmlInitParser();
  if ( a1 && a3 )
  {
    if ( !a6 )
      v6 = "UTF-8";
    memset(v7, 0, sizeof(v7));
    v7[9] = a4;
    v7[4] = (int)v6;
    v7[7] = a2;
    v7[6] = a1;
    v7[10] = a5 != 0;
    sub_41D4DA(v7);
    v7[8] |= 0x20u;
    sub_41DA5E((int)v7, a3);
  }
}

//----- (0041E6CF) --------------------------------------------------------
int (__cdecl *__cdecl xmlDocDumpFormatMemoryEnc(
        _DWORD *a1,
        int (__cdecl *a2)(int, char *Format, char ArgList),
        int *a3,
        char *a4,
        int a5))(int, char *Format, char ArgList)
{
  int *v5; // ebx
  char *v6; // esi
  int (__cdecl *result)(int, char *, char); // eax
  _DWORD *v8; // edi
  int v9; // eax
  _BYTE *v10; // eax
  int v11; // eax
  int v12; // [esp+Ch] [ebp-28h] BYREF
  void *Src; // [esp+10h] [ebp-24h]
  int (__cdecl *v14)(int, char *, char); // [esp+14h] [ebp-20h]
  int v15[31]; // [esp+18h] [ebp-1Ch] BYREF

  v5 = a3;
  v6 = a4;
  result = 0;
  Src = a1;
  v14 = a2;
  v12 = 0;
  if ( !a3 )
    v5 = &v12;
  if ( a2 )
  {
    *(_DWORD *)a2 = 0;
    *v5 = 0;
    if ( a1 )
    {
      if ( (a4 || (v6 = (char *)a1[15]) != 0)
        && (result = (int (__cdecl *)(int, char *, char))xmlFindCharEncodingHandler(v6)) == 0 )
      {
        return sub_41D13A(1403, (int (__cdecl *)(int, char *, char))a1, v6);
      }
      else
      {
        v8 = xmlAllocOutputBuffer((int)result);
        if ( v8 )
        {
          memset(v15, 0, sizeof(v15));
          v15[9] = 0;
          v15[7] = (int)Src;
          v15[4] = (int)v6;
          v15[6] = (int)v8;
          v15[10] = a5 != 0;
          sub_41D4DA(v15);
          v15[8] |= 0x20u;
          sub_41DEDF((int)v15, Src);
          xmlOutputBufferFlush(v8);
          if ( v8[5] )
          {
            v9 = *(_DWORD *)(v8[5] + 4);
            *v5 = v9;
            v10 = xmlStrndup(*(void **)v8[5], v9);
          }
          else
          {
            v11 = *(_DWORD *)(v8[4] + 4);
            *v5 = v11;
            v10 = xmlStrndup(*(void **)v8[4], v11);
          }
          *(_DWORD *)v14 = v10;
          xmlOutputBufferClose(v8);
          result = v14;
          if ( !*(_DWORD *)v14 && *v5 > 0 )
          {
            *v5 = 0;
            return sub_41D125("creating output");
          }
        }
        else
        {
          return sub_41D125("creating buffer");
        }
      }
    }
  }
  else
  {
    *v5 = 0;
  }
  return result;
}

//----- (0041E805) --------------------------------------------------------
int (__cdecl *__cdecl xmlDocDumpMemory(
        _DWORD *a1,
        int (__cdecl *a2)(int, char *Format, char ArgList),
        int *a3))(int, char *Format, char ArgList)
{
  return xmlDocDumpFormatMemoryEnc(a1, a2, a3, 0, 0);
}

//----- (0041E81E) --------------------------------------------------------
int (__cdecl *__cdecl xmlDocDumpFormatMemory(
        _DWORD *a1,
        int (__cdecl *a2)(int, char *Format, char ArgList),
        int *a3,
        int a4))(int, char *Format, char ArgList)
{
  return xmlDocDumpFormatMemoryEnc(a1, a2, a3, 0, a4);
}

//----- (0041E839) --------------------------------------------------------
int (__cdecl *__cdecl xmlDocDumpMemoryEnc(
        _DWORD *a1,
        int (__cdecl *a2)(int, char *Format, char ArgList),
        int *a3,
        char *a4))(int, char *Format, char ArgList)
{
  return xmlDocDumpFormatMemoryEnc(a1, a2, a3, a4, 0);
}

//----- (0041E854) --------------------------------------------------------
int __cdecl xmlDocFormatDump(int a1, _DWORD *Src, int a3)
{
  int CharEncodingHandler; // ebx
  int v5; // esi
  _DWORD *File; // ebx
  int v7[31]; // [esp+Ch] [ebp-80h] BYREF

  CharEncodingHandler = 0;
  if ( !Src )
    return -1;
  v5 = Src[15];
  if ( v5 )
  {
    CharEncodingHandler = xmlFindCharEncodingHandler((const char *)Src[15]);
    if ( !CharEncodingHandler )
    {
      ((void (__cdecl *)(_DWORD))xmlFree)(Src[15]);
      v5 = 0;
      Src[15] = 0;
    }
  }
  File = xmlOutputBufferCreateFile(a1, CharEncodingHandler);
  if ( !File )
    return -1;
  memset(v7, 0, sizeof(v7));
  v7[9] = 0;
  v7[4] = v5;
  v7[7] = (int)Src;
  v7[6] = (int)File;
  v7[10] = a3 != 0;
  sub_41D4DA(v7);
  v7[8] |= 0x20u;
  sub_41DEDF((int)v7, Src);
  return xmlOutputBufferClose(File);
}
// 496494: invalid function type has been ignored

//----- (0041E912) --------------------------------------------------------
int __cdecl xmlDocDump(int a1, _DWORD *Src)
{
  return xmlDocFormatDump(a1, Src, 0);
}

//----- (0041E925) --------------------------------------------------------
int __cdecl xmlSaveFileTo(_DWORD *Block, _DWORD *Src, int a3)
{
  int v4[31]; // [esp+Ch] [ebp-80h] BYREF

  if ( !Block )
    return -1;
  if ( !Src )
  {
    xmlOutputBufferClose(Block);
    return -1;
  }
  memset(v4, 0, sizeof(v4));
  v4[9] = 0;
  v4[10] = 0;
  v4[4] = a3;
  v4[7] = (int)Src;
  v4[6] = (int)Block;
  sub_41D4DA(v4);
  v4[8] |= 0x20u;
  sub_41DEDF((int)v4, Src);
  return xmlOutputBufferClose(Block);
}

//----- (0041E9A5) --------------------------------------------------------
int __cdecl xmlSaveFormatFileTo(_DWORD *Block, _DWORD *Src, int a3, int a4)
{
  int v4; // eax
  int v6[31]; // [esp+Ch] [ebp-80h] BYREF

  if ( Block )
  {
    if ( Src )
    {
      v4 = Src[1];
      if ( v4 == 9 || v4 == 13 )
      {
        memset(v6, 0, sizeof(v6));
        v6[9] = 0;
        v6[4] = a3;
        v6[7] = (int)Src;
        v6[6] = (int)Block;
        v6[10] = a4 != 0;
        sub_41D4DA(v6);
        v6[8] |= 0x20u;
        sub_41DEDF((int)v6, Src);
        return xmlOutputBufferClose(Block);
      }
    }
    xmlOutputBufferClose(Block);
  }
  return -1;
}

//----- (0041EA37) --------------------------------------------------------
int __cdecl xmlSaveFormatFileEnc(char *a1, _DWORD *Src, const char *a3, int a4)
{
  const char *v4; // esi
  int CharEncodingHandler; // eax
  _DWORD *Filename; // ebx
  int v8[31]; // [esp+Ch] [ebp-80h] BYREF

  v4 = a3;
  CharEncodingHandler = 0;
  if ( !Src )
    return -1;
  if ( a3 || (v4 = (const char *)Src[15]) != 0 )
  {
    CharEncodingHandler = xmlFindCharEncodingHandler(v4);
    if ( !CharEncodingHandler )
      return -1;
  }
  Filename = xmlOutputBufferCreateFilename(a1, CharEncodingHandler);
  if ( !Filename )
    return -1;
  memset(v8, 0, sizeof(v8));
  v8[9] = 0;
  v8[4] = (int)v4;
  v8[7] = (int)Src;
  v8[6] = (int)Filename;
  v8[10] = a4 != 0;
  sub_41D4DA(v8);
  v8[8] |= 0x20u;
  sub_41DEDF((int)v8, Src);
  return xmlOutputBufferClose(Filename);
}

//----- (0041EADC) --------------------------------------------------------
int __cdecl xmlSaveFileEnc(char *a1, _DWORD *Src, const char *a3)
{
  return xmlSaveFormatFileEnc(a1, Src, a3, 0);
}

//----- (0041EAF3) --------------------------------------------------------
int __cdecl xmlSaveFormatFile(char *a1, _DWORD *Src, int a3)
{
  return xmlSaveFormatFileEnc(a1, Src, 0, a3);
}

//----- (0041EB0A) --------------------------------------------------------
int __cdecl xmlSaveFile(char *a1, _DWORD *Src)
{
  return xmlSaveFormatFileEnc(a1, Src, 0, 0);
}

//----- (0041EB1F) --------------------------------------------------------
int __usercall sub_41EB1F@<eax>(int *a1@<eax>, int a2@<ecx>, unsigned int a3)
{
  int v4; // eax
  unsigned int v6; // eax

  v4 = 0;
  if ( a1 && (a1[90] & 0x80000) == 0 )
  {
    if ( a1[97] == 89 )
      return 1;
    if ( a3 )
    {
      if ( a3 < 0x3E8 )
        return 0;
      if ( a1[9] )
        v4 = *(_DWORD *)(a1[9] + 16) + *(_DWORD *)(a1[9] + 36) - *(_DWORD *)(a1[9] + 12);
      v6 = 10 * (a1[111] + v4);
      if ( a3 < v6 && 3 * a1[110] < v6 )
        return 0;
    }
    else
    {
      if ( !a2 )
        return 0;
      if ( a1[9] )
        v4 = *(_DWORD *)(a1[9] + 16) + *(_DWORD *)(a1[9] + 36) - *(_DWORD *)(a1[9] + 12);
      if ( 3 * *(_DWORD *)(a2 + 72) < (unsigned int)(10 * (v4 + a1[111])) )
        return 0;
    }
    sub_41EC3F(89, a1, 0);
    return 1;
  }
  return 0;
}

//----- (0041EBBA) --------------------------------------------------------
int (__cdecl *__usercall sub_41EBBA@<eax>(
        int (__cdecl *result)(int, char *Format, char ArgList)@<eax>,
        int *a2@<edi>,
        _BYTE *Src))(int, char *Format, char ArgList)
{
  if ( a2 )
  {
    if ( a2[53] && a2[43] == -1 )
      return result;
    a2[21] = 42;
  }
  if ( Src )
    result = _xmlRaiseError(
               0,
               0,
               0,
               a2,
               0,
               1,
               42,
               3,
               0,
               0,
               Src,
               result,
               0,
               0,
               0,
               "Attribute %s:%s redefined\n",
               Src,
               (const char *)result);
  else
    result = _xmlRaiseError(
               0,
               0,
               0,
               a2,
               0,
               1,
               42,
               3,
               0,
               0,
               result,
               0,
               0,
               0,
               0,
               "Attribute %s redefined\n",
               (const char *)result);
  if ( a2 )
  {
    a2[3] = 0;
    if ( !a2[72] )
      a2[53] = 1;
  }
  return result;
}

//----- (0041EC3F) --------------------------------------------------------
void __usercall sub_41EC3F(int a1@<ecx>, int *a2@<ebx>, _BYTE *Src)
{
  char *v3; // eax

  if ( a2 && a2[53] && a2[43] == -1 )
    return;
  if ( a1 > 55 )
  {
    if ( a1 > 75 )
    {
      if ( a1 > 85 )
      {
        switch ( a1 )
        {
          case 'V':
            v3 = "extra content at the end of well balanced chunk\n";
            goto LABEL_123;
          case 'X':
            v3 = "PEReferences forbidden in internal subset\n";
            goto LABEL_123;
          case 'Y':
            v3 = "Detected an entity reference loop\n";
            goto LABEL_123;
          case '\\':
            v3 = "Fragment not allowed";
            goto LABEL_123;
          case '_':
            v3 = "conditional section INCLUDE or IGNORE keyword expected\n";
            goto LABEL_123;
          case '`':
            v3 = "Malformed declaration expecting version\n";
            goto LABEL_123;
        }
      }
      else
      {
        switch ( a1 )
        {
          case 'U':
            v3 = "chunk is not well balanced\n";
            goto LABEL_123;
          case 'N':
            v3 = "standalone accepts only 'yes' or 'no'\n";
            goto LABEL_123;
          case 'O':
            v3 = "Invalid XML encoding name\n";
            goto LABEL_123;
          case 'P':
            v3 = "Comment must not contain '--' (double-hyphen)\n";
            goto LABEL_123;
          case 'R':
            v3 = "external parsed entities cannot be standalone\n";
            goto LABEL_123;
          case 'S':
            v3 = "XML conditional section '[' expected\n";
            goto LABEL_123;
          case 'T':
            v3 = "Entity value required\n";
            goto LABEL_123;
        }
      }
    }
    else
    {
      if ( a1 == 75 )
      {
        v3 = "expected '='\n";
        goto LABEL_123;
      }
      if ( a1 > 64 )
      {
        switch ( a1 )
        {
          case 'C':
            v3 = "NmToken expected in ATTLIST enumeration\n";
            goto LABEL_123;
          case 'E':
            v3 = "MixedContentDecl : '#PCDATA' expected\n";
            goto LABEL_123;
          case 'F':
            v3 = "SYSTEM or PUBLIC, the URI is missing\n";
            goto LABEL_123;
          case 'G':
            v3 = "PUBLIC, the Public Identifier is missing\n";
            goto LABEL_123;
          case 'I':
            v3 = "expected '>'\n";
            goto LABEL_123;
          case 'J':
            v3 = "EndTag: '</' not found\n";
            goto LABEL_123;
        }
      }
      else
      {
        switch ( a1 )
        {
          case '@':
            v3 = "Invalid PI name\n";
            goto LABEL_123;
          case '8':
            v3 = "Text declaration '<?xml' required\n";
            goto LABEL_123;
          case '9':
            v3 = "parsing XML declaration: '?>' expected\n";
            goto LABEL_123;
          case ';':
            v3 = "XML conditional section not closed\n";
            goto LABEL_123;
          case '<':
            v3 = "Content error in the external subset\n";
            goto LABEL_123;
          case '=':
            v3 = "DOCTYPE improperly terminated\n";
            goto LABEL_123;
          case '>':
            v3 = "Sequence ']]>' not allowed in content\n";
            goto LABEL_123;
        }
      }
    }
    goto LABEL_116;
  }
  if ( a1 == 55 )
  {
    v3 = "ContentDecl : ',' '|' or ')' expected\n";
    goto LABEL_123;
  }
  if ( a1 > 34 )
  {
    if ( a1 > 46 )
    {
      switch ( a1 )
      {
        case '0':
          v3 = "NOTATION: Name expected here\n";
          goto LABEL_123;
        case '1':
          v3 = "'>' required to close NOTATION declaration\n";
          goto LABEL_123;
        case '2':
          v3 = "'(' required to start ATTLIST enumeration\n";
          goto LABEL_123;
        case '3':
          v3 = "')' required to finish ATTLIST enumeration\n";
          goto LABEL_123;
        case '4':
          v3 = "MixedContentDecl : '|' or ')*' expected\n";
          goto LABEL_123;
        case '6':
          v3 = "ContentDecl : Name or '(' expected\n";
          goto LABEL_123;
      }
    }
    else
    {
      switch ( a1 )
      {
        case '.':
          v3 = "xmlParsePI : no target name\n";
          goto LABEL_123;
        case '$':
        case '%':
          v3 = "EntityValue: \" or ' expected\n";
          goto LABEL_123;
        case '&':
          v3 = "Unescaped '<' not allowed in attributes values\n";
          goto LABEL_123;
        case '\'':
          v3 = "AttValue: \" or ' expected\n";
          goto LABEL_123;
        case '+':
          v3 = "SystemLiteral \" or ' expected\n";
          goto LABEL_123;
        case ',':
          v3 = "Unfinished System or Public ID \" or ' expected\n";
          goto LABEL_123;
      }
    }
    goto LABEL_116;
  }
  if ( a1 == 34 )
  {
    v3 = "String not closed expecting \" or '\n";
    goto LABEL_123;
  }
  if ( a1 > 19 )
  {
    switch ( a1 )
    {
      case 20:
        v3 = "PEReference in epilog\n";
        goto LABEL_123;
      case 21:
        v3 = "PEReference: forbidden within markup decl in internal subset\n";
        goto LABEL_123;
      case 23:
        v3 = "EntityRef: expecting ';'\n";
        goto LABEL_123;
      case 24:
        v3 = "PEReference: no name\n";
        goto LABEL_123;
      case 25:
        v3 = "PEReference: expecting ';'\n";
        goto LABEL_123;
      case 33:
        v3 = "String not started expecting ' or \"\n";
        goto LABEL_123;
    }
    goto LABEL_116;
  }
  switch ( a1 )
  {
    case 19:
      v3 = "PEReference in prolog\n";
      goto LABEL_123;
    case 1:
      v3 = "internal error";
      goto LABEL_123;
    case 4:
      v3 = "Document is empty\n";
      goto LABEL_123;
    case 5:
      v3 = "Extra content at the end of the document\n";
      goto LABEL_123;
    case 6:
      v3 = "CharRef: invalid hexadecimal value\n";
      goto LABEL_123;
    case 7:
      v3 = "CharRef: invalid decimal value\n";
      goto LABEL_123;
    case 8:
      v3 = "CharRef: invalid value\n";
      goto LABEL_123;
  }
  if ( a1 != 18 )
  {
LABEL_116:
    v3 = "Unregistered error message\n";
    goto LABEL_123;
  }
  v3 = "PEReference at end of document\n";
LABEL_123:
  if ( a2 )
    a2[21] = a1;
  _xmlRaiseError(0, 0, 0, a2, 0, 1, a1, 3, 0, 0, Src, 0, 0, 0, 0, v3, Src);
  if ( a2 )
  {
    a2[3] = 0;
    if ( !a2[72] )
      a2[53] = 1;
  }
}

//----- (0041EFC6) --------------------------------------------------------
int (__cdecl *__usercall sub_41EFC6@<eax>(
        int (__cdecl *result)(int, char *Format, char ArgList)@<eax>,
        int *a2@<edi>,
        const char *ArgList))(int, char *Format, char ArgList)
{
  if ( a2 )
  {
    if ( a2[53] && a2[43] == -1 )
      return result;
    a2[21] = (int)result;
  }
  result = _xmlRaiseError(0, 0, 0, a2, 0, 1, (int)result, 3, 0, 0, 0, 0, 0, 0, 0, "%s", ArgList);
  if ( a2 )
  {
    a2[3] = 0;
    if ( !a2[72] )
      a2[53] = 1;
  }
  return result;
}

//----- (0041F01E) --------------------------------------------------------
int (__cdecl *__usercall sub_41F01E@<eax>(
        int a1@<ecx>,
        _BYTE *a2@<esi>,
        int a3,
        char *Format))(int, char *Format, char ArgList)
{
  int (__cdecl *result)(int, char *, char); // eax
  int (__cdecl *v5)(FILE *, int *); // edi
  _DWORD *v6; // edx
  int (__cdecl *v7)(int, char *, char); // edx

  result = 0;
  v5 = 0;
  if ( !a1 )
    return _xmlRaiseError(0, 0, 0, 0, 0, 1, a3, 1, 0, 0, a2, 0, 0, 0, 0, Format, a2, 0);
  if ( !*(_DWORD *)(a1 + 212) || *(_DWORD *)(a1 + 172) != -1 )
  {
    v6 = *(_DWORD **)a1;
    if ( *(_DWORD *)a1 )
    {
      if ( v6[27] == -554844497 )
        v5 = (int (__cdecl *)(FILE *, int *))v6[31];
      v7 = (int (__cdecl *)(int, char *, char))v6[21];
    }
    else
    {
      v7 = 0;
    }
    return _xmlRaiseError(v5, v7, *(FILE **)(a1 + 4), (int *)a1, 0, 1, a3, 1, 0, 0, a2, 0, 0, 0, 0, Format, a2, 0);
  }
  return result;
}

//----- (0041F093) --------------------------------------------------------
int (__cdecl *__usercall sub_41F093@<eax>(
        int (__cdecl *result)(int, char *Format, char ArgList)@<eax>,
        int *a2@<edi>,
        char *Format,
        int ArgList))(int, char *Format, char ArgList)
{
  if ( a2 )
  {
    if ( a2[53] && a2[43] == -1 )
      return result;
    a2[21] = (int)result;
  }
  result = _xmlRaiseError(0, 0, 0, a2, 0, 1, (int)result, 3, 0, 0, 0, 0, 0, ArgList, 0, Format, ArgList);
  if ( a2 )
  {
    a2[3] = 0;
    if ( !a2[72] )
      a2[53] = 1;
  }
  return result;
}

//----- (0041F0ED) --------------------------------------------------------
int (__cdecl *__usercall sub_41F0ED@<eax>(
        int (__cdecl *result)(int, char *Format, char ArgList)@<eax>,
        int *a2@<edi>,
        char *Format,
        _BYTE *Src,
        int a5,
        _BYTE *a6))(int, char *Format, char ArgList)
{
  if ( a2 )
  {
    if ( a2[53] && a2[43] == -1 )
      return result;
    a2[21] = (int)result;
  }
  result = _xmlRaiseError(0, 0, 0, a2, 0, 1, (int)result, 3, 0, 0, Src, a6, 0, a5, 0, Format, Src, a5, a6);
  if ( a2 )
  {
    a2[3] = 0;
    if ( !a2[72] )
      a2[53] = 1;
  }
  return result;
}

//----- (0041F152) --------------------------------------------------------
int (__cdecl *__usercall sub_41F152@<eax>(
        int (__cdecl *result)(int, char *Format, char ArgList)@<eax>,
        int *a2@<edi>,
        char *Format,
        _BYTE *Src))(int, char *Format, char ArgList)
{
  if ( a2 )
  {
    if ( a2[53] && a2[43] == -1 )
      return result;
    a2[21] = (int)result;
  }
  result = _xmlRaiseError(0, 0, 0, a2, 0, 1, (int)result, 3, 0, 0, Src, 0, 0, 0, 0, Format, Src);
  if ( a2 )
  {
    a2[3] = 0;
    if ( !a2[72] )
      a2[53] = 1;
  }
  return result;
}

//----- (0041F1AC) --------------------------------------------------------
int (__cdecl *__usercall sub_41F1AC@<eax>(
        int *a1@<ecx>,
        int a2@<edx>,
        char *Format,
        _BYTE *Src))(int, char *Format, char ArgList)
{
  int (__cdecl *result)(int, char *, char); // eax

  result = 0;
  if ( !a1 )
    return _xmlRaiseError(0, 0, 0, a1, 0, 1, a2, 2, 0, 0, Src, 0, 0, 0, 0, Format, Src);
  if ( !a1[53] || a1[43] != -1 )
  {
    a1[21] = a2;
    return _xmlRaiseError(0, 0, 0, a1, 0, 1, a2, 2, 0, 0, Src, 0, 0, 0, 0, Format, Src);
  }
  return result;
}

//----- (0041F1EB) --------------------------------------------------------
int (__cdecl *__usercall sub_41F1EB@<eax>(
        int (__cdecl *result)(int, char *Format, char ArgList)@<eax>,
        int *a2@<edi>,
        char *Format,
        _BYTE *Src,
        _BYTE *a5,
        _BYTE *a6))(int, char *Format, char ArgList)
{
  if ( !a2 )
    goto LABEL_5;
  if ( !a2[53] || a2[43] != -1 )
  {
    a2[21] = (int)result;
LABEL_5:
    result = _xmlRaiseError(0, 0, 0, a2, 0, 3, (int)result, 2, 0, 0, Src, a5, a6, 0, 0, Format, Src, a5, a6);
    if ( a2 )
      a2[89] = 0;
  }
  return result;
}

//----- (0041F241) --------------------------------------------------------
int (__cdecl *__cdecl sub_41F241(char *Format, _BYTE *Src, _BYTE *a3))(int, char *Format, char ArgList)
{
  int *v3; // ecx
  int (__cdecl *result)(int, char *, char); // eax

  result = 0;
  if ( !v3 || !v3[53] || v3[43] != -1 )
    return _xmlRaiseError(0, 0, 0, v3, 0, 3, 100, 1, 0, 0, Src, a3, 0, 0, 0, Format, Src, a3, 0);
  return result;
}
// 41F248: variable 'v3' is possibly undefined

//----- (0041F285) --------------------------------------------------------
int __cdecl xmlHasFeature(int a1)
{
  int result; // eax

  switch ( a1 )
  {
    case 2:
    case 3:
    case 4:
    case 5:
    case 7:
    case 8:
      result = 1;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (0041F321) --------------------------------------------------------
void __usercall sub_41F321(int a1@<esi>)
{
  _DWORD *v1; // eax
  unsigned __int8 *v2; // eax
  unsigned __int8 *v3; // eax
  unsigned __int8 *v4; // eax
  _DWORD *v5; // [esp-24h] [ebp-28h]
  _DWORD *v6; // [esp-18h] [ebp-1Ch]

  if ( a1 )
  {
    v1 = *(_DWORD **)a1;
    if ( *(_DWORD *)a1 && v1[27] == -554844497 && (v1[29] || v1[30]) )
      *(_DWORD *)(a1 + 324) = 1;
    v2 = xmlDictLookup(*(_DWORD **)(a1 + 296), "xml", 3);
    v6 = *(_DWORD **)(a1 + 296);
    *(_DWORD *)(a1 + 312) = v2;
    v3 = xmlDictLookup(v6, "xmlns", 5);
    v5 = *(_DWORD **)(a1 + 296);
    *(_DWORD *)(a1 + 316) = v3;
    v4 = xmlDictLookup(v5, "http://www.w3.org/XML/1998/namespace", 36);
    *(_DWORD *)(a1 + 320) = v4;
    if ( !*(_DWORD *)(a1 + 312) || !*(_DWORD *)(a1 + 316) || !v4 )
      xmlErrMemory(a1, 0);
  }
}

//----- (0041F3B9) --------------------------------------------------------
char *__fastcall sub_41F3B9(char *a1, char *a2)
{
  char v3; // al

  if ( !a1 || !a2 )
    return 0;
  while ( *a1 == 32 )
    ++a1;
  while ( 1 )
  {
    v3 = *a1;
    if ( !*a1 )
      break;
    if ( v3 == 32 )
    {
      do
        ++a1;
      while ( *a1 == 32 );
      if ( !*a1 )
        break;
      *a2++ = 32;
    }
    else
    {
      *a2++ = v3;
      ++a1;
    }
  }
  *a2 = 0;
  return a1 != a2 ? a2 : 0;
}

//----- (0041F3F9) --------------------------------------------------------
const char *__usercall sub_41F3F9@<eax>(int *a1@<eax>, char *a2@<ebx>, int a3)
{
  int v3; // esi
  int v5; // ecx
  char *i; // eax
  char v7; // dl
  char *v9; // eax
  const char *v10; // esi

  v3 = 0;
  if ( !a3 )
    return 0;
  if ( !a2 )
    return 0;
  if ( !a1 )
    return 0;
  v5 = *a1;
  if ( *a1 <= 0 )
    return 0;
  for ( i = a2; *i == 32; ++v3 )
    ++i;
  do
  {
    v7 = *i;
    if ( !*i )
    {
      if ( !v3 )
        return 0;
      *a1 -= v3;
      memcpy_0(a2, &a2[v3], *a1 + 1);
      return a2;
    }
    ++i;
  }
  while ( v7 != 32 || *i != 32 && *i );
  v9 = xmlStrndup(&a2[v3], v5 - v3 + 1);
  v10 = v9;
  if ( !v9 )
  {
    xmlErrMemory(a3, 0);
    return 0;
  }
  sub_41F3B9(v9, v9);
  *a1 = strlen(v10);
  return v10;
}

//----- (0041F496) --------------------------------------------------------
int __usercall sub_41F496@<eax>(char *a1@<eax>, int a2@<edi>, char *Src, char *a4)
{
  _DWORD *v5; // eax
  int result; // eax
  _DWORD *Dict; // eax
  char *v8; // eax
  unsigned __int8 *v9; // eax
  unsigned __int8 *v10; // ebx
  int v11; // eax
  _DWORD *v12; // esi
  _DWORD *v13; // eax
  int v14; // eax
  int v15; // eax
  char *v16; // eax
  unsigned __int8 *v17; // ebx
  unsigned __int8 *v18; // eax
  int v19; // ebx
  unsigned __int8 *v20; // eax
  size_t Size; // [esp+4h] [ebp-8h] BYREF
  unsigned __int8 *v22; // [esp+8h] [ebp-4h]

  v5 = *(_DWORD **)(a2 + 352);
  if ( v5 )
  {
    result = xmlHashLookup3(v5, a1, Src, 0);
    if ( result )
      return result;
  }
  if ( !*(_DWORD *)(a2 + 348) )
  {
    Dict = xmlHashCreateDict(10, *(_DWORD **)(a2 + 296));
    *(_DWORD *)(a2 + 348) = Dict;
    if ( !Dict )
      return xmlErrMemory(a2, 0);
  }
  v8 = (char *)xmlSplitQName3(a1, &Size);
  if ( v8 )
  {
    v10 = xmlDictLookup(*(_DWORD **)(a2 + 296), v8, -1);
    v22 = xmlDictLookup(*(_DWORD **)(a2 + 296), a1, Size);
  }
  else
  {
    v9 = xmlDictLookup(*(_DWORD **)(a2 + 296), a1, -1);
    v22 = 0;
    v10 = v9;
  }
  v11 = xmlHashLookup3(*(_DWORD **)(a2 + 348), (char *)v10, (char *)v22, 0);
  v12 = (_DWORD *)v11;
  if ( !v11 )
  {
    v13 = (_DWORD *)xmlMalloc(108);
    v12 = v13;
    if ( v13 )
    {
      *v13 = 0;
      v13[1] = 4;
      goto LABEL_14;
    }
    return xmlErrMemory(a2, 0);
  }
  v14 = *(_DWORD *)(v11 + 4);
  if ( *v12 >= v14 )
  {
    v15 = xmlRealloc(v12, 40 * v14 + 28);
    v12 = (_DWORD *)v15;
    if ( v15 )
    {
      *(_DWORD *)(v15 + 4) *= 2;
LABEL_14:
      if ( xmlHashUpdateEntry2(*(_DWORD **)(a2 + 348), v10, v22, (int)v12, 0) < 0 )
      {
        ((void (__cdecl *)(_DWORD *))xmlFree)(v12);
        return xmlErrMemory(a2, 0);
      }
      goto LABEL_17;
    }
    return xmlErrMemory(a2, 0);
  }
LABEL_17:
  v16 = (char *)xmlSplitQName3(Src, &Size);
  if ( v16 )
  {
    v17 = xmlDictLookup(*(_DWORD **)(a2 + 296), v16, -1);
    v18 = xmlDictLookup(*(_DWORD **)(a2 + 296), Src, Size);
  }
  else
  {
    v17 = xmlDictLookup(*(_DWORD **)(a2 + 296), Src, -1);
    v18 = 0;
  }
  v12[5 * *v12 + 2] = v17;
  v12[5 * *v12 + 3] = v18;
  v19 = xmlStrlen(a4);
  v20 = xmlDictLookup(*(_DWORD **)(a2 + 296), a4, v19);
  v12[5 * *v12 + 4] = v20;
  v12[5 * *v12 + 5] = &v20[v19];
  result = 20 * *v12;
  if ( *(_DWORD *)(a2 + 96) )
    *(_DWORD *)((char *)v12 + result + 24) = "external";
  else
    *(_DWORD *)((char *)v12 + result + 24) = 0;
  ++*v12;
  return result;
}
// 496494: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);

//----- (0041F666) --------------------------------------------------------
int __usercall sub_41F666@<eax>(int a1@<eax>, char *a2, char *a3, void *a4)
{
  _DWORD *Dict; // eax
  int result; // eax
  void ***v7; // esi

  if ( !*(_DWORD *)(a1 + 352) )
  {
    Dict = xmlHashCreateDict(10, *(_DWORD **)(a1 + 296));
    *(_DWORD *)(a1 + 352) = Dict;
    if ( !Dict )
      return xmlErrMemory(a1, 0);
  }
  v7 = *(void ****)(a1 + 352);
  result = xmlHashLookup3(v7, a2, a3, 0);
  if ( !result )
    return xmlHashAddEntry2(v7, (unsigned __int8 *)a2, (unsigned __int8 *)a3, a4);
  return result;
}

//----- (0041F6C9) --------------------------------------------------------
int __cdecl sub_41F6C9(int a1, int a2, char *a3, char *a4)
{
  int result; // eax

  if ( a1 == 1 )
    return xmlHashRemoveEntry2(*(_DWORD **)(a2 + 352), a3, a4, 0);
  return result;
}

//----- (0041F6ED) --------------------------------------------------------
void __usercall sub_41F6ED(int a1@<esi>)
{
  _DWORD *v1; // eax
  _DWORD *v2; // ecx

  v1 = *(_DWORD **)(a1 + 352);
  if ( v1 )
  {
    xmlHashScanFull(v1, (void (__cdecl *)(int, int, _DWORD, _DWORD, _DWORD))sub_41F6C9, a1);
    if ( !xmlHashSize(*(_DWORD *)(a1 + 352)) )
    {
      xmlHashFree(v2, 0);
      *(_DWORD *)(a1 + 352) = 0;
    }
  }
}
// 41F718: variable 'v2' is possibly undefined

//----- (0041F727) --------------------------------------------------------
BOOL __cdecl xmlCheckLanguageID(unsigned __int8 *a1)
{
  unsigned __int8 v1; // al
  unsigned __int8 *j; // ecx
  unsigned __int8 v3; // al
  unsigned __int8 *i; // eax
  unsigned __int8 v6; // dl
  int v7; // edx
  _BYTE *v8; // eax
  _BYTE *v9; // edx
  unsigned __int8 v10; // cl
  int v11; // ecx
  _BYTE *v12; // edx
  unsigned __int8 v13; // cl
  int v14; // ecx
  _BYTE *v15; // edx
  unsigned __int8 v16; // cl
  unsigned __int8 v17; // cl
  unsigned __int8 v18; // cl
  int v19; // ecx
  _BYTE *v20; // edx
  unsigned __int8 v21; // cl
  char v22; // al

  if ( !a1 )
    return 0;
  v1 = *a1;
  if ( (*a1 != 105 || a1[1] != 45)
    && (v1 != 73 || a1[1] != 45)
    && (v1 != 120 || a1[1] != 45)
    && (v1 != 88 || a1[1] != 45) )
  {
    for ( i = a1; ; ++i )
    {
      v6 = *i;
      if ( (*i < 0x41u || v6 > 0x5Au) && (v6 < 0x61u || v6 > 0x7Au) )
        break;
    }
    v7 = i - a1;
    if ( i - a1 >= 4 )
      return v7 <= 8 && !*i;
    if ( v7 < 2 )
      return 0;
    if ( !*i )
      return 1;
    if ( *i != 45 )
      return 0;
    v8 = i + 1;
    v9 = v8;
    if ( *v8 >= 0x30u && *v8 <= 0x39u )
      goto LABEL_60;
    while ( 1 )
    {
      v10 = *v8;
      if ( (*v8 < 0x41u || v10 > 0x5Au) && (v10 < 0x61u || v10 > 0x7Au) )
        break;
      ++v8;
    }
    v11 = v8 - v9;
    if ( v8 - v9 != 4 )
    {
      if ( v11 == 2 )
        goto LABEL_73;
      if ( v11 >= 5 && v11 <= 8 )
        goto LABEL_83;
      if ( v11 != 3 )
        return 0;
      if ( !*v8 )
        return 1;
      if ( *v8 != 45 )
        return 0;
      v12 = ++v8;
      if ( *v8 >= 0x30u && *v8 <= 0x39u )
        goto LABEL_60;
      while ( 1 )
      {
        v13 = *v8;
        if ( (*v8 < 0x41u || v13 > 0x5Au) && (v13 < 0x61u || v13 > 0x7Au) )
          break;
        ++v8;
      }
      v14 = v8 - v12;
      if ( v8 - v12 == 2 )
      {
LABEL_73:
        if ( !*v8 )
          return 1;
        if ( *v8 != 45 )
          return 0;
        v20 = ++v8;
        while ( 1 )
        {
          v21 = *v8;
          if ( (*v8 < 0x41u || v21 > 0x5Au) && (v21 < 0x61u || v21 > 0x7Au) )
            break;
          ++v8;
        }
        if ( v8 - v20 < 5 || v8 - v20 > 8 )
          return 0;
        goto LABEL_83;
      }
      if ( v14 >= 5 && v14 <= 8 )
        goto LABEL_83;
      if ( v14 != 4 )
        return 0;
    }
    if ( !*v8 )
      return 1;
    if ( *v8 != 45 )
      return 0;
    v15 = ++v8;
    if ( *v8 >= 0x30u && *v8 <= 0x39u )
    {
LABEL_60:
      v16 = v8[1];
      if ( v16 < 0x30u )
        return 0;
      if ( v16 > 0x39u )
        return 0;
      v17 = v8[2];
      if ( v17 < 0x30u || v17 > 0x39u )
        return 0;
      v8 += 3;
      goto LABEL_73;
    }
    while ( 1 )
    {
      v18 = *v8;
      if ( (*v8 < 0x41u || v18 > 0x5Au) && (v18 < 0x61u || v18 > 0x7Au) )
        break;
      ++v8;
    }
    v19 = v8 - v15;
    if ( v8 - v15 < 5 || v19 > 8 )
    {
      if ( v19 == 2 )
        goto LABEL_73;
      return 0;
    }
LABEL_83:
    v22 = *v8;
    if ( v22 )
      return v22 == 45;
    return 1;
  }
  for ( j = a1 + 2; ; ++j )
  {
    v3 = *j;
    if ( (*j < 0x41u || v3 > 0x5Au) && (v3 < 0x61u || v3 > 0x7Au) )
      break;
  }
  return *j == 0;
}

//----- (0041F940) --------------------------------------------------------
int __usercall sub_41F940@<eax>(int a1@<ebx>, _DWORD *a2@<esi>, int a3)
{
  int v3; // ecx
  _DWORD *v4; // edi
  int v5; // eax
  void *v6; // ecx
  int v7; // eax
  int v8; // eax
  int v10; // eax

  v3 = 0;
  if ( (a2[90] & 0x2000) != 0 && (int)a2[82] > 0 )
  {
    v4 = (_DWORD *)a2[84];
    while ( *v4 != a1 )
    {
      v3 += 2;
      v4 += 2;
      if ( v3 >= a2[82] )
        goto LABEL_6;
    }
    if ( *(_DWORD *)(a2[84] + 4 * v3 + 4) == a3 )
      return -2;
  }
LABEL_6:
  v5 = a2[83];
  if ( !v5 || (v6 = (void *)a2[84]) == 0 )
  {
    a2[83] = 10;
    a2[82] = 0;
    v10 = xmlMalloc(40);
    a2[84] = v10;
    if ( !v10 )
    {
      xmlErrMemory((int)a2, 0);
      a2[83] = 0;
      return -1;
    }
LABEL_14:
    *(_DWORD *)(a2[84] + 4 * a2[82]++) = a1;
    *(_DWORD *)(a2[84] + 4 * a2[82]++) = a3;
    return a2[82];
  }
  if ( a2[82] < v5 )
    goto LABEL_14;
  v7 = 2 * v5;
  a2[83] = v7;
  v8 = xmlRealloc(v6, 4 * v7);
  if ( v8 )
  {
    a2[84] = v8;
    goto LABEL_14;
  }
  xmlErrMemory((int)a2, 0);
  a2[83] /= 2;
  return -1;
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);

//----- (0041FA49) --------------------------------------------------------
int __usercall sub_41FA49@<eax>(int result@<eax>, int a2@<esi>)
{
  int v2; // ecx
  int v3; // edx

  if ( !*(_DWORD *)(a2 + 336) )
    return 0;
  v2 = *(_DWORD *)(a2 + 328);
  if ( v2 < result )
  {
    xmlGenericError(xmlGenericErrorContext, "Pbm popping %d NS\n", result);
    v2 = *(_DWORD *)(a2 + 328);
    result = v2;
  }
  if ( v2 <= 0 )
    return 0;
  if ( result > 0 )
  {
    v3 = result;
    do
    {
      --*(_DWORD *)(a2 + 328);
      *(_DWORD *)(*(_DWORD *)(a2 + 336) + 4 * *(_DWORD *)(a2 + 328)) = 0;
      --v3;
    }
    while ( v3 );
  }
  return result;
}
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);

//----- (0041FAA2) --------------------------------------------------------
int __usercall sub_41FAA2@<eax>(int a1@<esi>, int a2)
{
  void *v2; // ecx
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // edi
  int v7; // eax

  v2 = *(void **)(a1 + 300);
  if ( !v2 )
  {
    v3 = xmlMalloc(220);
    if ( v3 )
    {
      *(_DWORD *)(a1 + 300) = v3;
      v4 = xmlMalloc(44);
      if ( v4 )
      {
        *(_DWORD *)(a1 + 304) = 55;
LABEL_10:
        *(_DWORD *)(a1 + 340) = v4;
        return *(_DWORD *)(a1 + 304);
      }
    }
    goto LABEL_8;
  }
  v5 = a2 + 5;
  if ( a2 + 5 > *(_DWORD *)(a1 + 304) )
  {
    v6 = 2 * v5;
    v7 = xmlRealloc(v2, 8 * v5);
    if ( v7 )
    {
      *(_DWORD *)(a1 + 300) = v7;
      v4 = xmlRealloc(*(LPVOID *)(a1 + 340), 4 * (v6 / 5));
      if ( v4 )
      {
        *(_DWORD *)(a1 + 304) = v6;
        goto LABEL_10;
      }
    }
LABEL_8:
    xmlErrMemory(a1, 0);
    return -1;
  }
  return *(_DWORD *)(a1 + 304);
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);

//----- (0041FB48) --------------------------------------------------------
int __cdecl inputPush(int a1, int ***Block)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int result; // eax

  if ( !a1 || !Block )
    return -1;
  v2 = *(_DWORD *)(a1 + 44);
  if ( *(_DWORD *)(a1 + 40) >= v2 )
  {
    v3 = 2 * v2;
    *(_DWORD *)(a1 + 44) = v3;
    v4 = xmlRealloc(*(LPVOID *)(a1 + 48), 4 * v3);
    *(_DWORD *)(a1 + 48) = v4;
    if ( !v4 )
    {
      xmlErrMemory(a1, 0);
      xmlFreeInputStream(Block);
      *(int *)(a1 + 44) /= 2;
      return -1;
    }
  }
  *(_DWORD *)(*(_DWORD *)(a1 + 48) + 4 * *(_DWORD *)(a1 + 40)) = Block;
  result = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(a1 + 36) = Block;
  *(_DWORD *)(a1 + 40) = result + 1;
  return result;
}
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);

//----- (0041FBB5) --------------------------------------------------------
int __cdecl inputPop(_DWORD *a1)
{
  int result; // eax
  int v2; // ecx
  int v3; // ecx
  int *v4; // ecx

  if ( !a1 )
    return 0;
  v2 = a1[10];
  if ( v2 <= 0 )
    return 0;
  v3 = v2 - 1;
  a1[10] = v3;
  if ( v3 <= 0 )
    a1[9] = 0;
  else
    a1[9] = *(_DWORD *)(a1[12] + 4 * v3 - 4);
  v4 = (int *)(a1[12] + 4 * v3);
  result = *v4;
  *v4 = 0;
  return result;
}

//----- (0041FBEB) --------------------------------------------------------
int __cdecl nodePush(int a1, int a2)
{
  int result; // eax
  int v3; // eax
  int v4; // eax
  unsigned int v5; // ecx

  if ( !a1 )
    return 0;
  v3 = *(_DWORD *)(a1 + 60);
  if ( *(_DWORD *)(a1 + 56) >= v3 )
  {
    v4 = xmlRealloc(*(LPVOID *)(a1 + 64), 8 * v3);
    if ( !v4 )
    {
      xmlErrMemory(a1, 0);
      return -1;
    }
    *(_DWORD *)(a1 + 60) *= 2;
    *(_DWORD *)(a1 + 64) = v4;
  }
  v5 = *(_DWORD *)(a1 + 56);
  if ( v5 <= xmlParserMaxDepth || (*(_DWORD *)(a1 + 360) & 0x80000) != 0 )
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 64) + 4 * v5) = a2;
    *(_DWORD *)(a1 + 52) = a2;
    result = *(_DWORD *)(a1 + 56);
    *(_DWORD *)(a1 + 56) = result + 1;
  }
  else
  {
    sub_41F093(
      (int (__cdecl *)(int, char *, char))1,
      (int *)a1,
      "Excessive depth in document: %d use XML_PARSE_HUGE option\n",
      xmlParserMaxDepth);
    result = -1;
    *(_DWORD *)(a1 + 172) = -1;
  }
  return result;
}
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);
// 4A4D2C: using guessed type int xmlParserMaxDepth;

//----- (0041FC72) --------------------------------------------------------
int __cdecl nodePop(_DWORD *a1)
{
  int result; // eax
  int v2; // ecx
  int v3; // ecx
  int *v4; // ecx

  if ( !a1 )
    return 0;
  v2 = a1[14];
  if ( v2 <= 0 )
    return 0;
  v3 = v2 - 1;
  a1[14] = v3;
  if ( v3 <= 0 )
    a1[13] = 0;
  else
    a1[13] = *(_DWORD *)(a1[16] + 4 * v3 - 4);
  v4 = (int *)(a1[16] + 4 * v3);
  result = *v4;
  *v4 = 0;
  return result;
}

//----- (0041FCA8) --------------------------------------------------------
int __usercall sub_41FCA8@<eax>(int a1@<edi>, int a2@<esi>, int a3, int a4, int a5)
{
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int result; // eax
  int v10; // ecx
  int v11; // eax

  v5 = *(_DWORD *)(a2 + 192);
  if ( *(_DWORD *)(a2 + 188) >= v5 )
  {
    v6 = 2 * v5;
    *(_DWORD *)(a2 + 192) = v6;
    v7 = xmlRealloc(*(LPVOID *)(a2 + 196), 4 * v6);
    if ( !v7 || (*(_DWORD *)(a2 + 196) = v7, (v8 = xmlRealloc(*(LPVOID *)(a2 + 344), 12 * *(_DWORD *)(a2 + 192))) == 0) )
    {
      *(int *)(a2 + 192) /= 2;
      xmlErrMemory(a2, 0);
      return -1;
    }
    *(_DWORD *)(a2 + 344) = v8;
  }
  *(_DWORD *)(*(_DWORD *)(a2 + 196) + 4 * *(_DWORD *)(a2 + 188)) = a1;
  v10 = *(_DWORD *)(a2 + 344);
  v11 = 12 * *(_DWORD *)(a2 + 188);
  *(_DWORD *)(a2 + 184) = a1;
  *(_DWORD *)(v11 + v10) = a3;
  *(_DWORD *)(12 * *(_DWORD *)(a2 + 188) + *(_DWORD *)(a2 + 344) + 4) = a4;
  *(_DWORD *)(12 * *(_DWORD *)(a2 + 188) + *(_DWORD *)(a2 + 344) + 8) = a5;
  result = *(_DWORD *)(a2 + 188);
  *(_DWORD *)(a2 + 188) = result + 1;
  return result;
}
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);

//----- (0041FD84) --------------------------------------------------------
int __thiscall sub_41FD84(_DWORD *this)
{
  int v1; // eax
  int result; // eax
  int v3; // eax
  int *v4; // ecx

  v1 = this[47];
  if ( v1 <= 0 )
    return 0;
  v3 = v1 - 1;
  this[47] = v3;
  if ( v3 <= 0 )
    this[46] = 0;
  else
    this[46] = *(_DWORD *)(this[49] + 4 * v3 - 4);
  v4 = (int *)(this[49] + 4 * v3);
  result = *v4;
  *v4 = 0;
  return result;
}

//----- (0041FDC2) --------------------------------------------------------
int __cdecl namePush(int a1, int a2)
{
  int result; // eax
  int v3; // eax
  int v4; // eax

  if ( !a1 )
    return -1;
  v3 = *(_DWORD *)(a1 + 192);
  if ( *(_DWORD *)(a1 + 188) >= v3 )
  {
    v4 = xmlRealloc(*(LPVOID *)(a1 + 196), 8 * v3);
    if ( !v4 )
    {
      xmlErrMemory(a1, 0);
      return -1;
    }
    *(_DWORD *)(a1 + 192) *= 2;
    *(_DWORD *)(a1 + 196) = v4;
  }
  *(_DWORD *)(*(_DWORD *)(a1 + 196) + 4 * *(_DWORD *)(a1 + 188)) = a2;
  *(_DWORD *)(a1 + 184) = a2;
  result = *(_DWORD *)(a1 + 188);
  *(_DWORD *)(a1 + 188) = result + 1;
  return result;
}
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);

//----- (0041FE35) --------------------------------------------------------
int __cdecl namePop(_DWORD *a1)
{
  int v1; // eax
  int v2; // eax
  int *v3; // ecx
  int result; // eax

  if ( !a1 )
    return 0;
  v1 = a1[47];
  if ( v1 <= 0 )
    return 0;
  v2 = v1 - 1;
  a1[47] = v2;
  if ( v2 <= 0 )
    a1[46] = 0;
  else
    a1[46] = *(_DWORD *)(a1[49] + 4 * v2 - 4);
  v3 = (int *)(a1[49] + 4 * v2);
  result = *v3;
  *v3 = 0;
  return result;
}

//----- (0041FE7B) --------------------------------------------------------
int __usercall sub_41FE7B@<eax>(int a1@<edi>, int a2@<esi>)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int result; // eax

  v2 = *(_DWORD *)(a2 + 240);
  if ( *(_DWORD *)(a2 + 236) >= v2 )
  {
    v3 = 2 * v2;
    *(_DWORD *)(a2 + 240) = v3;
    v4 = xmlRealloc(*(LPVOID *)(a2 + 244), 4 * v3);
    if ( !v4 )
    {
      xmlErrMemory(a2, 0);
      *(int *)(a2 + 240) /= 2;
      return -1;
    }
    *(_DWORD *)(a2 + 244) = v4;
  }
  *(_DWORD *)(*(_DWORD *)(a2 + 244) + 4 * *(_DWORD *)(a2 + 236)) = a1;
  result = *(_DWORD *)(a2 + 236);
  *(_DWORD *)(a2 + 232) = *(_DWORD *)(a2 + 244) + 4 * result;
  *(_DWORD *)(a2 + 236) = result + 1;
  return result;
}
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);

//----- (0041FEF7) --------------------------------------------------------
int __fastcall sub_41FEF7(int a1, _DWORD *a2)
{
  int v2; // eax
  int result; // eax
  int v4; // eax
  int v5; // ecx
  int *v6; // ecx

  v2 = a2[59];
  if ( v2 <= 0 )
    return 0;
  v4 = v2 - 1;
  a2[59] = v4;
  v5 = a2[61];
  if ( v4 <= 0 )
    a2[58] = v5;
  else
    a2[58] = v5 + 4 * v4 - 4;
  v6 = (int *)(v5 + 4 * v4);
  result = *v6;
  *v6 = -1;
  return result;
}

//----- (0041FF30) --------------------------------------------------------
char __usercall sub_41FF30@<al>(_DWORD *a1@<esi>)
{
  int v1; // eax

  xmlParserInputShrink((_DWORD *)a1[9]);
  v1 = a1[9];
  if ( !**(_BYTE **)(v1 + 16) )
  {
    v1 = xmlParserInputGrow((int *)v1, 250);
    if ( v1 <= 0 )
      LOBYTE(v1) = xmlPopInput(a1);
  }
  return v1;
}

//----- (0041FF5D) --------------------------------------------------------
char __usercall sub_41FF5D@<al>(int a1@<esi>)
{
  int *v1; // eax
  _BYTE *v2; // ecx

  xmlParserInputGrow(*(int **)(a1 + 36), 250);
  v1 = *(int **)(a1 + 36);
  v2 = (_BYTE *)v1[4];
  if ( v2 )
  {
    if ( !*v2 )
    {
      v1 = (int *)xmlParserInputGrow(v1, 250);
      if ( (int)v1 <= 0 )
        LOBYTE(v1) = xmlPopInput((_DWORD *)a1);
    }
  }
  return (char)v1;
}

//----- (0041FF93) --------------------------------------------------------
int __cdecl xmlSkipBlankChars(int a1)
{
  int v1; // ebx
  unsigned __int8 *v2; // eax
  unsigned __int8 v3; // cl
  bool v4; // zf
  unsigned __int8 *v5; // eax
  int v6; // edi

  v1 = 0;
  if ( *(_DWORD *)(a1 + 40) == 1 && *(_DWORD *)(a1 + 172) != 3 )
  {
LABEL_3:
    v2 = *(unsigned __int8 **)(*(_DWORD *)(a1 + 36) + 16);
    while ( 1 )
    {
      v3 = *v2;
      if ( *v2 == 32 )
        goto LABEL_8;
      if ( v3 < 9u )
        break;
      v4 = v3 == 10;
      if ( v3 > 0xAu )
        break;
LABEL_9:
      if ( v4 )
      {
        ++*(_DWORD *)(*(_DWORD *)(a1 + 36) + 28);
        *(_DWORD *)(*(_DWORD *)(a1 + 36) + 32) = 1;
      }
      ++v2;
      ++v1;
      if ( !*v2 )
      {
        *(_DWORD *)(*(_DWORD *)(a1 + 36) + 16) = v2;
        xmlParserInputGrow(*(int **)(a1 + 36), 250);
        goto LABEL_3;
      }
    }
    if ( v3 != 13 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 36) + 16) = v2;
      return v1;
    }
LABEL_8:
    v4 = v3 == 10;
    goto LABEL_9;
  }
  do
  {
    while ( 1 )
    {
      v5 = *(unsigned __int8 **)(*(_DWORD *)(a1 + 36) + 16);
      v6 = *v5;
      if ( v6 != 32 && (*v5 < 9u || *v5 > 0xAu) && v6 != 13 )
        break;
      xmlNextChar((int *)a1);
      ++v1;
    }
    while ( !v6 && *(int *)(a1 + 40) > 1 && *(_DWORD *)(a1 + 172) != 5 )
    {
      xmlPopInput((_DWORD *)a1);
      v6 = **(unsigned __int8 **)(*(_DWORD *)(a1 + 36) + 16);
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 + 36) + 16) == 37 )
      xmlParserHandlePEReference((int *)a1);
  }
  while ( v6 == 32 || v6 >= 9 && v6 <= 10 || v6 == 13 );
  return v1;
}
// 420064: conditional instruction was optimized away because edi.4<100u

//----- (00420080) --------------------------------------------------------
char __cdecl xmlPopInput(_DWORD *a1)
{
  int ***v1; // eax
  int v2; // eax

  if ( a1 )
  {
    while ( (int)a1[10] > 1 )
    {
      if ( xmlParserDebugEntities )
        xmlGenericError(xmlGenericErrorContext, "Popping input %d\n", a1[10]);
      v1 = (int ***)inputPop(a1);
      xmlFreeInputStream(v1);
      v2 = a1[9];
      if ( **(_BYTE **)(v2 + 16) || xmlParserInputGrow((int *)v2, 250) > 0 )
        return **(_BYTE **)(a1[9] + 16);
    }
  }
  return 0;
}
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);
// 4A9C7C: using guessed type int xmlParserDebugEntities;

//----- (004200E7) --------------------------------------------------------
int __cdecl xmlPushInput(_DWORD *a1, const char **Block)
{
  int v3; // eax
  int v4; // ebx

  if ( !Block )
    return -1;
  if ( xmlParserDebugEntities )
  {
    v3 = a1[9];
    if ( v3 && *(_DWORD *)(v3 + 4) )
      xmlGenericError(xmlGenericErrorContext, "%s(%d): ", *(const char **)(v3 + 4), *(_DWORD *)(v3 + 28));
    xmlGenericError(xmlGenericErrorContext, "Pushing input %d : %.30s\n", a1[10] + 1, Block[4]);
  }
  v4 = inputPush((int)a1, (int ***)Block);
  if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
    sub_41FF5D((int)a1);
  return v4;
}
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);
// 4A9C7C: using guessed type int xmlParserDebugEntities;

//----- (00420175) --------------------------------------------------------
unsigned int __cdecl xmlParseCharRef(int *a1)
{
  int v1; // eax
  _BYTE *v2; // ecx
  unsigned int v3; // edi
  int v4; // eax
  int v5; // eax
  unsigned __int8 v6; // al
  int v7; // eax
  int v8; // eax
  unsigned __int8 v9; // al
  int v10; // eax
  int v11; // eax
  unsigned int v13; // [esp+Ch] [ebp-8h]
  int v14; // [esp+10h] [ebp-4h]
  int v15; // [esp+10h] [ebp-4h]
  int v16; // [esp+10h] [ebp-4h]

  v1 = a1[9];
  v2 = *(_BYTE **)(v1 + 16);
  v3 = 0;
  v14 = 0;
  v13 = 0;
  if ( *v2 != 38 )
    goto LABEL_57;
  if ( v2[1] != 35 || v2[2] != 120 )
  {
    if ( v2[1] == 35 )
    {
      a1[50] += 2;
      *(_DWORD *)(v1 + 16) += 2;
      *(_DWORD *)(a1[9] + 32) += 2;
      if ( **(_BYTE **)(a1[9] + 16) == 37 )
        xmlParserHandlePEReference(a1);
      v7 = a1[9];
      if ( !**(_BYTE **)(v7 + 16) && xmlParserInputGrow((int *)v7, 250) <= 0 )
        xmlPopInput(a1);
      if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
        sub_41FF5D((int)a1);
      while ( **(_BYTE **)(a1[9] + 16) != 59 )
      {
        v8 = v14;
        v16 = v14 + 1;
        if ( v8 > 20 )
        {
          v16 = 0;
          if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
            sub_41FF5D((int)a1);
        }
        v9 = **(_BYTE **)(a1[9] + 16);
        if ( v9 < 0x30u || v9 > 0x39u )
        {
          sub_41EC3F(7, a1, 0);
LABEL_54:
          v3 = 0;
          goto LABEL_55;
        }
        v3 = 10 * v3 + v9 - 48;
        if ( v3 > 0x10FFFF )
          v13 = v3;
        xmlNextChar(a1);
        v14 = v16 + 1;
      }
      goto LABEL_55;
    }
LABEL_57:
    sub_41EC3F(8, a1, 0);
    goto LABEL_58;
  }
  a1[50] += 3;
  *(_DWORD *)(v1 + 16) += 3;
  *(_DWORD *)(a1[9] + 32) += 3;
  if ( **(_BYTE **)(a1[9] + 16) == 37 )
    xmlParserHandlePEReference(a1);
  v4 = a1[9];
  if ( !**(_BYTE **)(v4 + 16) && xmlParserInputGrow((int *)v4, 250) <= 0 )
    xmlPopInput(a1);
  if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
    sub_41FF5D((int)a1);
  while ( **(_BYTE **)(a1[9] + 16) != 59 )
  {
    v5 = v14;
    v15 = v14 + 1;
    if ( v5 > 20 )
    {
      v15 = 0;
      if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
        sub_41FF5D((int)a1);
    }
    v6 = **(_BYTE **)(a1[9] + 16);
    if ( v6 < 0x30u || v6 > 0x39u )
    {
      if ( v6 < 0x61u || v6 > 0x66u || v15 >= 20 )
      {
        if ( v6 < 0x41u || v6 > 0x46u || v15 >= 20 )
        {
          sub_41EC3F(6, a1, 0);
          goto LABEL_54;
        }
        v3 = 16 * v3 + v6 - 55;
      }
      else
      {
        v3 = 16 * v3 + v6 - 87;
      }
    }
    else
    {
      v3 = 16 * v3 + v6 - 48;
    }
    if ( v3 > 0x10FFFF )
      v13 = v3;
    xmlNextChar(a1);
    v14 = v15 + 1;
  }
LABEL_55:
  v10 = a1[9];
  if ( **(_BYTE **)(v10 + 16) == 59 )
  {
    ++*(_DWORD *)(v10 + 32);
    v11 = a1[9];
    ++a1[50];
    ++*(_DWORD *)(v11 + 16);
  }
LABEL_58:
  if ( v3 >= 0x100 )
  {
    if ( v3 > 0xD7FF && (v3 < 0xE000 || v3 > 0xFFFD) && v3 - 0x10000 > 0xFFFFF )
      goto LABEL_63;
  }
  else if ( (v3 < 9 || v3 > 0xA) && v3 != 13 && v3 < 0x20 )
  {
    goto LABEL_63;
  }
  if ( v13 )
  {
LABEL_63:
    sub_41F093((int (__cdecl *)(int, char *, char))9, a1, "xmlParseCharRef: invalid xmlChar value %d\n", v3);
    return 0;
  }
  return v3;
}
// 4202C9: conditional instruction was optimized away because dl.1==26

//----- (0042043E) --------------------------------------------------------
unsigned int __usercall sub_42043E@<eax>(unsigned __int8 **a1@<eax>, int *a2@<ecx>)
{
  unsigned int result; // eax
  unsigned __int8 *v5; // esi
  unsigned __int8 *i; // esi
  unsigned __int8 v7; // cl
  unsigned int v8; // [esp+Ch] [ebp-8h]
  unsigned __int8 v9; // [esp+13h] [ebp-1h]

  result = 0;
  v8 = 0;
  if ( !a1 )
    return 0;
  v5 = *a1;
  if ( !*a1 )
    return 0;
  if ( *v5 != 38 || v5[1] != 35 )
  {
    sub_41EC3F(8, a2, 0);
    return 0;
  }
  if ( v5[2] == 120 )
  {
    i = v5 + 3;
    v7 = *i;
    v9 = *i;
    if ( *i != 59 )
    {
      while ( 1 )
      {
        if ( (unsigned __int8)(v7 - 48) > 9u )
        {
          if ( (unsigned __int8)(v7 - 97) > 5u )
          {
            if ( (unsigned __int8)(v7 - 65) > 5u )
            {
              sub_41EC3F(6, a2, 0);
              goto LABEL_28;
            }
            result = 16 * result + v7 - 55;
          }
          else
          {
            result = 16 * result + v7 - 87;
          }
        }
        else
        {
          result = 16 * result + v7 - 48;
        }
        if ( result > 0x10FFFF )
          v8 = result;
        v9 = *++i;
        if ( *i == 59 )
          break;
        v7 = *i;
      }
    }
  }
  else
  {
    for ( i = v5 + 2; ; ++i )
    {
      v9 = *i;
      if ( *i == 59 )
        break;
      if ( (unsigned __int8)(v9 - 48) > 9u )
      {
        sub_41EC3F(7, a2, 0);
LABEL_28:
        result = 0;
        if ( v9 != 59 )
          goto LABEL_30;
        break;
      }
      result = 10 * result + v9 - 48;
      if ( result > 0x10FFFF )
        v8 = result;
    }
  }
  ++i;
LABEL_30:
  *a1 = i;
  if ( result >= 0x100 )
  {
    if ( result <= 0xD7FF || result >= 0xE000 && result <= 0xFFFD || result - 0x10000 <= 0xFFFFF )
    {
LABEL_40:
      if ( !v8 )
        return result;
    }
  }
  else if ( result >= 9 && result <= 0xA || result == 13 || result >= 0x20 )
  {
    goto LABEL_40;
  }
  sub_41F093((int (__cdecl *)(int, char *, char))9, a2, "xmlParseStringCharRef: invalid xmlChar value %d\n", result);
  return 0;
}
// 4204F4: conditional instruction was optimized away because cl.1==23

//----- (004205B0) --------------------------------------------------------
_DWORD *__cdecl sub_4205B0(int *a1, int a2)
{
  _DWORD *v3; // edi
  size_t v4; // ebx
  _BYTE *v5; // esi
  _BYTE *v6; // ebx
  size_t v7; // [esp+8h] [ebp-4h]

  if ( !a2 )
  {
    sub_41EC3F(1, a1, "xmlNewBlanksWrapperInputStream entity\n");
    return 0;
  }
  if ( xmlParserDebugEntities )
    xmlGenericError(xmlGenericErrorContext, "new blanks wrapper for entity: %s\n", *(const char **)(a2 + 8));
  v3 = xmlNewInputStream((int)a1);
  if ( !v3 )
    return 0;
  v4 = xmlStrlen(*(_BYTE **)(a2 + 8)) + 5;
  v7 = v4;
  v5 = (_BYTE *)xmlMallocAtomic(v4);
  if ( !v5 )
  {
    xmlErrMemory((int)a1, 0);
    ((void (__cdecl *)(_DWORD *))xmlFree)(v3);
    return 0;
  }
  *v5 = 32;
  v5[1] = 37;
  v6 = &v5[v4];
  *(v6 - 3) = 59;
  *(v6 - 2) = 32;
  *(v6 - 1) = 0;
  memcpy(v5 + 2, *(const void **)(a2 + 8), v7 - 5);
  v3[6] = v7;
  v3[10] = j_xmlFree;
  v3[3] = v5;
  v3[4] = v5;
  v3[5] = v6;
  return v3;
}
// 496494: invalid function type has been ignored
// 49B2BC: using guessed type int (__cdecl *xmlMallocAtomic)(size_t Size);
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);
// 4A9C7C: using guessed type int xmlParserDebugEntities;

//----- (00420686) --------------------------------------------------------
void __cdecl xmlParserHandlePEReference(int *a1)
{
  int *v1; // edi
  _BYTE *v2; // ecx
  int v3; // ebx
  unsigned __int8 v4; // al
  unsigned __int8 *v5; // eax
  unsigned __int8 *v6; // esi
  int (__cdecl *v7)(int, unsigned __int8 *); // eax
  const char **v8; // eax
  int v9; // eax
  const char **v10; // eax
  int v11; // eax
  int v12; // eax
  _BYTE *v13; // eax
  unsigned __int8 v14; // al

  v1 = a1;
  v2 = *(_BYTE **)(a1[9] + 16);
  if ( *v2 == 37 )
  {
    switch ( a1[43] )
    {
      case -1:
        sub_41EC3F(18, a1, 0);
        break;
      case 0:
      case 1:
      case 4:
        sub_41EC3F(19, a1, 0);
        break;
      case 2:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 15:
      case 16:
        return;
      case 3:
        v3 = 0;
        if ( a1[24] || a1[10] != 1 )
        {
          v4 = v2[1];
          if ( v4 != 32 && (v4 < 9u || v4 > 0xAu) && v4 != 13 && v4 )
            goto LABEL_16;
        }
        break;
      case 14:
        sub_41EC3F(20, a1, 0);
        break;
      default:
        v3 = 0;
LABEL_16:
        xmlNextChar(a1);
        v5 = xmlParseName((int)v1);
        v6 = v5;
        if ( xmlParserDebugEntities )
          xmlGenericError(xmlGenericErrorContext, "PEReference: %s\n", (const char *)v5);
        if ( v6 )
        {
          if ( **(_BYTE **)(v1[9] + 16) == 59 )
          {
            xmlNextChar(v1);
            if ( *v1 && (v7 = *(int (__cdecl **)(int, unsigned __int8 *))(*v1 + 96)) != 0 && (v3 = v7(v1[1], v6)) != 0 )
            {
              if ( *(void (__cdecl **)(void *))(v1[9] + 40) == j_xmlFree )
              {
                v9 = *(_DWORD *)(v3 + 48);
                if ( v9 == 4 || v9 == 5 )
                {
                  v10 = (const char **)xmlNewEntityInputStream(v1, v3);
                  if ( xmlPushInput(v1, v10) >= 0 )
                  {
                    if ( !v1[73] && *(_DWORD *)(v1[9] + 20) - *(_DWORD *)(v1[9] + 16) < 250 )
                      sub_41FF5D((int)v1);
                    v11 = v1[9];
                    if ( *(_DWORD *)(v11 + 20) - *(_DWORD *)(v11 + 16) >= 4 )
                    {
                      a1 = **(int ***)(v11 + 16);
                      v12 = xmlDetectCharEncoding((char *)&a1, 4);
                      if ( v12 )
                        xmlSwitchEncoding(v1, v12);
                    }
                    if ( *(_DWORD *)(v3 + 48) == 5 )
                    {
                      v13 = *(_BYTE **)(v1[9] + 16);
                      if ( *v13 == 60 && v13[1] == 63 && v13[2] == 120 && v13[3] == 109 && v13[4] == 108 )
                      {
                        if ( (v14 = v13[5], v14 == 32) || v14 >= 9u && v14 <= 0xAu || v14 == 13 )
                          xmlParseTextDecl(v1);
                      }
                    }
                  }
                }
                else
                {
                  sub_41F152(
                    (int (__cdecl *)(int, char *, char))0x1E,
                    v1,
                    "PEReference: %s is not a parameter entity\n",
                    v6);
                }
              }
              else
              {
                v8 = (const char **)sub_4205B0(v1, v3);
                xmlPushInput(v1, v8);
              }
            }
            else if ( v1[7] == 1 || v1[22] == v3 && v1[23] == v3 )
            {
              sub_41F152((int (__cdecl *)(int, char *, char))0x1A, v1, "PEReference: %%%s; not found\n", v6);
            }
            else
            {
              if ( v1[26] == v3 || v1[28] == v3 )
                sub_41F01E((int)v1, v6, 27, "PEReference: %%%s; not found\n");
              else
                sub_43D29A(27, 0, v6, (int)v1, "PEReference: %%%s; not found\n");
              v1[25] = 0;
            }
          }
          else
          {
            sub_41EC3F(25, v1, 0);
          }
        }
        else
        {
          sub_41EC3F(24, v1, 0);
        }
        break;
    }
  }
}
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);
// 4A9C7C: using guessed type int xmlParserDebugEntities;

//----- (00420908) --------------------------------------------------------
_BYTE *__cdecl xmlStringLenDecodeEntities(
        int *a1,
        unsigned __int8 *ArgList,
        int a3,
        int a4,
        unsigned __int8 a5,
        unsigned __int8 a6,
        unsigned __int8 a7)
{
  int v8; // eax
  int v10; // esi
  _BYTE *v11; // ebx
  int v12; // eax
  int v13; // eax
  int v14; // eax
  _DWORD *v15; // esi
  int v16; // eax
  unsigned __int8 *v17; // esi
  int v18; // eax
  SIZE_T v19; // eax
  _BYTE *v20; // edx
  int v21; // eax
  char v22; // dl
  char *v23; // eax
  char v24; // cl
  unsigned int v25; // edx
  int v26; // eax
  int v27; // esi
  unsigned int v28; // eax
  char *v29; // edx
  int v30; // eax
  unsigned int v31; // ecx
  char v32; // al
  unsigned int v33; // eax
  _BYTE *v34; // eax
  bool v35; // zf
  _BYTE *v36; // esi
  _BYTE *v37; // edx
  _BYTE *v38; // eax
  int v39; // eax
  char v40; // dl
  char *v41; // esi
  char v42; // al
  unsigned int v43; // ecx
  int v44; // eax
  unsigned int v45; // ecx
  int v46; // eax
  int v47; // eax
  int v48; // [esp-10h] [ebp-30h]
  int v49; // [esp-10h] [ebp-30h]
  unsigned __int8 *v50; // [esp+Ch] [ebp-14h]
  int v51; // [esp+10h] [ebp-10h] BYREF
  char *v52; // [esp+14h] [ebp-Ch]
  void *Block; // [esp+18h] [ebp-8h]
  signed int v54; // [esp+1Ch] [ebp-4h]
  int v55; // [esp+28h] [ebp+8h]

  Block = 0;
  v54 = 0;
  if ( !a1 || !ArgList || a3 < 0 )
    return 0;
  v8 = a1[62];
  v50 = &ArgList[a3];
  if ( v8 > 40 && (a1[90] & 0x80000) == 0 || v8 > 1024 )
  {
    sub_41EC3F(89, a1, 0);
    return 0;
  }
  v10 = 300;
  v55 = 300;
  v11 = (_BYTE *)xmlMallocAtomic(0x12Cu);
  if ( !v11 )
  {
LABEL_83:
    xmlErrMemory((int)a1, 0);
LABEL_84:
    if ( Block )
      ((void (__cdecl *)(void *))xmlFree)(Block);
    if ( v11 )
      ((void (__cdecl *)(_BYTE *))xmlFree)(v11);
    return 0;
  }
  if ( ArgList >= v50 )
    v12 = 0;
  else
    v12 = xmlStringCurrentChar(a1, ArgList, &v51);
  if ( v12 )
  {
    while ( v12 != a5 && v12 != a6 && v12 != a7 )
    {
      if ( v12 == 38 )
      {
        if ( ArgList[1] == 35 )
        {
          v13 = sub_42043E(&ArgList, a1);
          if ( v13 )
          {
            v14 = xmlCopyCharMultiByte(&v11[v54], v13);
            v54 += v14;
          }
LABEL_74:
          if ( v54 <= v10 - 100 )
            goto LABEL_78;
          v19 = 2 * v10 + 100;
LABEL_76:
          v55 = v19;
          v47 = xmlRealloc(v11, v19);
          if ( !v47 )
            goto LABEL_83;
          v11 = (_BYTE *)v47;
          goto LABEL_78;
        }
        if ( (a4 & 1) == 0 )
          goto LABEL_70;
        if ( xmlParserDebugEntities )
          xmlGenericError(xmlGenericErrorContext, "String decoding Entity Reference: %.30s\n", (const char *)ArgList);
        v15 = sub_427A16(a1, &ArgList);
        v16 = a1[97];
        if ( v16 == 89 || v16 == 1 )
          goto LABEL_84;
        if ( v15 )
        {
          a1[110] += v15[18];
          if ( v15[12] == 6 )
          {
            v17 = (unsigned __int8 *)v15[10];
            if ( !v17 )
            {
              sub_41EFC6((int (__cdecl *)(int, char *, char))1, a1, "predefined entity has no content\n");
              goto LABEL_78;
            }
            v18 = xmlCopyCharMultiByte(&v11[v54], *v17);
            v54 += v18;
            if ( v54 <= v55 - 100 )
              goto LABEL_78;
            v19 = 2 * v55 + 100;
            goto LABEL_76;
          }
          if ( v15[10] )
          {
            ++a1[62];
            v20 = (_BYTE *)v15[10];
            if ( v20 )
            {
              v48 = a4;
              v21 = xmlStrlen(v20);
              Block = (void *)xmlStringLenDecodeEntities((int)a1, v22, v21, v48, 0, 0, 0);
            }
            else
            {
              Block = 0;
            }
            --a1[62];
            if ( Block )
            {
              v23 = (char *)Block;
              while ( *v23 )
              {
                v24 = *v23;
                v25 = v54++;
                v11[v25] = v24;
                v52 = ++v23;
                if ( v54 > v55 - 100 )
                {
                  if ( sub_41EB1F(a1, (int)v15, v54) )
                    goto LABEL_84;
                  v55 = 2 * v55 + 100;
                  v26 = xmlRealloc(v11, v55);
                  if ( !v26 )
                    goto LABEL_83;
                  v11 = (_BYTE *)v26;
                  v23 = v52;
                }
              }
LABEL_45:
              ((void (__cdecl *)(void *))xmlFree)(Block);
              Block = 0;
            }
          }
          else
          {
            v27 = xmlStrlen((_BYTE *)v15[2]);
            v28 = v54++;
            v11[v28] = 38;
            v52 = v29;
            if ( v54 > v55 - v27 - 100 )
            {
              v55 = v27 + 2 * v55 + 100;
              v30 = xmlRealloc(v11, v55);
              if ( !v30 )
                goto LABEL_83;
              v11 = (_BYTE *)v30;
            }
            while ( v27 > 0 )
            {
              v31 = v54++;
              v32 = *v52++;
              v11[v31] = v32;
              --v27;
            }
            v33 = v54++;
            v11[v33] = 59;
          }
        }
      }
      else
      {
        if ( v12 != 37 || (a4 & 2) == 0 )
        {
LABEL_70:
          if ( v51 == 1 )
          {
            v45 = v54++;
            v11[v45] = v12;
          }
          else
          {
            v46 = xmlCopyCharMultiByte(&v11[v54], v12);
            v54 += v46;
          }
          ArgList += v51;
          goto LABEL_74;
        }
        if ( xmlParserDebugEntities )
          xmlGenericError(xmlGenericErrorContext, "String decoding PE Reference: %.30s\n", (const char *)ArgList);
        v34 = (_BYTE *)sub_427FAB(a1, &ArgList);
        v35 = a1[97] == 89;
        v36 = v34;
        v52 = v34;
        if ( v35 )
          goto LABEL_84;
        if ( v34 )
        {
          a1[110] += *((_DWORD *)v34 + 18);
          if ( !*((_DWORD *)v34 + 10) )
            sub_427D3D(a1, (int)v34);
          ++a1[62];
          v37 = (_BYTE *)*((_DWORD *)v36 + 10);
          v38 = 0;
          if ( v37 )
          {
            v49 = a4;
            v39 = xmlStrlen(v37);
            v38 = (_BYTE *)xmlStringLenDecodeEntities((int)a1, v40, v39, v49, 0, 0, 0);
          }
          --a1[62];
          Block = v38;
          if ( v38 )
          {
            v41 = v38;
            if ( *v38 )
            {
              while ( 1 )
              {
                v42 = *v41;
                v43 = v54++;
                v11[v43] = v42;
                ++v41;
                if ( v54 > v55 - 100 )
                {
                  if ( sub_41EB1F(a1, (int)v52, v54) )
                    goto LABEL_84;
                  v55 = 2 * v55 + 100;
                  v44 = xmlRealloc(v11, v55);
                  if ( !v44 )
                    goto LABEL_83;
                  v11 = (_BYTE *)v44;
                }
                if ( !*v41 )
                  goto LABEL_45;
              }
            }
            goto LABEL_45;
          }
        }
      }
LABEL_78:
      if ( ArgList >= v50 )
        v12 = 0;
      else
        v12 = xmlStringCurrentChar(a1, ArgList, &v51);
      if ( !v12 )
        break;
      v10 = v55;
    }
  }
  v11[v54] = 0;
  return v11;
}
// 496494: invalid function type has been ignored
// 4209C8: conditional instruction was optimized away because eax.4!=0
// 420ADD: variable 'v22' is possibly undefined
// 420B8C: variable 'v29' is possibly undefined
// 420C66: variable 'v40' is possibly undefined
// 49B2BC: using guessed type int (__cdecl *xmlMallocAtomic)(size_t Size);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);
// 4A9C7C: using guessed type int xmlParserDebugEntities;

//----- (00420D79) --------------------------------------------------------
_BYTE *__cdecl xmlStringDecodeEntities(
        int *a1,
        unsigned __int8 *ArgList,
        int a3,
        unsigned __int8 a4,
        unsigned __int8 a5,
        unsigned __int8 a6)
{
  int v6; // eax

  if ( !a1 || !ArgList )
    return 0;
  v6 = xmlStrlen(ArgList);
  return xmlStringLenDecodeEntities(a1, ArgList, v6, a3, a4, a5, a6);
}
// 420D79: using guessed type unsigned __int8 *ArgList;

//----- (00420DB2) --------------------------------------------------------
int __usercall sub_420DB2@<eax>(_DWORD *a1@<eax>, int a2, int a3, int a4)
{
  int *v5; // eax
  int v6; // eax
  int v7; // ecx
  unsigned __int8 v8; // al
  int v9; // eax
  int v10; // ecx
  int IsMixedElement; // eax
  char *v13; // eax
  char v14; // cl
  _DWORD *v15; // esi
  int LastChild; // eax
  bool v17; // zf
  int v18; // edx

  if ( *(_DWORD *)(*a1 + 72) != *(_DWORD *)(*a1 + 68) )
  {
    v5 = (int *)a1[58];
    if ( v5 )
    {
      v6 = *v5;
      if ( v6 != 1 && v6 != -2 )
      {
        if ( !a4 )
        {
          v7 = 0;
          if ( a3 > 0 )
          {
            do
            {
              v8 = *(_BYTE *)(v7 + a2);
              if ( v8 != 32 && (v8 < 9u || v8 > 0xAu) && v8 != 13 )
                return 0;
            }
            while ( ++v7 < a3 );
          }
        }
        v9 = a1[13];
        if ( v9 )
        {
          v10 = a1[2];
          if ( !v10 )
            goto LABEL_17;
          IsMixedElement = xmlIsMixedElement(v10, *(char **)(v9 + 8));
          if ( !IsMixedElement )
            return 1;
          if ( IsMixedElement != 1 )
          {
LABEL_17:
            v13 = *(char **)(a1[9] + 16);
            v14 = *v13;
            if ( *v13 == 60 || v14 == 13 )
            {
              v15 = (_DWORD *)a1[13];
              if ( v15[3] || v14 != 60 || v13[1] != 47 )
              {
                LastChild = xmlGetLastChild((int)v15);
                if ( LastChild )
                {
                  if ( xmlNodeIsText(LastChild) )
                    return 0;
                  if ( !v18 )
                    return 1;
                  v17 = !xmlNodeIsText(v18);
                }
                else
                {
                  if ( v15[1] == 1 )
                    return 1;
                  v17 = v15[10] == 0;
                }
                if ( v17 )
                  return 1;
              }
            }
          }
        }
      }
    }
  }
  return 0;
}
// 420E89: variable 'v18' is possibly undefined

//----- (00420E9A) --------------------------------------------------------
_BYTE *__cdecl xmlSplitQName(int *a1, char *a2, _DWORD *a3)
{
  _DWORD *v3; // ecx
  int v4; // edi
  _BYTE *result; // eax
  unsigned __int8 v6; // dl
  int v7; // ebx
  unsigned __int8 *v8; // esi
  char *v9; // edx
  void *v10; // eax
  void *v11; // eax
  int v12; // ebx
  int v13; // eax
  int v14; // edi
  signed int v15; // eax
  unsigned __int8 *v16; // esi
  void *v17; // edi
  int v18; // eax
  void *v19; // eax
  signed int v20; // [esp+Ch] [ebp-84h]
  _DWORD *v21; // [esp+14h] [ebp-7Ch] BYREF
  signed int v22; // [esp+18h] [ebp-78h]
  void *Block; // [esp+1Ch] [ebp-74h]
  char Src[108]; // [esp+20h] [ebp-70h] BYREF

  v3 = a3;
  v4 = 0;
  v21 = a3;
  Block = 0;
  v22 = 100;
  if ( !a3 )
    return 0;
  *a3 = 0;
  if ( !a2 )
    return 0;
  v6 = *a2;
  if ( *a2 == 58 )
    return xmlStrdup(a2);
  v7 = v6;
  v8 = (unsigned __int8 *)(a2 + 1);
  if ( v6 )
  {
    v9 = (char *)(Src - (char *)v8);
    do
    {
      if ( v7 == 58 )
        break;
      if ( v4 >= 100 )
        goto LABEL_12;
      v8[(_DWORD)v9] = v7;
      v7 = *v8;
      ++v4;
      ++v8;
    }
    while ( v7 );
    if ( v4 >= 100 )
    {
LABEL_12:
      v22 = 2 * v4;
      v10 = (void *)xmlMallocAtomic(2 * v4);
      Block = v10;
      if ( !v10 )
        goto LABEL_65;
      memcpy(v10, Src, v4);
      if ( v7 )
      {
        v20 = v4 + 10;
        do
        {
          if ( v7 == 58 )
            break;
          if ( v20 > v22 )
          {
            v22 *= 2;
            v11 = (void *)xmlRealloc(Block, v22);
            if ( !v11 )
            {
              ((void (__cdecl *)(void *))xmlFree)(Block);
              xmlErrMemory((int)a1, 0);
              return 0;
            }
            Block = v11;
          }
          *((_BYTE *)Block + v4) = v7;
          v7 = *v8;
          ++v4;
          ++v20;
          ++v8;
        }
        while ( v7 );
      }
      v3 = v21;
      *((_BYTE *)Block + v4) = 0;
    }
  }
  if ( v7 == 58 && !*v8 )
  {
    if ( Block )
    {
      ((void (__cdecl *)(void *))xmlFree)(Block);
      v3 = v21;
    }
    *v3 = 0;
    return xmlStrdup(a2);
  }
  result = Block;
  if ( Block )
  {
    v22 = 100;
  }
  else
  {
    result = xmlStrndup(Src, v4);
    v3 = v21;
  }
  if ( v7 == 58 )
  {
    v12 = *v8;
    *v3 = result;
    if ( !v12 )
      return xmlStrndup((void *)byte_47627C, 0);
    Block = 0;
    if ( (v12 < 97 || v12 > 122) && (v12 < 65 || v12 > 90) && v12 != 95 && v12 != 58 )
    {
      v13 = xmlStringCurrentChar(a1, v8, &v21);
      v14 = v13;
      if ( v13 >= 256 )
      {
        if ( xmlCharInRange(v13, xmlIsBaseCharGroup) )
          goto LABEL_60;
      }
      else if ( v13 >= 65 && v13 <= 90
             || v13 >= 97 && v13 <= 122
             || v13 >= 192 && v13 <= 214
             || v13 >= 216 && v13 <= 246
             || v13 >= 248 )
      {
        goto LABEL_60;
      }
      if ( (v14 < 256 || (v14 < 19968 || v14 > 40869) && v14 != 12295 && (v14 < 12321 || v14 > 12329)) && v14 != 95 )
        sub_41F152((int (__cdecl *)(int, char *, char))0xCA, a1, "Name %s is not XML Namespace compliant\n", a2);
    }
LABEL_60:
    v15 = (signed int)Block;
    v16 = v8 + 1;
    do
    {
      if ( v15 >= v22 )
        goto LABEL_64;
      Src[v15] = v12;
      v12 = *v16;
      ++v15;
      ++v16;
      Block = (void *)v15;
    }
    while ( v12 );
    if ( v15 < v22 )
      return xmlStrndup(Src, (int)Block);
LABEL_64:
    v22 = 2 * v15;
    v17 = (void *)xmlMallocAtomic(2 * v15);
    if ( v17 )
    {
      memcpy(v17, Src, (size_t)Block);
      if ( !v12 )
      {
LABEL_72:
        *((_BYTE *)v17 + (_DWORD)Block) = 0;
        return v17;
      }
      v21 = (char *)Block + 10;
      while ( 1 )
      {
        if ( (int)v21 > v22 )
        {
          v22 *= 2;
          v18 = xmlRealloc(v17, v22);
          if ( !v18 )
          {
            xmlErrMemory((int)a1, 0);
            ((void (__cdecl *)(void *))xmlFree)(v17);
            return 0;
          }
          v17 = (void *)v18;
        }
        v19 = Block;
        Block = (char *)Block + 1;
        v21 = (_DWORD *)((char *)v21 + 1);
        *((_BYTE *)v17 + (_DWORD)v19) = v12;
        v12 = *v16++;
        if ( !v12 )
          goto LABEL_72;
      }
    }
LABEL_65:
    xmlErrMemory((int)a1, 0);
    return 0;
  }
  return result;
}
// 496494: invalid function type has been ignored
// 4211A9: conditional instruction was optimized away because edi.4!=0
// 47C2A4: using guessed type _DWORD xmlIsBaseCharGroup[2];
// 49B2BC: using guessed type int (__cdecl *xmlMallocAtomic)(size_t Size);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);
// 420E9A: using guessed type char Src[108];

//----- (004211E0) --------------------------------------------------------
int __usercall sub_4211E0@<eax>(int a1@<eax>, signed int a2@<ecx>)
{
  if ( (*(_DWORD *)(a1 + 360) & 0x20000) != 0 )
  {
    if ( a2 >= 256 )
    {
      if ( xmlCharInRange(a2, xmlIsBaseCharGroup) )
        return 1;
    }
    else if ( a2 >= 65 && a2 <= 90
           || a2 >= 97 && a2 <= 122
           || a2 >= 192 && a2 <= 214
           || a2 >= 216 && a2 <= 246
           || a2 >= 248 )
    {
      return 1;
    }
    if ( a2 >= 256 && (a2 >= 19968 && a2 <= 40869 || a2 == 12295 || a2 >= 12321 && a2 <= 12329) || a2 == 95 || a2 == 58 )
      return 1;
  }
  else if ( a2 != 32
         && a2 != 62
         && a2 != 47
         && (a2 >= 97 && a2 <= 122
          || a2 >= 65 && a2 <= 90
          || a2 == 95
          || a2 == 58
          || a2 >= 192 && a2 <= 214
          || a2 >= 216 && a2 <= 246
          || a2 >= 248 && a2 <= 767
          || a2 >= 880 && a2 <= 893
          || a2 >= 895 && a2 <= 0x1FFF
          || a2 >= 8204 && a2 <= 8205
          || a2 >= 8304 && a2 <= 8591
          || a2 >= 11264 && a2 <= 12271
          || a2 >= 12289 && a2 <= 55295
          || a2 >= 63744 && a2 <= 64975
          || a2 >= 65008 && a2 <= 65533
          || (unsigned int)(a2 - 0x10000) <= 0xDFFFF) )
  {
    return 1;
  }
  return 0;
}
// 47C2A4: using guessed type _DWORD xmlIsBaseCharGroup[2];

//----- (004213B6) --------------------------------------------------------
BOOL __usercall sub_4213B6@<eax>(int a1@<eax>, signed int a2@<ecx>)
{
  int v4; // eax

  if ( (*(_DWORD *)(a1 + 360) & 0x20000) != 0 )
  {
    if ( a2 >= 256 )
    {
      if ( xmlCharInRange(a2, xmlIsBaseCharGroup) )
        return 1;
    }
    else if ( a2 >= 65 && a2 <= 90
           || a2 >= 97 && a2 <= 122
           || a2 >= 192 && a2 <= 214
           || a2 >= 216 && a2 <= 246
           || a2 >= 248 )
    {
      return 1;
    }
    if ( a2 < 256 )
    {
      if ( (unsigned int)(a2 - 48) <= 9 )
        return 1;
    }
    else if ( a2 >= 19968 && a2 <= 40869
           || a2 == 12295
           || a2 >= 12321 && a2 <= 12329
           || xmlCharInRange(a2, xmlIsDigitGroup) )
    {
      return 1;
    }
    if ( a2 == 46 || a2 == 45 || a2 == 95 || a2 == 58 )
      return 1;
    if ( a2 < 256 )
    {
      v4 = a2 == 183;
    }
    else
    {
      if ( xmlCharInRange(a2, xmlIsCombiningGroup) )
        return 1;
      v4 = xmlCharInRange(a2, xmlIsExtenderGroup);
    }
    return v4 != 0;
  }
  return a2 != 32
      && a2 != 62
      && a2 != 47
      && (a2 >= 97 && a2 <= 122
       || a2 >= 65 && a2 <= 90
       || a2 >= 48 && a2 <= 57
       || a2 == 95
       || a2 == 58
       || a2 == 45
       || a2 == 46
       || a2 == 183
       || a2 >= 192 && a2 <= 214
       || a2 >= 216 && a2 <= 246
       || a2 >= 248 && a2 <= 767
       || a2 >= 768 && a2 <= 879
       || a2 >= 880 && a2 <= 893
       || a2 >= 895 && a2 <= 0x1FFF
       || a2 >= 8204 && a2 <= 8205
       || a2 >= 8255 && a2 <= 8256
       || a2 >= 8304 && a2 <= 8591
       || a2 >= 11264 && a2 <= 12271
       || a2 >= 12289 && a2 <= 55295
       || a2 >= 63744 && a2 <= 64975
       || a2 >= 65008 && a2 <= 65533
       || (unsigned int)(a2 - 0x10000) <= 0xDFFFF);
}
// 4215C9: conditional instruction was optimized away because esi.4 is in (100..3006|3008..3020|302A..4DFF|>=9FA6)
// 42162D: conditional instruction was optimized away because esi.4 is in (100..3006|3008..3020|302A..4DFF|>=9FA6)
// 47C2A4: using guessed type _DWORD xmlIsBaseCharGroup[2];
// 47C454: using guessed type _DWORD xmlIsCombiningGroup[2];
// 47C49C: using guessed type _DWORD xmlIsDigitGroup[2];
// 47C4D4: using guessed type _DWORD xmlIsExtenderGroup[2];

//----- (00421658) --------------------------------------------------------
unsigned __int8 *__usercall sub_421658@<eax>(int a1@<eax>)
{
  int v2; // eax
  int v3; // edi
  int v4; // ecx
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // ecx
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  signed int v13; // edi
  _BYTE *v14; // eax
  char *v15; // eax
  int Size; // [esp+10h] [ebp-Ch]
  int v18; // [esp+14h] [ebp-8h]
  int v19; // [esp+18h] [ebp-4h] BYREF

  v18 = 0;
  if ( !*(_DWORD *)(a1 + 292) && *(_DWORD *)(*(_DWORD *)(a1 + 36) + 20) - *(_DWORD *)(*(_DWORD *)(a1 + 36) + 16) < 250 )
    sub_41FF5D(a1);
  v2 = xmlCurrentChar((int *)a1, &v19);
  v3 = v2;
  if ( (*(_DWORD *)(a1 + 360) & 0x20000) != 0 )
  {
    if ( v2 == 32 || v2 == 62 || v2 == 47 )
      return 0;
    if ( v2 >= 256 )
    {
      if ( xmlCharInRange(v2, xmlIsBaseCharGroup) )
      {
LABEL_113:
        v8 = v19;
        for ( Size = v19; ; Size += v19 )
        {
          v11 = *(_DWORD *)(a1 + 36);
          if ( **(_BYTE **)(v11 + 16) == 10 )
          {
            ++*(_DWORD *)(v11 + 28);
            *(_DWORD *)(*(_DWORD *)(a1 + 36) + 32) = 1;
          }
          else
          {
            ++*(_DWORD *)(v11 + 32);
          }
          *(_DWORD *)(*(_DWORD *)(a1 + 36) + 16) += v8;
          if ( **(_BYTE **)(*(_DWORD *)(a1 + 36) + 16) == 37 )
            xmlParserHandlePEReference(a1);
          v12 = xmlCurrentChar((int *)a1, &v19);
          v13 = v12;
          if ( v12 == 32 || v12 == 62 || v12 == 47 )
            goto LABEL_158;
          if ( v12 >= 256 )
          {
            if ( xmlCharInRange(v12, xmlIsBaseCharGroup) )
              goto LABEL_147;
          }
          else if ( v12 >= 65 && v12 <= 90
                 || v12 >= 97 && v12 <= 122
                 || v12 >= 192 && v12 <= 214
                 || v12 >= 216 && v12 <= 246
                 || v12 >= 248 )
          {
            goto LABEL_147;
          }
          if ( v13 < 256 )
          {
            if ( (unsigned int)(v13 - 48) <= 9 )
              goto LABEL_147;
          }
          else if ( v13 >= 19968 && v13 <= 40869
                 || v13 == 12295
                 || v13 >= 12321 && v13 <= 12329
                 || xmlCharInRange(v13, xmlIsDigitGroup) )
          {
            goto LABEL_147;
          }
          if ( v13 != 46 && v13 != 45 && v13 != 95 && v13 != 58 )
          {
            if ( v13 < 256 )
            {
              v9 = v13 == 183;
            }
            else
            {
              if ( xmlCharInRange(v13, xmlIsCombiningGroup) )
                goto LABEL_147;
              v9 = xmlCharInRange(v13, xmlIsExtenderGroup);
            }
            if ( !v9 )
              goto LABEL_158;
          }
LABEL_147:
          v10 = v18++;
          if ( v10 > 100 )
          {
            v18 = 0;
            if ( !*(_DWORD *)(a1 + 292)
              && *(_DWORD *)(*(_DWORD *)(a1 + 36) + 20) - *(_DWORD *)(*(_DWORD *)(a1 + 36) + 16) < 250 )
            {
              sub_41FF5D(a1);
            }
          }
          v8 = v19;
        }
      }
    }
    else if ( v2 >= 65 && v2 <= 90
           || v2 >= 97 && v2 <= 122
           || v2 >= 192 && v2 <= 214
           || v2 >= 216 && v2 <= 246
           || v2 >= 248 )
    {
      goto LABEL_113;
    }
    if ( (v3 < 256 || (v3 < 19968 || v3 > 40869) && v3 != 12295 && (v3 < 12321 || v3 > 12329)) && v3 != 95 && v3 != 58 )
      return 0;
    goto LABEL_113;
  }
  if ( v2 == 32
    || v2 == 62
    || v2 == 47
    || (v2 < 97 || v2 > 122)
    && (v2 < 65 || v2 > 90)
    && v2 != 95
    && v2 != 58
    && (v2 < 192 || v2 > 214)
    && (v2 < 216 || v2 > 246)
    && (v2 < 248 || v2 > 767)
    && (v2 < 880 || v2 > 893)
    && (v2 < 895 || v2 > 0x1FFF)
    && (v2 < 8204 || v2 > 8205)
    && (v2 < 8304 || v2 > 8591)
    && (v2 < 11264 || v2 > 12271)
    && (v2 < 12289 || v2 > 55295)
    && (v2 < 63744 || v2 > 64975)
    && (v2 < 65008 || v2 > 65533)
    && (unsigned int)(v2 - 0x10000) > 0xDFFFF )
  {
    return 0;
  }
  v4 = v19;
  for ( Size = v19; ; Size += v19 )
  {
    v6 = *(_DWORD *)(a1 + 36);
    if ( **(_BYTE **)(v6 + 16) == 10 )
    {
      ++*(_DWORD *)(v6 + 28);
      *(_DWORD *)(*(_DWORD *)(a1 + 36) + 32) = 1;
    }
    else
    {
      ++*(_DWORD *)(v6 + 32);
    }
    *(_DWORD *)(*(_DWORD *)(a1 + 36) + 16) += v4;
    if ( **(_BYTE **)(*(_DWORD *)(a1 + 36) + 16) == 37 )
      xmlParserHandlePEReference(a1);
    v7 = xmlCurrentChar((int *)a1, &v19);
    if ( v7 == 32 || v7 == 62 || v7 == 47 )
      break;
    if ( (v7 < 97 || v7 > 122)
      && (v7 < 65 || v7 > 90)
      && (v7 < 48 || v7 > 57)
      && v7 != 95
      && v7 != 58
      && v7 != 45
      && v7 != 46
      && v7 != 183
      && (v7 < 192 || v7 > 214)
      && (v7 < 216 || v7 > 246)
      && (v7 < 248 || v7 > 767)
      && (v7 < 768 || v7 > 879)
      && (v7 < 880 || v7 > 893)
      && (v7 < 895 || v7 > 0x1FFF)
      && (v7 < 8204 || v7 > 8205)
      && (v7 < 8255 || v7 > 8256)
      && (v7 < 8304 || v7 > 8591)
      && (v7 < 11264 || v7 > 12271)
      && (v7 < 12289 || v7 > 55295)
      && (v7 < 63744 || v7 > 64975)
      && (v7 < 65008 || v7 > 65533)
      && (unsigned int)(v7 - 0x10000) > 0xDFFFF )
    {
      break;
    }
    v5 = v18++;
    if ( v5 > 100 )
    {
      v18 = 0;
      if ( !*(_DWORD *)(a1 + 292)
        && *(_DWORD *)(*(_DWORD *)(a1 + 36) + 20) - *(_DWORD *)(*(_DWORD *)(a1 + 36) + 16) < 250 )
      {
        sub_41FF5D(a1);
      }
    }
    v4 = v19;
  }
LABEL_158:
  v14 = *(_BYTE **)(*(_DWORD *)(a1 + 36) + 16);
  if ( *v14 == 10 && *(v14 - 1) == 13 )
    v15 = &v14[-Size - 1];
  else
    v15 = &v14[-Size];
  return xmlDictLookup(*(_DWORD **)(a1 + 296), v15, Size);
}
// 421AF6: conditional instruction was optimized away because edi.4 is in (100..3006|3008..3020|302A..4DFF|>=9FA6)
// 421B3E: conditional instruction was optimized away because edi.4 is in (100..3006|3008..3020|302A..4DFF|>=9FA6)
// 420686: using guessed type _DWORD __cdecl xmlParserHandlePEReference(_DWORD);
// 47C2A4: using guessed type _DWORD xmlIsBaseCharGroup[2];
// 47C454: using guessed type _DWORD xmlIsCombiningGroup[2];
// 47C49C: using guessed type _DWORD xmlIsDigitGroup[2];
// 47C4D4: using guessed type _DWORD xmlIsExtenderGroup[2];

//----- (00421C26) --------------------------------------------------------
unsigned __int8 *__cdecl xmlParseName(int a1)
{
  int v1; // ecx
  char *v2; // ebx
  char v3; // al
  unsigned __int8 v4; // al
  char *v5; // ecx
  int v6; // edi
  unsigned __int8 *v7; // ebp

  if ( !*(_DWORD *)(a1 + 292) && *(_DWORD *)(*(_DWORD *)(a1 + 36) + 20) - *(_DWORD *)(*(_DWORD *)(a1 + 36) + 16) < 250 )
    sub_41FF5D(a1);
  v1 = *(_DWORD *)(a1 + 36);
  v2 = *(char **)(v1 + 16);
  v3 = *v2;
  if ( ((unsigned __int8)*v2 < 0x61u || (unsigned __int8)v3 > 0x7Au)
    && ((unsigned __int8)v3 < 0x41u || (unsigned __int8)v3 > 0x5Au)
    && v3 != 95
    && v3 != 58 )
  {
    return sub_421658(a1);
  }
  do
  {
    do
      v4 = *++v2;
    while ( (unsigned __int8)*v2 >= 0x61u && v4 <= 0x7Au );
  }
  while ( v4 >= 0x41u && v4 <= 0x5Au || v4 >= 0x30u && v4 <= 0x39u || v4 == 95 || v4 == 45 || v4 == 58 || v4 == 46 );
  if ( *v2 <= 0 )
    return sub_421658(a1);
  v5 = *(char **)(v1 + 16);
  v6 = v2 - v5;
  v7 = xmlDictLookup(*(_DWORD **)(a1 + 296), v5, v2 - v5);
  *(_DWORD *)(*(_DWORD *)(a1 + 36) + 16) = v2;
  *(_DWORD *)(a1 + 200) += v6;
  *(_DWORD *)(*(_DWORD *)(a1 + 36) + 32) += v6;
  if ( !v7 )
    xmlErrMemory(a1, 0);
  return v7;
}

//----- (00421CEA) --------------------------------------------------------
unsigned __int8 *__usercall sub_421CEA@<eax>(int a1@<eax>)
{
  int v2; // eax
  int v3; // edi
  int v4; // eax
  int v5; // ecx
  _BYTE *v6; // eax
  bool v7; // zf
  int v8; // eax
  int v10; // [esp+Ch] [ebp-Ch] BYREF
  size_t Size; // [esp+10h] [ebp-8h]
  int v12; // [esp+14h] [ebp-4h]

  Size = 0;
  v12 = 0;
  if ( !*(_DWORD *)(a1 + 292) && *(_DWORD *)(*(_DWORD *)(a1 + 36) + 20) - *(_DWORD *)(*(_DWORD *)(a1 + 36) + 16) < 250 )
    sub_41FF5D(a1);
  v2 = xmlCurrentChar((int *)a1, &v10);
  v3 = v2;
  if ( v2 == 32 || v2 == 62 || v2 == 47 || !sub_4211E0(a1, v2) || v3 == 58 )
    return 0;
  do
  {
    if ( v3 == 62 || v3 == 47 || !sub_4213B6(a1, v3) || v3 == 58 )
      break;
    v4 = v12++;
    if ( v4 > 100 )
    {
      v12 = 0;
      if ( !*(_DWORD *)(a1 + 292)
        && *(_DWORD *)(*(_DWORD *)(a1 + 36) + 20) - *(_DWORD *)(*(_DWORD *)(a1 + 36) + 16) < 250 )
      {
        sub_41FF5D(a1);
      }
    }
    v5 = v10;
    v6 = *(_BYTE **)(*(_DWORD *)(a1 + 36) + 16);
    Size += v10;
    v7 = *v6 == 10;
    v8 = *(_DWORD *)(a1 + 36);
    if ( v7 )
    {
      ++*(_DWORD *)(v8 + 28);
      *(_DWORD *)(*(_DWORD *)(a1 + 36) + 32) = 1;
    }
    else
    {
      ++*(_DWORD *)(v8 + 32);
    }
    *(_DWORD *)(*(_DWORD *)(a1 + 36) + 16) += v5;
    if ( **(_BYTE **)(*(_DWORD *)(a1 + 36) + 16) == 37 )
      xmlParserHandlePEReference((int *)a1);
    v3 = xmlCurrentChar((int *)a1, &v10);
  }
  while ( v3 != 32 );
  return xmlDictLookup(*(_DWORD **)(a1 + 296), (char *)(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 16) - Size), Size);
}

//----- (00421E2A) --------------------------------------------------------
unsigned __int8 *__usercall sub_421E2A@<eax>(int a1@<esi>)
{
  int v1; // eax
  char *v2; // ebx
  char v3; // cl
  unsigned __int8 v4; // cl
  char *v5; // eax
  int v6; // edi
  unsigned __int8 *v7; // ebp

  v1 = *(_DWORD *)(a1 + 36);
  v2 = *(char **)(v1 + 16);
  v3 = *v2;
  if ( ((unsigned __int8)*v2 < 0x61u || (unsigned __int8)v3 > 0x7Au)
    && ((unsigned __int8)v3 < 0x41u || (unsigned __int8)v3 > 0x5Au)
    && v3 != 95 )
  {
    return sub_421CEA(a1);
  }
  do
  {
    do
      v4 = *++v2;
    while ( (unsigned __int8)*v2 >= 0x61u && v4 <= 0x7Au );
  }
  while ( v4 >= 0x41u && v4 <= 0x5Au || v4 >= 0x30u && v4 <= 0x39u || v4 == 95 || v4 == 45 || v4 == 46 );
  if ( *v2 <= 0 )
    return sub_421CEA(a1);
  v5 = *(char **)(v1 + 16);
  v6 = v2 - v5;
  v7 = xmlDictLookup(*(_DWORD **)(a1 + 296), v5, v2 - v5);
  *(_DWORD *)(*(_DWORD *)(a1 + 36) + 16) = v2;
  *(_DWORD *)(a1 + 200) += v6;
  *(_DWORD *)(*(_DWORD *)(a1 + 36) + 32) += v6;
  if ( !v7 )
    xmlErrMemory(a1, 0);
  return v7;
}

//----- (00421ECF) --------------------------------------------------------
unsigned __int8 *__usercall sub_421ECF@<eax>(int a1@<eax>, unsigned __int8 *a2)
{
  unsigned __int8 *v3; // edi
  unsigned __int8 *i; // ecx
  unsigned __int8 v5; // al
  unsigned __int8 *result; // eax

  v3 = a2;
  if ( !*(_DWORD *)(a1 + 292) && *(_DWORD *)(*(_DWORD *)(a1 + 36) + 20) - *(_DWORD *)(*(_DWORD *)(a1 + 36) + 16) < 250 )
    sub_41FF5D(a1);
  for ( i = *(unsigned __int8 **)(*(_DWORD *)(a1 + 36) + 16); *i && *i == *v3; ++i )
  {
    ++v3;
    ++*(_DWORD *)(*(_DWORD *)(a1 + 36) + 32);
  }
  if ( !*v3 && ((v5 = *i, *i == 62) || v5 == 32 || v5 >= 9u && v5 <= 0xAu || v5 == 13) )
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 36) + 16) = i;
  }
  else
  {
    result = xmlParseName(a1);
    if ( result != a2 )
      return result;
  }
  return (unsigned __int8 *)1;
}

//----- (00421F46) --------------------------------------------------------
_BYTE *__cdecl sub_421F46(unsigned __int8 **a1)
{
  int *v1; // ecx
  unsigned __int8 *v2; // ebx
  int *v3; // edi
  _BYTE *result; // eax
  int v5; // esi
  unsigned __int8 *v6; // ebx
  signed int v7; // eax
  void *v8; // edi
  signed int i; // ecx
  int v10; // eax
  signed int v11; // [esp+Ch] [ebp-80h]
  int *v12; // [esp+10h] [ebp-7Ch]
  int v13; // [esp+14h] [ebp-78h] BYREF
  int v14; // [esp+18h] [ebp-74h]
  char Src[108]; // [esp+1Ch] [ebp-70h] BYREF

  v2 = *a1;
  v3 = v1;
  v12 = v1;
  v14 = xmlStringCurrentChar(v1, *a1, &v13);
  result = (_BYTE *)sub_4211E0((int)v3, v14);
  if ( result )
  {
    v5 = 1;
    if ( v13 == 1 )
      Src[0] = v14;
    else
      v5 = xmlCopyCharMultiByte(Src, v14);
    v6 = &v2[v13];
    v7 = xmlStringCurrentChar(v3, v6, &v13);
    v14 = v7;
    while ( sub_4213B6((int)v3, v7) )
    {
      if ( v13 == 1 )
        Src[v5++] = v14;
      else
        v5 += xmlCopyCharMultiByte(&Src[v5], v14);
      v6 += v13;
      v7 = xmlStringCurrentChar(v3, v6, &v13);
      v14 = v7;
      if ( v5 >= 100 )
      {
        v11 = 2 * v5;
        v8 = (void *)xmlMallocAtomic(2 * v5);
        if ( !v8 )
        {
          xmlErrMemory((int)v12, 0);
          return 0;
        }
        memcpy(v8, Src, v5);
        for ( i = v14; ; v14 = i )
        {
          if ( !sub_4213B6((int)v12, i) )
          {
            *((_BYTE *)v8 + v5) = 0;
            *a1 = v6;
            return v8;
          }
          if ( v5 + 10 > v11 )
          {
            v11 *= 2;
            v10 = xmlRealloc(v8, v11);
            if ( !v10 )
            {
              xmlErrMemory((int)v12, 0);
              ((void (__cdecl *)(void *))xmlFree)(v8);
              return 0;
            }
            v8 = (void *)v10;
          }
          if ( v13 == 1 )
            *((_BYTE *)v8 + v5++) = v14;
          else
            v5 += xmlCopyCharMultiByte((_BYTE *)v8 + v5, v14);
          v6 += v13;
          i = xmlStringCurrentChar(v12, v6, &v13);
        }
      }
    }
    *a1 = v6;
    return xmlStrndup(Src, v5);
  }
  return result;
}
// 496494: invalid function type has been ignored
// 421F6A: variable 'v1' is possibly undefined
// 49B2BC: using guessed type int (__cdecl *xmlMallocAtomic)(size_t Size);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);
// 421F46: using guessed type char Src[108];

//----- (004220EE) --------------------------------------------------------
_BYTE *__cdecl xmlParseNmtoken(int *a1)
{
  int v1; // ebx
  int v2; // eax
  int v3; // eax
  int v4; // ecx
  void *v6; // edi
  int i; // ecx
  int v8; // eax
  int v9; // eax
  int v10; // eax
  signed int v11; // [esp+Ch] [ebp-80h]
  int v12; // [esp+10h] [ebp-7Ch] BYREF
  int v13; // [esp+14h] [ebp-78h]
  int v14; // [esp+18h] [ebp-74h]
  char Src[108]; // [esp+1Ch] [ebp-70h] BYREF

  v1 = 0;
  v14 = 0;
  if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
    sub_41FF5D((int)a1);
  v13 = xmlCurrentChar(a1, &v12);
  if ( !sub_4213B6((int)a1, v13) )
    return 0;
  while ( 1 )
  {
    v2 = v14++;
    if ( v2 > 100 )
    {
      v14 = 0;
      if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
        sub_41FF5D((int)a1);
    }
    if ( v12 == 1 )
      Src[v1++] = v13;
    else
      v1 += xmlCopyCharMultiByte(&Src[v1], v13);
    v3 = a1[9];
    if ( **(_BYTE **)(v3 + 16) == 10 )
    {
      ++*(_DWORD *)(v3 + 28);
      *(_DWORD *)(a1[9] + 32) = 1;
    }
    else
    {
      ++*(_DWORD *)(v3 + 32);
    }
    *(_DWORD *)(a1[9] + 16) += v12;
    if ( **(_BYTE **)(a1[9] + 16) == 37 )
      xmlParserHandlePEReference(a1);
    v4 = xmlCurrentChar(a1, &v12);
    v13 = v4;
    if ( v1 >= 100 )
      break;
    if ( !sub_4213B6((int)a1, v4) )
    {
      if ( !v1 )
        return 0;
      return xmlStrndup(Src, v1);
    }
  }
  v11 = 2 * v1;
  v6 = (void *)xmlMallocAtomic(2 * v1);
  if ( v6 )
  {
    memcpy(v6, Src, v1);
    for ( i = v13; ; v13 = i )
    {
      if ( !sub_4213B6((int)a1, i) )
      {
        *((_BYTE *)v6 + v1) = 0;
        return v6;
      }
      v8 = v14++;
      if ( v8 > 100 )
      {
        v14 = 0;
        if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
          sub_41FF5D((int)a1);
      }
      if ( v1 + 10 > v11 )
      {
        v11 *= 2;
        v9 = xmlRealloc(v6, v11);
        if ( !v9 )
        {
          xmlErrMemory((int)a1, 0);
          ((void (__cdecl *)(void *))xmlFree)(v6);
          return 0;
        }
        v6 = (void *)v9;
      }
      if ( v12 == 1 )
        *((_BYTE *)v6 + v1++) = v13;
      else
        v1 += xmlCopyCharMultiByte((_BYTE *)v6 + v1, v13);
      v10 = a1[9];
      if ( **(_BYTE **)(v10 + 16) == 10 )
      {
        ++*(_DWORD *)(v10 + 28);
        *(_DWORD *)(a1[9] + 32) = 1;
      }
      else
      {
        ++*(_DWORD *)(v10 + 32);
      }
      *(_DWORD *)(a1[9] + 16) += v12;
      if ( **(_BYTE **)(a1[9] + 16) == 37 )
        xmlParserHandlePEReference(a1);
      i = xmlCurrentChar(a1, &v12);
    }
  }
  xmlErrMemory((int)a1, 0);
  return 0;
}
// 496494: invalid function type has been ignored
// 49B2BC: using guessed type int (__cdecl *xmlMallocAtomic)(size_t Size);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);
// 4220EE: using guessed type char Src[108];

//----- (0042233D) --------------------------------------------------------
_BYTE *__cdecl xmlParseEntityValue(int *a1, _DWORD *a2)
{
  char v3; // al
  int v4; // eax
  int v5; // ebx
  unsigned __int8 *v6; // esi
  unsigned __int8 v7; // bl
  _BYTE *v8; // eax
  void *v9; // eax
  unsigned __int8 *v10; // esi
  int v11; // ecx
  int v12; // eax
  int v13; // eax
  void *v14; // ebx
  int v16; // [esp+Ch] [ebp-1Ch]
  _BYTE *v17; // [esp+10h] [ebp-18h]
  unsigned __int8 *v18; // [esp+14h] [ebp-14h] BYREF
  void *Block; // [esp+18h] [ebp-10h]
  int v20; // [esp+1Ch] [ebp-Ch]
  int v21; // [esp+20h] [ebp-8h]
  void *v22; // [esp+24h] [ebp-4h]
  unsigned __int8 v23; // [esp+33h] [ebp+Bh]

  v3 = **(_BYTE **)(a1[9] + 16);
  v21 = 0;
  Block = (void *)100;
  v17 = 0;
  if ( v3 == 34 )
  {
    v23 = 34;
  }
  else
  {
    if ( v3 != 39 )
    {
      sub_41EC3F(36, a1, 0);
      return 0;
    }
    v23 = 39;
  }
  v22 = (void *)xmlMallocAtomic(0x64u);
  if ( !v22 )
  {
    xmlErrMemory((int)a1, 0);
    return 0;
  }
  v4 = a1[9];
  a1[43] = 11;
  v16 = v4;
  if ( !a1[73] && *(_DWORD *)(v4 + 20) - *(_DWORD *)(v4 + 16) < 250 )
    sub_41FF5D((int)a1);
  xmlNextChar(a1);
  v5 = xmlCurrentChar(a1, &v18);
  v20 = v5;
  while ( v5 < 256 )
  {
    if ( (v5 < 9 || v5 > 10) && v5 != 13 && v5 < 32 )
      goto LABEL_17;
LABEL_39:
    if ( v5 == v23 && a1[9] == v16 )
      goto LABEL_17;
    if ( v21 + 5 >= (int)Block )
    {
      Block = (void *)(2 * (_DWORD)Block);
      v9 = (void *)xmlRealloc(v22, (SIZE_T)Block);
      if ( !v9 )
      {
        xmlErrMemory((int)a1, 0);
        ((void (__cdecl *)(void *))xmlFree)(v22);
        return 0;
      }
      v22 = v9;
    }
    v10 = v18;
    v11 = v21;
    if ( v18 == (unsigned __int8 *)1 )
    {
      ++v21;
      *((_BYTE *)v22 + v11) = v5;
    }
    else
    {
      v12 = xmlCopyCharMultiByte((_BYTE *)v22 + v21, v5);
      v21 += v12;
    }
    v13 = a1[9];
    if ( **(_BYTE **)(v13 + 16) == 10 )
    {
      ++*(_DWORD *)(v13 + 28);
      *(_DWORD *)(a1[9] + 32) = 1;
    }
    else
    {
      ++*(_DWORD *)(v13 + 32);
    }
    *(_DWORD *)(a1[9] + 16) += v10;
    if ( **(_BYTE **)(a1[9] + 16) == 37 )
      xmlParserHandlePEReference(a1);
    while ( !**(_BYTE **)(a1[9] + 16) && a1[10] > 1 )
      xmlPopInput(a1);
    if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
      sub_41FF5D((int)a1);
    v20 = xmlCurrentChar(a1, &v18);
    if ( !v20 )
    {
      if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
        sub_41FF5D((int)a1);
      v20 = xmlCurrentChar(a1, &v18);
    }
    v5 = v20;
  }
  if ( v5 <= 55295 || v5 >= 57344 && v5 <= 65533 || (unsigned int)(v5 - 0x10000) <= 0xFFFFF )
    goto LABEL_39;
LABEL_17:
  v6 = (unsigned __int8 *)v22;
  *((_BYTE *)v22 + v21) = 0;
  if ( *v6 )
  {
    do
    {
      v7 = *v6;
      if ( *v6 == 37 || v7 == 38 && v6[1] != 35 )
      {
        v18 = v6 + 1;
        v8 = sub_421F46(&v18);
        v6 = v18;
        Block = v8;
        if ( !v8 || *v18 != 59 )
          sub_41F093(
            (int (__cdecl *)(int, char *, char))0x57,
            a1,
            "EntityValue: '%c' forbidden except for entities references\n",
            v7);
        if ( v7 == 37 && a1[54] == 1 && a1[10] == 1 )
          sub_41EC3F(88, a1, 0);
        if ( Block )
          ((void (__cdecl *)(void *))xmlFree)(Block);
        if ( !*v6 )
          break;
      }
      ++v6;
    }
    while ( *v6 );
    v5 = v20;
  }
  if ( v5 == v23 )
  {
    xmlNextChar(a1);
    v14 = v22;
    v17 = xmlStringDecodeEntities(a1, (unsigned __int8 *)v22, 2, 0, 0, 0);
    if ( a2 )
      *a2 = v14;
    else
      ((void (__cdecl *)(void *))xmlFree)(v14);
  }
  else
  {
    sub_41EC3F(37, a1, 0);
    ((void (__cdecl *)(void *))xmlFree)(v22);
  }
  return v17;
}
// 496494: invalid function type has been ignored
// 49B2BC: using guessed type int (__cdecl *xmlMallocAtomic)(size_t Size);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);

//----- (00422666) --------------------------------------------------------
char *__cdecl sub_422666(int *a1, signed int *a2, int a3)
{
  int *v3; // ebx
  char v4; // al
  signed int v5; // esi
  char *v6; // edi
  int v7; // eax
  char v8; // cl
  bool v9; // zf
  unsigned int v10; // eax
  signed int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // esi
  int v15; // eax
  _DWORD *v16; // ebx
  int v17; // eax
  void *v18; // eax
  char *v19; // ebx
  char v20; // al
  int v21; // eax
  int v22; // eax
  char *v23; // edx
  void *v24; // eax
  int v25; // eax
  char *v26; // eax
  int v27; // eax
  int v28; // eax
  int v29; // eax
  int v30; // eax
  int v32; // [esp+Ch] [ebp-20h]
  char *v33; // [esp+Ch] [ebp-20h]
  int v34; // [esp+10h] [ebp-1Ch] BYREF
  int v35; // [esp+14h] [ebp-18h]
  void *Block; // [esp+18h] [ebp-14h]
  int v37; // [esp+1Ch] [ebp-10h]
  char *v38; // [esp+20h] [ebp-Ch]
  SIZE_T v39; // [esp+24h] [ebp-8h]
  char v40; // [esp+2Bh] [ebp-1h]

  v3 = a1;
  v4 = **(_BYTE **)(a1[9] + 16);
  v5 = 0;
  Block = 0;
  v37 = 0;
  v35 = 0;
  if ( v4 == 34 )
  {
    v40 = 34;
  }
  else
  {
    if ( v4 != 39 )
    {
      sub_41EC3F(39, a1, 0);
      return 0;
    }
    v40 = 39;
  }
  a1[43] = 12;
  xmlNextChar(a1);
  v39 = 100;
  v6 = (char *)xmlMallocAtomic(0x64u);
  v38 = v6;
  if ( !v6 )
  {
LABEL_109:
    xmlErrMemory((int)a1, 0);
    if ( v6 )
      ((void (__cdecl *)(char *))xmlFree)(v6);
    if ( Block )
      ((void (__cdecl *)(void *))xmlFree)(Block);
    return 0;
  }
  v7 = xmlCurrentChar(a1, &v34);
  if ( **(_BYTE **)(a1[9] + 16) == v40 )
    goto LABEL_17;
  do
  {
    if ( v7 >= 256 )
    {
      if ( v7 > 55295 && (v7 < 57344 || v7 > 65533) && (unsigned int)(v7 - 0x10000) > 0xFFFFF )
        break;
    }
    else if ( (v7 < 9 || v7 > 10) && v7 != 13 && v7 < 32 )
    {
      break;
    }
    if ( v7 == 60 )
      break;
    if ( v7 == 38 )
    {
      v9 = *(_BYTE *)(*(_DWORD *)(v3[9] + 16) + 1) == 35;
      v35 = 0;
      if ( v9 )
      {
        v10 = xmlParseCharRef(v3);
        v32 = v10;
        if ( v10 == 38 )
        {
          v11 = v39 - 10;
          if ( v3[4] )
          {
            if ( v5 > v11 )
            {
              v39 = 2 * v39 + 10;
              v12 = xmlRealloc(v6, v39);
              if ( !v12 )
                goto LABEL_109;
              v38 = (char *)v12;
              v6 = (char *)v12;
            }
            v6[v5] = 38;
            goto LABEL_73;
          }
          if ( v5 > v11 )
          {
            v39 = 2 * v39 + 10;
            v13 = xmlRealloc(v6, v39);
            if ( !v13 )
              goto LABEL_109;
            v38 = (char *)v13;
            v6 = (char *)v13;
          }
LABEL_35:
          v6[v5] = 38;
          v14 = v5 + 1;
          v6[v14] = 35;
          v6[++v14] = 51;
          v6[++v14] = 56;
          v5 = v14 + 1;
LABEL_72:
          v6[v5] = 59;
          goto LABEL_73;
        }
        if ( v10 )
        {
          if ( v5 > (int)(v39 - 10) )
          {
            v39 = 2 * v39 + 10;
            v15 = xmlRealloc(v6, v39);
            if ( !v15 )
              goto LABEL_109;
            v38 = (char *)v15;
            v6 = (char *)v15;
          }
          v5 += xmlCopyChar(0, &v6[v5], v32);
          goto LABEL_74;
        }
      }
      else
      {
        v16 = xmlParseEntityRef(a1);
        ++a1[110];
        if ( v16 )
        {
          a1[110] += v16[17];
          if ( v16[12] == 6 )
          {
            if ( v5 > (int)(v39 - 10) )
            {
              v39 = 2 * v39 + 10;
              v17 = xmlRealloc(v6, v39);
              if ( !v17 )
                goto LABEL_109;
              v38 = (char *)v17;
              v6 = (char *)v17;
            }
            if ( a1[4] || *(_BYTE *)v16[10] != 38 )
            {
              v6[v5] = *(_BYTE *)v16[10];
LABEL_73:
              ++v5;
LABEL_74:
              v37 = v5;
              goto LABEL_104;
            }
            goto LABEL_35;
          }
          if ( !a1[4] )
          {
            v37 = xmlStrlen((_BYTE *)v16[2]);
            v22 = v16[10];
            v33 = v23;
            if ( v22 )
            {
              v24 = (void *)xmlStringDecodeEntities((int)a1, v22, 1, 0, 0, 0);
              Block = v24;
              if ( v24 )
              {
                ((void (__cdecl *)(void *))xmlFree)(v24);
                Block = 0;
              }
            }
            v6[v5++] = 38;
            while ( v5 > (int)(v39 - v37 - 10) )
            {
              v39 = v37 + 2 * v39 + 10;
              v25 = xmlRealloc(v6, v39);
              if ( !v25 )
                goto LABEL_109;
              v38 = (char *)v25;
              v6 = (char *)v25;
            }
            if ( v37 > 0 )
            {
              v26 = v33;
              do
              {
                v6[v5++] = *v26++;
                --v37;
              }
              while ( v37 > 0 );
            }
            goto LABEL_72;
          }
          v18 = (void *)xmlStringDecodeEntities((int)a1, v16[10], 1, 0, 0, 0);
          Block = v18;
          if ( v18 )
          {
            v19 = (char *)v18;
            while ( *v19 )
            {
              v20 = *v19;
              if ( *v19 == 13 || v20 == 10 || v20 == 9 )
                v6[v5] = 32;
              else
                v6[v5] = v20;
              ++v5;
              ++v19;
              v37 = v5;
              if ( v5 > (int)(v39 - 10) )
              {
                v39 = 2 * v39 + 10;
                v21 = xmlRealloc(v6, v39);
                if ( !v21 )
                  goto LABEL_109;
                v38 = (char *)v21;
                v6 = (char *)v21;
              }
            }
            ((void (__cdecl *)(void *))xmlFree)(Block);
            Block = 0;
          }
        }
      }
    }
    else
    {
      if ( v7 == 32 || v7 == 13 || v7 == 10 || v7 == 9 )
      {
        if ( v5 || !a3 )
        {
          if ( !a3 || !v35 )
          {
            if ( v34 == 1 )
            {
              v6[v5++] = 32;
            }
            else
            {
              v28 = (int)&v6[v5];
              if ( &v6[v5] )
              {
                *(_BYTE *)v28 = 32;
                v28 = 1;
              }
              v5 += v28;
            }
            v37 = v5;
            while ( v5 > (int)(v39 - 10) )
            {
              v39 = 2 * v39 + 10;
              v29 = xmlRealloc(v6, v39);
              if ( !v29 )
                goto LABEL_109;
              v38 = (char *)v29;
              v6 = (char *)v29;
            }
          }
          v3 = a1;
          v35 = 1;
        }
      }
      else
      {
        v35 = 0;
        if ( v34 == 1 )
          v6[v5++] = v7;
        else
          v5 += xmlCopyCharMultiByte(&v6[v5], v7);
        v37 = v5;
        if ( v5 > (int)(v39 - 10) )
        {
          v39 = 2 * v39 + 10;
          v27 = xmlRealloc(v6, v39);
          if ( !v27 )
            goto LABEL_109;
          v38 = (char *)v27;
          v6 = (char *)v27;
        }
      }
      v30 = v3[9];
      if ( **(_BYTE **)(v30 + 16) == 10 )
      {
        ++*(_DWORD *)(v30 + 28);
        *(_DWORD *)(v3[9] + 32) = 1;
      }
      else
      {
        ++*(_DWORD *)(v30 + 32);
      }
      *(_DWORD *)(v3[9] + 16) += v34;
      if ( **(_BYTE **)(v3[9] + 16) == 37 )
        xmlParserHandlePEReference(v3);
    }
LABEL_104:
    v3 = a1;
    if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
    {
      sub_41FF5D((int)a1);
      v5 = v37;
      v6 = v38;
    }
    v7 = xmlCurrentChar(a1, &v34);
  }
  while ( **(_BYTE **)(a1[9] + 16) != v40 );
  if ( v35 && a3 && v6[v5 - 1] == 32 )
  {
    do
      --v5;
    while ( v6[v5 - 1] == 32 );
  }
  v3 = a1;
LABEL_17:
  v6[v5] = 0;
  v8 = **(_BYTE **)(v3[9] + 16);
  if ( v8 == 60 )
  {
    sub_41EC3F(38, a1, 0);
    goto LABEL_128;
  }
  if ( v8 == v40 )
  {
    xmlNextChar(v3);
  }
  else
  {
    if ( !v7 )
      goto LABEL_120;
    if ( v7 >= 256 )
    {
      if ( v7 > 55295 && (v7 < 57344 || v7 > 65533) && (unsigned int)(v7 - 0x10000) > 0xFFFFF )
        goto LABEL_125;
LABEL_120:
      sub_41EFC6((int (__cdecl *)(int, char *, char))0x28, v3, "AttValue: ' expected\n");
    }
    else
    {
      if ( v7 >= 9 && v7 <= 10 || v7 == 13 || v7 >= 32 )
        goto LABEL_120;
LABEL_125:
      sub_41EFC6((int (__cdecl *)(int, char *, char))9, v3, "invalid character in attribute value\n");
    }
    v6 = v38;
  }
LABEL_128:
  if ( a2 )
    *a2 = v5;
  return v6;
}
// 496494: invalid function type has been ignored
// 42276D: conditional instruction was optimized away because eax.4 is in (9..A|==D|20..3B|>=3D)
// 42296D: variable 'v23' is possibly undefined
// 49B2BC: using guessed type int (__cdecl *xmlMallocAtomic)(size_t Size);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);

//----- (00422BFB) --------------------------------------------------------
char *__cdecl xmlParseAttValue(int *a1)
{
  if ( a1 && a1[9] )
    return sub_428B02(a1, 0, 0, 0);
  else
    return 0;
}

//----- (00422C19) --------------------------------------------------------
void *__cdecl xmlParseSystemLiteral(int *a1)
{
  int v2; // eax
  _DWORD *v3; // eax
  char v4; // al
  int v5; // ebx
  void *v7; // eax
  int v8; // edi
  int v9; // ecx
  int v10; // eax
  int v11; // eax
  _DWORD *v12; // eax
  int v13; // [esp+Ch] [ebp-18h]
  int v14; // [esp+10h] [ebp-14h] BYREF
  signed int v15; // [esp+14h] [ebp-10h]
  int v16; // [esp+18h] [ebp-Ch]
  void *Block; // [esp+1Ch] [ebp-8h]
  int v18; // [esp+20h] [ebp-4h]
  unsigned __int8 v19; // [esp+2Fh] [ebp+Bh]

  v2 = a1[43];
  v18 = 0;
  v15 = 100;
  v13 = v2;
  v16 = 0;
  if ( !a1[73] )
  {
    v3 = (_DWORD *)a1[9];
    if ( v3[4] - v3[3] > 500 && v3[5] - v3[4] < 500 )
      sub_41FF30(a1);
  }
  v4 = **(_BYTE **)(a1[9] + 16);
  if ( v4 == 34 )
  {
    xmlNextChar(a1);
    v19 = 34;
  }
  else
  {
    if ( v4 != 39 )
    {
      sub_41EC3F(43, a1, 0);
      return 0;
    }
    xmlNextChar(a1);
    v19 = 39;
  }
  Block = (void *)xmlMallocAtomic(0x64u);
  if ( Block )
  {
    a1[43] = 13;
    v5 = xmlCurrentChar(a1, &v14);
    while ( 1 )
    {
      if ( v5 >= 256 )
      {
        if ( v5 > 55295 && (v5 < 57344 || v5 > 65533) && (unsigned int)(v5 - 0x10000) > 0xFFFFF )
        {
LABEL_17:
          *((_BYTE *)Block + v18) = 0;
          a1[43] = v13;
          if ( v5 >= 256 )
          {
            if ( v5 > 55295 && (v5 < 57344 || v5 > 65533) && (unsigned int)(v5 - 0x10000) > 0xFFFFF )
              goto LABEL_59;
LABEL_22:
            xmlNextChar(a1);
          }
          else
          {
            if ( v5 >= 9 && v5 <= 10 || v5 == 13 || v5 >= 32 )
              goto LABEL_22;
LABEL_59:
            sub_41EC3F(44, a1, 0);
          }
          return Block;
        }
      }
      else if ( (v5 < 9 || v5 > 10) && v5 != 13 && v5 < 32 )
      {
        goto LABEL_17;
      }
      if ( v5 == v19 )
        goto LABEL_17;
      if ( v18 + 5 >= v15 )
      {
        v15 *= 2;
        v7 = (void *)xmlRealloc(Block, v15);
        if ( !v7 )
        {
          ((void (__cdecl *)(void *))xmlFree)(Block);
          xmlErrMemory((int)a1, 0);
          a1[43] = v13;
          return 0;
        }
        Block = v7;
      }
      if ( ++v16 > 50 )
      {
        if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
          sub_41FF5D((int)a1);
        v16 = 0;
      }
      v8 = v14;
      v9 = v18;
      if ( v14 == 1 )
      {
        ++v18;
        *((_BYTE *)Block + v9) = v5;
      }
      else
      {
        v10 = xmlCopyCharMultiByte((_BYTE *)Block + v18, v5);
        v18 += v10;
      }
      v11 = a1[9];
      if ( **(_BYTE **)(v11 + 16) == 10 )
      {
        ++*(_DWORD *)(v11 + 28);
        *(_DWORD *)(a1[9] + 32) = 1;
      }
      else
      {
        ++*(_DWORD *)(v11 + 32);
      }
      *(_DWORD *)(a1[9] + 16) += v8;
      if ( **(_BYTE **)(a1[9] + 16) == 37 )
        xmlParserHandlePEReference(a1);
      v5 = xmlCurrentChar(a1, &v14);
      if ( !v5 )
      {
        if ( !a1[73] )
        {
          if ( *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
            sub_41FF5D((int)a1);
          if ( !a1[73] )
          {
            v12 = (_DWORD *)a1[9];
            if ( v12[4] - v12[3] > 500 && v12[5] - v12[4] < 500 )
              sub_41FF30(a1);
          }
        }
        v5 = xmlCurrentChar(a1, &v14);
      }
    }
  }
  xmlErrMemory((int)a1, 0);
  return 0;
}
// 496494: invalid function type has been ignored
// 49B2BC: using guessed type int (__cdecl *xmlMallocAtomic)(size_t Size);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);

//----- (00422EE9) --------------------------------------------------------
void *__cdecl xmlParsePubidLiteral(int *a1)
{
  _DWORD *v2; // eax
  char v3; // al
  int v4; // eax
  int v5; // eax
  unsigned __int8 *v6; // ecx
  unsigned __int8 v7; // bl
  _DWORD *v8; // eax
  int v10; // [esp+Ch] [ebp-14h]
  signed int v11; // [esp+10h] [ebp-10h]
  int v12; // [esp+14h] [ebp-Ch]
  int v13; // [esp+18h] [ebp-8h]
  void *Block; // [esp+1Ch] [ebp-4h]
  char v15; // [esp+2Bh] [ebp+Bh]

  v12 = 0;
  v11 = 100;
  v13 = 0;
  v10 = a1[43];
  if ( !a1[73] )
  {
    v2 = (_DWORD *)a1[9];
    if ( v2[4] - v2[3] > 500 && v2[5] - v2[4] < 500 )
      sub_41FF30(a1);
  }
  v3 = **(_BYTE **)(a1[9] + 16);
  if ( v3 == 34 )
  {
    xmlNextChar(a1);
    v15 = 34;
  }
  else
  {
    if ( v3 != 39 )
    {
      sub_41EC3F(43, a1, 0);
      return 0;
    }
    xmlNextChar(a1);
    v15 = 39;
  }
  Block = (void *)xmlMallocAtomic(0x64u);
  if ( !Block )
  {
    xmlErrMemory((int)a1, 0);
    return 0;
  }
  a1[43] = 16;
LABEL_29:
  v7 = **(_BYTE **)(a1[9] + 16);
  while ( xmlIsPubidChar_tab[v7] && v7 != v15 )
  {
    if ( v12 + 1 >= v11 )
    {
      v11 *= 2;
      v4 = xmlRealloc(Block, v11);
      if ( !v4 )
      {
        xmlErrMemory((int)a1, 0);
        ((void (__cdecl *)(void *))xmlFree)(Block);
        return 0;
      }
      Block = (void *)v4;
    }
    ++v13;
    *((_BYTE *)Block + v12++) = v7;
    if ( v13 > 50 )
    {
      if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
        sub_41FF5D((int)a1);
      v13 = 0;
    }
    xmlNextChar(a1);
    v5 = a1[9];
    v6 = *(unsigned __int8 **)(v5 + 16);
    v7 = *v6;
    if ( !*v6 )
    {
      if ( !a1[73] )
      {
        if ( *(_DWORD *)(v5 + 20) - (int)v6 < 250 )
          sub_41FF5D((int)a1);
        if ( !a1[73] )
        {
          v8 = (_DWORD *)a1[9];
          if ( v8[4] - v8[3] > 500 && v8[5] - v8[4] < 500 )
            sub_41FF30(a1);
        }
      }
      goto LABEL_29;
    }
  }
  *((_BYTE *)Block + v12) = 0;
  if ( v7 == v15 )
    xmlNextChar(a1);
  else
    sub_41EC3F(44, a1, 0);
  a1[43] = v10;
  return Block;
}
// 496494: invalid function type has been ignored
// 49B2BC: using guessed type int (__cdecl *xmlMallocAtomic)(size_t Size);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);

//----- (004230C0) --------------------------------------------------------
void __cdecl xmlParseCharData(int *a1, int a2)
{
  int v3; // eax
  _DWORD *v4; // eax
  unsigned __int8 *v5; // edi
  unsigned __int8 v6; // al
  int v7; // eax
  int v8; // ecx
  unsigned __int8 *v9; // ecx
  int v10; // ebx
  int v11; // eax
  void (__cdecl *v12)(int, unsigned __int8 *, int); // edx
  unsigned __int8 v13; // al
  int v14; // eax
  int v15; // ecx
  bool v16; // zf
  int v17; // eax
  void (__cdecl *v18)(int, int, int); // eax
  void (__cdecl *v19)(int, int, int); // eax
  _DWORD *v20; // eax
  int v21; // eax
  _BYTE *v22; // edi
  _DWORD *v23; // eax
  unsigned __int8 v24; // al
  int v25; // eax
  int v26; // ebx
  int v27; // ecx
  int v28; // eax
  void (__cdecl *v29)(int, int, int); // edx
  int v30; // eax
  void (__cdecl *v31)(int, int, int); // eax
  void (__cdecl *v32)(int, int, int); // eax
  _DWORD *v33; // esi
  int v34; // [esp+Ch] [ebp-4h]
  int v35; // [esp+18h] [ebp+8h]
  int v36; // [esp+18h] [ebp+8h]
  int v37; // [esp+1Ch] [ebp+Ch]

  v3 = a1[9];
  v35 = *(_DWORD *)(v3 + 28);
  v34 = *(_DWORD *)(v3 + 32);
  if ( !a1[73] )
  {
    v4 = (_DWORD *)a1[9];
    if ( v4[4] - v4[3] > 500 && v4[5] - v4[4] < 500 )
      sub_41FF30(a1);
    if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
      sub_41FF5D((int)a1);
  }
  if ( a2 )
  {
LABEL_62:
    *(_DWORD *)(a1[9] + 28) = v35;
    *(_DWORD *)(a1[9] + 32) = v34;
    sub_4233D6(a2);
    return;
  }
  v5 = *(unsigned __int8 **)(a1[9] + 16);
  while ( 1 )
  {
    v6 = *v5;
    while ( 1 )
    {
      if ( v6 == 32 )
      {
        do
        {
          ++v5;
          ++*(_DWORD *)(a1[9] + 32);
        }
        while ( *v5 == 32 );
      }
      if ( *v5 != 10 )
        break;
      do
      {
        ++*(_DWORD *)(a1[9] + 28);
        ++v5;
        *(_DWORD *)(a1[9] + 32) = 1;
        v6 = *v5;
      }
      while ( *v5 == 10 );
    }
    if ( *v5 == 60 )
      break;
    while ( 1 )
    {
      while ( 1 )
      {
        v7 = a1[9];
        v8 = *(_DWORD *)(v7 + 32);
        while ( byte_47C600[*v5] )
        {
          ++v5;
          ++v8;
        }
        *(_DWORD *)(v7 + 32) = v8;
        if ( *v5 != 10 )
          break;
        do
        {
          ++*(_DWORD *)(a1[9] + 28);
          ++v5;
          *(_DWORD *)(a1[9] + 32) = 1;
        }
        while ( *v5 == 10 );
      }
      if ( *v5 != 93 )
        break;
      if ( v5[1] == 93 && v5[2] == 62 )
      {
        sub_41EC3F(62, a1, 0);
        *(_DWORD *)(a1[9] + 16) = v5;
        return;
      }
      ++v5;
      ++*(_DWORD *)(a1[9] + 32);
    }
    v9 = *(unsigned __int8 **)(a1[9] + 16);
    v10 = v5 - v9;
    if ( v5 - v9 > 0 )
    {
      v11 = *a1;
      if ( *a1 )
      {
        v12 = *(void (__cdecl **)(int, unsigned __int8 *, int))(v11 + 68);
        if ( *(void (__cdecl **)(int, unsigned __int8 *, int))(v11 + 72) != v12
          && ((v13 = *v9, *v9 == 32) || v13 >= 9u && v13 <= 0xAu || v13 == 13) )
        {
          v14 = a1[9];
          v15 = *(_DWORD *)(v14 + 16);
          *(_DWORD *)(v14 + 16) = v5;
          v36 = v15;
          v16 = sub_420DB2(a1, v15, v10, 0) == 0;
          v17 = *a1;
          if ( v16 )
          {
            v19 = *(void (__cdecl **)(int, int, int))(v17 + 68);
            if ( v19 )
              v19(a1[1], v36, v10);
            v20 = (_DWORD *)a1[58];
            if ( *v20 == -1 )
              *v20 = -2;
          }
          else
          {
            v18 = *(void (__cdecl **)(int, int, int))(v17 + 72);
            if ( v18 )
              v18(a1[1], v36, v10);
          }
        }
        else if ( v12 )
        {
          v12(a1[1], v9, v5 - v9);
        }
        v21 = a1[9];
        v34 = *(_DWORD *)(v21 + 32);
        v35 = *(_DWORD *)(v21 + 28);
      }
      if ( a1[43] != 7 )
        return;
    }
    *(_DWORD *)(a1[9] + 16) = v5;
    if ( *v5 != 13 )
      goto LABEL_49;
    v22 = v5 + 1;
    if ( *v22 != 10 )
    {
      v5 = v22 - 1;
LABEL_49:
      if ( *v5 == 60 || *v5 == 38 )
        return;
      if ( !a1[73] )
      {
        v23 = (_DWORD *)a1[9];
        if ( v23[4] - v23[3] > 500 && v23[5] - v23[4] < 500 )
          sub_41FF30(a1);
        if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
          sub_41FF5D((int)a1);
      }
      v5 = *(unsigned __int8 **)(a1[9] + 16);
      goto LABEL_59;
    }
    *(_DWORD *)(a1[9] + 16) = v22;
    v5 = v22 + 1;
    ++*(_DWORD *)(a1[9] + 28);
    *(_DWORD *)(a1[9] + 32) = 1;
LABEL_59:
    v24 = *v5;
    if ( (*v5 < 0x20u || v24 > 0x7Fu) && v24 != 9 )
      goto LABEL_62;
  }
  v25 = a1[9];
  v26 = (int)&v5[-*(_DWORD *)(v25 + 16)];
  if ( v26 > 0 )
  {
    v27 = *(_DWORD *)(v25 + 16);
    *(_DWORD *)(v25 + 16) = v5;
    v28 = *a1;
    v37 = v27;
    if ( *a1 )
    {
      v29 = *(void (__cdecl **)(int, int, int))(v28 + 68);
      if ( *(void (__cdecl **)(int, int, int))(v28 + 72) == v29 )
      {
        if ( v29 )
          v29(a1[1], v27, v26);
      }
      else
      {
        v16 = sub_420DB2(a1, v27, v26, 1) == 0;
        v30 = *a1;
        if ( v16 )
        {
          v32 = *(void (__cdecl **)(int, int, int))(v30 + 68);
          if ( v32 )
            v32(a1[1], v37, v26);
          v33 = (_DWORD *)a1[58];
          if ( *v33 == -1 )
            *v33 = -2;
        }
        else
        {
          v31 = *(void (__cdecl **)(int, int, int))(v30 + 72);
          if ( v31 )
            v31(a1[1], v37, v26);
        }
      }
    }
  }
}

//----- (004233D6) --------------------------------------------------------
void __cdecl sub_4233D6(int a1)
{
  int *v1; // ecx
  int *v2; // esi
  _DWORD *v3; // eax
  int v4; // ebx
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  bool v9; // zf
  int v10; // eax
  void (__cdecl *v11)(int, char *, int); // eax
  void (__cdecl *v12)(int, char *, int); // eax
  _DWORD *v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  void (__cdecl *v17)(int, char *, int); // eax
  void (__cdecl *v18)(int, char *, int); // eax
  _DWORD *v19; // eax
  int v20; // eax
  int v21; // [esp+Ch] [ebp-80h]
  int v22; // [esp+10h] [ebp-7Ch] BYREF
  int v23; // [esp+14h] [ebp-78h]
  int v24; // [esp+18h] [ebp-74h]
  char v25[308]; // [esp+1Ch] [ebp-70h] BYREF

  v2 = v1;
  v24 = 0;
  v21 = 0;
  if ( !v1[73] )
  {
    v3 = (_DWORD *)v1[9];
    if ( v3[4] - v3[3] > 500 && v3[5] - v3[4] < 500 )
      sub_41FF30(v1);
    if ( !v2[73] && *(_DWORD *)(v2[9] + 20) - *(_DWORD *)(v2[9] + 16) < 250 )
      sub_41FF5D((int)v2);
  }
  v4 = xmlCurrentChar(v2, &v22);
  v23 = v4;
  if ( v4 != 60 )
  {
    do
    {
      if ( v4 == 38 )
        break;
      if ( v4 >= 256 )
      {
        if ( v4 > 55295 && (v4 < 57344 || v4 > 65533) && (unsigned int)(v4 - 0x10000) > 0xFFFFF )
          break;
      }
      else if ( (v4 < 9 || v4 > 10) && v4 != 13 && v4 < 32 )
      {
        break;
      }
      if ( v4 == 93 )
      {
        v5 = *(_DWORD *)(v2[9] + 16);
        if ( *(_BYTE *)(v5 + 1) == 93 && *(_BYTE *)(v5 + 2) == 62 )
        {
          if ( a1 )
            break;
          sub_41EC3F(62, v2, 0);
          v4 = v23;
        }
      }
      v6 = v24;
      if ( v22 == 1 )
      {
        ++v24;
        v25[v6] = v4;
      }
      else
      {
        v7 = xmlCopyCharMultiByte(&v25[v24], v4);
        v24 += v7;
      }
      v8 = v24;
      if ( v24 >= 300 )
      {
        v25[v24] = 0;
        if ( *v2 && !v2[53] )
        {
          v9 = sub_420DB2(v2, (int)v25, v8, 0) == 0;
          v10 = *v2;
          if ( v9 )
          {
            v12 = *(void (__cdecl **)(int, char *, int))(v10 + 68);
            if ( v12 )
              v12(v2[1], v25, v24);
            if ( *(_DWORD *)(*v2 + 68) != *(_DWORD *)(*v2 + 72) )
            {
              v13 = (_DWORD *)v2[58];
              if ( *v13 == -1 )
                *v13 = -2;
            }
          }
          else
          {
            v11 = *(void (__cdecl **)(int, char *, int))(v10 + 72);
            if ( v11 )
              v11(v2[1], v25, v24);
          }
        }
        v9 = v2[43] == 7;
        v24 = 0;
        if ( !v9 )
          return;
      }
      if ( ++v21 > 50 )
      {
        if ( !v2[73] && *(_DWORD *)(v2[9] + 20) - *(_DWORD *)(v2[9] + 16) < 250 )
          sub_41FF5D((int)v2);
        v21 = 0;
      }
      v14 = v2[9];
      if ( **(_BYTE **)(v14 + 16) == 10 )
      {
        ++*(_DWORD *)(v14 + 28);
        *(_DWORD *)(v2[9] + 32) = 1;
      }
      else
      {
        ++*(_DWORD *)(v14 + 32);
      }
      *(_DWORD *)(v2[9] + 16) += v22;
      if ( **(_BYTE **)(v2[9] + 16) == 37 )
        xmlParserHandlePEReference(v2);
      v23 = xmlCurrentChar(v2, &v22);
      v4 = v23;
    }
    while ( v23 != 60 );
    v15 = v24;
    if ( v24 )
    {
      v25[v24] = 0;
      if ( *v2 )
      {
        if ( !v2[53] )
        {
          v9 = sub_420DB2(v2, (int)v25, v15, 0) == 0;
          v16 = *v2;
          if ( v9 )
          {
            v18 = *(void (__cdecl **)(int, char *, int))(v16 + 68);
            if ( v18 )
              v18(v2[1], v25, v24);
            if ( *(_DWORD *)(*v2 + 68) != *(_DWORD *)(*v2 + 72) )
            {
              v19 = (_DWORD *)v2[58];
              if ( *v19 == -1 )
                *v19 = -2;
            }
          }
          else
          {
            v17 = *(void (__cdecl **)(int, char *, int))(v16 + 72);
            if ( v17 )
              v17(v2[1], v25, v24);
          }
        }
      }
    }
  }
  if ( v4 )
  {
    if ( v4 < 256 )
    {
      if ( v4 >= 9 && v4 <= 10 || v4 == 13 || v4 >= 32 )
        return;
LABEL_73:
      sub_41F093((int (__cdecl *)(int, char *, char))9, v2, "PCDATA invalid Char value %d\n", v4);
      v20 = v2[9];
      if ( **(_BYTE **)(v20 + 16) == 10 )
      {
        ++*(_DWORD *)(v20 + 28);
        *(_DWORD *)(v2[9] + 32) = 1;
      }
      else
      {
        ++*(_DWORD *)(v20 + 32);
      }
      *(_DWORD *)(v2[9] + 16) += v22;
      if ( **(_BYTE **)(v2[9] + 16) == 37 )
        xmlParserHandlePEReference(v2);
      return;
    }
    if ( v4 > 55295 && (v4 < 57344 || v4 > 65533) && (unsigned int)(v4 - 0x10000) > 0xFFFFF )
      goto LABEL_73;
  }
}
// 4233F6: variable 'v1' is possibly undefined
// 4233D6: using guessed type char var_138[308];

//----- (00423736) --------------------------------------------------------
void *__cdecl xmlParseExternalID(int *a1, _DWORD *a2, int a3)
{
  void *v3; // ebp
  _DWORD *v4; // eax
  int v5; // eax
  _BYTE *v6; // ecx
  int v7; // eax
  unsigned __int8 v8; // al
  int v9; // eax
  unsigned __int8 v10; // al
  void *v11; // eax
  unsigned __int8 v12; // al
  unsigned __int8 *v13; // eax
  unsigned __int8 v14; // cl
  unsigned __int8 v16; // cl
  unsigned __int8 v17; // al

  v3 = 0;
  if ( !a1[73] )
  {
    v4 = (_DWORD *)a1[9];
    if ( v4[4] - v4[3] > 500 && v4[5] - v4[4] < 500 )
      sub_41FF30(a1);
  }
  *a2 = 0;
  v5 = a1[9];
  v6 = *(_BYTE **)(v5 + 16);
  if ( *v6 == 83 && v6[1] == 89 && v6[2] == 83 && v6[3] == 84 && v6[4] == 69 && v6[5] == 77 )
  {
    a1[50] += 6;
    *(_DWORD *)(v5 + 16) += 6;
    *(_DWORD *)(a1[9] + 32) += 6;
    if ( **(_BYTE **)(a1[9] + 16) == 37 )
      xmlParserHandlePEReference(a1);
    v7 = a1[9];
    if ( !**(_BYTE **)(v7 + 16) && xmlParserInputGrow((int *)v7, 250) <= 0 )
      xmlPopInput(a1);
    v8 = **(_BYTE **)(a1[9] + 16);
    if ( v8 != 32 && (v8 < 9u || v8 > 0xAu) && v8 != 13 )
      sub_41EFC6((int (__cdecl *)(int, char *, char))0x41, a1, "Space required after 'SYSTEM'\n");
  }
  else
  {
    if ( *v6 != 80 || v6[1] != 85 || v6[2] != 66 || v6[3] != 76 || v6[4] != 73 || v6[5] != 67 )
      return v3;
    a1[50] += 6;
    *(_DWORD *)(v5 + 16) += 6;
    *(_DWORD *)(a1[9] + 32) += 6;
    if ( **(_BYTE **)(a1[9] + 16) == 37 )
      xmlParserHandlePEReference(a1);
    v9 = a1[9];
    if ( !**(_BYTE **)(v9 + 16) && xmlParserInputGrow((int *)v9, 250) <= 0 )
      xmlPopInput(a1);
    v10 = **(_BYTE **)(a1[9] + 16);
    if ( v10 != 32 && (v10 < 9u || v10 > 0xAu) && v10 != 13 )
      sub_41EFC6((int (__cdecl *)(int, char *, char))0x41, a1, "Space required after 'PUBLIC'\n");
    xmlSkipBlankChars((int)a1);
    v11 = xmlParsePubidLiteral(a1);
    *a2 = v11;
    if ( !v11 )
      sub_41EC3F(71, a1, 0);
    if ( a3 )
    {
      v12 = **(_BYTE **)(a1[9] + 16);
      if ( v12 != 32 && (v12 < 9u || v12 > 0xAu) && v12 != 13 )
        sub_41EFC6((int (__cdecl *)(int, char *, char))0x41, a1, "Space required after the Public Identifier\n");
    }
    else
    {
      if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
        sub_41FF5D((int)a1);
      v13 = *(unsigned __int8 **)(a1[9] + 16);
      v14 = *v13;
      if ( *v13 != 32 && (v14 < 9u || v14 > 0xAu) && v14 != 13 )
        return 0;
      while ( 1 )
      {
        v16 = *v13;
        if ( *v13 != 32 && (v16 < 9u || v16 > 0xAu) && v16 != 13 )
          break;
        ++v13;
      }
      v17 = *v13;
      if ( v17 != 39 && v17 != 34 )
        return 0;
    }
  }
  xmlSkipBlankChars((int)a1);
  v3 = xmlParseSystemLiteral(a1);
  if ( !v3 )
    sub_41EC3F(70, a1, 0);
  return v3;
}

//----- (004239A0) --------------------------------------------------------
int __usercall sub_4239A0@<eax>(int *a1@<eax>, _BYTE *Block, int a3, int a4)
{
  int v5; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // edi
  int v12; // ebx
  _BYTE *v13; // eax
  int v14; // edi
  int v15; // eax
  _DWORD *v16; // eax
  void (__cdecl *v17)(int, _BYTE *); // eax
  int v18; // [esp-8h] [ebp-2Ch]
  int v19; // [esp+8h] [ebp-1Ch]
  int v20; // [esp+Ch] [ebp-18h] BYREF
  int v21; // [esp+10h] [ebp-14h] BYREF
  int v22; // [esp+14h] [ebp-10h] BYREF
  int v23; // [esp+18h] [ebp-Ch]
  int v24; // [esp+1Ch] [ebp-8h]
  int v25; // [esp+20h] [ebp-4h]

  v5 = *(_DWORD *)(a1[9] + 56);
  v23 = 0;
  v19 = v5;
  if ( !Block )
  {
    a3 = 0;
    a4 = 100;
    Block = (_BYTE *)xmlMallocAtomic(0x64u);
    if ( !Block )
      return xmlErrMemory((int)a1, 0);
  }
  if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
    sub_41FF5D((int)a1);
  v7 = xmlCurrentChar(a1, &v22);
  v25 = v7;
  if ( !v7 )
    goto LABEL_41;
  if ( v7 < 256 )
  {
    if ( v7 >= 9 && v7 <= 10 || v7 == 13 || v7 >= 32 )
      goto LABEL_13;
LABEL_19:
    v18 = v7;
LABEL_36:
    sub_41F093((int (__cdecl *)(int, char *, char))9, a1, "xmlParseComment: invalid xmlChar value %d\n", v18);
    return ((int (__cdecl *)(_BYTE *))xmlFree)(Block);
  }
  if ( v7 > 55295 && (v7 < 57344 || v7 > 65533) && (unsigned int)(v7 - 0x10000) > 0xFFFFF )
    goto LABEL_19;
LABEL_13:
  v8 = a1[9];
  if ( **(_BYTE **)(v8 + 16) == 10 )
  {
    ++*(_DWORD *)(v8 + 28);
    *(_DWORD *)(a1[9] + 32) = 1;
  }
  else
  {
    ++*(_DWORD *)(v8 + 32);
  }
  *(_DWORD *)(a1[9] + 16) += v22;
  if ( **(_BYTE **)(a1[9] + 16) == 37 )
    xmlParserHandlePEReference(a1);
  v9 = xmlCurrentChar(a1, &v21);
  v24 = v9;
  if ( !v9 )
    goto LABEL_41;
  if ( v9 >= 256 )
  {
    if ( v9 <= 55295 || v9 >= 57344 && v9 <= 65533 || (unsigned int)(v9 - 0x10000) <= 0xFFFFF )
      goto LABEL_29;
    goto LABEL_35;
  }
  if ( (v9 < 9 || v9 > 10) && v9 != 13 && v9 < 32 )
  {
LABEL_35:
    v18 = v25;
    goto LABEL_36;
  }
LABEL_29:
  v10 = a1[9];
  if ( **(_BYTE **)(v10 + 16) == 10 )
  {
    ++*(_DWORD *)(v10 + 28);
    *(_DWORD *)(a1[9] + 32) = 1;
  }
  else
  {
    ++*(_DWORD *)(v10 + 32);
  }
  *(_DWORD *)(a1[9] + 16) += v21;
  if ( **(_BYTE **)(a1[9] + 16) == 37 )
    xmlParserHandlePEReference(a1);
  v11 = xmlCurrentChar(a1, &v20);
  if ( !v11 )
  {
LABEL_41:
    sub_41F152((int (__cdecl *)(int, char *, char))0x2D, a1, "Comment not terminated\n", 0);
    return ((int (__cdecl *)(_BYTE *))xmlFree)(Block);
  }
  v12 = a3;
  while ( v11 < 256 )
  {
    if ( (v11 < 9 || v11 > 10) && v11 != 13 && v11 < 32 )
      goto LABEL_49;
LABEL_55:
    if ( v11 == 62 )
    {
      if ( v24 != 45 )
        goto LABEL_61;
      if ( v25 == 45 )
        goto LABEL_49;
    }
    if ( v24 == 45 && v25 == 45 )
    {
      sub_41EC3F(80, a1, 0);
      v12 = a3;
    }
LABEL_61:
    if ( v12 + 5 >= a4 )
    {
      a4 *= 2;
      v13 = (_BYTE *)xmlRealloc(Block, a4);
      if ( !v13 )
      {
        ((void (__cdecl *)(_BYTE *))xmlFree)(Block);
        return xmlErrMemory((int)a1, 0);
      }
      Block = v13;
    }
    if ( v22 == 1 )
      Block[v12++] = v25;
    else
      v12 += xmlCopyCharMultiByte(&Block[v12], v25);
    ++v23;
    v25 = v24;
    v24 = v11;
    v14 = v20;
    a3 = v12;
    v22 = v21;
    v21 = v20;
    if ( v23 > 50 )
    {
      if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
        sub_41FF5D((int)a1);
      v23 = 0;
    }
    v15 = a1[9];
    if ( **(_BYTE **)(v15 + 16) == 10 )
    {
      ++*(_DWORD *)(v15 + 28);
      *(_DWORD *)(a1[9] + 32) = 1;
    }
    else
    {
      ++*(_DWORD *)(v15 + 32);
    }
    *(_DWORD *)(a1[9] + 16) += v14;
    if ( **(_BYTE **)(a1[9] + 16) == 37 )
      xmlParserHandlePEReference(a1);
    v11 = xmlCurrentChar(a1, &v20);
    if ( !v11 )
    {
      if ( !a1[73] )
      {
        v16 = (_DWORD *)a1[9];
        if ( v16[4] - v16[3] > 500 && v16[5] - v16[4] < 500 )
          sub_41FF30(a1);
        if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
          sub_41FF5D((int)a1);
      }
      v11 = xmlCurrentChar(a1, &v20);
    }
  }
  if ( v11 <= 55295 || v11 >= 57344 && v11 <= 65533 || (unsigned int)(v11 - 0x10000) <= 0xFFFFF )
    goto LABEL_55;
LABEL_49:
  Block[v12] = 0;
  if ( !v11 )
  {
    sub_41F152((int (__cdecl *)(int, char *, char))0x2D, a1, "Comment not terminated \n<!--%.50s\n", Block);
    return ((int (__cdecl *)(_BYTE *))xmlFree)(Block);
  }
  if ( v11 >= 256 )
  {
    if ( (unsigned int)(v11 - 0x10000) > 0xFFFFF )
      goto LABEL_97;
LABEL_89:
    if ( v19 != *(_DWORD *)(a1[9] + 56) )
      sub_41EFC6((int (__cdecl *)(int, char *, char))0x5A, a1, "Comment doesn't start and stop in the same entity\n");
    xmlNextChar(a1);
    if ( *a1 )
    {
      v17 = *(void (__cdecl **)(int, _BYTE *))(*a1 + 80);
      if ( v17 )
      {
        if ( !a1[53] )
          v17(a1[1], Block);
      }
    }
  }
  else
  {
    if ( v11 >= 32 )
      goto LABEL_89;
LABEL_97:
    sub_41F093((int (__cdecl *)(int, char *, char))9, a1, "xmlParseComment: invalid xmlChar value %d\n", v11);
  }
  return ((int (__cdecl *)(_BYTE *))xmlFree)(Block);
}
// 496494: invalid function type has been ignored
// 423D53: conditional instruction was optimized away because edi.4 is in (B..C|E..1F|==3E)
// 423D58: conditional instruction was optimized away because edi.4 is in (1..8|B..C|E..1F|==3E|<0)
// 423DB6: conditional instruction was optimized away because edi.4 is in (D800..DFFF|>=FFFE)
// 423DC6: conditional instruction was optimized away because edi.4>=FFFE
// 49B2BC: using guessed type int (__cdecl *xmlMallocAtomic)(size_t Size);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);

//----- (00423DE7) --------------------------------------------------------
int __cdecl xmlParseComment(int *a1)
{
  int result; // eax
  _BYTE *v3; // ecx
  int v4; // ecx
  int v5; // ecx
  int v6; // eax
  _DWORD *v7; // eax
  unsigned __int8 *i; // edi
  int v9; // ecx
  int j; // edx
  unsigned __int8 v11; // al
  signed int v12; // ebx
  size_t v13; // eax
  int v14; // eax
  _BYTE *v15; // edi
  _DWORD *v16; // eax
  int v17; // eax
  unsigned __int8 v18; // al
  int v19; // eax
  void (__cdecl *v20)(int, char *); // eax
  int v21; // [esp+8h] [ebp-10h]
  int v22; // [esp+Ch] [ebp-Ch]
  int v23; // [esp+10h] [ebp-8h]
  char *Block; // [esp+14h] [ebp-4h]
  int v25; // [esp+20h] [ebp+8h]

  result = a1[9];
  v3 = *(_BYTE **)(result + 16);
  Block = 0;
  v22 = 100;
  v23 = 0;
  if ( *v3 != 60 || v3[1] != 33 || v3[2] != 45 || v3[3] != 45 )
    return result;
  v4 = a1[43];
  a1[43] = 5;
  v25 = v4;
  v5 = *(_DWORD *)(result + 56);
  a1[50] += 4;
  *(_DWORD *)(result + 16) += 4;
  *(_DWORD *)(a1[9] + 32) += 4;
  v21 = v5;
  if ( **(_BYTE **)(a1[9] + 16) == 37 )
    xmlParserHandlePEReference(a1);
  v6 = a1[9];
  if ( !**(_BYTE **)(v6 + 16) && xmlParserInputGrow((int *)v6, 250) <= 0 )
    xmlPopInput(a1);
  if ( !a1[73] )
  {
    v7 = (_DWORD *)a1[9];
    if ( v7[4] - v7[3] > 500 && v7[5] - v7[4] < 500 )
      sub_41FF30(a1);
    if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
      sub_41FF5D((int)a1);
  }
LABEL_19:
  for ( i = *(unsigned __int8 **)(a1[9] + 16); *i == 10; ++i )
  {
    ++*(_DWORD *)(a1[9] + 28);
    *(_DWORD *)(a1[9] + 32) = 1;
  }
  while ( 1 )
  {
    while ( 1 )
    {
      v9 = a1[9];
      for ( j = *(_DWORD *)(v9 + 32); ; ++j )
      {
        v11 = *i;
        if ( (*i <= 0x2Du || v11 > 0x7Fu) && (v11 < 0x20u || v11 >= 0x2Du) && v11 != 9 )
          break;
        ++i;
      }
      *(_DWORD *)(v9 + 32) = j;
      if ( *i != 10 )
        break;
      do
      {
        ++*(_DWORD *)(a1[9] + 28);
        ++i;
        *(_DWORD *)(a1[9] + 32) = 1;
      }
      while ( *i == 10 );
    }
    v12 = (signed int)&i[-*(_DWORD *)(a1[9] + 16)];
    if ( v12 > 0 && *a1 && *(_DWORD *)(*a1 + 80) )
    {
      if ( Block )
      {
        if ( v12 + v23 + 1 >= v22 )
        {
          v22 += v12 + v23 + 100;
          v14 = xmlRealloc(Block, v22);
          if ( !v14 )
          {
            ((void (__cdecl *)(char *))xmlFree)(Block);
            xmlErrMemory((int)a1, 0);
            goto LABEL_67;
          }
          Block = (char *)v14;
        }
      }
      else
      {
        if ( *i != 45 || (v13 = v12 + 1, i[1] != 45) )
          v13 = v12 + 100;
        v22 = v13;
        Block = (char *)xmlMallocAtomic(v13);
        if ( !Block )
        {
          xmlErrMemory((int)a1, 0);
          goto LABEL_67;
        }
        v23 = 0;
      }
      memcpy(&Block[v23], *(const void **)(a1[9] + 16), v12);
      v23 += v12;
      Block[v23] = 0;
    }
    *(_DWORD *)(a1[9] + 16) = i;
    if ( *i == 10 )
    {
      ++i;
      ++*(_DWORD *)(a1[9] + 28);
      *(_DWORD *)(a1[9] + 32) = 1;
    }
    if ( *i == 13 )
    {
      v15 = i + 1;
      if ( *v15 == 10 )
      {
        *(_DWORD *)(a1[9] + 16) = v15;
        i = v15 + 1;
        ++*(_DWORD *)(a1[9] + 28);
        *(_DWORD *)(a1[9] + 32) = 1;
LABEL_63:
        v18 = *i;
        if ( (*i < 0x20u || v18 > 0x7Fu) && v18 != 9 )
        {
          sub_4239A0(a1, Block, v23, v22);
          goto LABEL_67;
        }
        goto LABEL_19;
      }
    }
    if ( !a1[73] )
    {
      v16 = (_DWORD *)a1[9];
      if ( v16[4] - v16[3] > 500 && v16[5] - v16[4] < 500 )
        sub_41FF30(a1);
      if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
        sub_41FF5D((int)a1);
    }
    v17 = a1[9];
    i = *(unsigned __int8 **)(v17 + 16);
    if ( *i != 45 )
      goto LABEL_63;
    if ( i[1] == 45 )
      break;
LABEL_61:
    ++i;
    ++*(_DWORD *)(a1[9] + 32);
  }
  if ( i[2] != 62 )
  {
    if ( Block )
      sub_41F152((int (__cdecl *)(int, char *, char))0x50, a1, "Double hyphen within comment: <!--%.50s\n", Block);
    else
      sub_41F152((int (__cdecl *)(int, char *, char))0x50, a1, "Double hyphen within comment\n", 0);
    ++*(_DWORD *)(a1[9] + 32);
    ++i;
    goto LABEL_61;
  }
  if ( *(_DWORD *)(v17 + 56) != v21 )
    sub_41EFC6((int (__cdecl *)(int, char *, char))0x5A, a1, "comment doesn't start and stop in the same entity\n");
  a1[50] += 3;
  *(_DWORD *)(a1[9] + 16) += 3;
  *(_DWORD *)(a1[9] + 32) += 3;
  if ( **(_BYTE **)(a1[9] + 16) == 37 )
    xmlParserHandlePEReference(a1);
  v19 = a1[9];
  if ( !**(_BYTE **)(v19 + 16) && xmlParserInputGrow((int *)v19, 250) <= 0 )
    xmlPopInput(a1);
  if ( *a1 )
  {
    v20 = *(void (__cdecl **)(int, char *))(*a1 + 80);
    if ( v20 )
    {
      if ( !a1[53] )
      {
        if ( Block )
          v20(a1[1], Block);
        else
          v20(a1[1], (char *)byte_47627C);
      }
    }
  }
  if ( Block )
    ((void (__cdecl *)(char *))xmlFree)(Block);
LABEL_67:
  result = v25;
  a1[43] = v25;
  return result;
}
// 496494: invalid function type has been ignored
// 49B2BC: using guessed type int (__cdecl *xmlMallocAtomic)(size_t Size);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);

//----- (004241BB) --------------------------------------------------------
char *__cdecl xmlParsePITarget(int *a1)
{
  unsigned __int8 *v1; // eax
  char *v2; // esi
  unsigned __int8 v3; // dl
  unsigned __int8 v4; // cl
  unsigned __int8 v5; // al
  char *v6; // eax
  int v7; // edi
  unsigned __int8 *v9; // [esp+Ch] [ebp-4h]

  v1 = xmlParseName((int)a1);
  v2 = (char *)v1;
  v9 = v1;
  if ( v1 )
  {
    v3 = *v1;
    if ( *v1 == 120 || v3 == 88 )
    {
      v4 = v1[1];
      if ( v4 == 109 || v4 == 77 )
      {
        v5 = v1[2];
        if ( v5 == 108 || v5 == 76 )
        {
          if ( v3 == 120 && v4 == 109 && v5 == 108 )
          {
            if ( !v2[3] )
            {
              sub_41EFC6(
                (int (__cdecl *)(int, char *, char))0x40,
                a1,
                "XML declaration allowed only at the start of the document\n");
              return v2;
            }
          }
          else if ( !v2[3] )
          {
            sub_41EC3F(64, a1, 0);
            return v2;
          }
          v6 = off_4A4D7C[0];
          v7 = 0;
          while ( v6 )
          {
            if ( xmlStrEqual(v2, v6) )
              return v2;
            v6 = (&off_4A4D80)[v7++];
          }
          sub_41F01E((int)a1, 0, 64, "xmlParsePITarget: invalid name prefix 'xml'\n");
          v2 = (char *)v9;
        }
      }
    }
    if ( xmlStrchr(v2, 58) )
      sub_41F1EB((int (__cdecl *)(int, char *, char))0xCD, a1, "colon are forbidden from PI names '%s'\n", v2, 0, 0);
  }
  return v2;
}
// 4A4D7C: using guessed type char *off_4A4D7C[2];
// 4A4D80: using guessed type char *off_4A4D80;

//----- (0042429D) --------------------------------------------------------
void __cdecl xmlParsePI(int *Block)
{
  int v2; // eax
  _BYTE *v3; // ecx
  bool v4; // zf
  int v5; // ecx
  int v6; // eax
  _DWORD *v7; // eax
  int v8; // ecx
  _BYTE *v9; // eax
  int v10; // eax
  void (__cdecl *v11)(int, char *, _DWORD); // eax
  int v12; // eax
  int v13; // eax
  int v14; // ebx
  int v15; // eax
  int v16; // edi
  int v17; // eax
  _DWORD *v18; // eax
  int v19; // eax
  void (__cdecl *v20)(int, char *, void *); // eax
  int v21; // [esp+8h] [ebp-1Ch]
  signed int v22; // [esp+Ch] [ebp-18h]
  int v23; // [esp+10h] [ebp-14h]
  char *v24; // [esp+14h] [ebp-10h]
  int v25; // [esp+18h] [ebp-Ch]
  int v26; // [esp+1Ch] [ebp-8h] BYREF
  int v27; // [esp+20h] [ebp-4h]
  void *Blocka; // [esp+2Ch] [ebp+8h]

  v2 = Block[9];
  v3 = *(_BYTE **)(v2 + 16);
  v4 = *v3 == 60;
  v25 = 0;
  v22 = 100;
  v27 = 0;
  if ( !v4 || v3[1] != 63 )
    return;
  v5 = Block[43];
  Block[50] += 2;
  Block[43] = 2;
  *(_DWORD *)(v2 + 16) += 2;
  v21 = v2;
  *(_DWORD *)(Block[9] + 32) += 2;
  v23 = v5;
  if ( **(_BYTE **)(Block[9] + 16) == 37 )
    xmlParserHandlePEReference(Block);
  v6 = Block[9];
  if ( !**(_BYTE **)(v6 + 16) && xmlParserInputGrow((int *)v6, 250) <= 0 )
    xmlPopInput(Block);
  if ( !Block[73] )
  {
    v7 = (_DWORD *)Block[9];
    if ( v7[4] - v7[3] > 500 && v7[5] - v7[4] < 500 )
      sub_41FF30(Block);
  }
  v24 = xmlParsePITarget(Block);
  if ( !v24 )
  {
    sub_41EC3F(46, Block, 0);
    goto LABEL_87;
  }
  v8 = Block[9];
  v9 = *(_BYTE **)(v8 + 16);
  if ( *v9 == 63 && v9[1] == 62 )
  {
    if ( v21 != v8 )
      sub_41EFC6(
        (int (__cdecl *)(int, char *, char))0x5A,
        Block,
        "PI declaration doesn't start and stop in the same entity\n");
    Block[50] += 2;
    *(_DWORD *)(Block[9] + 16) += 2;
    *(_DWORD *)(Block[9] + 32) += 2;
    if ( **(_BYTE **)(Block[9] + 16) == 37 )
      xmlParserHandlePEReference(Block);
    v10 = Block[9];
    if ( !**(_BYTE **)(v10 + 16) && xmlParserInputGrow((int *)v10, 250) <= 0 )
      xmlPopInput(Block);
    if ( *Block && !Block[53] )
    {
      v11 = *(void (__cdecl **)(int, char *, _DWORD))(*Block + 76);
      if ( v11 )
        v11(Block[1], v24, 0);
    }
    goto LABEL_87;
  }
  Blocka = (void *)xmlMallocAtomic(0x64u);
  if ( !Blocka )
  {
    xmlErrMemory((int)Block, 0);
    goto LABEL_88;
  }
  v12 = **(unsigned __int8 **)(Block[9] + 16);
  if ( v12 != 32
    && (**(unsigned __int8 **)(Block[9] + 16) < 9u || **(unsigned __int8 **)(Block[9] + 16) > 0xAu)
    && v12 != 13 )
  {
    sub_41F152((int (__cdecl *)(int, char *, char))0x41, Block, "ParsePI: PI %s space expected\n", v24);
  }
  xmlSkipBlankChars((int)Block);
  v13 = xmlCurrentChar(Block, &v26);
LABEL_34:
  v14 = v13;
  while ( 1 )
  {
    if ( v14 < 256 )
    {
      if ( (v14 < 9 || v14 > 10) && v14 != 13 && v14 < 32 )
        break;
      goto LABEL_46;
    }
    if ( v14 > 55295 && (v14 < 57344 || v14 > 65533) && (unsigned int)(v14 - 0x10000) > 0xFFFFF )
      break;
LABEL_46:
    if ( v14 == 63 && *(_BYTE *)(*(_DWORD *)(Block[9] + 16) + 1) == 62 )
      break;
    if ( v25 + 5 >= v22 )
    {
      v22 *= 2;
      v15 = xmlRealloc(Blocka, v22);
      if ( !v15 )
      {
        xmlErrMemory((int)Block, 0);
        ((void (__cdecl *)(void *))xmlFree)(Blocka);
        goto LABEL_88;
      }
      Blocka = (void *)v15;
    }
    if ( ++v27 > 50 )
    {
      if ( !Block[73] && *(_DWORD *)(Block[9] + 20) - *(_DWORD *)(Block[9] + 16) < 250 )
        sub_41FF5D((int)Block);
      v27 = 0;
    }
    if ( v26 == 1 )
    {
      *((_BYTE *)Blocka + v25) = v14;
      v16 = v25 + 1;
    }
    else
    {
      v16 = xmlCopyCharMultiByte((_BYTE *)Blocka + v25, v14) + v25;
    }
    v17 = Block[9];
    v25 = v16;
    if ( **(_BYTE **)(v17 + 16) == 10 )
    {
      ++*(_DWORD *)(v17 + 28);
      *(_DWORD *)(Block[9] + 32) = 1;
    }
    else
    {
      ++*(_DWORD *)(v17 + 32);
    }
    *(_DWORD *)(Block[9] + 16) += v26;
    if ( **(_BYTE **)(Block[9] + 16) == 37 )
      xmlParserHandlePEReference(Block);
    v14 = xmlCurrentChar(Block, &v26);
    if ( !v14 )
    {
      if ( !Block[73] )
      {
        v18 = (_DWORD *)Block[9];
        if ( v18[4] - v18[3] > 500 && v18[5] - v18[4] < 500 )
          sub_41FF30(Block);
        if ( !Block[73] && *(_DWORD *)(Block[9] + 20) - *(_DWORD *)(Block[9] + 16) < 250 )
          sub_41FF5D((int)Block);
      }
      v13 = xmlCurrentChar(Block, &v26);
      goto LABEL_34;
    }
  }
  *((_BYTE *)Blocka + v25) = 0;
  if ( v14 == 63 )
  {
    if ( v21 != Block[9] )
      sub_41EFC6(
        (int (__cdecl *)(int, char *, char))0x41,
        Block,
        "PI declaration doesn't start and stop in the same entity\n");
    Block[50] += 2;
    *(_DWORD *)(Block[9] + 16) += 2;
    *(_DWORD *)(Block[9] + 32) += 2;
    if ( **(_BYTE **)(Block[9] + 16) == 37 )
      xmlParserHandlePEReference(Block);
    v19 = Block[9];
    if ( !**(_BYTE **)(v19 + 16) && xmlParserInputGrow((int *)v19, 250) <= 0 )
      xmlPopInput(Block);
    if ( *Block )
    {
      if ( !Block[53] )
      {
        v20 = *(void (__cdecl **)(int, char *, void *))(*Block + 76);
        if ( v20 )
          v20(Block[1], v24, Blocka);
      }
    }
  }
  else
  {
    sub_41F152((int (__cdecl *)(int, char *, char))0x2F, Block, "ParsePI: PI %s never end ...\n", v24);
  }
  ((void (__cdecl *)(void *))xmlFree)(Blocka);
LABEL_87:
  if ( Block[43] != -1 )
LABEL_88:
    Block[43] = v23;
}
// 496494: invalid function type has been ignored
// 49B2BC: using guessed type int (__cdecl *xmlMallocAtomic)(size_t Size);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);

//----- (004246E2) --------------------------------------------------------
void __cdecl xmlParseNotationDecl(int *Block)
{
  int *v1; // edi
  _DWORD *v2; // ecx
  _BYTE *v3; // eax
  int v4; // eax
  int v5; // eax
  unsigned __int8 v6; // al
  unsigned __int8 *v7; // edx
  unsigned __int8 v8; // al
  _BYTE *v9; // edx
  void *v10; // esi
  int v11; // eax
  void (__cdecl *v12)(int, unsigned __int8 *, int *, void *); // eax
  unsigned __int8 *v13; // [esp+4h] [ebp-8h]
  int v14; // [esp+8h] [ebp-4h]

  v1 = Block;
  v2 = (_DWORD *)Block[9];
  v3 = (_BYTE *)v2[4];
  if ( *v3 == 60
    && v3[1] == 33
    && v3[2] == 78
    && v3[3] == 79
    && v3[4] == 84
    && v3[5] == 65
    && v3[6] == 84
    && v3[7] == 73
    && v3[8] == 79
    && v3[9] == 78 )
  {
    v14 = Block[9];
    if ( !Block[73] && (int)&v3[-v2[3]] > 500 && v2[5] - (int)v3 < 500 )
      sub_41FF30(Block);
    v4 = v1[9];
    v1[50] += 10;
    *(_DWORD *)(v4 + 16) += 10;
    *(_DWORD *)(v1[9] + 32) += 10;
    if ( **(_BYTE **)(v1[9] + 16) == 37 )
      xmlParserHandlePEReference(v1);
    v5 = v1[9];
    if ( !**(_BYTE **)(v5 + 16) && xmlParserInputGrow((int *)v5, 250) <= 0 )
      xmlPopInput(v1);
    v6 = **(_BYTE **)(v1[9] + 16);
    if ( v6 == 32 || v6 >= 9u && v6 <= 0xAu || v6 == 13 )
    {
      xmlSkipBlankChars((int)v1);
      v7 = xmlParseName((int)v1);
      v13 = v7;
      if ( v7 )
      {
        v8 = **(_BYTE **)(v1[9] + 16);
        if ( v8 == 32 || v8 >= 9u && v8 <= 0xAu || v8 == 13 )
        {
          if ( xmlStrchr(v7, 58) )
            sub_41F1EB(
              (int (__cdecl *)(int, char *, char))0xCD,
              v1,
              "colon are forbidden from notation names '%s'\n",
              v9,
              0,
              0);
          xmlSkipBlankChars((int)v1);
          v10 = xmlParseExternalID(v1, &Block, 0);
          xmlSkipBlankChars((int)v1);
          v11 = v1[9];
          if ( **(_BYTE **)(v11 + 16) == 62 )
          {
            if ( v14 != v11 )
              sub_41EFC6(
                (int (__cdecl *)(int, char *, char))0x41,
                v1,
                "Notation declaration doesn't start and stop in the same entity\n");
            xmlNextChar(v1);
            if ( *v1 )
            {
              if ( !v1[53] )
              {
                v12 = *(void (__cdecl **)(int, unsigned __int8 *, int *, void *))(*v1 + 28);
                if ( v12 )
                  v12(v1[1], v13, Block, v10);
              }
            }
          }
          else
          {
            sub_41EC3F(49, v1, 0);
          }
          if ( v10 )
            ((void (__cdecl *)(void *))xmlFree)(v10);
          if ( Block )
            ((void (__cdecl *)(int *))xmlFree)(Block);
        }
        else
        {
          sub_41EFC6((int (__cdecl *)(int, char *, char))0x41, v1, "Space required after the NOTATION name'\n");
        }
      }
      else
      {
        sub_41EC3F(48, v1, 0);
      }
    }
    else
    {
      sub_41EFC6((int (__cdecl *)(int, char *, char))0x41, v1, "Space required after '<!NOTATION'\n");
    }
  }
}
// 496494: invalid function type has been ignored
// 424858: variable 'v9' is possibly undefined

//----- (004248F6) --------------------------------------------------------
void __cdecl xmlParseEntityDecl(int *Src)
{
  _DWORD *v2; // ecx
  _BYTE *v3; // eax
  bool v4; // zf
  int v5; // eax
  unsigned __int8 *v6; // eax
  _BYTE *v7; // edx
  int v8; // eax
  char v9; // al
  _BYTE *v10; // eax
  _BYTE *v11; // ebx
  _DWORD *v12; // eax
  void (__cdecl *v13)(int, char *, int, void *, _BYTE *, _DWORD); // eax
  void (__cdecl *v14)(int, char *, int, _DWORD, _DWORD, void *); // eax
  _BYTE *v15; // eax
  _BYTE *v16; // ebx
  _DWORD *v17; // eax
  _DWORD *v18; // esi
  unsigned __int8 v19; // al
  int v20; // eax
  _BYTE *v21; // ecx
  int v22; // eax
  unsigned __int8 v23; // al
  unsigned __int8 *v24; // eax
  void (__cdecl *v25)(int, char *, void *, void *, unsigned __int8 *); // ecx
  void (__cdecl *v26)(int, char *, int, void *, void *, _DWORD); // eax
  int v27; // ebx
  _DWORD *v28; // eax
  int v29; // eax
  void (__cdecl *v30)(int, char *, int, _DWORD, _DWORD, void *); // eax
  int v31; // ebx
  _DWORD *v32; // eax
  int v33; // eax
  int v34; // eax
  void *v35; // esi
  int v36; // eax
  int (__cdecl *v37)(int, char *); // eax
  _DWORD *Entity; // eax
  int (__cdecl *v39)(int, char *); // eax
  _DWORD *v40; // [esp+8h] [ebp-1Ch]
  _DWORD *v41; // [esp+Ch] [ebp-18h]
  int v42; // [esp+10h] [ebp-14h]
  void *Block; // [esp+14h] [ebp-10h] BYREF
  void *v44; // [esp+18h] [ebp-Ch]
  void *v45; // [esp+1Ch] [ebp-8h]
  void *v46; // [esp+20h] [ebp-4h] BYREF
  char *Srca; // [esp+2Ch] [ebp+8h]

  v2 = (_DWORD *)Src[9];
  v3 = (_BYTE *)v2[4];
  v4 = *v3 == 60;
  v45 = 0;
  v44 = 0;
  v46 = 0;
  v42 = 0;
  Block = 0;
  if ( !v4 || v3[1] != 33 || v3[2] != 69 || v3[3] != 78 || v3[4] != 84 || v3[5] != 73 || v3[6] != 84 || v3[7] != 89 )
    return;
  v40 = v2;
  if ( !Src[73] && (int)&v3[-v2[3]] > 500 && v2[5] - (int)v3 < 500 )
    sub_41FF30(Src);
  Src[50] += 8;
  *(_DWORD *)(Src[9] + 16) += 8;
  *(_DWORD *)(Src[9] + 32) += 8;
  if ( **(_BYTE **)(Src[9] + 16) == 37 )
    xmlParserHandlePEReference(Src);
  v5 = Src[9];
  if ( !**(_BYTE **)(v5 + 16) && xmlParserInputGrow((int *)v5, 250) <= 0 )
    xmlPopInput(Src);
  if ( !xmlSkipBlankChars((int)Src) )
    sub_41EFC6((int (__cdecl *)(int, char *, char))0x41, Src, "Space required after '<!ENTITY'\n");
  if ( **(_BYTE **)(Src[9] + 16) == 37 )
  {
    xmlNextChar(Src);
    if ( !xmlSkipBlankChars((int)Src) )
      sub_41EFC6((int (__cdecl *)(int, char *, char))0x41, Src, "Space required after '%'\n");
    v42 = 1;
  }
  v6 = xmlParseName((int)Src);
  Srca = (char *)v6;
  if ( !v6 )
  {
    sub_41EFC6((int (__cdecl *)(int, char *, char))0x44, Src, "xmlParseEntityDecl: no name\n");
    return;
  }
  if ( xmlStrchr(v6, 58) )
    sub_41F1EB(
      (int (__cdecl *)(int, char *, char))0xCD,
      Src,
      "colon are forbidden from entities names '%s'\n",
      v7,
      0,
      0);
  if ( !xmlSkipBlankChars((int)Src) )
    sub_41EFC6((int (__cdecl *)(int, char *, char))0x41, Src, "Space required after the entity name\n");
  v8 = Src[9];
  Src[43] = 10;
  v9 = **(_BYTE **)(v8 + 16);
  if ( v42 )
  {
    if ( v9 == 34 || v9 == 39 )
    {
      v45 = xmlParseEntityValue(Src, &Block);
      if ( v45 )
      {
        if ( *Src )
        {
          if ( !Src[53] )
          {
            v14 = *(void (__cdecl **)(int, char *, int, _DWORD, _DWORD, void *))(*Src + 24);
            if ( v14 )
              v14(Src[1], Srca, 4, 0, 0, v45);
          }
        }
      }
    }
    else
    {
      v10 = xmlParseExternalID(Src, &v46, 1);
      v11 = v10;
      v44 = v10;
      if ( v10 )
      {
        v12 = xmlParseURI(v10);
        v41 = v12;
        if ( v12 )
        {
          if ( v12[8] )
          {
            sub_41EC3F(92, Src, 0);
          }
          else if ( *Src )
          {
            if ( !Src[53] )
            {
              v13 = *(void (__cdecl **)(int, char *, int, void *, _BYTE *, _DWORD))(*Src + 24);
              if ( v13 )
                v13(Src[1], Srca, 5, v46, v11, 0);
            }
          }
          xmlFreeURI(v41);
        }
        else
        {
          sub_41F1AC(Src, 91, "Invalid URI: %s\n", v11);
        }
      }
      else if ( !v46 )
      {
        sub_41EC3F(84, Src, 0);
      }
    }
    goto LABEL_111;
  }
  if ( v9 == 34 || v9 == 39 )
  {
    v45 = xmlParseEntityValue(Src, &Block);
    if ( *Src )
    {
      if ( !Src[53] )
      {
        v30 = *(void (__cdecl **)(int, char *, int, _DWORD, _DWORD, void *))(*Src + 24);
        if ( v30 )
          v30(Src[1], Srca, 1, 0, 0, v45);
      }
    }
    v31 = Src[2];
    if ( v31 )
    {
      if ( !xmlStrEqual(*(char **)(v31 + 56), "SAX compatibility mode document") )
        goto LABEL_111;
    }
    else
    {
      v32 = xmlNewDoc("SAX compatibility mode document");
      Src[2] = (int)v32;
      if ( !v32 )
        goto LABEL_94;
      v32[23] = 64;
    }
    v33 = Src[2];
    if ( !*(_DWORD *)(v33 + 44) )
      *(_DWORD *)(Src[2] + 44) = xmlNewDtd(v33, "fake", 0, 0);
    xmlSAX2EntityDecl(Src, Srca, 1, 0, 0, v45);
  }
  else
  {
    v15 = xmlParseExternalID(Src, &v46, 1);
    v16 = v15;
    v44 = v15;
    if ( v15 )
    {
      v17 = xmlParseURI(v15);
      v18 = v17;
      if ( v17 )
      {
        if ( v17[8] )
          sub_41EC3F(92, Src, 0);
        xmlFreeURI(v18);
      }
      else
      {
        sub_41F1AC(Src, 91, "Invalid URI: %s\n", v16);
      }
    }
    else if ( !v46 )
    {
      sub_41EC3F(84, Src, 0);
    }
    v19 = **(_BYTE **)(Src[9] + 16);
    if ( v19 != 62 && v19 != 32 && (v19 < 9u || v19 > 0xAu) && v19 != 13 )
      sub_41EFC6((int (__cdecl *)(int, char *, char))0x41, Src, "Space required before 'NDATA'\n");
    xmlSkipBlankChars((int)Src);
    v20 = Src[9];
    v21 = *(_BYTE **)(v20 + 16);
    if ( *v21 == 78 && v21[1] == 68 && v21[2] == 65 && v21[3] == 84 && v21[4] == 65 )
    {
      Src[50] += 5;
      *(_DWORD *)(v20 + 16) += 5;
      *(_DWORD *)(Src[9] + 32) += 5;
      if ( **(_BYTE **)(Src[9] + 16) == 37 )
        xmlParserHandlePEReference(Src);
      v22 = Src[9];
      if ( !**(_BYTE **)(v22 + 16) && xmlParserInputGrow((int *)v22, 250) <= 0 )
        xmlPopInput(Src);
      v23 = **(_BYTE **)(Src[9] + 16);
      if ( v23 != 32 && (v23 < 9u || v23 > 0xAu) && v23 != 13 )
        sub_41EFC6((int (__cdecl *)(int, char *, char))0x41, Src, "Space required after 'NDATA'\n");
      xmlSkipBlankChars((int)Src);
      v24 = xmlParseName((int)Src);
      if ( *Src )
      {
        if ( !Src[53] )
        {
          v25 = *(void (__cdecl **)(int, char *, void *, void *, unsigned __int8 *))(*Src + 40);
          if ( v25 )
            v25(Src[1], Srca, v46, v44, v24);
        }
      }
      goto LABEL_111;
    }
    if ( *Src )
    {
      if ( !Src[53] )
      {
        v26 = *(void (__cdecl **)(int, char *, int, void *, void *, _DWORD))(*Src + 24);
        if ( v26 )
          v26(Src[1], Srca, 2, v46, v44, 0);
      }
    }
    if ( Src[4] )
    {
      v27 = Src[2];
      if ( v27 )
      {
        if ( !xmlStrEqual(*(char **)(v27 + 56), "SAX compatibility mode document") )
          goto LABEL_111;
        goto LABEL_96;
      }
      v28 = xmlNewDoc("SAX compatibility mode document");
      Src[2] = (int)v28;
      if ( v28 )
      {
        v28[23] = 64;
LABEL_96:
        v29 = Src[2];
        if ( !*(_DWORD *)(v29 + 44) )
          *(_DWORD *)(Src[2] + 44) = xmlNewDtd(v29, "fake", 0, 0);
        xmlSAX2EntityDecl(Src, Srca, 2, (char *)v46, (char *)v44, 0);
        goto LABEL_111;
      }
LABEL_94:
      xmlErrMemory((int)Src, "New Doc failed");
      return;
    }
  }
LABEL_111:
  xmlSkipBlankChars((int)Src);
  v34 = Src[9];
  if ( **(_BYTE **)(v34 + 16) == 62 )
  {
    if ( v40 != (_DWORD *)v34 )
      sub_41EFC6(
        (int (__cdecl *)(int, char *, char))0x5A,
        Src,
        "Entity declaration doesn't start and stop in the same entity\n");
    xmlNextChar(Src);
  }
  else
  {
    sub_41F152((int (__cdecl *)(int, char *, char))0x25, Src, "xmlParseEntityDecl: entity %s not terminated\n", Srca);
  }
  v35 = Block;
  if ( !Block )
    goto LABEL_130;
  v36 = *Src;
  if ( v42 )
  {
    if ( !v36 )
      goto LABEL_129;
    v37 = *(int (__cdecl **)(int, char *))(v36 + 96);
    if ( !v37 )
      goto LABEL_129;
    Entity = (_DWORD *)v37(Src[1], Srca);
    goto LABEL_126;
  }
  if ( !v36 || (v39 = *(int (__cdecl **)(int, char *))(v36 + 20)) == 0 || (Entity = (_DWORD *)v39(Src[1], Srca)) == 0 )
  {
    if ( (int *)Src[1] != Src )
      goto LABEL_129;
    Entity = xmlSAX2GetEntity(Src, Srca);
LABEL_126:
    if ( Entity )
      goto LABEL_127;
LABEL_129:
    ((void (__cdecl *)(void *))xmlFree)(v35);
    goto LABEL_130;
  }
LABEL_127:
  if ( Entity[9] )
    goto LABEL_129;
  Entity[9] = v35;
LABEL_130:
  if ( v45 )
    ((void (__cdecl *)(void *))xmlFree)(v45);
  if ( v44 )
    ((void (__cdecl *)(void *))xmlFree)(v44);
  if ( v46 )
    ((void (__cdecl *)(void *))xmlFree)(v46);
}
// 496494: invalid function type has been ignored
// 424D78: conditional instruction was optimized away because ebx.4!=0
// 424E22: conditional instruction was optimized away because ebx.4!=0
// 424A61: variable 'v7' is possibly undefined

//----- (00424F48) --------------------------------------------------------
int __cdecl xmlParseDefaultDecl(int a1, char **a2)
{
  int v2; // ecx
  _BYTE *v3; // eax
  int v4; // eax
  int v6; // eax
  int v7; // esi
  int v8; // eax
  unsigned __int8 v9; // al
  char *v10; // eax

  *a2 = 0;
  v2 = *(_DWORD *)(a1 + 36);
  v3 = *(_BYTE **)(v2 + 16);
  if ( *v3 == 35 )
  {
    if ( v3[1] == 82
      && v3[2] == 69
      && v3[3] == 81
      && v3[4] == 85
      && v3[5] == 73
      && v3[6] == 82
      && v3[7] == 69
      && v3[8] == 68 )
    {
      *(_DWORD *)(a1 + 200) += 9;
      *(_DWORD *)(v2 + 16) += 9;
      *(_DWORD *)(*(_DWORD *)(a1 + 36) + 32) += 9;
      if ( **(_BYTE **)(*(_DWORD *)(a1 + 36) + 16) == 37 )
        xmlParserHandlePEReference((int *)a1);
      v4 = *(_DWORD *)(a1 + 36);
      if ( !**(_BYTE **)(v4 + 16) && xmlParserInputGrow((int *)v4, 250) <= 0 )
        xmlPopInput((_DWORD *)a1);
      return 2;
    }
    if ( v3[1] == 73 && v3[2] == 77 && v3[3] == 80 && v3[4] == 76 && v3[5] == 73 && v3[6] == 69 && v3[7] == 68 )
    {
      *(_DWORD *)(a1 + 200) += 8;
      *(_DWORD *)(v2 + 16) += 8;
      *(_DWORD *)(*(_DWORD *)(a1 + 36) + 32) += 8;
      if ( **(_BYTE **)(*(_DWORD *)(a1 + 36) + 16) == 37 )
        xmlParserHandlePEReference((int *)a1);
      v6 = *(_DWORD *)(a1 + 36);
      if ( !**(_BYTE **)(v6 + 16) && xmlParserInputGrow((int *)v6, 250) <= 0 )
        xmlPopInput((_DWORD *)a1);
      return 3;
    }
  }
  v7 = 1;
  if ( *v3 == 35 && v3[1] == 70 && v3[2] == 73 && v3[3] == 88 && v3[4] == 69 && v3[5] == 68 )
  {
    *(_DWORD *)(a1 + 200) += 6;
    *(_DWORD *)(v2 + 16) += 6;
    *(_DWORD *)(*(_DWORD *)(a1 + 36) + 32) += 6;
    if ( **(_BYTE **)(*(_DWORD *)(a1 + 36) + 16) == 37 )
      xmlParserHandlePEReference((int *)a1);
    v8 = *(_DWORD *)(a1 + 36);
    if ( !**(_BYTE **)(v8 + 16) && xmlParserInputGrow((int *)v8, 250) <= 0 )
      xmlPopInput((_DWORD *)a1);
    v9 = **(_BYTE **)(*(_DWORD *)(a1 + 36) + 16);
    v7 = 4;
    if ( v9 != 32 && (v9 < 9u || v9 > 0xAu) && v9 != 13 )
      sub_41EFC6((int (__cdecl *)(int, char *, char))0x41, (int *)a1, "Space required after '#FIXED'\n");
    xmlSkipBlankChars(a1);
  }
  v10 = xmlParseAttValue((int *)a1);
  *(_DWORD *)(a1 + 172) = 3;
  if ( v10 )
    *a2 = v10;
  else
    sub_41EFC6(
      *(int (__cdecl **)(int, char *, char))(a1 + 84),
      (int *)a1,
      "Attribute default value declaration error\n");
  return v7;
}
// 424FE4: conditional instruction was optimized away because dl.1==23

//----- (00425139) --------------------------------------------------------
void **__cdecl xmlParseNotationType(int *a1)
{
  void **v1; // ebp
  _DWORD *v3; // eax
  unsigned __int8 *v4; // ebx
  void **v5; // edi
  void **Enumeration; // eax
  void ***v7; // ecx
  void **v8; // [esp+Ch] [ebp-4h]

  v1 = 0;
  v8 = 0;
  if ( **(_BYTE **)(a1[9] + 16) != 40 )
  {
    sub_41EC3F(48, a1, 0);
    return 0;
  }
  if ( !a1[73] )
  {
    v3 = (_DWORD *)a1[9];
    if ( v3[4] - v3[3] > 500 && v3[5] - v3[4] < 500 )
      sub_41FF30(a1);
  }
  do
  {
    xmlNextChar(a1);
    xmlSkipBlankChars((int)a1);
    v4 = xmlParseName((int)a1);
    if ( !v4 )
    {
      sub_41EFC6((int (__cdecl *)(int, char *, char))0x44, a1, "Name expected in NOTATION declaration\n");
LABEL_21:
      xmlFreeEnumeration(v1);
      return 0;
    }
    v5 = v1;
    if ( !v1 )
    {
LABEL_11:
      Enumeration = (void **)xmlCreateEnumeration(v4);
      if ( Enumeration )
      {
        v7 = (void ***)v8;
        v8 = Enumeration;
        if ( v7 )
          *v7 = Enumeration;
        else
          v1 = Enumeration;
        goto LABEL_17;
      }
      xmlFreeEnumeration(v1);
      return 0;
    }
    while ( !xmlStrEqual((char *)v4, (char *)v5[1]) )
    {
      v5 = (void **)*v5;
      if ( !v5 )
        goto LABEL_11;
    }
    sub_43D29A(541, 0, v4, (int)a1, "standalone: attribute notation value token %s duplicated\n");
    if ( !xmlDictOwns(a1[74], (unsigned int)v4) )
      ((void (__cdecl *)(unsigned __int8 *))xmlFree)(v4);
LABEL_17:
    xmlSkipBlankChars((int)a1);
  }
  while ( **(_BYTE **)(a1[9] + 16) == 124 );
  if ( **(_BYTE **)(a1[9] + 16) != 41 )
  {
    sub_41EC3F(49, a1, 0);
    goto LABEL_21;
  }
  xmlNextChar(a1);
  return v1;
}
// 496494: invalid function type has been ignored

//----- (00425278) --------------------------------------------------------
void **__cdecl xmlParseEnumerationType(int *a1)
{
  _DWORD *v2; // eax
  char *v3; // edi
  void **v4; // ebx
  void **Enumeration; // ebx
  void ***v6; // eax
  void **v7; // [esp+8h] [ebp-8h]
  void **Block; // [esp+Ch] [ebp-4h]

  Block = 0;
  v7 = 0;
  if ( **(_BYTE **)(a1[9] + 16) == 40 )
  {
    if ( !a1[73] )
    {
      v2 = (_DWORD *)a1[9];
      if ( v2[4] - v2[3] > 500 && v2[5] - v2[4] < 500 )
        sub_41FF30(a1);
    }
    do
    {
      xmlNextChar(a1);
      xmlSkipBlankChars((int)a1);
      v3 = xmlParseNmtoken(a1);
      if ( !v3 )
      {
        sub_41EC3F(67, a1, 0);
        return Block;
      }
      v4 = Block;
      if ( Block )
      {
        while ( !xmlStrEqual(v3, (char *)v4[1]) )
        {
          v4 = (void **)*v4;
          if ( !v4 )
            goto LABEL_11;
        }
        sub_43D29A(541, 0, v3, (int)a1, "standalone: attribute enumeration value token %s duplicated\n");
        if ( !xmlDictOwns(a1[74], (unsigned int)v3) )
          ((void (__cdecl *)(char *))xmlFree)(v3);
      }
      else
      {
LABEL_11:
        Enumeration = (void **)xmlCreateEnumeration(v3);
        if ( !xmlDictOwns(a1[74], (unsigned int)v3) )
          ((void (__cdecl *)(char *))xmlFree)(v3);
        if ( !Enumeration )
        {
          xmlFreeEnumeration(Block);
          return 0;
        }
        v6 = (void ***)v7;
        v7 = Enumeration;
        if ( v6 )
          *v6 = Enumeration;
        else
          Block = Enumeration;
      }
      xmlSkipBlankChars((int)a1);
    }
    while ( **(_BYTE **)(a1[9] + 16) == 124 );
    if ( **(_BYTE **)(a1[9] + 16) == 41 )
      xmlNextChar(a1);
    else
      sub_41EC3F(51, a1, 0);
    return Block;
  }
  else
  {
    sub_41EC3F(50, a1, 0);
    return 0;
  }
}
// 496494: invalid function type has been ignored

//----- (004253C5) --------------------------------------------------------
int __cdecl xmlParseEnumeratedType(int *a1, void ***a2)
{
  int v2; // ecx
  _BYTE *v3; // eax
  int v4; // eax
  unsigned __int8 v5; // al
  void **v7; // eax
  void **v8; // eax

  v2 = a1[9];
  v3 = *(_BYTE **)(v2 + 16);
  if ( *v3 == 78
    && v3[1] == 79
    && v3[2] == 84
    && v3[3] == 65
    && v3[4] == 84
    && v3[5] == 73
    && v3[6] == 79
    && v3[7] == 78 )
  {
    a1[50] += 8;
    *(_DWORD *)(v2 + 16) += 8;
    *(_DWORD *)(a1[9] + 32) += 8;
    if ( **(_BYTE **)(a1[9] + 16) == 37 )
      xmlParserHandlePEReference(a1);
    v4 = a1[9];
    if ( !**(_BYTE **)(v4 + 16) && xmlParserInputGrow((int *)v4, 250) <= 0 )
      xmlPopInput(a1);
    v5 = **(_BYTE **)(a1[9] + 16);
    if ( v5 == 32 || v5 >= 9u && v5 <= 0xAu || v5 == 13 )
    {
      xmlSkipBlankChars((int)a1);
      v7 = xmlParseNotationType(a1);
      *a2 = v7;
      return v7 != 0 ? 0xA : 0;
    }
    else
    {
      sub_41EFC6((int (__cdecl *)(int, char *, char))0x41, a1, "Space required after 'NOTATION'\n");
      return 0;
    }
  }
  else
  {
    v8 = xmlParseEnumerationType(a1);
    *a2 = v8;
    return v8 != 0 ? 9 : 0;
  }
}

//----- (004254C3) --------------------------------------------------------
int __cdecl xmlParseAttributeType(int *a1, void ***a2)
{
  _DWORD *v2; // eax
  int v3; // ecx
  char *v4; // eax
  char v5; // dl
  int v6; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // edi
  int v13; // eax
  int v15; // [esp-8h] [ebp-10h]

  if ( !a1[73] )
  {
    v2 = (_DWORD *)a1[9];
    if ( v2[4] - v2[3] > 500 && v2[5] - v2[4] < 500 )
      sub_41FF30(a1);
  }
  v3 = a1[9];
  v4 = *(char **)(v3 + 16);
  v5 = *v4;
  if ( *v4 == 67 && v4[1] == 68 && v4[2] == 65 && v4[3] == 84 && v4[4] == 65 )
  {
    a1[50] += 5;
    *(_DWORD *)(v3 + 16) += 5;
    *(_DWORD *)(a1[9] + 32) += 5;
    if ( **(_BYTE **)(a1[9] + 16) == 37 )
      xmlParserHandlePEReference(a1);
    v6 = a1[9];
    if ( !**(_BYTE **)(v6 + 16) && xmlParserInputGrow((int *)v6, 250) <= 0 )
      xmlPopInput(a1);
    return 1;
  }
  if ( v5 != 73 )
    goto LABEL_40;
  if ( v4[1] == 68 && v4[2] == 82 && v4[3] == 69 && v4[4] == 70 && v4[5] == 83 )
  {
    a1[50] += 6;
    *(_DWORD *)(v3 + 16) += 6;
    *(_DWORD *)(a1[9] + 32) += 6;
    if ( **(_BYTE **)(a1[9] + 16) == 37 )
      xmlParserHandlePEReference(a1);
    v8 = a1[9];
    if ( !**(_BYTE **)(v8 + 16) && xmlParserInputGrow((int *)v8, 250) <= 0 )
      xmlPopInput(a1);
    return 4;
  }
  if ( v4[1] == 68 && v4[2] == 82 && v4[3] == 69 && v4[4] == 70 )
  {
    a1[50] += 5;
    *(_DWORD *)(v3 + 16) += 5;
    *(_DWORD *)(a1[9] + 32) += 5;
    if ( **(_BYTE **)(a1[9] + 16) == 37 )
      xmlParserHandlePEReference(a1);
    v9 = a1[9];
    if ( !**(_BYTE **)(v9 + 16) && xmlParserInputGrow((int *)v9, 250) <= 0 )
      xmlPopInput(a1);
    return 3;
  }
  if ( v4[1] != 68 )
  {
LABEL_40:
    if ( v5 == 69 )
    {
      if ( v4[1] == 78 && v4[2] == 84 && v4[3] == 73 && v4[4] == 84 && v4[5] == 89 )
      {
        a1[50] += 6;
        *(_DWORD *)(v3 + 16) += 6;
        *(_DWORD *)(a1[9] + 32) += 6;
        if ( **(_BYTE **)(a1[9] + 16) == 37 )
          xmlParserHandlePEReference(a1);
        v10 = a1[9];
        if ( !**(_BYTE **)(v10 + 16) && xmlParserInputGrow((int *)v10, 250) <= 0 )
          xmlPopInput(a1);
        return 5;
      }
      if ( v4[1] == 78 && v4[2] == 84 && v4[3] == 73 && v4[4] == 84 && v4[5] == 73 && v4[6] == 69 && v4[7] == 83 )
      {
        a1[50] += 8;
        *(_DWORD *)(v3 + 16) += 8;
        *(_DWORD *)(a1[9] + 32) += 8;
        if ( **(_BYTE **)(a1[9] + 16) == 37 )
          xmlParserHandlePEReference(a1);
        v11 = a1[9];
        if ( !**(_BYTE **)(v11 + 16) && xmlParserInputGrow((int *)v11, 250) <= 0 )
          xmlPopInput(a1);
        return 6;
      }
    }
    if ( v5 == 78 )
    {
      if ( v4[1] == 77 && v4[2] == 84 && v4[3] == 79 && v4[4] == 75 && v4[5] == 69 && v4[6] == 78 && v4[7] == 83 )
      {
        v15 = 8;
        goto LABEL_82;
      }
      if ( v4[1] == 77 && v4[2] == 84 && v4[3] == 79 && v4[4] == 75 && v4[5] == 69 && v4[6] == 78 )
      {
        v15 = 7;
        goto LABEL_82;
      }
    }
    return xmlParseEnumeratedType(a1, a2);
  }
  v15 = 2;
LABEL_82:
  v12 = v15;
  a1[50] += v15;
  *(_DWORD *)(v3 + 16) += v15;
  *(_DWORD *)(a1[9] + 32) += v15;
  if ( **(_BYTE **)(a1[9] + 16) == 37 )
    xmlParserHandlePEReference(a1);
  v13 = a1[9];
  if ( !**(_BYTE **)(v13 + 16) && xmlParserInputGrow((int *)v13, 250) <= 0 )
    xmlPopInput(a1);
  return v12;
}
// 4255E1: conditional instruction was optimized away because dl.1==49
// 42564B: conditional instruction was optimized away because dl.1==49
// 4256CE: conditional instruction was optimized away because dl.1==45
// 42577F: conditional instruction was optimized away because dl.1==4E

//----- (004257FF) --------------------------------------------------------
void __cdecl xmlParseAttributeListDecl(int *a1)
{
  int *v1; // esi
  int v2; // ecx
  _BYTE *v3; // eax
  int v4; // eax
  unsigned __int8 v5; // al
  bool v6; // cc
  int v7; // eax
  int v8; // ecx
  unsigned __int8 v9; // al
  unsigned __int8 v10; // al
  int v11; // ebx
  char *v12; // edi
  unsigned __int8 v13; // al
  void (__cdecl *v14)(int, unsigned __int8 *, unsigned __int8 *, void *, int, char *, int *); // eax
  int v15; // eax
  int v16; // [esp+4h] [ebp-18h]
  int v17; // [esp+8h] [ebp-14h]
  unsigned __int8 *v18; // [esp+Ch] [ebp-10h]
  unsigned __int8 *v19; // [esp+10h] [ebp-Ch]
  void *v20; // [esp+14h] [ebp-8h]
  void *Block; // [esp+18h] [ebp-4h] BYREF

  v1 = a1;
  v2 = a1[9];
  v3 = *(_BYTE **)(v2 + 16);
  if ( *v3 == 60
    && v3[1] == 33
    && v3[2] == 65
    && v3[3] == 84
    && v3[4] == 84
    && v3[5] == 76
    && v3[6] == 73
    && v3[7] == 83
    && v3[8] == 84 )
  {
    a1[50] += 9;
    *(_DWORD *)(v2 + 16) += 9;
    *(_DWORD *)(v1[9] + 32) += 9;
    v16 = v2;
    if ( **(_BYTE **)(v1[9] + 16) == 37 )
      xmlParserHandlePEReference(v1);
    v4 = v1[9];
    if ( !**(_BYTE **)(v4 + 16) && xmlParserInputGrow((int *)v4, 250) <= 0 )
      xmlPopInput(v1);
    v5 = **(_BYTE **)(v1[9] + 16);
    if ( v5 != 32 && (v5 < 9u || v5 > 0xAu) && v5 != 13 )
      sub_41EFC6((int (__cdecl *)(int, char *, char))0x41, v1, "Space required after '<!ATTLIST'\n");
    xmlSkipBlankChars((int)v1);
    v18 = xmlParseName((int)v1);
    if ( v18 )
    {
      xmlSkipBlankChars((int)v1);
      if ( v1[73] )
        goto LABEL_76;
      v6 = *(_DWORD *)(v1[9] + 20) - *(_DWORD *)(v1[9] + 16) < 250;
LABEL_74:
      if ( v6 )
        sub_41FF5D((int)v1);
LABEL_76:
      while ( **(_BYTE **)(v1[9] + 16) != 62 )
      {
        v7 = v1[9];
        v8 = *(_DWORD *)(v7 + 16);
        v17 = v8;
        Block = 0;
        if ( !v1[73] && *(_DWORD *)(v7 + 20) - v8 < 250 )
          sub_41FF5D((int)v1);
        a1 = 0;
        v19 = xmlParseName((int)v1);
        if ( !v19 )
        {
          sub_41EFC6((int (__cdecl *)(int, char *, char))0x44, v1, "ATTLIST: no name for Attribute\n");
          break;
        }
        if ( !v1[73] && *(_DWORD *)(v1[9] + 20) - *(_DWORD *)(v1[9] + 16) < 250 )
          sub_41FF5D((int)v1);
        v9 = **(_BYTE **)(v1[9] + 16);
        if ( v9 != 32 && (v9 < 9u || v9 > 0xAu) && v9 != 13 )
        {
          sub_41EFC6((int (__cdecl *)(int, char *, char))0x41, v1, "Space required after the attribute name\n");
          break;
        }
        xmlSkipBlankChars((int)v1);
        v20 = (void *)xmlParseAttributeType(v1, (void ***)&a1);
        if ( (int)v20 <= 0 )
          break;
        if ( !v1[73] && *(_DWORD *)(v1[9] + 20) - *(_DWORD *)(v1[9] + 16) < 250 )
          sub_41FF5D((int)v1);
        v10 = **(_BYTE **)(v1[9] + 16);
        if ( v10 != 32 && (v10 < 9u || v10 > 0xAu) && v10 != 13 )
        {
          sub_41EFC6((int (__cdecl *)(int, char *, char))0x41, v1, "Space required after the attribute type\n");
          goto LABEL_86;
        }
        xmlSkipBlankChars((int)v1);
        v11 = xmlParseDefaultDecl((int)v1, (char **)&Block);
        if ( v11 <= 0 )
          goto LABEL_81;
        v12 = (char *)Block;
        if ( v20 != (void *)1 && Block )
          sub_41F3B9((char *)Block, (char *)Block);
        if ( !v1[73] && *(_DWORD *)(v1[9] + 20) - *(_DWORD *)(v1[9] + 16) < 250 )
          sub_41FF5D((int)v1);
        v13 = **(_BYTE **)(v1[9] + 16);
        if ( v13 != 62 )
        {
          if ( v13 != 32 && (v13 < 9u || v13 > 0xAu) && v13 != 13 )
          {
            sub_41EFC6(
              (int (__cdecl *)(int, char *, char))0x41,
              v1,
              "Space required after the attribute default value\n");
LABEL_81:
            if ( Block )
              ((void (__cdecl *)(void *))xmlFree)(Block);
LABEL_86:
            if ( a1 )
              xmlFreeEnumeration((void **)a1);
            break;
          }
          xmlSkipBlankChars((int)v1);
        }
        if ( v17 == *(_DWORD *)(v1[9] + 16) )
        {
          sub_41EC3F(1, v1, "in xmlParseAttributeListDecl\n");
          if ( v12 )
            ((void (__cdecl *)(char *))xmlFree)(v12);
          goto LABEL_86;
        }
        if ( *v1
          && !v1[53]
          && (v14 = *(void (__cdecl **)(int, unsigned __int8 *, unsigned __int8 *, void *, int, char *, int *))(*v1 + 32)) != 0 )
        {
          v14(v1[1], v18, v19, v20, v11, v12, a1);
        }
        else if ( a1 )
        {
          xmlFreeEnumeration((void **)a1);
        }
        if ( v1[81] )
        {
          if ( v12 && v11 != 3 && v11 != 2 )
          {
            sub_41F496((char *)v18, (int)v1, (char *)v19, v12);
            v12 = (char *)Block;
          }
          if ( v1[81] )
            sub_41F666((int)v1, (char *)v18, (char *)v19, v20);
        }
        if ( v12 )
          ((void (__cdecl *)(char *))xmlFree)(v12);
        if ( !v1[73] )
        {
          v6 = *(_DWORD *)(v1[9] + 20) - *(_DWORD *)(v1[9] + 16) < 250;
          goto LABEL_74;
        }
      }
      v15 = v1[9];
      if ( **(_BYTE **)(v15 + 16) == 62 )
      {
        if ( v16 != v15 )
          sub_43D29A(90, 0, 0, (int)v1, "Attribute list declaration doesn't start and stop in the same entity\n");
        xmlNextChar(v1);
      }
    }
    else
    {
      sub_41EFC6((int (__cdecl *)(int, char *, char))0x44, v1, "ATTLIST: no name for Element\n");
    }
  }
}
// 496494: invalid function type has been ignored

//----- (00425BE1) --------------------------------------------------------
int *__cdecl xmlParseElementMixedContentDecl(int *a1, int a2)
{
  int *v2; // ebx
  int v3; // ecx
  _BYTE *v4; // eax
  int v5; // eax
  _DWORD *v6; // eax
  int v7; // eax
  char v8; // cl
  int *v9; // edi
  int *v11; // eax
  int *v12; // edi
  int *v13; // eax
  _BYTE *v14; // eax
  int *v15; // eax
  int v16; // eax
  int *Block; // [esp+Ch] [ebp-8h]
  unsigned __int8 *Src; // [esp+10h] [ebp-4h]

  v2 = 0;
  Block = 0;
  Src = 0;
  if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
    sub_41FF5D((int)a1);
  v3 = a1[9];
  v4 = *(_BYTE **)(v3 + 16);
  if ( *v4 != 35 || v4[1] != 80 || v4[2] != 67 || v4[3] != 68 || v4[4] != 65 || v4[5] != 84 || v4[6] != 65 )
  {
    sub_41EC3F(69, a1, 0);
    return Block;
  }
  a1[50] += 7;
  *(_DWORD *)(v3 + 16) += 7;
  *(_DWORD *)(a1[9] + 32) += 7;
  if ( **(_BYTE **)(a1[9] + 16) == 37 )
    xmlParserHandlePEReference(a1);
  v5 = a1[9];
  if ( !**(_BYTE **)(v5 + 16) && xmlParserInputGrow((int *)v5, 250) <= 0 )
    xmlPopInput(a1);
  xmlSkipBlankChars((int)a1);
  if ( !a1[73] )
  {
    v6 = (_DWORD *)a1[9];
    if ( v6[4] - v6[3] > 500 && v6[5] - v6[4] < 500 )
      sub_41FF30(a1);
  }
  v7 = a1[9];
  v8 = **(_BYTE **)(v7 + 16);
  if ( v8 != 41 )
  {
    if ( v8 == 40 || v8 == 124 )
    {
      v2 = xmlNewDocElementContent(a1[2], 0, 1);
      Block = v2;
      if ( !v2 )
        return 0;
    }
    while ( **(_BYTE **)(a1[9] + 16) == 124 )
    {
      xmlNextChar(a1);
      if ( Src )
      {
        v12 = xmlNewDocElementContent(a1[2], 0, 4);
        if ( !v12 )
          return 0;
        v13 = xmlNewDocElementContent(a1[2], (char *)Src, 2);
        v12[3] = (int)v13;
        if ( v13 )
          v13[5] = (int)v12;
        v2[4] = (int)v12;
        v12[5] = (int)v2;
        v2 = v12;
      }
      else
      {
        v11 = xmlNewDocElementContent(a1[2], 0, 4);
        Block = v11;
        if ( !v11 )
          return 0;
        v11[3] = (int)v2;
        if ( v2 )
          v2[5] = (int)v11;
        v2 = v11;
      }
      xmlSkipBlankChars((int)a1);
      Src = xmlParseName((int)a1);
      if ( !Src )
      {
        sub_41EFC6((int (__cdecl *)(int, char *, char))0x44, a1, "xmlParseElementMixedContentDecl : Name expected\n");
        xmlFreeDocElementContent(a1[2], v2);
        return 0;
      }
      xmlSkipBlankChars((int)a1);
      if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
        sub_41FF5D((int)a1);
    }
    v14 = *(_BYTE **)(a1[9] + 16);
    if ( *v14 != 41 || v14[1] != 42 )
    {
      xmlFreeDocElementContent(a1[2], Block);
      sub_41EC3F(52, a1, 0);
      return 0;
    }
    if ( Src )
    {
      v15 = xmlNewDocElementContent(a1[2], (char *)Src, 2);
      v2[4] = (int)v15;
      if ( v15 )
        v15[5] = (int)v2;
    }
    if ( Block )
      Block[1] = 3;
    if ( a1[26] && *(_DWORD *)(a1[9] + 56) != a2 )
      sub_43D29A(90, 0, 0, (int)a1, "Element content declaration doesn't start and stop in the same entity\n");
    a1[50] += 2;
    *(_DWORD *)(a1[9] + 16) += 2;
    *(_DWORD *)(a1[9] + 32) += 2;
    if ( **(_BYTE **)(a1[9] + 16) == 37 )
      xmlParserHandlePEReference(a1);
    v16 = a1[9];
    if ( !**(_BYTE **)(v16 + 16) && xmlParserInputGrow((int *)v16, 250) <= 0 )
      xmlPopInput(a1);
    return Block;
  }
  if ( a1[26] && *(_DWORD *)(v7 + 56) != a2 )
    sub_43D29A(90, 0, 0, (int)a1, "Element content declaration doesn't start and stop in the same entity\n");
  xmlNextChar(a1);
  v9 = xmlNewDocElementContent(a1[2], 0, 1);
  if ( !v9 )
    return 0;
  if ( **(_BYTE **)(a1[9] + 16) == 42 )
  {
    v9[1] = 3;
    xmlNextChar(a1);
  }
  return v9;
}

//----- (00425F26) --------------------------------------------------------
int *__cdecl sub_425F26(int *a1, int a2, int a3)
{
  int *v3; // edi
  int v5; // eax
  int v6; // ebx
  unsigned __int8 *v7; // eax
  int *v8; // ebx
  char v9; // al
  _DWORD *v10; // eax
  char v11; // al
  int *v12; // ebx
  int *v13; // eax
  int v14; // eax
  int v15; // ebx
  unsigned __int8 *v16; // eax
  int *v17; // eax
  char v18; // cl
  int *v19; // ebx
  char v20; // al
  int *v21; // ecx
  int v22; // eax
  int *v23; // eax
  int v24; // ecx
  int v25; // edx
  int v26; // ecx
  int v27; // edx
  int v28; // eax
  int v29; // edx
  int v30; // eax
  int v31; // ecx
  int v32; // eax
  int v33; // ecx
  int *v34; // [esp+8h] [ebp-10h]
  int *v35; // [esp+Ch] [ebp-Ch]
  int *Block; // [esp+10h] [ebp-8h]
  unsigned __int8 v37; // [esp+17h] [ebp-1h]

  v3 = 0;
  v34 = 0;
  v37 = 0;
  if ( a3 > 128 && (a1[90] & 0x80000) == 0 || a3 > 2048 )
  {
    sub_41F093(
      (int (__cdecl *)(int, char *, char))0x37,
      a1,
      "xmlParseElementChildrenContentDecl : depth %d too deep, use XML_PARSE_HUGE\n",
      a3);
    return 0;
  }
  xmlSkipBlankChars((int)a1);
  if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
    sub_41FF5D((int)a1);
  v5 = a1[9];
  if ( **(_BYTE **)(v5 + 16) == 40 )
  {
    v6 = *(_DWORD *)(v5 + 56);
    xmlNextChar(a1);
    xmlSkipBlankChars((int)a1);
    Block = (int *)sub_425F26(a1, v6, a3 + 1);
    v35 = Block;
    xmlSkipBlankChars((int)a1);
  }
  else
  {
    v7 = xmlParseName((int)a1);
    if ( !v7 )
    {
      sub_41EC3F(54, a1, 0);
      return 0;
    }
    v8 = xmlNewDocElementContent(a1[2], (char *)v7, 2);
    Block = v8;
    v35 = v8;
    if ( !v8 )
    {
      xmlErrMemory((int)a1, 0);
      return 0;
    }
    if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
      sub_41FF5D((int)a1);
    v9 = **(_BYTE **)(a1[9] + 16);
    switch ( v9 )
    {
      case '?':
        v8[1] = 2;
        break;
      case '*':
        v8[1] = 3;
        break;
      case '+':
        v8[1] = 4;
        break;
      default:
        v8[1] = 1;
        goto LABEL_25;
    }
    xmlNextChar(a1);
  }
LABEL_25:
  if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
    sub_41FF5D((int)a1);
  xmlSkipBlankChars((int)a1);
  if ( !a1[73] )
  {
    v10 = (_DWORD *)a1[9];
    if ( v10[4] - v10[3] > 500 && v10[5] - v10[4] < 500 )
      sub_41FF30(a1);
  }
  v11 = **(_BYTE **)(a1[9] + 16);
  if ( v11 == 41 )
  {
LABEL_76:
    v19 = v35;
    if ( v35 && v3 )
    {
      v35[4] = (int)v3;
      v3[5] = (int)v35;
    }
    if ( a1[26] && *(_DWORD *)(a1[9] + 56) != a2 )
    {
      sub_43D29A(90, 0, 0, (int)a1, "Element content declaration doesn't start and stop in the same entity\n");
      v19 = v35;
    }
    xmlNextChar(a1);
    v20 = **(_BYTE **)(a1[9] + 16);
    switch ( v20 )
    {
      case '?':
        v21 = Block;
        if ( Block )
        {
          v22 = Block[1];
          if ( v22 != 4 && v22 != 3 )
          {
            Block[1] = 2;
            break;
          }
LABEL_132:
          v21[1] = 3;
        }
        break;
      case '*':
        v23 = Block;
        if ( Block )
        {
          Block[1] = 3;
          do
          {
            if ( *v23 != 4 )
              break;
            v24 = v23[3];
            if ( v24 )
            {
              v25 = *(_DWORD *)(v24 + 4);
              if ( v25 == 2 || v25 == 3 )
                *(_DWORD *)(v24 + 4) = 1;
            }
            v26 = v23[4];
            if ( v26 )
            {
              v27 = *(_DWORD *)(v26 + 4);
              if ( v27 == 2 || v27 == 3 )
                *(_DWORD *)(v26 + 4) = 1;
            }
            v23 = (int *)v23[4];
          }
          while ( v23 );
        }
        break;
      case '+':
        v21 = Block;
        if ( Block )
        {
          v28 = Block[1];
          v29 = 0;
          if ( v28 == 2 || v28 == 3 )
            Block[1] = 3;
          else
            Block[1] = 4;
          if ( v19 )
          {
            do
            {
              if ( *v19 != 4 )
                break;
              v30 = v19[3];
              if ( v30 )
              {
                v31 = *(_DWORD *)(v30 + 4);
                if ( v31 == 2 || v31 == 3 )
                {
                  *(_DWORD *)(v30 + 4) = 1;
                  v29 = 1;
                }
              }
              v32 = v19[4];
              if ( v32 )
              {
                v33 = *(_DWORD *)(v32 + 4);
                if ( v33 == 2 || v33 == 3 )
                {
                  *(_DWORD *)(v32 + 4) = 1;
                  v29 = 1;
                }
              }
              v19 = (int *)v19[4];
              v21 = Block;
            }
            while ( v19 );
            if ( v29 )
              goto LABEL_132;
          }
        }
        break;
      default:
        return Block;
    }
    xmlNextChar(a1);
    return Block;
  }
  v12 = Block;
  while ( 1 )
  {
    if ( v11 == 44 )
    {
      if ( v37 )
      {
        if ( v37 != 44 )
          goto LABEL_90;
      }
      else
      {
        v37 = 44;
      }
      xmlNextChar(a1);
      v13 = xmlNewDocElementContent(a1[2], 0, 3);
      if ( !v13 )
      {
        if ( v3 && v3 != v12 )
          xmlFreeDocElementContent(a1[2], v3);
        goto LABEL_52;
      }
      goto LABEL_39;
    }
    if ( v11 != 124 )
      break;
    if ( v37 )
    {
      if ( v37 != 124 )
      {
LABEL_90:
        sub_41F093(
          (int (__cdecl *)(int, char *, char))0x42,
          a1,
          "xmlParseElementChildrenContentDecl : '%c' expected\n",
          v37);
        if ( v34 && v34 != Block )
          xmlFreeDocElementContent(a1[2], v34);
        goto LABEL_97;
      }
    }
    else
    {
      v37 = 124;
    }
    xmlNextChar(a1);
    v13 = xmlNewDocElementContent(a1[2], 0, 4);
    if ( !v13 )
    {
      if ( v3 && v3 != v12 )
        xmlFreeDocElementContent(a1[2], v3);
LABEL_51:
      if ( !v12 )
        return 0;
LABEL_52:
      xmlFreeDocElementContent(a1[2], v12);
      return 0;
    }
LABEL_39:
    if ( v3 )
    {
      v35[4] = (int)v13;
      v13[5] = (int)v35;
      v13[3] = (int)v3;
      v3[5] = (int)v13;
    }
    else
    {
      v13[3] = (int)v12;
      if ( v12 )
        v12[5] = (int)v13;
      Block = v13;
      v12 = v13;
    }
    v35 = v13;
    if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
      sub_41FF5D((int)a1);
    xmlSkipBlankChars((int)a1);
    if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
      sub_41FF5D((int)a1);
    v14 = a1[9];
    if ( **(_BYTE **)(v14 + 16) == 40 )
    {
      v15 = *(_DWORD *)(v14 + 56);
      xmlNextChar(a1);
      xmlSkipBlankChars((int)a1);
      v34 = (int *)sub_425F26(a1, v15, a3 + 1);
      xmlSkipBlankChars((int)a1);
      v12 = Block;
      goto LABEL_72;
    }
    v16 = xmlParseName((int)a1);
    if ( !v16 )
    {
      sub_41EC3F(54, a1, 0);
      goto LABEL_97;
    }
    v17 = xmlNewDocElementContent(a1[2], (char *)v16, 2);
    v34 = v17;
    if ( !v17 )
      goto LABEL_51;
    v18 = **(_BYTE **)(a1[9] + 16);
    switch ( v18 )
    {
      case '?':
        v17[1] = 2;
LABEL_70:
        xmlNextChar(a1);
        goto LABEL_72;
      case '*':
        v17[1] = 3;
        goto LABEL_70;
      case '+':
        v17[1] = 4;
        goto LABEL_70;
    }
    v17[1] = 1;
LABEL_72:
    xmlSkipBlankChars((int)a1);
    if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
      sub_41FF5D((int)a1);
    v11 = **(_BYTE **)(a1[9] + 16);
    v3 = v34;
    if ( v11 == 41 )
      goto LABEL_76;
  }
  sub_41EC3F(55, a1, 0);
  if ( v3 && v3 != Block )
    xmlFreeDocElementContent(a1[2], v3);
LABEL_97:
  if ( Block )
    xmlFreeDocElementContent(a1[2], Block);
  return 0;
}

//----- (0042648F) --------------------------------------------------------
int *__cdecl xmlParseElementChildrenContentDecl(int *a1, int a2)
{
  return sub_425F26(a1, a2, 1);
}

//----- (004264A2) --------------------------------------------------------
int __cdecl xmlParseElementContentDecl(int *a1, _BYTE *a2, int **a3)
{
  int v3; // edi
  _BYTE *v5; // eax
  int *v6; // eax
  int v7; // ebx
  int *v8; // edi
  int v9; // [esp-8h] [ebp-10h]

  v3 = *(_DWORD *)(a1[9] + 56);
  *a3 = 0;
  if ( **(_BYTE **)(a1[9] + 16) == 40 )
  {
    xmlNextChar(a1);
    if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
      sub_41FF5D((int)a1);
    xmlSkipBlankChars((int)a1);
    v5 = *(_BYTE **)(a1[9] + 16);
    if ( *v5 == 35 && v5[1] == 80 && v5[2] == 67 && v5[3] == 68 && v5[4] == 65 && v5[5] == 84 && v5[6] == 65 )
    {
      v6 = xmlParseElementMixedContentDecl(a1, v3);
      v9 = 3;
    }
    else
    {
      v6 = sub_425F26(a1, v3, 1);
      v9 = 4;
    }
    v7 = v9;
    v8 = v6;
    xmlSkipBlankChars((int)a1);
    *a3 = v8;
    return v7;
  }
  else
  {
    sub_41F152((int (__cdecl *)(int, char *, char))0x36, a1, "xmlParseElementContentDecl : %s '(' expected\n", a2);
    return -1;
  }
}

//----- (0042656B) --------------------------------------------------------
int __cdecl xmlParseElementDecl(int *a1)
{
  int v2; // ecx
  _BYTE *v3; // eax
  int v4; // esi
  int v5; // eax
  unsigned __int8 v6; // al
  unsigned __int8 v8; // al
  int v9; // eax
  char *v10; // ecx
  char v11; // dl
  int v12; // eax
  int v13; // eax
  int v14; // eax
  bool v15; // zf
  _DWORD *v16; // ebx
  int v17; // [esp+Ch] [ebp-8h]
  void *Block; // [esp+10h] [ebp-4h] BYREF
  unsigned __int8 *v19; // [esp+1Ch] [ebp+8h]

  Block = 0;
  v2 = a1[9];
  v3 = *(_BYTE **)(v2 + 16);
  v4 = -1;
  if ( *v3 == 60
    && v3[1] == 33
    && v3[2] == 69
    && v3[3] == 76
    && v3[4] == 69
    && v3[5] == 77
    && v3[6] == 69
    && v3[7] == 78
    && v3[8] == 84 )
  {
    a1[50] += 9;
    *(_DWORD *)(v2 + 16) += 9;
    *(_DWORD *)(a1[9] + 32) += 9;
    v17 = v2;
    if ( **(_BYTE **)(a1[9] + 16) == 37 )
      xmlParserHandlePEReference(a1);
    v5 = a1[9];
    if ( !**(_BYTE **)(v5 + 16) && xmlParserInputGrow((int *)v5, 250) <= 0 )
      xmlPopInput(a1);
    v6 = **(_BYTE **)(a1[9] + 16);
    if ( v6 != 32 && (v6 < 9u || v6 > 0xAu) && v6 != 13 )
      sub_41EFC6((int (__cdecl *)(int, char *, char))0x41, a1, "Space required after 'ELEMENT'\n");
    xmlSkipBlankChars((int)a1);
    v19 = xmlParseName((int)a1);
    if ( !v19 )
    {
      sub_41EFC6((int (__cdecl *)(int, char *, char))0x44, a1, "xmlParseElementDecl: no name for Element\n");
      return -1;
    }
    while ( !**(_BYTE **)(a1[9] + 16) && a1[10] > 1 )
      xmlPopInput(a1);
    v8 = **(_BYTE **)(a1[9] + 16);
    if ( v8 != 32 && (v8 < 9u || v8 > 0xAu) && v8 != 13 )
      sub_41EFC6((int (__cdecl *)(int, char *, char))0x41, a1, "Space required after the element name\n");
    xmlSkipBlankChars((int)a1);
    v9 = a1[9];
    v10 = *(char **)(v9 + 16);
    v11 = *v10;
    if ( *v10 == 69 && v10[1] == 77 && v10[2] == 80 && v10[3] == 84 && v10[4] == 89 )
    {
      a1[50] += 5;
      *(_DWORD *)(v9 + 16) += 5;
      *(_DWORD *)(a1[9] + 32) += 5;
      if ( **(_BYTE **)(a1[9] + 16) == 37 )
        xmlParserHandlePEReference(a1);
      v12 = a1[9];
      if ( !**(_BYTE **)(v12 + 16) && xmlParserInputGrow((int *)v12, 250) <= 0 )
        xmlPopInput(a1);
      v4 = 1;
    }
    else if ( v11 == 65 && v10[1] == 78 && v10[2] == 89 )
    {
      a1[50] += 3;
      *(_DWORD *)(v9 + 16) += 3;
      *(_DWORD *)(a1[9] + 32) += 3;
      if ( **(_BYTE **)(a1[9] + 16) == 37 )
        xmlParserHandlePEReference(a1);
      v13 = a1[9];
      if ( !**(_BYTE **)(v13 + 16) && xmlParserInputGrow((int *)v13, 250) <= 0 )
        xmlPopInput(a1);
      v4 = 2;
    }
    else
    {
      if ( v11 != 40 )
      {
        if ( v11 == 37 && !a1[24] && a1[10] == 1 )
          sub_41EFC6(
            (int (__cdecl *)(int, char *, char))0x15,
            a1,
            "PEReference: forbidden within markup decl in internal subset\n");
        else
          sub_41EFC6(
            (int (__cdecl *)(int, char *, char))0x36,
            a1,
            "xmlParseElementDecl: 'EMPTY', 'ANY' or '(' expected\n");
        return -1;
      }
      v4 = xmlParseElementContentDecl(a1, v19, (int **)&Block);
    }
    xmlSkipBlankChars((int)a1);
    while ( !**(_BYTE **)(a1[9] + 16) && a1[10] > 1 )
      xmlPopInput(a1);
    xmlSkipBlankChars((int)a1);
    v14 = a1[9];
    if ( **(_BYTE **)(v14 + 16) == 62 )
    {
      if ( v17 != v14 )
        sub_41EFC6(
          (int (__cdecl *)(int, char *, char))0x5A,
          a1,
          "Element declaration doesn't start and stop in the same entity\n");
      xmlNextChar(a1);
      if ( *a1 && !a1[53] && *(_DWORD *)(*a1 + 36) )
      {
        v16 = Block;
        if ( Block )
          *((_DWORD *)Block + 5) = 0;
        (*(void (__cdecl **)(int, unsigned __int8 *, int, _DWORD *))(*a1 + 36))(a1[1], v19, v4, v16);
        if ( v16 && !v16[5] )
          xmlFreeDocElementContent(a1[2], v16);
        return v4;
      }
      v15 = Block == 0;
    }
    else
    {
      sub_41EC3F(73, a1, 0);
      v15 = Block == 0;
    }
    if ( !v15 )
      xmlFreeDocElementContent(a1[2], Block);
  }
  return v4;
}

//----- (0042687B) --------------------------------------------------------
void __cdecl sub_42687B(int *Block)
{
  int v2; // eax
  void *v3; // edi
  _BYTE *v4; // eax
  int v5; // eax
  int v6; // eax
  _BYTE *v7; // ecx
  int v8; // eax
  int v9; // eax
  int v10; // eax
  const char *v11; // ecx
  int v12; // eax
  unsigned __int8 *v13; // ecx
  unsigned __int8 v14; // dl
  unsigned __int8 *v15; // edi
  int v16; // ebx
  int v17; // eax
  const char *v18; // ecx
  int v19; // ebp
  int v20; // eax
  int v21; // eax
  int v22; // eax
  const char *v23; // ecx
  int v24; // edi
  int v25; // ebx
  int v26; // eax
  char *v27; // ecx
  char v28; // dl
  int v29; // eax
  int v30; // eax
  const char *v31; // ecx
  _DWORD *v32; // eax
  _BYTE *v33; // ecx
  int v34; // eax
  int v35; // eax
  void *Blocka; // [esp+10h] [ebp+4h]

  v2 = Block[9];
  v3 = *(void **)(v2 + 56);
  Block[50] += 3;
  *(_DWORD *)(v2 + 16) += 3;
  *(_DWORD *)(Block[9] + 32) += 3;
  v4 = *(_BYTE **)(Block[9] + 16);
  Blocka = v3;
  if ( *v4 == 37 )
    xmlParserHandlePEReference(Block);
  v5 = Block[9];
  if ( !**(_BYTE **)(v5 + 16) && xmlParserInputGrow((int *)v5, 250) <= 0 )
    xmlPopInput(Block);
  xmlSkipBlankChars((int)Block);
  v6 = Block[9];
  v7 = *(_BYTE **)(v6 + 16);
  if ( *v7 != 73 )
    goto LABEL_102;
  if ( v7[1] != 78 || v7[2] != 67 || v7[3] != 76 || v7[4] != 85 || v7[5] != 68 || v7[6] != 69 )
  {
    if ( v7[1] == 71 && v7[2] == 78 && v7[3] == 79 && v7[4] == 82 && v7[5] == 69 )
    {
      Block[50] += 6;
      *(_DWORD *)(v6 + 16) += 6;
      *(_DWORD *)(Block[9] + 32) += 6;
      v19 = 0;
      if ( **(_BYTE **)(Block[9] + 16) == 37 )
        xmlParserHandlePEReference(Block);
      v20 = Block[9];
      if ( !**(_BYTE **)(v20 + 16) && xmlParserInputGrow((int *)v20, 250) <= 0 )
        xmlPopInput(Block);
      xmlSkipBlankChars((int)Block);
      v21 = Block[9];
      if ( **(_BYTE **)(v21 + 16) == 91 )
      {
        if ( *(void **)(v21 + 56) != v3 )
          sub_43D29A(90, 0, 0, (int)Block, "All markup of the conditional section is not in the same entity\n");
        xmlNextChar(Block);
      }
      else
      {
        sub_41EC3F(83, Block, 0);
      }
      if ( xmlParserDebugEntities )
      {
        v22 = Block[9];
        if ( v22 )
        {
          v23 = *(const char **)(v22 + 4);
          if ( v23 )
            xmlGenericError(xmlGenericErrorContext, "%s(%d): ", v23, *(_DWORD *)(v22 + 28));
        }
        xmlGenericError(xmlGenericErrorContext, "Entering IGNORE Conditional Section\n");
      }
      v24 = Block[53];
      v25 = Block[43];
      if ( !Block[72] )
        Block[53] = 1;
      Block[43] = 15;
      while ( 1 )
      {
        v26 = Block[9];
        v27 = *(char **)(v26 + 16);
        v28 = *v27;
        if ( !*v27 )
        {
LABEL_97:
          Block[53] = v24;
          Block[43] = v25;
          if ( xmlParserDebugEntities )
          {
            v30 = Block[9];
            if ( v30 )
            {
              v31 = *(const char **)(v30 + 4);
              if ( v31 )
                xmlGenericError(xmlGenericErrorContext, "%s(%d): ", v31, *(_DWORD *)(v30 + 28));
            }
            xmlGenericError(xmlGenericErrorContext, "Leaving IGNORE Conditional Section\n");
          }
          goto LABEL_103;
        }
        if ( v28 == 60 && v27[1] == 33 && v27[2] == 91 )
          break;
        if ( v28 == 93 && v27[1] == 93 && v27[2] == 62 )
        {
          if ( --v19 < 0 )
            goto LABEL_97;
          goto LABEL_85;
        }
        xmlNextChar(Block);
LABEL_96:
        if ( v19 < 0 )
          goto LABEL_97;
      }
      ++v19;
LABEL_85:
      Block[50] += 3;
      *(_DWORD *)(v26 + 16) += 3;
      *(_DWORD *)(Block[9] + 32) += 3;
      if ( **(_BYTE **)(Block[9] + 16) == 37 )
        xmlParserHandlePEReference(Block);
      v29 = Block[9];
      if ( !**(_BYTE **)(v29 + 16) && xmlParserInputGrow((int *)v29, 250) <= 0 )
        xmlPopInput(Block);
      goto LABEL_96;
    }
LABEL_102:
    sub_41EC3F(95, Block, 0);
    goto LABEL_103;
  }
  Block[50] += 7;
  *(_DWORD *)(v6 + 16) += 7;
  *(_DWORD *)(Block[9] + 32) += 7;
  if ( **(_BYTE **)(Block[9] + 16) == 37 )
    xmlParserHandlePEReference(Block);
  v8 = Block[9];
  if ( !**(_BYTE **)(v8 + 16) && xmlParserInputGrow((int *)v8, 250) <= 0 )
    xmlPopInput(Block);
  xmlSkipBlankChars((int)Block);
  v9 = Block[9];
  if ( **(_BYTE **)(v9 + 16) == 91 )
  {
    if ( *(void **)(v9 + 56) != v3 )
      sub_43D29A(90, 0, 0, (int)Block, "All markup of the conditional section is not in the same entity\n");
    xmlNextChar(Block);
  }
  else
  {
    sub_41EC3F(83, Block, 0);
  }
  if ( xmlParserDebugEntities )
  {
    v10 = Block[9];
    if ( v10 )
    {
      v11 = *(const char **)(v10 + 4);
      if ( v11 )
        xmlGenericError(xmlGenericErrorContext, "%s(%d): ", v11, *(_DWORD *)(v10 + 28));
    }
    xmlGenericError(xmlGenericErrorContext, "Entering INCLUDE Conditional Section\n");
  }
  v12 = Block[9];
  v13 = *(unsigned __int8 **)(v12 + 16);
  if ( *v13 )
  {
    do
    {
      v14 = *v13;
      if ( *v13 == 93 && v13[1] == 93 && v13[2] == 62 )
        break;
      v15 = *(unsigned __int8 **)(v12 + 16);
      v16 = *(_DWORD *)(v12 + 36);
      if ( *v15 == 60 && v13[1] == 33 && v13[2] == 91 )
      {
        sub_42687B(Block);
      }
      else if ( v14 == 32 || v14 >= 9u && v14 <= 0xAu || v14 == 13 )
      {
        xmlNextChar(Block);
      }
      else if ( v14 == 37 )
      {
        xmlParsePEReference(Block);
      }
      else
      {
        xmlParseMarkupDecl(Block);
      }
      while ( !**(_BYTE **)(Block[9] + 16) && Block[10] > 1 )
        xmlPopInput(Block);
      v12 = Block[9];
      v13 = *(unsigned __int8 **)(v12 + 16);
      if ( v13 == v15 && v16 == *(_DWORD *)(v12 + 36) )
      {
        sub_41EC3F(60, Block, 0);
        break;
      }
    }
    while ( **(_BYTE **)(Block[9] + 16) );
  }
  if ( xmlParserDebugEntities )
  {
    v17 = Block[9];
    if ( v17 )
    {
      v18 = *(const char **)(v17 + 4);
      if ( v18 )
        xmlGenericError(xmlGenericErrorContext, "%s(%d): ", v18, *(_DWORD *)(v17 + 28));
    }
    xmlGenericError(xmlGenericErrorContext, "Leaving INCLUDE Conditional Section\n");
  }
LABEL_103:
  v32 = (_DWORD *)Block[9];
  v33 = (_BYTE *)v32[4];
  if ( !*v33 && !Block[73] && (int)&v33[-v32[3]] > 500 && v32[5] - (int)v33 < 500 )
    sub_41FF30(Block);
  v34 = Block[9];
  if ( **(_BYTE **)(v34 + 16) )
  {
    if ( *(void **)(v34 + 56) != Blocka )
      sub_43D29A(90, 0, 0, (int)Block, "All markup of the conditional section is not in the same entity\n");
    Block[50] += 3;
    *(_DWORD *)(Block[9] + 16) += 3;
    *(_DWORD *)(Block[9] + 32) += 3;
    if ( **(_BYTE **)(Block[9] + 16) == 37 )
      xmlParserHandlePEReference(Block);
    v35 = Block[9];
    if ( !**(_BYTE **)(v35 + 16) && xmlParserInputGrow((int *)v35, 250) <= 0 )
      xmlPopInput(Block);
  }
  else
  {
    sub_41EC3F(59, Block, 0);
  }
}
// 426AF1: conditional instruction was optimized away because dl.1==49
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);
// 4A9C7C: using guessed type int xmlParserDebugEntities;

//----- (00426DAA) --------------------------------------------------------
void __cdecl xmlParseMarkupDecl(int *Block)
{
  _BYTE *v1; // eax
  char v2; // cl
  char v3; // cl
  char v4; // al
  _BYTE *v5; // eax

  if ( !Block[73] && *(_DWORD *)(Block[9] + 20) - *(_DWORD *)(Block[9] + 16) < 250 )
    sub_41FF5D((int)Block);
  v1 = *(_BYTE **)(Block[9] + 16);
  if ( *v1 == 60 )
  {
    v2 = v1[1];
    if ( v2 == 33 )
    {
      v3 = v1[2];
      switch ( v3 )
      {
        case '-':
          xmlParseComment(Block);
          break;
        case 'A':
          xmlParseAttributeListDecl(Block);
          break;
        case 'E':
          v4 = v1[3];
          if ( v4 == 76 )
          {
            xmlParseElementDecl(Block);
          }
          else if ( v4 == 78 )
          {
            xmlParseEntityDecl(Block);
          }
          break;
        case 'N':
          xmlParseNotationDecl(Block);
          break;
      }
    }
    else if ( v2 == 63 )
    {
      xmlParsePI(Block);
    }
  }
  if ( !Block[24] )
  {
    if ( Block[10] == 1 )
      xmlParsePEReference(Block);
    if ( !Block[24] && Block[10] > 1 )
    {
      v5 = *(_BYTE **)(Block[9] + 16);
      if ( *v5 == 60 && v5[1] == 33 && v5[2] == 91 )
        sub_42687B(Block);
    }
  }
  Block[43] = 3;
}
// 42687B: using guessed type _DWORD __cdecl sub_42687B(void *Block);

//----- (00426E80) --------------------------------------------------------
void __cdecl xmlParseTextDecl(int *a1)
{
  int v1; // ecx
  _BYTE *v2; // eax
  unsigned __int8 v3; // al
  int v4; // eax
  unsigned __int8 v5; // al
  _BYTE *v6; // esi
  unsigned __int8 v7; // al
  unsigned __int8 *v8; // eax
  int v9; // ecx
  int v10; // eax
  _BYTE *v11; // ecx
  int v12; // eax
  int v13; // eax

  v1 = a1[9];
  v2 = *(_BYTE **)(v1 + 16);
  if ( *v2 == 60
    && v2[1] == 63
    && v2[2] == 120
    && v2[3] == 109
    && v2[4] == 108
    && ((v3 = v2[5], v3 == 32) || v3 >= 9u && v3 <= 0xAu || v3 == 13) )
  {
    a1[50] += 5;
    *(_DWORD *)(v1 + 16) += 5;
    *(_DWORD *)(a1[9] + 32) += 5;
    if ( **(_BYTE **)(a1[9] + 16) == 37 )
      xmlParserHandlePEReference(a1);
    v4 = a1[9];
    if ( !**(_BYTE **)(v4 + 16) && xmlParserInputGrow((int *)v4, 250) <= 0 )
      xmlPopInput(a1);
    v5 = **(_BYTE **)(a1[9] + 16);
    if ( v5 != 32 && (v5 < 9u || v5 > 0xAu) && v5 != 13 )
      sub_41EFC6((int (__cdecl *)(int, char *, char))0x41, a1, "Space needed after '<?xml'\n");
    xmlSkipBlankChars(a1);
    v6 = xmlParseVersionInfo(a1);
    if ( v6 )
    {
      v7 = **(_BYTE **)(a1[9] + 16);
      if ( v7 != 32 && (v7 < 9u || v7 > 0xAu) && v7 != 13 )
        sub_41EFC6((int (__cdecl *)(int, char *, char))0x41, a1, "Space needed here\n");
    }
    else
    {
      v6 = xmlCharStrdup("1.0");
    }
    *(_DWORD *)(a1[9] + 48) = v6;
    v8 = xmlParseEncodingDecl(a1);
    v9 = a1[21];
    if ( v9 != 32 )
    {
      if ( !v8 && !v9 )
        sub_41EFC6((int (__cdecl *)(int, char *, char))0x65, a1, "Missing encoding in text declaration\n");
      xmlSkipBlankChars(a1);
      v10 = a1[9];
      v11 = *(_BYTE **)(v10 + 16);
      if ( *v11 == 63 && v11[1] == 62 )
      {
        a1[50] += 2;
        *(_DWORD *)(v10 + 16) += 2;
        *(_DWORD *)(a1[9] + 32) += 2;
        if ( **(_BYTE **)(a1[9] + 16) == 37 )
          xmlParserHandlePEReference(a1);
        v12 = a1[9];
        if ( !**(_BYTE **)(v12 + 16) && xmlParserInputGrow((int *)v12, 250) <= 0 )
          xmlPopInput(a1);
      }
      else if ( *v11 == 62 )
      {
        sub_41EC3F(57, a1, 0);
        xmlNextChar(a1);
      }
      else
      {
        sub_41EC3F(57, a1, 0);
        while ( **(_BYTE **)(a1[9] + 16) )
        {
          v13 = a1[9];
          if ( **(_BYTE **)(v13 + 16) == 62 )
            break;
          ++*(_DWORD *)(v13 + 16);
        }
        xmlNextChar(a1);
      }
    }
  }
  else
  {
    sub_41EC3F(56, a1, 0);
  }
}
// 41FF93: using guessed type _DWORD __cdecl xmlSkipBlankChars(_DWORD);
// 420686: using guessed type _DWORD __cdecl xmlParserHandlePEReference(_DWORD);

//----- (00427070) --------------------------------------------------------
void __cdecl xmlParseExternalSubset(int *Block, _BYTE *a2, _BYTE *a3)
{
  int *v3; // esi
  int v4; // eax
  int v5; // eax
  _BYTE *v6; // eax
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  _DWORD *v9; // eax
  unsigned __int8 *v10; // ecx
  unsigned __int8 v11; // dl
  int v12; // edi
  int v13; // ebx
  unsigned __int8 *v14; // eax
  unsigned __int8 v15; // cl
  int v16; // eax

  v3 = Block;
  sub_41F321((int)Block);
  if ( !v3[73] && *(_DWORD *)(v3[9] + 20) - *(_DWORD *)(v3[9] + 16) < 250 )
    sub_41FF5D((int)v3);
  if ( !v3[6] )
  {
    v4 = v3[9];
    if ( *(_DWORD *)(v4 + 20) - *(_DWORD *)(v4 + 16) >= 4 )
    {
      Block = **(int ***)(v4 + 16);
      v5 = xmlDetectCharEncoding((char *)&Block, 4);
      if ( v5 )
        xmlSwitchEncoding(v3, v5);
    }
  }
  v6 = *(_BYTE **)(v3[9] + 16);
  if ( *v6 == 60 && v6[1] == 63 && v6[2] == 120 && v6[3] == 109 && v6[4] == 108 )
  {
    xmlParseTextDecl(v3);
    if ( v3[21] == 32 )
    {
      v3[43] = -1;
      return;
    }
  }
  if ( !v3[2] )
  {
    v7 = xmlNewDoc("1.0");
    v3[2] = (int)v7;
    if ( !v7 )
    {
      xmlErrMemory((int)v3, "New Doc failed");
      return;
    }
    v7[23] = 64;
  }
  v8 = (_DWORD *)v3[2];
  if ( v8 && !v8[11] )
    xmlCreateIntSubset(v8, 0, a2, a3);
  v3[43] = 3;
  v3[24] = 1;
  while ( 1 )
  {
    v9 = (_DWORD *)v3[9];
    v10 = (unsigned __int8 *)v9[4];
    v11 = *v10;
    if ( (*v10 != 60 || v10[1] != 63 && v10[1] != 33) && v11 != 37 && v11 != 32 && (v11 < 9u || v11 > 0xAu) && v11 != 13 )
      break;
    v12 = v9[9];
    v13 = v9[4];
    if ( !v3[73] && v9[5] - (int)v10 < 250 )
      sub_41FF5D((int)v3);
    v14 = *(unsigned __int8 **)(v3[9] + 16);
    v15 = *v14;
    if ( *v14 == 60 && v14[1] == 33 && v14[2] == 91 )
    {
      sub_42687B(v3);
    }
    else if ( v15 == 32 || v15 >= 9u && v15 <= 0xAu || v15 == 13 )
    {
      xmlNextChar(v3);
    }
    else if ( v15 == 37 )
    {
      xmlParsePEReference(v3);
    }
    else
    {
      xmlParseMarkupDecl(v3);
    }
    while ( !**(_BYTE **)(v3[9] + 16) && v3[10] > 1 )
      xmlPopInput(v3);
    v16 = v3[9];
    if ( *(_DWORD *)(v16 + 16) == v13 && v12 == *(_DWORD *)(v16 + 36) )
    {
      sub_41EC3F(60, v3, 0);
      break;
    }
  }
  if ( **(_BYTE **)(v3[9] + 16) )
    sub_41EC3F(60, v3, 0);
}

//----- (0042727F) --------------------------------------------------------
void __cdecl xmlParseReference(int a1)
{
  _BYTE *v1; // ecx
  _DWORD *v2; // esi
  bool v3; // zf
  int v4; // ebx
  int v5; // eax
  int v6; // eax
  void (__cdecl *v7)(_DWORD, char *, int); // eax
  void (__cdecl *v8)(_DWORD, char *); // eax
  int v9; // eax
  int v10; // ecx
  void (__cdecl *v11)(_DWORD, char *, int); // ecx
  _DWORD *v12; // eax
  int v13; // ebx
  int v14; // eax
  int v15; // edx
  int v16; // eax
  int v17; // eax
  int v18; // eax
  _DWORD *v19; // edx
  int v20; // eax
  int v21; // ecx
  int v22; // eax
  int v23; // eax
  void (__cdecl *v24)(_DWORD, _DWORD); // eax
  _DWORD *v25; // esi
  char *v26; // eax
  _DWORD *v27; // ecx
  _DWORD *v28; // esi
  _DWORD *v29; // eax
  char *v30; // eax
  unsigned __int8 *v31; // eax
  int v32; // ecx
  int v33; // ecx
  _BYTE *v34; // ebx
  int v35; // eax
  void (__cdecl *v36)(_DWORD, _BYTE *, int); // edx
  int v37; // [esp+8h] [ebp-20h]
  _DWORD *v38; // [esp+8h] [ebp-20h]
  int v39; // [esp+Ch] [ebp-1Ch]
  _DWORD *v40; // [esp+Ch] [ebp-1Ch]
  int v41; // [esp+10h] [ebp-18h]
  int v42; // [esp+10h] [ebp-18h]
  void *Block; // [esp+14h] [ebp-14h] BYREF
  char Buffer[12]; // [esp+18h] [ebp-10h] BYREF

  v1 = *(_BYTE **)(*(_DWORD *)(a1 + 36) + 16);
  v2 = 0;
  v3 = *v1 == 38;
  Block = 0;
  if ( !v3 )
    return;
  if ( v1[1] == 35 )
  {
    v4 = (unsigned __int8)v1[2];
    v5 = xmlParseCharRef((int *)a1);
    if ( v5 )
    {
      if ( *(_DWORD *)(a1 + 256) == 1 )
      {
        v9 = xmlCopyCharMultiByte(Buffer, v5);
        v10 = *(_DWORD *)a1;
        Buffer[v9] = 0;
        if ( v10 )
        {
          v11 = *(void (__cdecl **)(_DWORD, char *, int))(v10 + 68);
          if ( v11 )
          {
            if ( !*(_DWORD *)(a1 + 212) )
              v11(*(_DWORD *)(a1 + 4), Buffer, v9);
          }
        }
      }
      else if ( v5 > 255 )
      {
        if ( v4 == 120 || v4 == 88 )
          _snprintf(Buffer, 0xAu, "#x%X", v5);
        else
          _snprintf(Buffer, 0xAu, "#%d", v5);
        if ( *(_DWORD *)a1 )
        {
          v8 = *(void (__cdecl **)(_DWORD, char *))(*(_DWORD *)a1 + 64);
          if ( v8 )
          {
            if ( !*(_DWORD *)(a1 + 212) )
              v8(*(_DWORD *)(a1 + 4), Buffer);
          }
        }
      }
      else
      {
        Buffer[0] = v5;
        v6 = *(_DWORD *)a1;
        Buffer[1] = 0;
        if ( v6 )
        {
          v7 = *(void (__cdecl **)(_DWORD, char *, int))(v6 + 68);
          if ( v7 )
          {
            if ( !*(_DWORD *)(a1 + 212) )
              v7(*(_DWORD *)(a1 + 4), Buffer, 1);
          }
        }
      }
    }
    return;
  }
  v12 = xmlParseEntityRef((int *)a1);
  v13 = (int)v12;
  if ( !v12 || !*(_DWORD *)(a1 + 12) )
    return;
  v14 = v12[18];
  v37 = *(_DWORD *)(v13 + 72);
  if ( !*(_DWORD *)(v13 + 8) || (v15 = *(_DWORD *)(v13 + 48), v15 == 6) )
  {
    v34 = *(_BYTE **)(v13 + 40);
    if ( v34 && *(_DWORD *)a1 && *(_DWORD *)(*(_DWORD *)a1 + 68) && !*(_DWORD *)(a1 + 212) )
    {
      v35 = xmlStrlen(v34);
      v36(*(_DWORD *)(a1 + 4), v34, v35);
    }
    return;
  }
  if ( !v14 )
  {
    v39 = *(_DWORD *)(a1 + 440);
    v16 = a1 != *(_DWORD *)(a1 + 4) ? *(_DWORD *)(a1 + 4) : 0;
    if ( v15 == 1 )
    {
      ++*(_DWORD *)(a1 + 248);
      v17 = sub_42D5D2((int *)a1, *(_BYTE **)(v13 + 40), v16, &Block);
      --*(_DWORD *)(a1 + 248);
    }
    else
    {
      if ( v15 != 2 )
      {
        v41 = 88;
        sub_41F1AC((int *)a1, 1, "invalid entity type found\n", 0);
LABEL_33:
        *(_DWORD *)(v13 + 72) = *(_DWORD *)(a1 + 440) - v39;
        if ( v41 == 89 )
        {
          sub_41EC3F(89, (int *)a1, 0);
          xmlFreeNodeList(v2);
          return;
        }
        if ( sub_41EB1F((int *)a1, v13, 0) )
        {
          xmlFreeNodeList(v2);
          return;
        }
        if ( v41 )
        {
          if ( v41 != 27 )
          {
            sub_41F152(
              (int (__cdecl *)(int, char *, char))0x1A,
              (int *)a1,
              "Entity '%s' failed to parse\n",
              *(_BYTE **)(v13 + 8));
            goto LABEL_62;
          }
          if ( !v2 )
          {
LABEL_62:
            if ( !*(_DWORD *)(v13 + 72) )
              *(_DWORD *)(v13 + 72) = 1;
            goto LABEL_66;
          }
        }
        else
        {
          if ( !v2 )
            goto LABEL_62;
          v18 = *(_DWORD *)(v13 + 48);
          if ( (v18 == 1 || v18 == 2) && !*(_DWORD *)(v13 + 12) )
          {
            *(_DWORD *)(v13 + 12) = v2;
            if ( !*(_DWORD *)(a1 + 16) )
            {
              *(_DWORD *)(v13 + 68) = 1;
              do
              {
                v2[5] = v13;
                xmlSetTreeDoc(v2, *(_DWORD *)(v13 + 32));
                if ( !v2[6] )
                  *(_DWORD *)(v13 + 16) = v2;
                v2 = (_DWORD *)v2[6];
              }
              while ( v2 );
              goto LABEL_62;
            }
            if ( (v2[1] != 3 || v2[6]) && *(_DWORD *)(a1 + 436) != 5 )
            {
              *(_DWORD *)(v13 + 68) = 0;
              do
              {
                v2[5] = *(_DWORD *)(a1 + 52);
                v2[8] = *(_DWORD *)(a1 + 8);
                if ( !v2[6] )
                  *(_DWORD *)(v13 + 16) = v2;
                v2 = (_DWORD *)v2[6];
              }
              while ( v2 );
              v2 = *(_DWORD **)(v13 + 12);
              goto LABEL_62;
            }
            v2[5] = v13;
            *(_DWORD *)(v13 + 68) = 1;
            goto LABEL_61;
          }
        }
        xmlFreeNodeList(v2);
LABEL_61:
        v2 = 0;
        goto LABEL_62;
      }
      v17 = sub_42D227(
              *(_DWORD *)(a1 + 8),
              (_DWORD *)a1,
              *(_DWORD *)a1,
              v16,
              ++*(_DWORD *)(a1 + 248),
              *(char **)(v13 + 64),
              *(_DWORD *)(v13 + 52),
              &Block);
      --*(_DWORD *)(a1 + 248);
    }
    v2 = Block;
    v41 = v17;
    goto LABEL_33;
  }
  if ( v14 != 1 )
    *(_DWORD *)(a1 + 440) += v14;
LABEL_66:
  v19 = *(_DWORD **)(v13 + 12);
  if ( v19 )
  {
    if ( *(_DWORD *)a1 )
    {
      v24 = *(void (__cdecl **)(_DWORD, _DWORD))(*(_DWORD *)a1 + 64);
      if ( v24 )
      {
        if ( *(_DWORD *)(a1 + 16) )
        {
LABEL_86:
          if ( *(_DWORD *)(a1 + 52) )
          {
            if ( (v2 || *(_DWORD *)(v13 + 68)) && *(_DWORD *)(a1 + 436) != 5 )
            {
              if ( v2 )
              {
                v31 = xmlDictLookup(*(_DWORD **)(a1 + 296), "nbktext", -1);
                v32 = *(_DWORD *)(v13 + 12);
                if ( *(_DWORD *)(v32 + 4) == 3 )
                  *(_DWORD *)(v32 + 8) = v31;
                v33 = *(_DWORD *)(v13 + 16);
                if ( v33 != *(_DWORD *)(v13 + 12) && *(_DWORD *)(v33 + 4) == 3 )
                  *(_DWORD *)(v33 + 8) = v31;
                xmlAddChildList(*(_DWORD **)(a1 + 52), *(_BYTE ***)(v13 + 12));
              }
              else
              {
                v27 = *(_DWORD **)(v13 + 16);
                v28 = *(_DWORD **)(v13 + 12);
                Block = 0;
                *(_DWORD *)(v13 + 12) = 0;
                v38 = v27;
                *(_DWORD *)(v13 + 16) = 0;
                do
                {
                  v29 = (_DWORD *)v28[6];
                  v28[6] = 0;
                  v28[5] = 0;
                  v40 = v29;
                  v30 = xmlDocCopyNode((int)v28, *(_DWORD *)(a1 + 8), 1);
                  if ( v30 )
                  {
                    if ( !*(_DWORD *)v30 )
                      *(_DWORD *)v30 = *v28;
                    if ( !Block )
                      Block = v28;
                    xmlAddChild((char *)v13, v30);
                    xmlAddChild(*(char **)(a1 + 52), (char *)v28);
                  }
                  if ( v28 == v38 )
                    break;
                  v28 = v40;
                }
                while ( v40 );
                if ( !*(_DWORD *)(v13 + 68) )
                  *(_DWORD *)(v13 + 68) = 1;
              }
            }
            else
            {
              Block = 0;
              v25 = v19;
              while ( 1 )
              {
                v26 = xmlDocCopyNode((int)v25, *(_DWORD *)(a1 + 8), 1);
                if ( v26 )
                {
                  if ( !*(_DWORD *)v26 )
                    *(_DWORD *)v26 = *v25;
                  if ( !Block )
                    Block = v26;
                  v26 = xmlAddChild(*(char **)(a1 + 52), v26);
                }
                if ( v25 == *(_DWORD **)(v13 + 16) )
                  break;
                v25 = (_DWORD *)v25[6];
                if ( !v25 )
                  goto LABEL_123;
              }
              if ( *(_DWORD *)(a1 + 436) == 5 && v26 && *((_DWORD *)v26 + 1) == 1 && !*((_DWORD *)v26 + 3) )
                *((_WORD *)v26 + 29) = 1;
            }
LABEL_123:
            *(_DWORD *)(a1 + 264) = 0;
            *(_DWORD *)(a1 + 260) = 0;
          }
          return;
        }
        if ( !*(_DWORD *)(a1 + 212) )
        {
LABEL_84:
          v24(*(_DWORD *)(a1 + 4), *(_DWORD *)(v13 + 8));
          return;
        }
      }
    }
    if ( !*(_DWORD *)(a1 + 16) )
      return;
    goto LABEL_86;
  }
  if ( v37 )
  {
    v20 = a1 != *(_DWORD *)(a1 + 4) ? *(_DWORD *)(a1 + 4) : 0;
    v21 = *(_DWORD *)(v13 + 48);
    if ( v21 == 1 )
    {
      ++*(_DWORD *)(a1 + 248);
      v22 = sub_42D5D2((int *)a1, *(_BYTE **)(v13 + 40), v20, 0);
      --*(_DWORD *)(a1 + 248);
      v42 = v22;
    }
    else if ( v21 == 2 )
    {
      v23 = sub_42D227(
              *(_DWORD *)(a1 + 8),
              (_DWORD *)a1,
              *(_DWORD *)a1,
              v20,
              ++*(_DWORD *)(a1 + 248),
              *(char **)(v13 + 64),
              *(_DWORD *)(v13 + 52),
              0);
      --*(_DWORD *)(a1 + 248);
      v42 = v23;
    }
    else
    {
      v42 = 88;
      sub_41F1AC((int *)a1, 1, "invalid entity type found\n", 0);
    }
    if ( v42 == 89 )
    {
      sub_41EC3F(89, (int *)a1, 0);
      return;
    }
  }
  if ( *(_DWORD *)a1 )
  {
    v24 = *(void (__cdecl **)(_DWORD, _DWORD))(*(_DWORD *)a1 + 64);
    if ( v24 )
    {
      if ( !*(_DWORD *)(a1 + 16) && !*(_DWORD *)(a1 + 212) )
        goto LABEL_84;
    }
  }
}
// 427743: conditional instruction was optimized away because edx.4!=0
// 42781B: variable 'v36' is possibly undefined

//----- (0042782F) --------------------------------------------------------
_DWORD *__cdecl xmlParseEntityRef(int *a1)
{
  _DWORD *result; // eax
  unsigned __int8 *v2; // esi
  int v3; // eax
  int (__cdecl *v4)(int, unsigned __int8 *); // eax
  _DWORD *v5; // ecx
  void (__cdecl *v6)(int, unsigned __int8 *); // eax
  int v7; // edx
  _BYTE *v8; // eax
  _DWORD *PredefinedEntity; // [esp+Ch] [ebp-4h]

  PredefinedEntity = 0;
  if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
    sub_41FF5D((int)a1);
  if ( **(_BYTE **)(a1[9] + 16) != 38 )
    return 0;
  xmlNextChar(a1);
  v2 = xmlParseName((int)a1);
  if ( !v2 )
  {
    sub_41EFC6((int (__cdecl *)(int, char *, char))0x44, a1, "xmlParseEntityRef: no name\n");
    return 0;
  }
  if ( **(_BYTE **)(a1[9] + 16) != 59 )
  {
    sub_41EC3F(23, a1, 0);
    return 0;
  }
  xmlNextChar(a1);
  if ( (a1[90] & 0x100000) != 0 || (result = xmlGetPredefinedEntity((char *)v2), (PredefinedEntity = result) == 0) )
  {
    v3 = *a1;
    ++a1[110];
    if ( v3 )
    {
      v4 = *(int (__cdecl **)(int, unsigned __int8 *))(v3 + 20);
      if ( v4 )
        PredefinedEntity = (_DWORD *)v4(a1[1], v2);
      if ( a1[3] == 1 )
      {
        if ( !PredefinedEntity && (a1[90] & 0x100000) != 0 )
          PredefinedEntity = xmlGetPredefinedEntity((char *)v2);
        v5 = PredefinedEntity;
        if ( PredefinedEntity )
          goto LABEL_32;
        if ( (int *)a1[1] != a1 )
          goto LABEL_23;
        PredefinedEntity = (_DWORD *)xmlSAX2GetEntity(a1, v2);
      }
    }
    v5 = PredefinedEntity;
    if ( !PredefinedEntity )
    {
LABEL_23:
      if ( a1[7] != 1 && (a1[22] || a1[23]) )
      {
        sub_41F1AC(a1, 27, "Entity '%s' not defined\n", v2);
        if ( !a1[54] && *a1 )
        {
          v6 = *(void (__cdecl **)(int, unsigned __int8 *))(*a1 + 64);
          if ( v6 )
            v6(a1[1], v2);
        }
      }
      else
      {
        sub_41F152((int (__cdecl *)(int, char *, char))0x1A, a1, "Entity '%s' not defined\n", v2);
      }
      a1[25] = 0;
      return PredefinedEntity;
    }
LABEL_32:
    v7 = v5[12];
    if ( v7 == 3 )
    {
      sub_41F152((int (__cdecl *)(int, char *, char))0x1C, a1, "Entity reference to unparsed entity %s\n", v2);
      return PredefinedEntity;
    }
    if ( a1[43] == 12 )
    {
      if ( v7 == 2 )
      {
        sub_41F152((int (__cdecl *)(int, char *, char))0x1D, a1, "Attribute references external entity '%s'\n", v2);
        return PredefinedEntity;
      }
      v8 = (_BYTE *)v5[10];
      if ( v8 && v7 != 6 && xmlStrchr(v8, 60) )
      {
        sub_41F152(
          (int (__cdecl *)(int, char *, char))0x26,
          a1,
          "'<' in entity '%s' is not allowed in attributes values\n",
          v2);
        return PredefinedEntity;
      }
    }
    if ( (unsigned int)(v7 - 4) <= 1 )
      sub_41F152((int (__cdecl *)(int, char *, char))0x1E, a1, "Attempt to reference the parameter entity '%s'\n", v2);
    return PredefinedEntity;
  }
  return result;
}
// 427918: conditional instruction was optimized away because esi.4==1
// 4279CC: conditional instruction was optimized away because eax.4==C
// 4279F4: variable 'v7' is possibly undefined
// 43D716: using guessed type _DWORD __cdecl xmlSAX2GetEntity(_DWORD, _DWORD);

//----- (00427A16) --------------------------------------------------------
_DWORD *__usercall sub_427A16@<eax>(int *a1@<eax>, _BYTE **a2)
{
  _BYTE *v3; // eax
  char *v4; // esi
  void *v6; // edi
  _DWORD *PredefinedEntity; // eax
  int v8; // eax
  int (__cdecl *v9)(int, char *); // eax
  int v10; // edx
  _BYTE *v11; // eax
  unsigned __int8 *v12; // [esp+Ch] [ebp-8h] BYREF
  _DWORD *Entity; // [esp+10h] [ebp-4h]

  Entity = 0;
  if ( !a2 )
    return 0;
  v3 = *a2;
  if ( !*a2 || *v3 != 38 )
    return 0;
  v12 = v3 + 1;
  v4 = sub_421F46(&v12);
  if ( !v4 )
  {
    sub_41EFC6((int (__cdecl *)(int, char *, char))0x44, a1, "xmlParseStringEntityRef: no name\n");
    *a2 = v12;
    return 0;
  }
  if ( *v12 != 59 )
  {
    sub_41EC3F(23, a1, 0);
    v6 = 0;
LABEL_9:
    ((void (__cdecl *)(char *))xmlFree)(v4);
    *a2 = v12;
    return v6;
  }
  ++v12;
  if ( (a1[90] & 0x100000) == 0 )
  {
    PredefinedEntity = xmlGetPredefinedEntity(v4);
    Entity = PredefinedEntity;
    if ( PredefinedEntity )
    {
      v6 = PredefinedEntity;
      goto LABEL_9;
    }
  }
  v8 = *a1;
  ++a1[110];
  if ( v8 )
  {
    v9 = *(int (__cdecl **)(int, char *))(v8 + 20);
    if ( v9 )
      Entity = (_DWORD *)v9(a1[1], v4);
    if ( Entity )
      goto LABEL_27;
    if ( (a1[90] & 0x100000) != 0 )
    {
      Entity = xmlGetPredefinedEntity(v4);
      if ( Entity )
        goto LABEL_27;
    }
    if ( (int *)a1[1] != a1 )
    {
LABEL_22:
      if ( a1[7] != 1 && (a1[22] || a1[23]) )
        sub_41F1AC(a1, 27, "Entity '%s' not defined\n", v4);
      else
        sub_41F152((int (__cdecl *)(int, char *, char))0x1A, a1, "Entity '%s' not defined\n", v4);
      goto LABEL_38;
    }
    Entity = xmlSAX2GetEntity(a1, v4);
  }
  if ( !Entity )
    goto LABEL_22;
LABEL_27:
  v10 = Entity[12];
  if ( v10 != 3 )
  {
    if ( a1[43] == 12 )
    {
      if ( v10 == 2 )
      {
        sub_41F152((int (__cdecl *)(int, char *, char))0x1D, a1, "Attribute references external entity '%s'\n", v4);
        goto LABEL_38;
      }
      v11 = (_BYTE *)Entity[10];
      if ( v11 && v10 != 6 && xmlStrchr(v11, 60) )
      {
        sub_41F152(
          (int (__cdecl *)(int, char *, char))0x26,
          a1,
          "'<' in entity '%s' is not allowed in attributes values\n",
          v4);
        goto LABEL_38;
      }
    }
    if ( (unsigned int)(v10 - 4) <= 1 )
      sub_41F152((int (__cdecl *)(int, char *, char))0x1E, a1, "Attempt to reference the parameter entity '%s'\n", v4);
    goto LABEL_38;
  }
  sub_41F152((int (__cdecl *)(int, char *, char))0x1C, a1, "Entity reference to unparsed entity %s\n", v4);
LABEL_38:
  ((void (__cdecl *)(char *))xmlFree)(v4);
  *a2 = v12;
  return Entity;
}
// 496494: invalid function type has been ignored
// 427B64: conditional instruction was optimized away because eax.4==C
// 427B8A: variable 'v10' is possibly undefined

//----- (00427BBA) --------------------------------------------------------
void __cdecl xmlParsePEReference(int *a1)
{
  unsigned __int8 *v1; // esi
  int v2; // eax
  int (__cdecl *v3)(int, unsigned __int8 *); // eax
  int v4; // eax
  int v5; // ebx
  int v6; // eax
  const char **v7; // eax
  const char **v8; // eax
  _BYTE *v9; // eax
  unsigned __int8 v10; // al

  if ( **(_BYTE **)(a1[9] + 16) == 37 )
  {
    xmlNextChar(a1);
    v1 = xmlParseName((int)a1);
    if ( !v1 )
    {
      sub_41EFC6((int (__cdecl *)(int, char *, char))0x44, a1, "xmlParsePEReference: no name\n");
      return;
    }
    if ( **(_BYTE **)(a1[9] + 16) != 59 )
    {
      sub_41EC3F(23, a1, 0);
      return;
    }
    xmlNextChar(a1);
    v2 = *a1;
    ++a1[110];
    if ( !v2 || (v3 = *(int (__cdecl **)(int, unsigned __int8 *))(v2 + 96)) == 0 || (v4 = v3(a1[1], v1), (v5 = v4) == 0) )
    {
      if ( a1[7] != 1 && (a1[22] || a1[23]) )
      {
        sub_41F01E((int)a1, v1, 27, "PEReference: %%%s; not found\n");
        a1[25] = 0;
      }
      else
      {
        sub_41F152((int (__cdecl *)(int, char *, char))0x1A, a1, "PEReference: %%%s; not found\n", v1);
      }
      goto LABEL_13;
    }
    v6 = *(_DWORD *)(v4 + 48);
    if ( v6 != 4 && v6 != 5 )
    {
      sub_41F01E((int)a1, v1, 27, "Internal: %%%s; is not a parameter entity\n");
LABEL_13:
      a1[23] = 1;
      return;
    }
    if ( *(void (__cdecl **)(void *))(a1[9] + 40) == j_xmlFree )
    {
      v8 = (const char **)xmlNewEntityInputStream(a1, v5);
      if ( xmlPushInput(a1, v8) >= 0 )
      {
        if ( *(_DWORD *)(v5 + 48) == 5 )
        {
          v9 = *(_BYTE **)(a1[9] + 16);
          if ( *v9 == 60 && v9[1] == 63 && v9[2] == 120 && v9[3] == 109 && v9[4] == 108 )
          {
            if ( (v10 = v9[5], v10 == 32) || v10 >= 9u && v10 <= 0xAu || v10 == 13 )
            {
              xmlParseTextDecl(a1);
              if ( a1[21] == 32 )
              {
                a1[43] = -1;
                return;
              }
            }
          }
        }
        goto LABEL_13;
      }
    }
    else
    {
      v7 = (const char **)sub_4205B0(a1, v5);
      if ( xmlPushInput(a1, v7) >= 0 )
        goto LABEL_13;
    }
  }
}

//----- (00427D3D) --------------------------------------------------------
int __usercall sub_427D3D@<eax>(int *a1@<eax>, int a2)
{
  int v3; // edi
  int v4; // eax
  _DWORD *v5; // esi
  const char **v6; // eax
  int v7; // eax
  int v8; // edi
  int v9; // eax
  int v10; // eax
  int v11; // ecx
  int *v12; // eax
  int v14; // [esp+Ch] [ebp-10h] BYREF
  void *Block; // [esp+10h] [ebp-Ch]
  const char **v16; // [esp+14h] [ebp-8h]
  int v17; // [esp+18h] [ebp-4h]

  v17 = 0;
  if ( !a1 )
    goto LABEL_54;
  v3 = a2;
  if ( !a2 )
    goto LABEL_54;
  v4 = *(_DWORD *)(a2 + 48);
  if ( v4 != 5 && v4 != 2 )
    goto LABEL_54;
  if ( *(_DWORD *)(a2 + 40) )
    goto LABEL_54;
  if ( xmlParserDebugEntities )
    xmlGenericError(xmlGenericErrorContext, "Reading %s entity content input\n", *(const char **)(a2 + 8));
  v5 = xmlBufferCreate();
  Block = v5;
  if ( !v5 )
  {
LABEL_54:
    sub_41EC3F(1, a1, "xmlLoadEntityContent parameter error");
    return -1;
  }
  v6 = (const char **)xmlNewEntityInputStream(a1, a2);
  v16 = v6;
  if ( v6 )
  {
    if ( xmlPushInput(a1, v6) < 0 )
    {
      xmlBufferFree(v5);
      return -1;
    }
    if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
      sub_41FF5D((int)a1);
    v7 = xmlCurrentChar(a1, &v14);
    while ( 1 )
    {
      v11 = a1[9];
      if ( (const char **)v11 != v16 || *(_DWORD *)(a1[9] + 16) >= *(_DWORD *)(a1[9] + 20) )
        break;
      if ( v7 >= 256 )
      {
        if ( v7 > 55295 && (v7 < 57344 || v7 > 65533) && (unsigned int)(v7 - 0x10000) > 0xFFFFF )
          break;
      }
      else if ( (v7 < 9 || v7 > 10) && v7 != 13 && v7 < 32 )
      {
        break;
      }
      v8 = v14;
      xmlBufferAdd((int *)Block, *(_BYTE **)(v11 + 16), v14);
      v9 = v17++;
      if ( v9 > 100 )
      {
        v17 = 0;
        if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
          sub_41FF5D((int)a1);
      }
      v10 = a1[9];
      if ( **(_BYTE **)(v10 + 16) == 10 )
      {
        ++*(_DWORD *)(v10 + 28);
        *(_DWORD *)(a1[9] + 32) = 1;
      }
      else
      {
        ++*(_DWORD *)(v10 + 32);
      }
      *(_DWORD *)(a1[9] + 16) += v8;
      if ( **(_BYTE **)(a1[9] + 16) == 37 )
        xmlParserHandlePEReference(a1);
      v7 = xmlCurrentChar(a1, &v14);
      v3 = a2;
    }
    if ( (const char **)a1[9] == v16 && *(_DWORD *)(a1[9] + 16) >= *(_DWORD *)(a1[9] + 20) )
    {
      xmlPopInput(a1);
LABEL_42:
      v12 = (int *)Block;
      *(_DWORD *)(v3 + 40) = *(_DWORD *)Block;
      *v12 = 0;
      xmlBufferFree(v12);
      return 0;
    }
    if ( v7 >= 256 )
    {
      if ( v7 <= 55295 || v7 >= 57344 && v7 <= 65533 || (unsigned int)(v7 - 0x10000) <= 0xFFFFF )
        goto LABEL_42;
    }
    else if ( v7 >= 9 && v7 <= 10 || v7 == 13 || v7 >= 32 )
    {
      goto LABEL_42;
    }
    sub_41F093((int (__cdecl *)(int, char *, char))9, a1, "xmlLoadEntityContent: invalid char value %d\n", v7);
    xmlBufferFree((int *)Block);
    return -1;
  }
  sub_41EC3F(1, a1, "xmlLoadEntityContent input error");
  xmlBufferFree(v5);
  return -1;
}
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);
// 4A9C7C: using guessed type int xmlParserDebugEntities;

//----- (00427FAB) --------------------------------------------------------
int __usercall sub_427FAB@<eax>(int *a1@<eax>, _BYTE **a2)
{
  _DWORD *v2; // esi
  _BYTE *v4; // eax
  _BYTE *v5; // ebx
  int v7; // eax
  int (__cdecl *v8)(int, _BYTE *); // eax
  int v9; // eax
  int v10; // eax
  int v11; // [esp+10h] [ebp-8h]
  unsigned __int8 *v12; // [esp+14h] [ebp-4h] BYREF

  v11 = 0;
  v2 = a2;
  if ( !a2 )
    return 0;
  v4 = *a2;
  if ( !*a2 || *v4 != 37 )
    return 0;
  v12 = v4 + 1;
  v5 = sub_421F46(&v12);
  if ( !v5 )
  {
    sub_41EFC6((int (__cdecl *)(int, char *, char))0x44, a1, "xmlParseStringPEReference: no name\n");
LABEL_6:
    *a2 = v12;
    return 0;
  }
  if ( *v12 != 59 )
  {
    sub_41EC3F(23, a1, 0);
    ((void (__cdecl *)(_BYTE *))xmlFree)(v5);
    goto LABEL_6;
  }
  ++v12;
  v7 = *a1;
  ++a1[110];
  if ( v7 )
  {
    v8 = *(int (__cdecl **)(int, _BYTE *))(v7 + 96);
    if ( v8 )
    {
      v9 = v8(a1[1], v5);
      v11 = v9;
      if ( v9 )
      {
        v10 = *(_DWORD *)(v9 + 48);
        if ( v10 == 4 || v10 == 5 )
          goto LABEL_22;
        sub_41F01E((int)a1, v5, 27, "%%%s; is not a parameter entity\n");
        goto LABEL_21;
      }
    }
  }
  if ( a1[7] != 1 && (a1[22] || a1[23]) )
  {
    sub_41F01E((int)a1, v5, 27, "PEReference: %%%s; not found\n");
    a1[25] = 0;
LABEL_21:
    v2 = a2;
    goto LABEL_22;
  }
  sub_41F152((int (__cdecl *)(int, char *, char))0x1A, a1, "PEReference: %%%s; not found\n", v5);
LABEL_22:
  a1[23] = 1;
  ((void (__cdecl *)(_BYTE *))xmlFree)(v5);
  *v2 = v12;
  return v11;
}
// 496494: invalid function type has been ignored

//----- (004280BA) --------------------------------------------------------
void __cdecl xmlParseDocTypeDecl(int *a1)
{
  int v2; // eax
  unsigned __int8 *v3; // esi
  void *v4; // eax
  int v5; // ebx
  void *v6; // esi
  void (__cdecl **v7)(int, unsigned __int8 *, int, void *); // eax
  char v8; // al
  int v9; // [esp+Ch] [ebp-4h] BYREF
  unsigned __int8 *v10; // [esp+18h] [ebp+8h]

  v9 = 0;
  a1[50] += 9;
  *(_DWORD *)(a1[9] + 16) += 9;
  *(_DWORD *)(a1[9] + 32) += 9;
  if ( **(_BYTE **)(a1[9] + 16) == 37 )
    xmlParserHandlePEReference(a1);
  v2 = a1[9];
  if ( !**(_BYTE **)(v2 + 16) && xmlParserInputGrow((int *)v2, 250) <= 0 )
    xmlPopInput(a1);
  xmlSkipBlankChars((int)a1);
  v3 = xmlParseName((int)a1);
  v10 = v3;
  if ( !v3 )
    sub_41EFC6((int (__cdecl *)(int, char *, char))0x44, a1, "xmlParseDocTypeDecl : no DOCTYPE name !\n");
  a1[55] = (int)v3;
  xmlSkipBlankChars((int)a1);
  v4 = xmlParseExternalID(a1, &v9, 1);
  v5 = v9;
  v6 = v4;
  if ( v4 || v9 )
    a1[22] = 1;
  a1[56] = (int)v4;
  a1[57] = v5;
  xmlSkipBlankChars((int)a1);
  v7 = (void (__cdecl **)(int, unsigned __int8 *, int, void *))*a1;
  if ( *a1 && *v7 && !a1[53] )
    (*v7)(a1[1], v10, v5, v6);
  v8 = **(_BYTE **)(a1[9] + 16);
  if ( v8 != 91 )
  {
    if ( v8 != 62 )
      sub_41EC3F(61, a1, 0);
    xmlNextChar(a1);
  }
}

//----- (004281C3) --------------------------------------------------------
void __usercall sub_4281C3(int *a1@<eax>)
{
  int v2; // eax
  _BYTE *v3; // ecx
  int v4; // esi
  _BYTE *v5; // edi

  if ( **(_BYTE **)(a1[9] + 16) == 91 )
  {
    a1[43] = 3;
    xmlNextChar(a1);
    v2 = a1[9];
    v3 = *(_BYTE **)(v2 + 16);
    if ( *v3 != 93 )
    {
      while ( 1 )
      {
        v4 = *(_DWORD *)(v2 + 36);
        v5 = v3;
        xmlSkipBlankChars((int)a1);
        xmlParseMarkupDecl(a1);
        xmlParsePEReference(a1);
        while ( !**(_BYTE **)(a1[9] + 16) && a1[10] > 1 )
          xmlPopInput(a1);
        v2 = a1[9];
        v3 = *(_BYTE **)(v2 + 16);
        if ( v3 == v5 && v4 == *(_DWORD *)(v2 + 36) )
          break;
        if ( **(_BYTE **)(v2 + 16) == 93 )
          goto LABEL_12;
      }
      sub_41EC3F(1, a1, "xmlParseInternalSubset: error detected in Markup declaration\n");
    }
LABEL_12:
    if ( **(_BYTE **)(a1[9] + 16) == 93 )
    {
      xmlNextChar(a1);
      xmlSkipBlankChars((int)a1);
    }
  }
  if ( **(_BYTE **)(a1[9] + 16) != 62 )
    sub_41EC3F(61, a1, 0);
  xmlNextChar(a1);
}

//----- (0042828A) --------------------------------------------------------
unsigned __int8 *__cdecl xmlParseAttribute(int a1, unsigned __int8 **a2)
{
  char *v3; // eax
  bool v4; // zf
  unsigned __int8 *v5; // esi
  unsigned __int8 *v7; // [esp+10h] [ebp+8h]

  *a2 = 0;
  if ( !*(_DWORD *)(a1 + 292) && *(_DWORD *)(*(_DWORD *)(a1 + 36) + 20) - *(_DWORD *)(*(_DWORD *)(a1 + 36) + 16) < 250 )
    sub_41FF5D(a1);
  v7 = xmlParseName(a1);
  if ( !v7 )
  {
    sub_41EFC6((int (__cdecl *)(int, char *, char))0x44, (int *)a1, "error parsing attribute name\n");
    return 0;
  }
  xmlSkipBlankChars(a1);
  if ( **(_BYTE **)(*(_DWORD *)(a1 + 36) + 16) != 61 )
  {
    sub_41F152(
      (int (__cdecl *)(int, char *, char))0x29,
      (int *)a1,
      "Specification mandate value for attribute %s\n",
      v7);
    return 0;
  }
  xmlNextChar((int *)a1);
  xmlSkipBlankChars(a1);
  v3 = xmlParseAttValue((int *)a1);
  v4 = *(_DWORD *)(a1 + 268) == 0;
  v5 = (unsigned __int8 *)v3;
  *(_DWORD *)(a1 + 172) = 7;
  if ( !v4 && xmlStrEqual((char *)v7, "xml:lang") && !xmlCheckLanguageID(v5) )
    sub_41F01E(a1, v5, 98, "Malformed value for xml:lang : %s\n");
  if ( xmlStrEqual((char *)v7, "xml:space") )
  {
    if ( xmlStrEqual((char *)v5, "default") )
    {
      **(_DWORD **)(a1 + 232) = 0;
    }
    else if ( xmlStrEqual((char *)v5, "preserve") )
    {
      **(_DWORD **)(a1 + 232) = 1;
    }
    else
    {
      sub_41F01E(a1, v5, 102, "Invalid value \"%s\" for xml:space : \"default\" or \"preserve\" expected\n");
    }
  }
  *a2 = v5;
  return v7;
}

//----- (004283C7) --------------------------------------------------------
unsigned __int8 *__cdecl xmlParseStartTag(int *Block)
{
  int *v1; // esi
  char *v2; // ebx
  int v3; // eax
  int v4; // edi
  int v6; // eax
  int v7; // eax
  unsigned __int8 *v8; // ecx
  unsigned __int8 v9; // dl
  int v10; // edi
  int v11; // eax
  int v12; // eax
  int v13; // eax
  char *v14; // eax
  unsigned __int8 *v15; // eax
  unsigned __int8 v16; // cl
  _DWORD *v17; // eax
  void (__cdecl *v18)(int, unsigned __int8 *, char *); // eax
  int i; // esi
  SIZE_T v20; // [esp-4h] [ebp-2Ch]
  int v21; // [esp+Ch] [ebp-1Ch]
  int v22; // [esp+10h] [ebp-18h]
  unsigned __int8 *v23; // [esp+14h] [ebp-14h]
  unsigned __int8 *v24; // [esp+18h] [ebp-10h]
  int v25; // [esp+1Ch] [ebp-Ch]
  int v26; // [esp+20h] [ebp-8h]
  int v27; // [esp+24h] [ebp-4h]

  v1 = Block;
  v2 = (char *)Block[75];
  v25 = Block[76];
  v3 = Block[9];
  v4 = 0;
  v27 = 0;
  if ( **(_BYTE **)(v3 + 16) != 60 )
    return 0;
  ++*(_DWORD *)(v3 + 32);
  ++*(_DWORD *)(v1[9] + 16);
  ++v1[50];
  v6 = v1[9];
  if ( !**(_BYTE **)(v6 + 16) )
    xmlParserInputGrow((int *)v6, 250);
  v23 = xmlParseName((int)v1);
  if ( !v23 )
  {
    sub_41EFC6((int (__cdecl *)(int, char *, char))0x44, v1, "xmlParseStartTag: invalid element name\n");
    return 0;
  }
  xmlSkipBlankChars((int)v1);
  if ( !v1[73] && *(_DWORD *)(v1[9] + 20) - *(_DWORD *)(v1[9] + 16) < 250 )
    sub_41FF5D((int)v1);
  if ( **(_BYTE **)(v1[9] + 16) != 62 )
  {
    v26 = 4;
    do
    {
      v7 = v1[9];
      v8 = *(unsigned __int8 **)(v7 + 16);
      v9 = *v8;
      if ( *v8 == 47 && v8[1] == 62 || (v9 < 9u || v9 > 0xAu) && v9 != 13 && v9 < 0x20u )
        break;
      v22 = *(_DWORD *)(v7 + 36);
      v21 = *(_DWORD *)(v7 + 16);
      v24 = xmlParseAttribute((int)v1, (unsigned __int8 **)&Block);
      if ( v24 )
      {
        if ( Block )
        {
          if ( v27 <= 0 )
          {
LABEL_23:
            if ( v2 )
            {
              if ( v26 <= v25 )
                goto LABEL_32;
              v10 = 2 * v25;
              v20 = 8 * v25;
              v25 *= 2;
              v12 = xmlRealloc(v2, v20);
              if ( v12 )
              {
                v2 = (char *)v12;
                v1[75] = v12;
                goto LABEL_31;
              }
            }
            else
            {
              v10 = 22;
              v25 = 22;
              v11 = xmlMalloc(88);
              v2 = (char *)v11;
              if ( v11 )
              {
                v1[75] = v11;
LABEL_31:
                v1[76] = v10;
LABEL_32:
                *(_DWORD *)&v2[4 * v27] = v24;
                v13 = v27 + 1;
                *(_DWORD *)&v2[4 * v13] = Block;
                v26 += 2;
                v27 += 2;
                v14 = &v2[4 * v13 + 4];
                *(_DWORD *)v14 = 0;
                *((_DWORD *)v14 + 1) = 0;
                goto LABEL_35;
              }
            }
            xmlErrMemory((int)v1, 0);
            ((void (__cdecl *)(int *))xmlFree)(Block);
          }
          else
          {
            while ( !xmlStrEqual(*(char **)&v2[4 * v4], (char *)v24) )
            {
              v4 += 2;
              if ( v4 >= v27 )
                goto LABEL_23;
            }
            sub_41EBBA((int (__cdecl *)(int, char *, char))v24, v1, 0);
            ((void (__cdecl *)(int *))xmlFree)(Block);
          }
        }
      }
      else if ( Block )
      {
        ((void (__cdecl *)(int *))xmlFree)(Block);
      }
LABEL_35:
      if ( !v1[73] && *(_DWORD *)(v1[9] + 20) - *(_DWORD *)(v1[9] + 16) < 250 )
        sub_41FF5D((int)v1);
      v15 = *(unsigned __int8 **)(v1[9] + 16);
      v16 = *v15;
      if ( *v15 == 62 || v16 == 47 && v15[1] == 62 )
        break;
      if ( v16 != 32 && (v16 < 9u || v16 > 0xAu) && v16 != 13 )
        sub_41EFC6((int (__cdecl *)(int, char *, char))0x41, v1, "attributes construct error\n");
      xmlSkipBlankChars((int)v1);
      v17 = (_DWORD *)v1[9];
      if ( v22 == v17[9] && v21 == v17[4] && !v24 && !Block )
      {
        sub_41EFC6((int (__cdecl *)(int, char *, char))1, v1, "xmlParseStartTag: problem parsing attributes\n");
        break;
      }
      v4 = 0;
      if ( !v1[73] )
      {
        if ( v17[4] - v17[3] > 500 && v17[5] - v17[4] < 500 )
          sub_41FF30(v1);
        v4 = 0;
        if ( !v1[73] && *(_DWORD *)(v1[9] + 20) - *(_DWORD *)(v1[9] + 16) < 250 )
          sub_41FF5D((int)v1);
      }
    }
    while ( **(_BYTE **)(v1[9] + 16) != 62 );
  }
  if ( *v1 )
  {
    v18 = *(void (__cdecl **)(int, unsigned __int8 *, char *))(*v1 + 56);
    if ( v18 )
    {
      if ( !v1[53] )
      {
        if ( v27 <= 0 )
          v18(v1[1], v23, 0);
        else
          v18(v1[1], v23, v2);
      }
    }
  }
  if ( v2 )
  {
    for ( i = 1; i < v27; i += 2 )
    {
      if ( *(_DWORD *)&v2[4 * i] )
        ((void (__cdecl *)(_DWORD))xmlFree)(*(_DWORD *)&v2[4 * i]);
    }
  }
  return v23;
}
// 496494: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);

//----- (004286F2) --------------------------------------------------------
int (__cdecl *__usercall sub_4286F2@<eax>(int a1@<eax>, int a2))(int, char *Format, char ArgList)
{
  int v3; // eax
  _BYTE *v4; // ecx
  int v5; // eax
  unsigned __int8 *v6; // edi
  int v7; // eax
  unsigned __int8 v8; // cl
  int v9; // eax
  void (__cdecl *v10)(_DWORD, _DWORD); // eax
  int v12; // [esp-4h] [ebp-10h]

  if ( !*(_DWORD *)(a1 + 292) && *(_DWORD *)(*(_DWORD *)(a1 + 36) + 20) - *(_DWORD *)(*(_DWORD *)(a1 + 36) + 16) < 250 )
    sub_41FF5D(a1);
  v3 = *(_DWORD *)(a1 + 36);
  v4 = *(_BYTE **)(v3 + 16);
  if ( *v4 != 60 || v4[1] != 47 )
    return sub_41EFC6((int (__cdecl *)(int, char *, char))0x4A, (int *)a1, "xmlParseEndTag: '</' not found\n");
  *(_DWORD *)(a1 + 200) += 2;
  *(_DWORD *)(v3 + 16) += 2;
  *(_DWORD *)(*(_DWORD *)(a1 + 36) + 32) += 2;
  if ( **(_BYTE **)(*(_DWORD *)(a1 + 36) + 16) == 37 )
    xmlParserHandlePEReference((int *)a1);
  v5 = *(_DWORD *)(a1 + 36);
  if ( !**(_BYTE **)(v5 + 16) && xmlParserInputGrow((int *)v5, 250) <= 0 )
    xmlPopInput((_DWORD *)a1);
  v6 = sub_421ECF(a1, *(unsigned __int8 **)(a1 + 184));
  if ( !*(_DWORD *)(a1 + 292) && *(_DWORD *)(*(_DWORD *)(a1 + 36) + 20) - *(_DWORD *)(*(_DWORD *)(a1 + 36) + 16) < 250 )
    sub_41FF5D(a1);
  xmlSkipBlankChars(a1);
  v7 = *(_DWORD *)(a1 + 36);
  v8 = **(_BYTE **)(v7 + 16);
  if ( (v8 >= 9u && v8 <= 0xAu || v8 == 13 || v8 >= 0x20u) && v8 == 62 )
  {
    ++*(_DWORD *)(v7 + 32);
    ++*(_DWORD *)(*(_DWORD *)(a1 + 36) + 16);
    ++*(_DWORD *)(a1 + 200);
    v9 = *(_DWORD *)(a1 + 36);
    if ( !**(_BYTE **)(v9 + 16) )
      xmlParserInputGrow((int *)v9, 250);
  }
  else
  {
    sub_41EC3F(73, (int *)a1, 0);
  }
  if ( v6 != (unsigned __int8 *)1 )
  {
    if ( !v6 )
      v6 = "unparseable";
    sub_41F0ED(
      (int (__cdecl *)(int, char *, char))0x4C,
      (int *)a1,
      "Opening and ending tag mismatch: %s line %d and %s\n",
      *(_BYTE **)(a1 + 184),
      a2,
      v6);
  }
  if ( *(_DWORD *)a1 )
  {
    v10 = *(void (__cdecl **)(_DWORD, _DWORD))(*(_DWORD *)a1 + 60);
    if ( v10 )
    {
      if ( !*(_DWORD *)(a1 + 212) )
        v10(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 184));
    }
  }
  namePop((_DWORD *)a1);
  return (int (__cdecl *)(int, char *, char))sub_41FEF7(v12, (_DWORD *)a1);
}
// 428851: variable 'v12' is possibly undefined

//----- (0042886A) --------------------------------------------------------
int (__cdecl *__cdecl xmlParseEndTag(int a1))(int, char *Format, char ArgList)
{
  return sub_4286F2(a1, 0);
}

//----- (00428877) --------------------------------------------------------
int __usercall sub_428877@<eax>(_DWORD *a1@<ecx>, int a2@<esi>)
{
  int v3; // eax
  int v4; // ecx
  _DWORD *i; // edx

  if ( a2 == a1[78] )
    return a1[80];
  v3 = a1[82] - 2;
  if ( v3 < 0 )
    return 0;
  v4 = a1[84];
  for ( i = (_DWORD *)(v4 + 4 * v3); *i != a2; i -= 2 )
  {
    v3 -= 2;
    if ( v3 < 0 )
      return 0;
  }
  if ( a2 || **(_BYTE **)(v4 + 4 * v3 + 4) )
    return *(_DWORD *)(v4 + 4 * v3 + 4);
  else
    return 0;
}

//----- (004288BC) --------------------------------------------------------
unsigned __int8 *__usercall sub_4288BC@<eax>(int a1@<eax>, unsigned __int8 **a2)
{
  unsigned __int8 *v3; // edi
  _BYTE *v4; // eax
  unsigned __int8 *v5; // eax
  unsigned __int8 *result; // eax
  unsigned __int8 *v7; // eax
  const char *v8; // eax
  char *v9; // edi
  unsigned __int8 *v10; // esi
  unsigned __int8 *v11; // eax
  char *v12; // eax
  char *v13; // edi
  unsigned __int8 *v14; // esi
  unsigned __int8 *Src; // [esp+Ch] [ebp-8h]
  unsigned __int8 *Block; // [esp+10h] [ebp-4h]
  const char *Blocka; // [esp+10h] [ebp-4h]
  const char *Blockb; // [esp+10h] [ebp-4h]

  if ( !*(_DWORD *)(a1 + 292) && *(_DWORD *)(*(_DWORD *)(a1 + 36) + 20) - *(_DWORD *)(*(_DWORD *)(a1 + 36) + 16) < 250 )
    sub_41FF5D(a1);
  v3 = sub_421E2A(a1);
  v4 = *(_BYTE **)(*(_DWORD *)(a1 + 36) + 16);
  if ( v3 )
  {
    if ( *v4 == 58 )
    {
      xmlNextChar((int *)a1);
      Src = v3;
      v7 = sub_421E2A(a1);
      Blocka = (const char *)v7;
      if ( !v7 )
      {
        sub_41F1EB((int (__cdecl *)(int, char *, char))0xCA, (int *)a1, "Failed to parse QName '%s:'\n", v3, 0, 0);
        v8 = xmlParseNmtoken((int *)a1);
        Blockb = v8;
        if ( v8 )
        {
          v9 = (char *)xmlBuildQName(v8, (const char *)v3, 0, 0);
          ((void (__cdecl *)(const char *))xmlFree)(Blockb);
        }
        else
        {
          v9 = (char *)xmlBuildQName(byte_47627C, (const char *)v3, 0, 0);
        }
        v10 = xmlDictLookup(*(_DWORD **)(a1 + 296), v9, -1);
        if ( v9 )
          ((void (__cdecl *)(char *))xmlFree)(v9);
        result = v10;
        goto LABEL_8;
      }
      if ( **(_BYTE **)(*(_DWORD *)(a1 + 36) + 16) == 58 )
      {
        sub_41F1EB((int (__cdecl *)(int, char *, char))0xCA, (int *)a1, "Failed to parse QName '%s:%s:'\n", v3, v7, 0);
        xmlNextChar((int *)a1);
        v11 = xmlParseName(a1);
        if ( v11 )
          v12 = (char *)xmlBuildQName((const char *)v11, Blocka, 0, 0);
        else
          v12 = (char *)xmlBuildQName(byte_47627C, Blocka, 0, 0);
        v13 = v12;
        v14 = xmlDictLookup(*(_DWORD **)(a1 + 296), v12, -1);
        if ( v13 )
          ((void (__cdecl *)(char *))xmlFree)(v13);
        *a2 = Src;
        return v14;
      }
      *a2 = v3;
      return v7;
    }
    else
    {
      *a2 = 0;
    }
    return v3;
  }
  if ( *v4 == 58 )
  {
    v5 = xmlParseName(a1);
    Block = v5;
    if ( v5 )
    {
      sub_41F1EB((int (__cdecl *)(int, char *, char))0xCA, (int *)a1, "Failed to parse QName '%s'\n", v5, 0, 0);
      result = Block;
LABEL_8:
      *a2 = 0;
      return result;
    }
  }
  return 0;
}
// 496494: invalid function type has been ignored

//----- (00428A4F) --------------------------------------------------------
unsigned __int8 *__usercall sub_428A4F@<eax>(int a1@<eax>, unsigned __int8 *a2, unsigned __int8 *a3)
{
  unsigned __int8 *result; // eax
  unsigned __int8 *v5; // edx
  int v6; // edi
  _BYTE *i; // eax
  unsigned __int8 *v8; // edx
  unsigned __int8 *j; // eax
  unsigned __int8 v10; // cl
  unsigned __int8 *v11; // [esp+4h] [ebp-4h] BYREF

  if ( !a3 )
    return sub_421ECF(a1, a2);
  if ( !*(_DWORD *)(a1 + 292) && *(_DWORD *)(*(_DWORD *)(a1 + 36) + 20) - *(_DWORD *)(*(_DWORD *)(a1 + 36) + 16) < 250 )
    sub_41FF5D(a1);
  v5 = a3;
  v6 = *(_DWORD *)(a1 + 36);
  for ( i = *(_BYTE **)(v6 + 16); *i && *i == *v5; ++i )
    ++v5;
  if ( !*v5 && *i == 58 )
  {
    v8 = a2;
    for ( j = i + 1; *j && *j == *v8; ++j )
      ++v8;
    if ( !*v8 )
    {
      if ( (v10 = *j, *j == 62) || v10 == 32 || v10 >= 9u && v10 <= 0xAu || v10 == 13 )
      {
        *(_DWORD *)(v6 + 16) = j;
        return (unsigned __int8 *)1;
      }
    }
  }
  result = sub_4288BC(a1, &v11);
  if ( result == a2 && a3 == v11 )
    return (unsigned __int8 *)1;
  return result;
}

//----- (00428B02) --------------------------------------------------------
char *__usercall sub_428B02@<eax>(int *a1@<eax>, signed int *a2, _DWORD *a3, int a4)
{
  _DWORD *v5; // eax
  char *v6; // edi
  char *result; // eax
  unsigned int v8; // esi
  char *v9; // edi
  unsigned int v10; // ecx
  int v11; // ecx
  char v12; // cl
  int v13; // ecx
  char v14; // al
  _DWORD *v15; // eax
  int v16; // ecx
  int v17; // eax
  int v18; // eax
  char *v19; // esi
  char *i; // eax
  char v21; // al
  _DWORD *v22; // eax
  int v23; // ecx
  int v24; // eax
  int v25; // eax
  char v26; // cl
  int v27; // ecx
  int v28; // ecx
  _BYTE *v29; // edi
  int v30; // [esp+Ch] [ebp-10h]
  int v31; // [esp+Ch] [ebp-10h]
  unsigned int v32; // [esp+10h] [ebp-Ch]
  int v33; // [esp+10h] [ebp-Ch]
  int v34; // [esp+10h] [ebp-Ch]
  int v35; // [esp+10h] [ebp-Ch]
  char *v36; // [esp+10h] [ebp-Ch]
  char *Src; // [esp+14h] [ebp-8h]
  char v38; // [esp+1Bh] [ebp-1h]

  if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
    sub_41FF5D((int)a1);
  v5 = (_DWORD *)a1[9];
  v6 = (char *)v5[4];
  if ( *v6 != 34 && *v6 != 39 )
  {
    sub_41EC3F(39, a1, 0);
    return 0;
  }
  a1[43] = 12;
  v8 = v5[5];
  v38 = *v6;
  v9 = v6 + 1;
  v10 = v8;
  v32 = v8;
  Src = v9;
  if ( (unsigned int)v9 >= v8 )
  {
    v33 = v5[3];
    if ( !a1[73] && (int)(v8 - v5[4]) < 250 )
      sub_41FF5D((int)a1);
    v5 = (_DWORD *)a1[9];
    v11 = v5[3];
    if ( v33 != v11 )
    {
      v9 += v11 - v33;
      Src = v9;
    }
    v8 = v5[5];
    v10 = v8;
    v32 = v8;
  }
  if ( a4 )
  {
    if ( (unsigned int)v9 < v10 )
    {
      while ( 1 )
      {
        v12 = *v9;
        if ( *v9 == v38 || v12 != 32 && v12 != 9 && v12 != 10 && v12 != 13 )
          break;
        Src = ++v9;
        if ( (unsigned int)v9 >= v32 )
        {
          v34 = v5[3];
          if ( !a1[73] && (int)(v8 - v5[4]) < 250 )
            sub_41FF5D((int)a1);
          v5 = (_DWORD *)a1[9];
          v13 = v5[3];
          if ( v34 != v13 )
          {
            v9 += v13 - v34;
            Src = v9;
          }
          v8 = v5[5];
          v10 = v8;
          v32 = v8;
          if ( (unsigned int)v9 >= v8 )
            goto LABEL_43;
        }
      }
      v10 = v32;
LABEL_43:
      if ( (unsigned int)v9 < v10 )
      {
        while ( 1 )
        {
          v14 = *v9;
          if ( *v9 == v38 )
            break;
          if ( v14 < 32 )
            break;
          if ( v14 == 38 )
            break;
          if ( v14 == 60 )
            break;
          ++v9;
          if ( v14 == 32 && *v9 == 32 )
            break;
          if ( (unsigned int)v9 >= v10 )
          {
            v15 = (_DWORD *)a1[9];
            v35 = v15[3];
            if ( !a1[73] && v15[5] - v15[4] < 250 )
              sub_41FF5D((int)a1);
            v16 = a1[9];
            v17 = *(_DWORD *)(v16 + 12);
            if ( v35 != v17 )
            {
              v18 = v17 - v35;
              Src += v18;
              v9 += v18;
            }
            v10 = *(_DWORD *)(v16 + 20);
            goto LABEL_43;
          }
        }
      }
    }
    v19 = v9;
    v36 = v9;
    for ( i = v9 - 1; *i == 32 && v19 > Src; --i )
    {
      v36 = i;
      v19 = i;
    }
LABEL_61:
    if ( (unsigned int)v9 < v10 )
    {
      while ( 1 )
      {
        v21 = *v9;
        if ( *v9 == v38 )
          goto LABEL_81;
        if ( v21 != 32 && v21 != 9 && v21 != 10 && v21 != 13 )
          break;
        if ( (unsigned int)++v9 >= v10 )
        {
          v22 = (_DWORD *)a1[9];
          v30 = v22[3];
          if ( !a1[73] && v22[5] - v22[4] < 250 )
          {
            sub_41FF5D((int)a1);
            v19 = v36;
          }
          v23 = a1[9];
          v24 = *(_DWORD *)(v23 + 12);
          if ( v30 != v24 )
          {
            v25 = v24 - v30;
            Src += v25;
            v9 += v25;
            v19 += v25;
            v36 = v19;
          }
          v10 = *(_DWORD *)(v23 + 20);
          goto LABEL_61;
        }
      }
    }
    if ( *v9 == v38 )
    {
LABEL_81:
      v29 = v9 + 1;
      if ( a2 )
      {
        *a2 = v19 - Src;
        result = Src;
      }
      else
      {
        if ( a3 )
          *a3 = 1;
        result = xmlStrndup(Src, v19 - Src);
      }
      *(_DWORD *)(a1[9] + 16) = v29;
      if ( a3 )
        *a3 = 0;
      return result;
    }
  }
  else
  {
    if ( (unsigned int)v9 < v10 )
    {
      while ( 1 )
      {
        v26 = *v9;
        if ( *v9 == v38 || v26 < 32 || v26 == 38 || v26 == 60 )
          break;
        if ( (unsigned int)++v9 >= v32 )
        {
          v31 = v5[3];
          if ( !a1[73] && (int)(v8 - v5[4]) < 250 )
            sub_41FF5D((int)a1);
          v5 = (_DWORD *)a1[9];
          v27 = v5[3];
          if ( v31 != v27 )
          {
            v28 = v27 - v31;
            Src += v28;
            v9 += v28;
          }
          v8 = v5[5];
          v32 = v8;
          if ( (unsigned int)v9 >= v8 )
            break;
        }
      }
    }
    if ( *v9 == v38 )
    {
      v19 = v9;
      goto LABEL_81;
    }
  }
  if ( a3 )
    *a3 = 1;
  return sub_422666(a1, a2, a4);
}

//----- (00428DF1) --------------------------------------------------------
char *__usercall sub_428DF1@<eax>(
        int a1@<eax>,
        char *a2,
        unsigned __int8 *a3,
        unsigned __int8 **a4,
        char **a5,
        signed int *a6,
        _DWORD *a7)
{
  unsigned __int8 *v8; // ebx
  _DWORD *v9; // eax
  char *v10; // ebx
  const char *v11; // eax
  char *v12; // esi
  unsigned __int8 *v13; // eax
  unsigned __int8 *v14; // esi
  char *v16; // [esp+Ch] [ebp-Ch]
  int v17; // [esp+10h] [ebp-8h]
  unsigned __int8 *Block; // [esp+14h] [ebp-4h]

  Block = 0;
  v17 = 0;
  *a5 = 0;
  if ( !*(_DWORD *)(a1 + 292) && *(_DWORD *)(*(_DWORD *)(a1 + 36) + 20) - *(_DWORD *)(*(_DWORD *)(a1 + 36) + 16) < 250 )
    sub_41FF5D(a1);
  v8 = sub_4288BC(a1, a4);
  v16 = (char *)v8;
  if ( !v8 )
  {
    sub_41EFC6((int (__cdecl *)(int, char *, char))0x44, (int *)a1, "error parsing attribute name\n");
    return 0;
  }
  v9 = *(_DWORD **)(a1 + 352);
  if ( v9 && xmlHashQLookup2(v9, a2, a3, (char *)*a4, (char *)v8) )
    v17 = 1;
  xmlSkipBlankChars(a1);
  if ( **(_BYTE **)(*(_DWORD *)(a1 + 36) + 16) != 61 )
  {
    sub_41F152(
      (int (__cdecl *)(int, char *, char))0x29,
      (int *)a1,
      "Specification mandate value for attribute %s\n",
      v8);
    return 0;
  }
  xmlNextChar((int *)a1);
  xmlSkipBlankChars(a1);
  v10 = sub_428B02((int *)a1, a6, a7, v17);
  if ( v17 )
  {
    if ( *a7 )
    {
      v11 = sub_41F3F9(a6, v10, a1);
      v12 = (char *)v11;
      if ( v11 )
      {
        if ( v11 != v10 )
        {
          ((void (__cdecl *)(char *))xmlFree)(v10);
          v10 = v12;
        }
      }
    }
  }
  v13 = *a4;
  *(_DWORD *)(a1 + 172) = 7;
  if ( v13 == *(unsigned __int8 **)(a1 + 312) )
  {
    if ( *(_DWORD *)(a1 + 268) )
    {
      if ( xmlStrEqual(v16, "lang") )
      {
        Block = xmlStrndup(v10, *a6);
        if ( !xmlCheckLanguageID(Block) )
          sub_41F01E(a1, Block, 98, "Malformed value for xml:lang : %s\n");
      }
    }
    if ( xmlStrEqual(v16, "space") )
    {
      v14 = xmlStrndup(v10, *a6);
      Block = v14;
      if ( xmlStrEqual((char *)v14, "default") )
      {
        **(_DWORD **)(a1 + 232) = 0;
      }
      else if ( xmlStrEqual((char *)v14, "preserve") )
      {
        **(_DWORD **)(a1 + 232) = 1;
      }
      else
      {
        sub_41F01E(a1, v14, 102, "Invalid value \"%s\" for xml:space : \"default\" or \"preserve\" expected\n");
      }
    }
    if ( Block )
      ((void (__cdecl *)(unsigned __int8 *))xmlFree)(Block);
  }
  *a5 = v10;
  return v16;
}
// 496494: invalid function type has been ignored

//----- (00428FDD) --------------------------------------------------------
unsigned __int8 *__usercall sub_428FDD@<eax>(int a1@<eax>, char **a2, int *a3, _DWORD *a4)
{
  int v5; // eax
  int v7; // eax
  _DWORD *v8; // eax
  _DWORD *v9; // eax
  int v10; // esi
  int v11; // ecx
  int v12; // ebx
  int v13; // eax
  unsigned __int8 *v14; // ecx
  unsigned __int8 v15; // dl
  void *v16; // eax
  char *v17; // eax
  unsigned __int8 *v18; // eax
  unsigned __int8 *v19; // ebx
  _DWORD *v20; // eax
  _DWORD *v21; // esi
  int v22; // ecx
  _DWORD *v23; // eax
  unsigned __int8 *v24; // esi
  _DWORD *v25; // eax
  int v26; // ecx
  char **v27; // eax
  int v28; // eax
  int v29; // ecx
  bool v30; // zf
  int v31; // eax
  int v32; // esi
  int v33; // ebx
  char *v34; // edx
  char *v35; // edx
  int v36; // eax
  unsigned __int8 *v37; // eax
  unsigned __int8 v38; // cl
  _DWORD *v39; // eax
  int v40; // esi
  _DWORD *v41; // ebx
  _DWORD *v42; // eax
  _DWORD *v43; // eax
  bool v44; // cc
  int *v45; // ebx
  char *v46; // esi
  _BYTE *v47; // eax
  unsigned __int8 *v48; // edx
  int v49; // ecx
  _DWORD *v50; // eax
  int v51; // ebx
  int v52; // eax
  int v53; // ecx
  char **v54; // eax
  char *v55; // esi
  int v56; // eax
  int v57; // ecx
  int v58; // eax
  int v59; // eax
  int v60; // eax
  int v61; // eax
  int v62; // edx
  int v63; // edx
  int v64; // eax
  int v65; // ebx
  _BYTE *v66; // esi
  _BYTE *v67; // edx
  int (__cdecl *v68)(int, char *, char); // eax
  _DWORD *v69; // ecx
  int v70; // eax
  int v71; // esi
  void (__cdecl *v72)(_DWORD, unsigned __int8 *, char *, int, int, int, int, int, int); // ecx
  int v73; // eax
  int v74; // ebx
  _DWORD *v75; // esi
  int v76; // [esp+4h] [ebp-54h]
  int v77; // [esp+8h] [ebp-50h]
  unsigned __int8 *v78; // [esp+Ch] [ebp-4Ch]
  int v79; // [esp+10h] [ebp-48h]
  int v80; // [esp+14h] [ebp-44h]
  int v81; // [esp+18h] [ebp-40h]
  void *v82; // [esp+1Ch] [ebp-3Ch]
  _DWORD *v83; // [esp+1Ch] [ebp-3Ch]
  _DWORD *v84; // [esp+1Ch] [ebp-3Ch]
  int v85; // [esp+20h] [ebp-38h]
  int v86; // [esp+24h] [ebp-34h]
  int v87; // [esp+28h] [ebp-30h]
  int *i; // [esp+28h] [ebp-30h]
  int v89; // [esp+2Ch] [ebp-2Ch]
  unsigned __int8 *v90; // [esp+30h] [ebp-28h]
  char *v91; // [esp+34h] [ebp-24h] BYREF
  unsigned __int8 *v92; // [esp+38h] [ebp-20h] BYREF
  int v93; // [esp+3Ch] [ebp-1Ch] BYREF
  size_t Size; // [esp+40h] [ebp-18h] BYREF
  int v95; // [esp+44h] [ebp-14h]
  void *Block; // [esp+48h] [ebp-10h] BYREF
  int v97; // [esp+4Ch] [ebp-Ch]
  char *v98; // [esp+50h] [ebp-8h]
  int v99; // [esp+54h] [ebp-4h]

  v95 = *(_DWORD *)(a1 + 300);
  v86 = *(_DWORD *)(a1 + 304);
  v79 = *(_DWORD *)(a1 + 328);
  v5 = *(_DWORD *)(a1 + 36);
  if ( **(_BYTE **)(v5 + 16) != 60 )
    return 0;
  ++*(_DWORD *)(v5 + 32);
  ++*(_DWORD *)(*(_DWORD *)(a1 + 36) + 16);
  ++*(_DWORD *)(a1 + 200);
  v7 = *(_DWORD *)(a1 + 36);
  if ( !**(_BYTE **)(v7 + 16) )
    xmlParserInputGrow((int *)v7, 250);
  v85 = 0;
  while ( 1 )
  {
    if ( !*(_DWORD *)(a1 + 292) )
    {
      v8 = *(_DWORD **)(a1 + 36);
      if ( v8[4] - v8[3] > 500 && v8[5] - v8[4] < 500 )
        sub_41FF30((_DWORD *)a1);
    }
    v9 = *(_DWORD **)(a1 + 36);
    v10 = v9[3];
    v80 = v9[4] - v10;
    v11 = v9[7];
    v76 = v9[8];
    *(_DWORD *)(a1 + 328) = v79;
    v12 = 0;
    v87 = v10;
    v77 = v11;
    v97 = 0;
    v89 = 0;
    v99 = 0;
    v81 = 0;
    v90 = sub_4288BC(a1, (unsigned __int8 **)&v91);
    if ( !v90 )
    {
      sub_41EFC6((int (__cdecl *)(int, char *, char))0x44, (int *)a1, "StartTag: invalid element name\n");
      return 0;
    }
    *a4 = *(_DWORD *)(*(_DWORD *)(a1 + 36) + 16) - *(_DWORD *)(*(_DWORD *)(a1 + 36) + 12) - v80;
    xmlSkipBlankChars(a1);
    if ( !*(_DWORD *)(a1 + 292) && *(_DWORD *)(*(_DWORD *)(a1 + 36) + 20) - *(_DWORD *)(*(_DWORD *)(a1 + 36) + 16) < 250 )
      sub_41FF5D(a1);
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 36) + 12) == v10 )
      break;
LABEL_125:
    *(_DWORD *)(*(_DWORD *)(a1 + 36) + 16) = v80 + *(_DWORD *)(*(_DWORD *)(a1 + 36) + 12);
    *(_DWORD *)(*(_DWORD *)(a1 + 36) + 28) = v77;
    *(_DWORD *)(*(_DWORD *)(a1 + 36) + 32) = v76;
    if ( *(_DWORD *)(a1 + 12) != 1 )
      return 0;
  }
  while ( 1 )
  {
    while ( 1 )
    {
      v13 = *(_DWORD *)(a1 + 36);
      v14 = *(unsigned __int8 **)(v13 + 16);
      v15 = *v14;
      if ( *v14 == 62 || v15 == 47 && v14[1] == 62 || (v15 < 9u || v15 > 0xAu) && v15 != 13 && v15 < 0x20u )
        goto LABEL_130;
      v16 = *(void **)(v13 + 36);
      Size = -1;
      v82 = v16;
      v78 = v14;
      v93 = 0;
      v98 = sub_428DF1(a1, v91, v90, &v92, (char **)&Block, (signed int *)&Size, &v93);
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 36) + 12) != v87 )
      {
        if ( Block && v93 )
          ((void (__cdecl *)(void *))xmlFree)(Block);
        Block = 0;
LABEL_118:
        v40 = 0;
        if ( v81 && v89 > 0 )
        {
          v41 = (_DWORD *)(v95 + 12);
          do
          {
            if ( *(_DWORD *)(*(_DWORD *)(a1 + 340) + 4 * v40) && *v41 )
              ((void (__cdecl *)(_DWORD))xmlFree)(*v41);
            v41 += 5;
            ++v40;
          }
          while ( v40 < v89 );
        }
        goto LABEL_125;
      }
      if ( !v98 )
      {
        if ( !Block )
          goto LABEL_96;
        v30 = *((_BYTE *)Block + Size) == 0;
        goto LABEL_94;
      }
      if ( !Block )
        goto LABEL_96;
      if ( (Size & 0x80000000) != 0 )
        Size = xmlStrlen(Block);
      v17 = *(char **)(a1 + 316);
      if ( v98 != v17 || v92 )
        break;
      v18 = xmlDictLookup(*(_DWORD **)(a1 + 296), (char *)Block, Size);
      v19 = v18;
      if ( *v18 )
      {
        v20 = xmlParseURI(v18);
        v21 = v20;
        if ( v20 )
        {
          if ( !*v20 )
            sub_41F241("xmlns: URI %s is not absolute\n", v19, 0);
          xmlFreeURI(v21);
        }
        else
        {
          sub_41F1EB((int (__cdecl *)(int, char *, char))0x63, (int *)a1, "xmlns: '%s' is not a valid URI\n", v19, 0, 0);
        }
        if ( v19 == *(unsigned __int8 **)(a1 + 320) )
        {
          if ( v98 != *(char **)(a1 + 312) )
            sub_41F1EB(
              (int (__cdecl *)(int, char *, char))0xC8,
              (int *)a1,
              "xml namespace URI cannot be the default namespace\n",
              0,
              0,
              0);
          goto LABEL_49;
        }
        if ( Size == 29 && xmlStrEqual((char *)v19, "http://www.w3.org/2000/xmlns/") )
        {
          sub_41F1EB(
            (int (__cdecl *)(int, char *, char))0xC8,
            (int *)a1,
            "reuse of the xmlns namespace name is forbidden\n",
            0,
            0,
            0);
          goto LABEL_49;
        }
      }
      v22 = 1;
      if ( v99 < 1 )
        goto LABEL_47;
      v23 = (_DWORD *)(*(_DWORD *)(a1 + 336) + 4 * *(_DWORD *)(a1 + 328) - 8);
      do
      {
        if ( !*v23 )
          break;
        ++v22;
        v23 -= 2;
      }
      while ( v22 <= v99 );
      if ( v22 > v99 )
      {
LABEL_47:
        if ( sub_41F940(0, (_DWORD *)a1, (int)v19) > 0 )
          ++v99;
      }
      else
      {
        sub_41EBBA((int (__cdecl *)(int, char *, char))v98, (int *)a1, 0);
      }
LABEL_49:
      if ( v93 )
        ((void (__cdecl *)(void *))xmlFree)(Block);
      xmlSkipBlankChars(a1);
      v12 = v97;
    }
    if ( v92 == (unsigned __int8 *)v17 )
    {
      v24 = xmlDictLookup(*(_DWORD **)(a1 + 296), (char *)Block, Size);
      if ( v98 == *(char **)(a1 + 312) )
      {
        if ( v24 != *(unsigned __int8 **)(a1 + 320) )
          sub_41F1EB(
            (int (__cdecl *)(int, char *, char))0xC8,
            (int *)a1,
            "xml namespace prefix mapped to wrong URI\n",
            0,
            0,
            0);
      }
      else if ( v24 == *(unsigned __int8 **)(a1 + 320) )
      {
        sub_41F1EB(
          (int (__cdecl *)(int, char *, char))0xC8,
          (int *)a1,
          "xml namespace URI mapped to wrong prefix\n",
          0,
          0,
          0);
      }
      else if ( v98 == *(char **)(a1 + 316) )
      {
        sub_41F1EB(
          (int (__cdecl *)(int, char *, char))0xC8,
          (int *)a1,
          "redefinition of the xmlns prefix is forbidden\n",
          0,
          0,
          0);
      }
      else if ( Size == 29 && xmlStrEqual((char *)v24, "http://www.w3.org/2000/xmlns/") )
      {
        sub_41F1EB(
          (int (__cdecl *)(int, char *, char))0xC8,
          (int *)a1,
          "reuse of the xmlns namespace name is forbidden\n",
          0,
          0,
          0);
      }
      else if ( v24 && *v24 )
      {
        v25 = xmlParseURI(v24);
        v83 = v25;
        if ( v25 )
        {
          if ( *(_DWORD *)(a1 + 268) && !*v25 )
            sub_41F241("xmlns:%s: URI %s is not absolute\n", v98, v24);
          xmlFreeURI(v83);
        }
        else
        {
          sub_41F1EB(
            (int (__cdecl *)(int, char *, char))0x63,
            (int *)a1,
            "xmlns:%s: '%s' is not a valid URI\n",
            v98,
            v24,
            0);
        }
        v26 = 1;
        if ( v99 < 1 )
          goto LABEL_77;
        v27 = (char **)(*(_DWORD *)(a1 + 336) + 4 * *(_DWORD *)(a1 + 328) - 8);
        do
        {
          if ( *v27 == v98 )
            break;
          ++v26;
          v27 -= 2;
        }
        while ( v26 <= v99 );
        if ( v26 > v99 )
        {
LABEL_77:
          v28 = sub_41F940((int)v98, (_DWORD *)a1, (int)v24);
          v12 = v97;
          if ( v28 > 0 )
            ++v99;
        }
        else
        {
          sub_41EBBA((int (__cdecl *)(int, char *, char))v98, (int *)a1, v92);
        }
      }
      else
      {
        sub_41F1EB(
          (int (__cdecl *)(int, char *, char))0xC8,
          (int *)a1,
          "xmlns:%s: Empty XML namespace is not allowed\n",
          v98,
          0,
          0);
      }
      if ( v93 )
        ((void (__cdecl *)(void *))xmlFree)(Block);
      xmlSkipBlankChars(a1);
      goto LABEL_83;
    }
    v29 = v95;
    if ( !v95 || v12 + 5 > v86 )
    {
      if ( sub_41FAA2(a1, v12 + 5) < 0 )
      {
        v30 = *((_BYTE *)Block + Size) == 0;
LABEL_94:
        if ( v30 )
          ((void (__cdecl *)(void *))xmlFree)(Block);
        goto LABEL_96;
      }
      v86 = *(_DWORD *)(a1 + 304);
      v95 = *(_DWORD *)(a1 + 300);
      v29 = v95;
    }
    v31 = v93;
    v32 = v89++;
    *(_DWORD *)(*(_DWORD *)(a1 + 340) + 4 * v32) = v93;
    *(_DWORD *)(v29 + 4 * v12) = v98;
    v33 = v12 + 1;
    *(_DWORD *)(v29 + 4 * v33) = v92;
    v34 = (char *)Block;
    ++v33;
    *(_DWORD *)(v29 + 4 * v33++) = 0;
    *(_DWORD *)(v29 + 4 * v33) = v34;
    v35 = &v34[Size];
    ++v33;
    *(_DWORD *)(v29 + 4 * v33) = v35;
    v12 = v33 + 1;
    Block = v35;
    v97 = v12;
    if ( v31 )
      v81 = 1;
LABEL_96:
    if ( !*(_DWORD *)(a1 + 292) && *(_DWORD *)(*(_DWORD *)(a1 + 36) + 20) - *(_DWORD *)(*(_DWORD *)(a1 + 36) + 16) < 250 )
      sub_41FF5D(a1);
    v36 = *(_DWORD *)(a1 + 36);
    if ( *(_DWORD *)(v36 + 12) != v87 )
      goto LABEL_118;
    v37 = *(unsigned __int8 **)(v36 + 16);
    v38 = *v37;
    if ( *v37 == 62 || v38 == 47 && v37[1] == 62 )
      goto LABEL_130;
    if ( v38 != 32 && (v38 < 9u || v38 > 0xAu) && v38 != 13 )
      break;
    xmlSkipBlankChars(a1);
    v39 = *(_DWORD **)(a1 + 36);
    if ( v82 == (void *)v39[9] && v78 == (unsigned __int8 *)v39[4] && !v98 && !Block )
    {
      sub_41EC3F(1, (int *)a1, "xmlParseStartTag: problem parsing attributes\n");
      v12 = v97;
      goto LABEL_130;
    }
    if ( !*(_DWORD *)(a1 + 292) && v39[5] - v39[4] < 250 )
      sub_41FF5D(a1);
LABEL_83:
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 36) + 12) != v87 )
      goto LABEL_118;
  }
  sub_41EFC6((int (__cdecl *)(int, char *, char))0x41, (int *)a1, "attributes construct error\n");
LABEL_130:
  v42 = *(_DWORD **)(a1 + 348);
  if ( v42 )
  {
    v43 = (_DWORD *)xmlHashLookup3(v42, (char *)v90, v91, 0);
    v84 = v43;
    if ( v43 )
    {
      v44 = *v43 <= 0;
      v93 = 0;
      if ( !v44 )
      {
        v45 = v43 + 4;
        Block = (void *)(v97 + 5);
        for ( i = v43 + 4; ; v45 = i )
        {
          v46 = (char *)*(v45 - 2);
          v47 = *(_BYTE **)(a1 + 316);
          v48 = (unsigned __int8 *)*(v45 - 1);
          v98 = v46;
          v92 = v48;
          if ( v46 == v47 && !v48 )
            break;
          if ( v48 == v47 )
          {
            v53 = 1;
            if ( v99 >= 1 )
            {
              v54 = (char **)(*(_DWORD *)(a1 + 336) + 4 * *(_DWORD *)(a1 + 328) - 8);
              do
              {
                if ( *v54 == v46 )
                  break;
                ++v53;
                v54 -= 2;
              }
              while ( v53 <= v99 );
              if ( v53 <= v99 )
                goto LABEL_172;
            }
            v55 = v98;
            if ( sub_428877((_DWORD *)a1, (int)v98) == v84[4] )
              goto LABEL_172;
            v52 = sub_41F940((int)v55, (_DWORD *)a1, *i);
            goto LABEL_153;
          }
          v56 = v97;
          Size = 0;
          if ( v97 > 0 )
          {
            do
            {
              if ( v46 == *(char **)(4 * Size + v95) && v48 == *(unsigned __int8 **)(4 * Size + v95 + 4) )
                break;
              Size += 5;
            }
            while ( (int)Size < v97 );
            if ( (int)Size < v97 )
              goto LABEL_172;
            v45 = i;
            v56 = v97;
            v48 = v92;
          }
          v57 = v95;
          if ( !v95 || (int)Block > v86 )
          {
            if ( sub_41FAA2(a1, (int)Block) < 0 )
              return 0;
            v48 = v92;
            v86 = *(_DWORD *)(a1 + 304);
            v95 = *(_DWORD *)(a1 + 300);
            v57 = v95;
            v56 = v97;
          }
          *(_DWORD *)(v57 + 4 * v56) = v98;
          v58 = v56 + 1;
          Block = (char *)Block + 1;
          *(_DWORD *)(v57 + 4 * v58) = v48;
          v59 = v58 + 1;
          Block = (char *)Block + 1;
          v97 = v59;
          if ( v48 )
          {
            v61 = sub_428877((_DWORD *)a1, (int)v92);
            v62 = v97;
            v57 = v95;
            ++v97;
            *(_DWORD *)(v95 + 4 * v62) = v61;
            v60 = v97;
          }
          else
          {
            *(_DWORD *)(v57 + 4 * v59) = 0;
            v60 = v59 + 1;
          }
          Block = (char *)Block + 1;
          *(_DWORD *)(v57 + 4 * v60) = *v45;
          v63 = v45[1];
          v64 = v60 + 1;
          Block = (char *)Block + 1;
          *(_DWORD *)(v57 + 4 * v64) = v63;
          Block = (char *)Block + 1;
          v30 = *(_DWORD *)(a1 + 28) == 1;
          v97 = v64 + 1;
          if ( v30 && v45[2] )
            sub_43D29A(538, v90, v98, a1, "standalone: attribute %s on %s defaulted from external subset\n");
          ++v85;
LABEL_172:
          ++v93;
          i += 5;
          if ( v93 >= *v84 )
          {
            v12 = v97;
            goto LABEL_174;
          }
        }
        v49 = 1;
        if ( v99 >= 1 )
        {
          v50 = (_DWORD *)(*(_DWORD *)(a1 + 336) + 4 * *(_DWORD *)(a1 + 328) - 8);
          do
          {
            if ( !*v50 )
              break;
            ++v49;
            v50 -= 2;
          }
          while ( v49 <= v99 );
          if ( v49 <= v99 )
            goto LABEL_172;
          v45 = i;
        }
        v51 = *v45;
        if ( sub_428877((_DWORD *)a1, 0) == v51 )
          goto LABEL_172;
        v52 = sub_41F940(0, (_DWORD *)a1, v51);
LABEL_153:
        if ( v52 > 0 )
          ++v99;
        goto LABEL_172;
      }
    }
  }
LABEL_174:
  v93 = 0;
  if ( v12 > 0 )
  {
    v65 = v95 + 4;
    do
    {
      v66 = *(_BYTE **)v65;
      if ( *(_DWORD *)v65 )
      {
        v67 = (_BYTE *)sub_428877((_DWORD *)a1, (int)v66);
        if ( !v67 )
        {
          sub_41F1EB(
            (int (__cdecl *)(int, char *, char))0xC9,
            (int *)a1,
            "Namespace prefix %s for %s on %s is not defined\n",
            v66,
            *(_BYTE **)(v65 - 4),
            v90);
          v67 = 0;
        }
        *(_DWORD *)(v65 + 4) = v67;
      }
      else
      {
        v67 = 0;
      }
      Size = 0;
      if ( v93 > 0 )
      {
        v68 = *(int (__cdecl **)(int, char *, char))(v65 - 4);
        v69 = (_DWORD *)(v95 + 8);
        while ( 1 )
        {
          if ( v68 == (int (__cdecl *)(int, char *, char))*(v69 - 2) )
          {
            if ( *(_DWORD *)v65 == *(v69 - 1) )
            {
              sub_41EBBA(v68, (int *)a1, *(_BYTE **)v65);
              goto LABEL_191;
            }
            if ( v67 && (_BYTE *)*v69 == v67 )
              break;
          }
          Size += 5;
          v69 += 5;
          if ( (int)Size >= v93 )
            goto LABEL_191;
        }
        sub_41F1EB(
          (int (__cdecl *)(int, char *, char))0xCB,
          (int *)a1,
          "Namespaced Attribute %s in '%s' redefined\n",
          v68,
          v67,
          0);
      }
LABEL_191:
      v93 += 5;
      v65 += 20;
    }
    while ( v93 < v97 );
    v12 = v97;
  }
  v70 = sub_428877((_DWORD *)a1, (int)v91);
  v71 = v70;
  if ( v91 && !v70 )
    sub_41F1EB(
      (int (__cdecl *)(int, char *, char))0xC9,
      (int *)a1,
      "Namespace prefix %s on %s is not defined\n",
      v91,
      v90,
      0);
  *a2 = v91;
  *a3 = v71;
  if ( *(_DWORD *)a1 )
  {
    v72 = *(void (__cdecl **)(_DWORD, unsigned __int8 *, char *, int, int, int, int, int, int))(*(_DWORD *)a1 + 116);
    if ( v72 )
    {
      if ( !*(_DWORD *)(a1 + 212) )
      {
        v73 = v12 / 5;
        if ( v99 <= 0 )
          v72(*(_DWORD *)(a1 + 4), v90, v91, v71, 0, 0, v73, v85, v95);
        else
          v72(
            *(_DWORD *)(a1 + 4),
            v90,
            v91,
            v71,
            v99,
            *(_DWORD *)(a1 + 336) + 4 * (*(_DWORD *)(a1 + 328) - 2 * v99),
            v73,
            v85,
            v95);
      }
    }
  }
  v74 = 0;
  if ( v81 && v89 > 0 )
  {
    v75 = (_DWORD *)(v95 + 12);
    do
    {
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 340) + 4 * v74) && *v75 )
        ((void (__cdecl *)(_DWORD))xmlFree)(*v75);
      v75 += 5;
      ++v74;
    }
    while ( v74 < v89 );
  }
  return v90;
}
// 496494: invalid function type has been ignored

//----- (00429A1C) --------------------------------------------------------
void __usercall sub_429A1C(int a1@<eax>, unsigned __int8 *a2, int a3, int a4, int a5, int a6)
{
  int v7; // eax
  _BYTE *v8; // ecx
  int v9; // eax
  int v10; // edi
  unsigned __int8 *v11; // ebx
  _BYTE *v12; // ecx
  int v13; // edi
  unsigned __int8 *v14; // eax
  int v15; // eax
  unsigned __int8 v16; // cl
  int *v17; // eax
  int v18; // eax
  void (__cdecl *v19)(_DWORD, _DWORD, unsigned __int8 *, int); // eax
  _BYTE *v20; // [esp-4h] [ebp-10h]

  if ( !*(_DWORD *)(a1 + 292) && *(_DWORD *)(*(_DWORD *)(a1 + 36) + 20) - *(_DWORD *)(*(_DWORD *)(a1 + 36) + 16) < 250 )
    sub_41FF5D(a1);
  v7 = *(_DWORD *)(a1 + 36);
  v8 = *(_BYTE **)(v7 + 16);
  if ( *v8 != 60 || v8[1] != 47 )
  {
    sub_41EC3F(74, (int *)a1, 0);
    return;
  }
  *(_DWORD *)(a1 + 200) += 2;
  *(_DWORD *)(v7 + 16) += 2;
  *(_DWORD *)(*(_DWORD *)(a1 + 36) + 32) += 2;
  if ( **(_BYTE **)(*(_DWORD *)(a1 + 36) + 16) == 37 )
    xmlParserHandlePEReference((int *)a1);
  v9 = *(_DWORD *)(a1 + 36);
  if ( !**(_BYTE **)(v9 + 16) && xmlParserInputGrow((int *)v9, 250) <= 0 )
    xmlPopInput((_DWORD *)a1);
  if ( a6 <= 0
    || (v10 = *(_DWORD *)(a1 + 36), v11 = *(unsigned __int8 **)(v10 + 16), xmlStrncmp(v11, *(char **)(a1 + 184), a6)) )
  {
    if ( a2 )
      v14 = sub_428A4F(a1, *(unsigned __int8 **)(a1 + 184), a2);
    else
      v14 = sub_421ECF(a1, *(unsigned __int8 **)(a1 + 184));
    v13 = (int)v14;
LABEL_20:
    if ( !*(_DWORD *)(a1 + 292) && *(_DWORD *)(*(_DWORD *)(a1 + 36) + 20) - *(_DWORD *)(*(_DWORD *)(a1 + 36) + 16) < 250 )
      sub_41FF5D(a1);
    xmlSkipBlankChars(a1);
    v15 = *(_DWORD *)(a1 + 36);
    v16 = **(_BYTE **)(v15 + 16);
    if ( (v16 >= 9u && v16 <= 0xAu || v16 == 13 || v16 >= 0x20u) && v16 == 62 )
    {
      ++*(_DWORD *)(v15 + 32);
      ++*(_DWORD *)(*(_DWORD *)(a1 + 36) + 16);
      ++*(_DWORD *)(a1 + 200);
      v17 = *(int **)(a1 + 36);
      v12 = (_BYTE *)v17[4];
      if ( *v12 )
        goto LABEL_32;
      xmlParserInputGrow(v17, 250);
    }
    else
    {
      sub_41EC3F(73, (int *)a1, 0);
    }
    v12 = v20;
LABEL_32:
    if ( v13 != 1 )
    {
      if ( !v13 )
        v13 = (int)"unparseable";
      if ( !a4 )
      {
        v18 = *(_DWORD *)(a1 + 52);
        if ( v18 )
          a4 = *(unsigned __int16 *)(v18 + 56);
      }
      sub_41F0ED(
        (int (__cdecl *)(int, char *, char))0x4C,
        (int *)a1,
        "Opening and ending tag mismatch: %s line %d and %s\n",
        *(_BYTE **)(a1 + 184),
        a4,
        (_BYTE *)v13);
    }
    goto LABEL_39;
  }
  if ( v11[a6] != 62 )
  {
    *(_DWORD *)(v10 + 16) += a6;
    v13 = 1;
    goto LABEL_20;
  }
  *(_DWORD *)(v10 + 16) += a6 + 1;
LABEL_39:
  if ( *(_DWORD *)a1 )
  {
    v19 = *(void (__cdecl **)(_DWORD, _DWORD, unsigned __int8 *, int))(*(_DWORD *)a1 + 120);
    if ( v19 )
    {
      if ( !*(_DWORD *)(a1 + 212) )
        v19(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 184), a2, a3);
    }
  }
  sub_41FEF7((int)v12, (_DWORD *)a1);
  if ( a5 )
    sub_41FA49(a5, a1);
}
// 429B81: variable 'v20' is possibly undefined
// 429BEC: variable 'v12' is possibly undefined

//----- (00429C10) --------------------------------------------------------
void __cdecl xmlParseCDSect(int *a1)
{
  int v2; // ecx
  _BYTE *v3; // eax
  bool v4; // zf
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // edi
  _BYTE *v11; // ebx
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // edi
  int v16; // eax
  int v17; // eax
  int v18; // eax
  void (__cdecl *v19)(int, _BYTE *, int); // ecx
  void (__cdecl *v20)(int, _BYTE *, int); // eax
  int v21; // [esp+4h] [ebp-1Ch] BYREF
  int v22; // [esp+8h] [ebp-18h] BYREF
  int v23; // [esp+Ch] [ebp-14h]
  int v24; // [esp+10h] [ebp-10h] BYREF
  signed int v25; // [esp+14h] [ebp-Ch]
  int v26; // [esp+18h] [ebp-8h]
  int v27; // [esp+1Ch] [ebp-4h]
  int v28; // [esp+28h] [ebp+8h]

  v27 = 0;
  v26 = 0;
  v2 = a1[9];
  v3 = *(_BYTE **)(v2 + 16);
  v4 = *v3 == 60;
  v25 = 100;
  if ( !v4
    || v3[1] != 33
    || v3[2] != 91
    || v3[3] != 67
    || v3[4] != 68
    || v3[5] != 65
    || v3[6] != 84
    || v3[7] != 65
    || v3[8] != 91 )
  {
    return;
  }
  a1[50] += 9;
  *(_DWORD *)(v2 + 16) += 9;
  *(_DWORD *)(a1[9] + 32) += 9;
  if ( **(_BYTE **)(a1[9] + 16) == 37 )
    xmlParserHandlePEReference(a1);
  v5 = a1[9];
  if ( !**(_BYTE **)(v5 + 16) && xmlParserInputGrow((int *)v5, 250) <= 0 )
    xmlPopInput(a1);
  a1[43] = 8;
  v6 = xmlCurrentChar(a1, &v24);
  v28 = v6;
  if ( v6 >= 256 )
  {
    if ( v6 > 55295 && (v6 < 57344 || v6 > 65533) && (unsigned int)(v6 - 0x10000) > 0xFFFFF )
      goto LABEL_26;
  }
  else if ( (v6 < 9 || v6 > 10) && v6 != 13 && v6 < 32 )
  {
    goto LABEL_26;
  }
  v7 = a1[9];
  if ( **(_BYTE **)(v7 + 16) == 10 )
  {
    ++*(_DWORD *)(v7 + 28);
    *(_DWORD *)(a1[9] + 32) = 1;
  }
  else
  {
    ++*(_DWORD *)(v7 + 32);
  }
  *(_DWORD *)(a1[9] + 16) += v24;
  if ( **(_BYTE **)(a1[9] + 16) == 37 )
    xmlParserHandlePEReference(a1);
  v8 = xmlCurrentChar(a1, &v22);
  v23 = v8;
  if ( v8 < 256 )
  {
    if ( v8 >= 9 && v8 <= 10 || v8 == 13 || v8 >= 32 )
      goto LABEL_40;
LABEL_26:
    sub_41EC3F(63, a1, 0);
    a1[43] = 7;
    return;
  }
  if ( v8 > 55295 && (v8 < 57344 || v8 > 65533) && (unsigned int)(v8 - 0x10000) > 0xFFFFF )
    goto LABEL_26;
LABEL_40:
  v9 = a1[9];
  if ( **(_BYTE **)(v9 + 16) == 10 )
  {
    ++*(_DWORD *)(v9 + 28);
    *(_DWORD *)(a1[9] + 32) = 1;
  }
  else
  {
    ++*(_DWORD *)(v9 + 32);
  }
  *(_DWORD *)(a1[9] + 16) += v22;
  if ( **(_BYTE **)(a1[9] + 16) == 37 )
    xmlParserHandlePEReference(a1);
  v10 = xmlCurrentChar(a1, &v21);
  v11 = (_BYTE *)xmlMallocAtomic(0x64u);
  if ( !v11 )
  {
    xmlErrMemory((int)a1, 0);
    return;
  }
  while ( v10 < 256 )
  {
    if ( (v10 < 9 || v10 > 10) && v10 != 13 && v10 < 32 )
      goto LABEL_52;
LABEL_58:
    if ( v28 == 93 && v23 == 93 && v10 == 62 )
      goto LABEL_52;
    v12 = v27;
    if ( v27 + 5 >= v25 )
    {
      v25 *= 2;
      v13 = xmlRealloc(v11, v25);
      if ( !v13 )
      {
        ((void (__cdecl *)(_BYTE *))xmlFree)(v11);
        xmlErrMemory((int)a1, 0);
        return;
      }
      v11 = (_BYTE *)v13;
      v12 = v27;
    }
    if ( v24 == 1 )
    {
      v11[v12] = v28;
      v27 = v12 + 1;
    }
    else
    {
      v14 = xmlCopyCharMultiByte(&v11[v12], v28);
      v27 += v14;
    }
    ++v26;
    v28 = v23;
    v23 = v10;
    v15 = v21;
    v24 = v22;
    v22 = v21;
    if ( v26 > 50 )
    {
      if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
        sub_41FF5D((int)a1);
      v26 = 0;
    }
    v16 = a1[9];
    if ( **(_BYTE **)(v16 + 16) == 10 )
    {
      ++*(_DWORD *)(v16 + 28);
      *(_DWORD *)(a1[9] + 32) = 1;
    }
    else
    {
      ++*(_DWORD *)(v16 + 32);
    }
    *(_DWORD *)(a1[9] + 16) += v15;
    if ( **(_BYTE **)(a1[9] + 16) == 37 )
      xmlParserHandlePEReference(a1);
    v10 = xmlCurrentChar(a1, &v21);
  }
  if ( v10 <= 55295 || v10 >= 57344 && v10 <= 65533 || (unsigned int)(v10 - 0x10000) <= 0xFFFFF )
    goto LABEL_58;
LABEL_52:
  v11[v27] = 0;
  a1[43] = 7;
  if ( v10 == 62 )
  {
    v17 = a1[9];
    if ( **(_BYTE **)(v17 + 16) == 10 )
    {
      ++*(_DWORD *)(v17 + 28);
      *(_DWORD *)(a1[9] + 32) = 1;
    }
    else
    {
      ++*(_DWORD *)(v17 + 32);
    }
    *(_DWORD *)(a1[9] + 16) += v21;
    if ( **(_BYTE **)(a1[9] + 16) == 37 )
      xmlParserHandlePEReference(a1);
    v18 = *a1;
    if ( *a1 && !a1[53] )
    {
      v19 = *(void (__cdecl **)(int, _BYTE *, int))(v18 + 100);
      if ( v19 )
      {
        v19(a1[1], v11, v27);
      }
      else
      {
        v20 = *(void (__cdecl **)(int, _BYTE *, int))(v18 + 68);
        if ( v20 )
          v20(a1[1], v11, v27);
      }
    }
    ((void (__cdecl *)(_BYTE *))xmlFree)(v11);
  }
  else
  {
    sub_41F152((int (__cdecl *)(int, char *, char))0x3F, a1, "CData section not finished\n%.50s\n", v11);
    ((void (__cdecl *)(_BYTE *))xmlFree)(v11);
  }
}
// 496494: invalid function type has been ignored
// 49B2BC: using guessed type int (__cdecl *xmlMallocAtomic)(size_t Size);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);

//----- (0042A016) --------------------------------------------------------
void __cdecl xmlParseContent(int *Block)
{
  int v1; // ecx
  char *v2; // eax
  int v3; // ebp
  int v4; // edi
  char v5; // cl
  _DWORD *v6; // eax

  if ( !Block[73] && *(_DWORD *)(Block[9] + 20) - *(_DWORD *)(Block[9] + 16) < 250 )
    sub_41FF5D((int)Block);
  v1 = Block[9];
  while ( **(_BYTE **)(v1 + 16) )
  {
    v2 = *(char **)(v1 + 16);
    if ( *v2 == 60 && v2[1] == 47 )
      break;
    if ( Block[43] == -1 )
      break;
    v3 = *(_DWORD *)(v1 + 36);
    v4 = *(_DWORD *)(v1 + 16);
    v5 = *v2;
    if ( *v2 == 60 && v2[1] == 63 )
    {
      xmlParsePI(Block);
    }
    else if ( *v2 == 60
           && v2[1] == 33
           && v2[2] == 91
           && v2[3] == 67
           && v2[4] == 68
           && v2[5] == 65
           && v2[6] == 84
           && v2[7] == 65
           && v2[8] == 91 )
    {
      xmlParseCDSect(Block);
    }
    else if ( v5 == 60 )
    {
      if ( v2[1] == 33 && v2[2] == 45 && v2[3] == 45 )
      {
        xmlParseComment(Block);
        Block[43] = 7;
      }
      else
      {
        xmlParseElement(Block);
      }
    }
    else if ( v5 == 38 )
    {
      xmlParseReference((int)Block);
    }
    else
    {
      xmlParseCharData(Block, 0);
    }
    if ( !Block[73] && *(_DWORD *)(Block[9] + 20) - *(_DWORD *)(Block[9] + 16) < 250 )
      sub_41FF5D((int)Block);
    while ( !**(_BYTE **)(Block[9] + 16) && Block[10] > 1 )
      xmlPopInput(Block);
    if ( !Block[73] )
    {
      v6 = (_DWORD *)Block[9];
      if ( v6[4] - v6[3] > 500 && v6[5] - v6[4] < 500 )
        sub_41FF30(Block);
    }
    v1 = Block[9];
    if ( v3 == *(_DWORD *)(v1 + 36) && v4 == *(_DWORD *)(v1 + 16) )
    {
      sub_41EC3F(1, Block, "detected an error in element content\n");
      Block[43] = -1;
      return;
    }
  }
}

//----- (0042A1AC) --------------------------------------------------------
void __cdecl xmlParseElement(int *Block)
{
  _DWORD *v2; // eax
  int v3; // ecx
  unsigned int v4; // eax
  int v5; // edi
  int v6; // edi
  unsigned __int8 *started; // eax
  int v8; // ecx
  unsigned __int8 *v9; // ebx
  int v10; // eax
  _BYTE *v11; // ecx
  int v12; // eax
  int v13; // eax
  void (__cdecl *v14)(int, unsigned __int8 *, char *, int); // eax
  void (__cdecl *v15)(int, unsigned __int8 *); // eax
  _BYTE *v16; // eax
  unsigned int v17; // ecx
  bool v18; // zf
  int v19; // eax
  unsigned __int8 v20; // al
  int v21; // ecx
  _BYTE *v22; // eax
  int v23; // ecx
  _BYTE *v24; // eax
  _DWORD *v25; // eax
  int v26; // edx
  unsigned int v27; // edx
  int v28; // [esp-4h] [ebp-34h]
  int v29; // [esp-4h] [ebp-34h]
  unsigned int v30[5]; // [esp+Ch] [ebp-24h] BYREF
  int v31; // [esp+20h] [ebp-10h] BYREF
  unsigned int v32; // [esp+24h] [ebp-Ch]
  char *v33; // [esp+28h] [ebp-8h] BYREF
  int v34; // [esp+2Ch] [ebp-4h] BYREF
  _BYTE *Blocka; // [esp+38h] [ebp+8h]

  Blocka = (_BYTE *)Block[82];
  v33 = 0;
  v34 = 0;
  v31 = 0;
  if ( Block[47] > (unsigned int)xmlParserMaxDepth && (Block[90] & 0x80000) == 0 )
  {
    sub_41F093(
      (int (__cdecl *)(int, char *, char))1,
      Block,
      "Excessive depth in document: %d use XML_PARSE_HUGE option\n",
      xmlParserMaxDepth);
    Block[43] = -1;
    return;
  }
  if ( Block[17] )
  {
    v2 = (_DWORD *)Block[9];
    v3 = v2[4] + v2[9] - v2[3];
    v4 = v2[7];
    v30[1] = v3;
    v30[2] = v4;
  }
  if ( !Block[59] || (v5 = *(_DWORD *)Block[58], v5 == -2) )
    v5 = -1;
  sub_41FE7B(v5, (int)Block);
  v6 = *(_DWORD *)(Block[9] + 28);
  if ( Block[81] )
  {
    started = sub_428FDD((int)Block, &v33, &v34, &v31);
  }
  else
  {
    started = xmlParseStartTag(Block);
    v8 = v28;
  }
  v9 = started;
  if ( Block[43] != -1 )
  {
    if ( !started )
    {
      sub_41FEF7(v8, Block);
      return;
    }
    namePush((int)Block, (int)started);
    v32 = Block[13];
    v10 = Block[9];
    v11 = *(_BYTE **)(v10 + 16);
    if ( *v11 != 47 || v11[1] != 62 )
    {
      if ( *v11 == 62 )
      {
        ++*(_DWORD *)(v10 + 32);
        ++*(_DWORD *)(Block[9] + 16);
        ++Block[50];
        v19 = Block[9];
        if ( !**(_BYTE **)(v19 + 16) )
          xmlParserInputGrow((int *)v19, 250);
        xmlParseContent(Block);
        v20 = **(_BYTE **)(Block[9] + 16);
        if ( (v20 < 9u || v20 > 0xAu) && v20 != 13 && v20 < 0x20u )
        {
          sub_41F0ED(
            (int (__cdecl *)(int, char *, char))0x4D,
            Block,
            "Premature end of data in tag %s line %d\n",
            v9,
            v6,
            0);
          nodePop(Block);
          namePop(Block);
          sub_41FEF7(v21, Block);
          v22 = (_BYTE *)Block[82];
          if ( Blocka != v22 )
            sub_41FA49(v22 - Blocka, (int)Block);
          return;
        }
        if ( Block[81] )
        {
          sub_429A1C((int)Block, (unsigned __int8 *)v33, v34, v6, Block[82] - (_DWORD)Blocka, v31);
          namePop(Block);
        }
        else
        {
          sub_4286F2((int)Block, v6);
        }
      }
      else
      {
        sub_41F0ED(
          (int (__cdecl *)(int, char *, char))0x49,
          Block,
          "Couldn't find end of Start Tag %s line %d\n",
          v9,
          v6,
          0);
        nodePop(Block);
        namePop(Block);
        sub_41FEF7(v23, Block);
        v24 = (_BYTE *)Block[82];
        if ( Blocka != v24 )
          sub_41FA49(v24 - Blocka, (int)Block);
      }
      v17 = v32;
      if ( !v32 )
        return;
      v18 = Block[17] == 0;
      goto LABEL_51;
    }
    Block[50] += 2;
    *(_DWORD *)(v10 + 16) += 2;
    *(_DWORD *)(Block[9] + 32) += 2;
    if ( **(_BYTE **)(Block[9] + 16) == 37 )
      xmlParserHandlePEReference(Block);
    v12 = Block[9];
    if ( !**(_BYTE **)(v12 + 16) && xmlParserInputGrow((int *)v12, 250) <= 0 )
      xmlPopInput(Block);
    v13 = *Block;
    if ( Block[81] )
    {
      if ( v13 )
      {
        v14 = *(void (__cdecl **)(int, unsigned __int8 *, char *, int))(v13 + 120);
        if ( v14 )
        {
          if ( !Block[53] )
            v14(Block[1], v9, v33, v34);
        }
      }
    }
    else if ( v13 )
    {
      v15 = *(void (__cdecl **)(int, unsigned __int8 *))(v13 + 60);
      if ( v15 )
      {
        if ( !Block[53] )
          v15(Block[1], v9);
      }
    }
    namePop(Block);
    sub_41FEF7(v29, Block);
    v16 = (_BYTE *)Block[82];
    if ( Blocka != v16 )
      sub_41FA49(v16 - Blocka, (int)Block);
    v17 = v32;
    if ( v32 )
    {
      v18 = Block[17] == 0;
LABEL_51:
      if ( !v18 )
      {
        v25 = (_DWORD *)Block[9];
        v26 = v25[9] - v25[3];
        v30[0] = v17;
        v27 = v25[4] + v26;
        v30[4] = v25[7];
        v30[3] = v27;
        xmlParserAddNodeInfo((int)Block, v30);
      }
    }
  }
}
// 42A264: variable 'v28' is possibly undefined
// 42A27A: variable 'v8' is possibly undefined
// 42A349: variable 'v29' is possibly undefined
// 42A3E7: variable 'v21' is possibly undefined
// 42A466: variable 'v23' is possibly undefined
// 4A4D2C: using guessed type int xmlParserMaxDepth;

//----- (0042A4B4) --------------------------------------------------------
_BYTE *__cdecl xmlParseVersionNum(int *a1)
{
  _BYTE *v1; // esi
  char v3; // al
  int v4; // eax
  int v5; // eax
  unsigned __int8 v6; // bl
  signed int v7; // [esp+Ch] [ebp-8h]
  int i; // [esp+10h] [ebp-4h]

  v7 = 10;
  v1 = (_BYTE *)xmlMallocAtomic(0xAu);
  if ( v1 )
  {
    v3 = **(_BYTE **)(a1[9] + 16);
    if ( (unsigned __int8)(v3 - 48) <= 9u )
    {
      *v1 = v3;
      xmlNextChar(a1);
      if ( **(_BYTE **)(a1[9] + 16) == 46 )
      {
        v1[1] = 46;
        for ( i = 2; ; i = v4 )
        {
          xmlNextChar(a1);
          v6 = **(_BYTE **)(a1[9] + 16);
          if ( v6 < 0x30u || v6 > 0x39u )
          {
            v1[i] = 0;
            return v1;
          }
          v4 = i + 1;
          if ( i + 1 >= v7 )
          {
            v7 *= 2;
            v5 = xmlRealloc(v1, v7);
            if ( !v5 )
            {
              ((void (__cdecl *)(_BYTE *))xmlFree)(v1);
              xmlErrMemory((int)a1, 0);
              return 0;
            }
            v1 = (_BYTE *)v5;
            v4 = i + 1;
          }
          v1[i] = v6;
        }
      }
    }
    ((void (__cdecl *)(_BYTE *))xmlFree)(v1);
    return 0;
  }
  else
  {
    xmlErrMemory((int)a1, 0);
    return 0;
  }
}
// 496494: invalid function type has been ignored
// 49B2BC: using guessed type int (__cdecl *xmlMallocAtomic)(size_t Size);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);

//----- (0042A594) --------------------------------------------------------
_BYTE *__cdecl xmlParseVersionInfo(int *a1)
{
  int v1; // eax
  _BYTE *v2; // ecx
  _BYTE *v3; // edi
  int v4; // eax
  char v6; // al
  bool v7; // zf

  v1 = a1[9];
  v2 = *(_BYTE **)(v1 + 16);
  v3 = 0;
  if ( *v2 != 118 || v2[1] != 101 || v2[2] != 114 || v2[3] != 115 || v2[4] != 105 || v2[5] != 111 || v2[6] != 110 )
    return v3;
  a1[50] += 7;
  *(_DWORD *)(v1 + 16) += 7;
  *(_DWORD *)(a1[9] + 32) += 7;
  if ( **(_BYTE **)(a1[9] + 16) == 37 )
    xmlParserHandlePEReference(a1);
  v4 = a1[9];
  if ( !**(_BYTE **)(v4 + 16) && xmlParserInputGrow((int *)v4, 250) <= 0 )
    xmlPopInput(a1);
  xmlSkipBlankChars(a1);
  if ( **(_BYTE **)(a1[9] + 16) != 61 )
  {
    sub_41EC3F(75, a1, 0);
    return 0;
  }
  xmlNextChar(a1);
  xmlSkipBlankChars(a1);
  v6 = **(_BYTE **)(a1[9] + 16);
  if ( v6 == 34 )
  {
    xmlNextChar(a1);
    v3 = xmlParseVersionNum(a1);
    v7 = **(_BYTE **)(a1[9] + 16) == 34;
    goto LABEL_17;
  }
  if ( v6 == 39 )
  {
    xmlNextChar(a1);
    v3 = xmlParseVersionNum(a1);
    v7 = **(_BYTE **)(a1[9] + 16) == 39;
LABEL_17:
    if ( v7 )
      xmlNextChar(a1);
    else
      sub_41EC3F(34, a1, 0);
    return v3;
  }
  sub_41EC3F(33, a1, 0);
  return v3;
}
// 41FF93: using guessed type _DWORD __cdecl xmlSkipBlankChars(_DWORD);
// 420686: using guessed type _DWORD __cdecl xmlParserHandlePEReference(_DWORD);

//----- (0042A6C7) --------------------------------------------------------
unsigned __int8 *__cdecl xmlParseEncName(int *a1)
{
  unsigned __int8 v2; // bl
  unsigned __int8 *v3; // edi
  unsigned __int8 *v4; // eax
  unsigned __int8 v6; // bl
  int v7; // eax
  int v8; // eax
  _DWORD *v9; // eax
  signed int v10; // [esp+10h] [ebp-4h]
  int v11; // [esp+1Ch] [ebp+8h]

  v2 = **(_BYTE **)(a1[9] + 16);
  v3 = 0;
  v10 = 10;
  if ( (v2 < 0x61u || v2 > 0x7Au) && (unsigned __int8)(v2 - 65) > 0x19u )
  {
    sub_41EC3F(79, a1, 0);
    return v3;
  }
  v4 = (unsigned __int8 *)xmlMallocAtomic(0xAu);
  v3 = v4;
  if ( !v4 )
  {
    xmlErrMemory((int)a1, 0);
    return 0;
  }
  *v4 = v2;
  v11 = 1;
  xmlNextChar(a1);
LABEL_8:
  v6 = **(_BYTE **)(a1[9] + 16);
  while ( 1 )
  {
    if ( (v6 < 0x61u || v6 > 0x7Au)
      && (v6 < 0x41u || v6 > 0x5Au)
      && (v6 < 0x30u || v6 > 0x39u)
      && v6 != 46
      && v6 != 95
      && v6 != 45 )
    {
      v3[v11] = 0;
      return v3;
    }
    v7 = v11 + 1;
    if ( v11 + 1 < v10 )
      goto LABEL_21;
    v10 *= 2;
    v8 = xmlRealloc(v3, v10);
    if ( !v8 )
      break;
    v3 = (unsigned __int8 *)v8;
    v7 = v11 + 1;
LABEL_21:
    v3[v11] = v6;
    v11 = v7;
    xmlNextChar(a1);
    v6 = **(_BYTE **)(a1[9] + 16);
    if ( !v6 )
    {
      if ( !a1[73] )
      {
        v9 = (_DWORD *)a1[9];
        if ( v9[4] - v9[3] > 500 && v9[5] - v9[4] < 500 )
          sub_41FF30(a1);
        if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
          sub_41FF5D((int)a1);
      }
      goto LABEL_8;
    }
  }
  xmlErrMemory((int)a1, 0);
  ((void (__cdecl *)(unsigned __int8 *))xmlFree)(v3);
  return 0;
}
// 496494: invalid function type has been ignored
// 49B2BC: using guessed type int (__cdecl *xmlMallocAtomic)(size_t Size);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);

//----- (0042A835) --------------------------------------------------------
unsigned __int8 *__cdecl xmlParseEncodingDecl(int *a1)
{
  unsigned __int8 *v1; // esi
  int v2; // ecx
  _BYTE *v3; // eax
  int v4; // eax
  char v6; // al
  bool v7; // zf
  int v8; // eax
  const char **CharEncodingHandler; // eax

  v1 = 0;
  xmlSkipBlankChars(a1);
  v2 = a1[9];
  v3 = *(_BYTE **)(v2 + 16);
  if ( *v3 != 101
    || v3[1] != 110
    || v3[2] != 99
    || v3[3] != 111
    || v3[4] != 100
    || v3[5] != 105
    || v3[6] != 110
    || v3[7] != 103 )
  {
    return v1;
  }
  a1[50] += 8;
  *(_DWORD *)(v2 + 16) += 8;
  *(_DWORD *)(a1[9] + 32) += 8;
  if ( **(_BYTE **)(a1[9] + 16) == 37 )
    xmlParserHandlePEReference(a1);
  v4 = a1[9];
  if ( !**(_BYTE **)(v4 + 16) && xmlParserInputGrow((int *)v4, 250) <= 0 )
    xmlPopInput(a1);
  xmlSkipBlankChars(a1);
  if ( **(_BYTE **)(a1[9] + 16) != 61 )
  {
    sub_41EC3F(75, a1, 0);
    return 0;
  }
  xmlNextChar(a1);
  xmlSkipBlankChars(a1);
  v6 = **(_BYTE **)(a1[9] + 16);
  if ( v6 == 34 )
  {
    xmlNextChar(a1);
    v1 = xmlParseEncName(a1);
    v7 = **(_BYTE **)(a1[9] + 16) == 34;
  }
  else
  {
    if ( v6 != 39 )
    {
      sub_41EC3F(33, a1, 0);
      goto LABEL_25;
    }
    xmlNextChar(a1);
    v1 = xmlParseEncName(a1);
    v7 = **(_BYTE **)(a1[9] + 16) == 39;
  }
  if ( v7 )
    xmlNextChar(a1);
  else
    sub_41EC3F(34, a1, 0);
LABEL_25:
  if ( (a1[90] & 0x200000) == 0 && v1 )
  {
    if ( !xmlStrcasecmp(v1, "UTF-16") || !xmlStrcasecmp(v1, "UTF16") )
    {
      if ( !a1[6] )
      {
        v8 = a1[9];
        if ( *(_DWORD *)v8 )
        {
          if ( !*(_DWORD *)(*(_DWORD *)v8 + 12) )
            sub_41EFC6((int (__cdecl *)(int, char *, char))0x51, a1, "Document labelled UTF-16 but has UTF-8 content\n");
        }
      }
      goto LABEL_35;
    }
    if ( !xmlStrcasecmp(v1, "UTF-8") || !xmlStrcasecmp(v1, "UTF8") )
    {
LABEL_35:
      if ( a1[6] )
        ((void (__cdecl *)(int))xmlFree)(a1[6]);
      a1[6] = (int)v1;
      return v1;
    }
    if ( *(_DWORD *)(a1[9] + 44) )
      ((void (__cdecl *)(_DWORD))xmlFree)(*(_DWORD *)(a1[9] + 44));
    *(_DWORD *)(a1[9] + 44) = v1;
    CharEncodingHandler = (const char **)xmlFindCharEncodingHandler((const char *)v1);
    if ( !CharEncodingHandler )
    {
      sub_41F152((int (__cdecl *)(int, char *, char))0x20, a1, "Unsupported encoding %s\n", v1);
      return 0;
    }
    xmlSwitchToEncoding(a1, CharEncodingHandler);
  }
  return v1;
}
// 496494: invalid function type has been ignored
// 41FF93: using guessed type _DWORD __cdecl xmlSkipBlankChars(_DWORD);
// 420686: using guessed type _DWORD __cdecl xmlParserHandlePEReference(_DWORD);

//----- (0042AA49) --------------------------------------------------------
int __cdecl xmlParseSDDecl(int *a1)
{
  int v1; // ebp
  int v2; // ecx
  _BYTE *v3; // eax
  int v4; // eax
  char v6; // al
  int v7; // eax
  _BYTE *v8; // ecx
  int v9; // eax
  bool v10; // zf
  int v11; // eax
  _BYTE *v12; // ecx
  int v13; // eax

  v1 = -2;
  xmlSkipBlankChars((int)a1);
  v2 = a1[9];
  v3 = *(_BYTE **)(v2 + 16);
  if ( *v3 != 115
    || v3[1] != 116
    || v3[2] != 97
    || v3[3] != 110
    || v3[4] != 100
    || v3[5] != 97
    || v3[6] != 108
    || v3[7] != 111
    || v3[8] != 110
    || v3[9] != 101 )
  {
    return v1;
  }
  a1[50] += 10;
  *(_DWORD *)(v2 + 16) += 10;
  *(_DWORD *)(a1[9] + 32) += 10;
  if ( **(_BYTE **)(a1[9] + 16) == 37 )
    xmlParserHandlePEReference(a1);
  v4 = a1[9];
  if ( !**(_BYTE **)(v4 + 16) && xmlParserInputGrow((int *)v4, 250) <= 0 )
    xmlPopInput(a1);
  xmlSkipBlankChars((int)a1);
  if ( **(_BYTE **)(a1[9] + 16) != 61 )
  {
    sub_41EC3F(75, a1, 0);
    return -2;
  }
  xmlNextChar(a1);
  xmlSkipBlankChars((int)a1);
  v6 = **(_BYTE **)(a1[9] + 16);
  if ( v6 == 39 )
  {
    xmlNextChar(a1);
    v7 = a1[9];
    v8 = *(_BYTE **)(v7 + 16);
    if ( *v8 == 110 && v8[1] == 111 )
    {
      a1[50] += 2;
      *(_DWORD *)(v7 + 16) += 2;
      v1 = 0;
      *(_DWORD *)(a1[9] + 32) += 2;
    }
    else
    {
      if ( *v8 != 121 || v8[1] != 101 || v8[2] != 115 )
      {
        sub_41EC3F(78, a1, 0);
LABEL_32:
        v10 = **(_BYTE **)(a1[9] + 16) == 39;
        goto LABEL_33;
      }
      a1[50] += 3;
      *(_DWORD *)(v7 + 16) += 3;
      v1 = 1;
      *(_DWORD *)(a1[9] + 32) += 3;
    }
    if ( **(_BYTE **)(a1[9] + 16) == 37 )
      xmlParserHandlePEReference(a1);
    v9 = a1[9];
    if ( !**(_BYTE **)(v9 + 16) && xmlParserInputGrow((int *)v9, 250) <= 0 )
      xmlPopInput(a1);
    goto LABEL_32;
  }
  if ( v6 == 34 )
  {
    xmlNextChar(a1);
    v11 = a1[9];
    v12 = *(_BYTE **)(v11 + 16);
    if ( *v12 == 110 && v12[1] == 111 )
    {
      a1[50] += 2;
      *(_DWORD *)(v11 + 16) += 2;
      v1 = 0;
      *(_DWORD *)(a1[9] + 32) += 2;
    }
    else
    {
      if ( *v12 != 121 || v12[1] != 101 || v12[2] != 115 )
      {
        sub_41EC3F(78, a1, 0);
LABEL_50:
        v10 = **(_BYTE **)(a1[9] + 16) == 34;
LABEL_33:
        if ( v10 )
          xmlNextChar(a1);
        else
          sub_41EC3F(34, a1, 0);
        return v1;
      }
      a1[50] += 3;
      *(_DWORD *)(v11 + 16) += 3;
      v1 = 1;
      *(_DWORD *)(a1[9] + 32) += 3;
    }
    if ( **(_BYTE **)(a1[9] + 16) == 37 )
      xmlParserHandlePEReference(a1);
    v13 = a1[9];
    if ( !**(_BYTE **)(v13 + 16) && xmlParserInputGrow((int *)v13, 250) <= 0 )
      xmlPopInput(a1);
    goto LABEL_50;
  }
  sub_41EC3F(33, a1, 0);
  return v1;
}

//----- (0042ACC3) --------------------------------------------------------
void __cdecl xmlParseXMLDecl(int *a1)
{
  int v1; // eax
  unsigned __int8 v2; // al
  char *v3; // eax
  char *v4; // esi
  int v5; // eax
  unsigned __int8 *v6; // ecx
  unsigned __int8 v7; // dl
  int v8; // eax
  unsigned __int8 *v9; // edx
  unsigned __int8 v10; // cl
  _BYTE *v11; // ecx
  int v12; // eax

  *(_DWORD *)(a1[9] + 52) = -2;
  a1[50] += 5;
  *(_DWORD *)(a1[9] + 16) += 5;
  *(_DWORD *)(a1[9] + 32) += 5;
  if ( **(_BYTE **)(a1[9] + 16) == 37 )
    xmlParserHandlePEReference(a1);
  v1 = a1[9];
  if ( !**(_BYTE **)(v1 + 16) && xmlParserInputGrow((int *)v1, 250) <= 0 )
    xmlPopInput(a1);
  v2 = **(_BYTE **)(a1[9] + 16);
  if ( v2 != 32 && (v2 < 9u || v2 > 0xAu) && v2 != 13 )
    sub_41EFC6((int (__cdecl *)(int, char *, char))0x41, a1, "Blank needed after '<?xml'\n");
  xmlSkipBlankChars((int)a1);
  v3 = xmlParseVersionInfo(a1);
  v4 = v3;
  if ( v3 )
  {
    if ( !xmlStrEqual(v3, "1.0") )
    {
      if ( (a1[90] & 0x20000) == 0 && *v4 == 49 && v4[1] == 46 )
        sub_41F01E((int)a1, v4, 97, "Unsupported version '%s'\n");
      else
        sub_41F152((int (__cdecl *)(int, char *, char))0x6C, a1, "Unsupported version '%s'\n", v4);
    }
    if ( a1[5] )
      ((void (__cdecl *)(int))xmlFree)(a1[5]);
    a1[5] = (int)v4;
  }
  else
  {
    sub_41EC3F(96, a1, 0);
  }
  v5 = a1[9];
  v6 = *(unsigned __int8 **)(v5 + 16);
  v7 = *v6;
  if ( *v6 != 32 && (v7 < 9u || v7 > 0xAu) && v7 != 13 )
  {
    if ( v7 == 63 && v6[1] == 62 )
      goto LABEL_28;
    sub_41EFC6((int (__cdecl *)(int, char *, char))0x41, a1, "Blank needed here\n");
  }
  xmlParseEncodingDecl(a1);
  if ( a1[21] == 32 )
    return;
  v5 = a1[9];
  if ( *(_DWORD *)(v5 + 44) )
  {
    v9 = *(unsigned __int8 **)(v5 + 16);
    v10 = *v9;
    if ( *v9 != 32 && (v10 < 9u || v10 > 0xAu) && v10 != 13 )
    {
      if ( v10 == 63 && v9[1] == 62 )
        goto LABEL_28;
      sub_41EFC6((int (__cdecl *)(int, char *, char))0x41, a1, "Blank needed here\n");
    }
  }
  if ( !a1[73] && *(_DWORD *)(a1[9] + 20) - *(_DWORD *)(a1[9] + 16) < 250 )
    sub_41FF5D((int)a1);
  xmlSkipBlankChars((int)a1);
  *(_DWORD *)(a1[9] + 52) = xmlParseSDDecl(a1);
  xmlSkipBlankChars((int)a1);
  v5 = a1[9];
  v11 = *(_BYTE **)(v5 + 16);
  if ( *v11 != 63 || v11[1] != 62 )
  {
    if ( *v11 == 62 )
    {
      sub_41EC3F(57, a1, 0);
      xmlNextChar(a1);
    }
    else
    {
      sub_41EC3F(57, a1, 0);
      while ( **(_BYTE **)(a1[9] + 16) )
      {
        v12 = a1[9];
        if ( **(_BYTE **)(v12 + 16) == 62 )
          break;
        ++*(_DWORD *)(v12 + 16);
      }
      xmlNextChar(a1);
    }
    return;
  }
LABEL_28:
  a1[50] += 2;
  *(_DWORD *)(v5 + 16) += 2;
  *(_DWORD *)(a1[9] + 32) += 2;
  if ( **(_BYTE **)(a1[9] + 16) == 37 )
    xmlParserHandlePEReference(a1);
  v8 = a1[9];
  if ( !**(_BYTE **)(v8 + 16) && xmlParserInputGrow((int *)v8, 250) <= 0 )
    xmlPopInput(a1);
}
// 496494: invalid function type has been ignored

//----- (0042AF28) --------------------------------------------------------
unsigned __int8 *__cdecl xmlParseMisc(int *Block)
{
  unsigned __int8 *result; // eax
  unsigned __int8 v2; // cl

  while ( 1 )
  {
    result = *(unsigned __int8 **)(Block[9] + 16);
    v2 = *result;
    if ( (*result != 60 || result[1] != 63 && (result[1] != 33 || result[2] != 45 || result[3] != 45))
      && v2 != 32
      && (v2 < 9u || v2 > 0xAu)
      && v2 != 13 )
    {
      break;
    }
    if ( v2 == 60 && result[1] == 63 )
    {
      xmlParsePI(Block);
    }
    else if ( v2 == 32 || v2 <= 0xAu || v2 == 13 )
    {
      xmlNextChar(Block);
    }
    else
    {
      xmlParseComment(Block);
    }
  }
  return result;
}
// 42AF85: conditional instruction was optimized away because cl.1 is in (9..A|==D|==3C)

//----- (0042AFA4) --------------------------------------------------------
int __cdecl xmlParseDocument(int *Block)
{
  int *v1; // esi
  int v2; // eax
  void (__cdecl *v3)(int, int (**)()); // eax
  int v4; // eax
  int v5; // eax
  _BYTE *v6; // eax
  unsigned __int8 v7; // al
  void (__cdecl *v8)(int); // eax
  _BYTE *v9; // eax
  int v10; // eax
  void (__cdecl *v11)(int, int, int, int); // eax
  void (__cdecl *v12)(int); // eax
  char **v13; // edi
  int v14; // eax

  xmlInitParser();
  v1 = Block;
  if ( !Block )
    return -1;
  v2 = Block[9];
  if ( !v2 )
    return -1;
  if ( !Block[73] && *(_DWORD *)(v2 + 20) - *(_DWORD *)(v2 + 16) < 250 )
    sub_41FF5D((int)Block);
  sub_41F321((int)v1);
  if ( *v1 )
  {
    v3 = *(void (__cdecl **)(int, int (**)()))(*v1 + 44);
    if ( v3 )
      v3(v1[1], &xmlDefaultSAXLocator);
  }
  if ( !v1[6] )
  {
    v4 = v1[9];
    if ( *(_DWORD *)(v4 + 20) - *(_DWORD *)(v4 + 16) >= 4 )
    {
      Block = **(int ***)(v4 + 16);
      v5 = xmlDetectCharEncoding((char *)&Block, 4);
      if ( v5 )
        xmlSwitchEncoding(v1, v5);
    }
  }
  if ( !**(_BYTE **)(v1[9] + 16) )
    sub_41EC3F(4, v1, 0);
  if ( *(_DWORD *)(v1[9] + 20) - *(_DWORD *)(v1[9] + 16) < 35 && !v1[73] )
    sub_41FF5D((int)v1);
  v6 = *(_BYTE **)(v1[9] + 16);
  if ( *v6 == 60
    && v6[1] == 63
    && v6[2] == 120
    && v6[3] == 109
    && v6[4] == 108
    && ((v7 = v6[5], v7 == 32) || v7 >= 9u && v7 <= 0xAu || v7 == 13) )
  {
    xmlParseXMLDecl(v1);
    if ( v1[21] == 32 )
      return -1;
    v1[7] = *(_DWORD *)(v1[9] + 52);
    xmlSkipBlankChars((int)v1);
  }
  else
  {
    v1[5] = (int)xmlCharStrdup("1.0");
  }
  if ( *v1 )
  {
    v8 = *(void (__cdecl **)(int))(*v1 + 48);
    if ( v8 )
    {
      if ( !v1[53] )
        v8(v1[1]);
    }
  }
  if ( !v1[73] && *(_DWORD *)(v1[9] + 20) - *(_DWORD *)(v1[9] + 16) < 250 )
    sub_41FF5D((int)v1);
  xmlParseMisc(v1);
  if ( !v1[73] && *(_DWORD *)(v1[9] + 20) - *(_DWORD *)(v1[9] + 16) < 250 )
    sub_41FF5D((int)v1);
  v9 = *(_BYTE **)(v1[9] + 16);
  if ( *v9 == 60
    && v9[1] == 33
    && v9[2] == 68
    && v9[3] == 79
    && v9[4] == 67
    && v9[5] == 84
    && v9[6] == 89
    && v9[7] == 80
    && v9[8] == 69 )
  {
    v1[54] = 1;
    xmlParseDocTypeDecl(v1);
    if ( **(_BYTE **)(v1[9] + 16) == 91 )
    {
      v1[43] = 3;
      sub_4281C3(v1);
    }
    v10 = *v1;
    v1[54] = 2;
    if ( v10 )
    {
      v11 = *(void (__cdecl **)(int, int, int, int))(v10 + 104);
      if ( v11 )
      {
        if ( !v1[53] )
          v11(v1[1], v1[55], v1[57], v1[56]);
      }
    }
    v1[54] = 0;
    sub_41F6ED((int)v1);
    v1[43] = 4;
    xmlParseMisc(v1);
  }
  if ( !v1[73] && *(_DWORD *)(v1[9] + 20) - *(_DWORD *)(v1[9] + 16) < 250 )
    sub_41FF5D((int)v1);
  if ( **(_BYTE **)(v1[9] + 16) == 60 )
  {
    v1[43] = 7;
    xmlParseElement(v1);
    v1[43] = 14;
    xmlParseMisc(v1);
    if ( **(_BYTE **)(v1[9] + 16) )
      sub_41EC3F(5, v1, 0);
    v1[43] = -1;
  }
  else
  {
    sub_41EFC6((int (__cdecl *)(int, char *, char))4, v1, "Start tag expected, '<' not found\n");
  }
  if ( *v1 )
  {
    v12 = *(void (__cdecl **)(int))(*v1 + 52);
    if ( v12 )
      v12(v1[1]);
  }
  v13 = (char **)v1[2];
  if ( v13 && xmlStrEqual(v13[14], "SAX compatibility mode document") )
  {
    xmlFreeDoc(v13);
    v1[2] = 0;
  }
  if ( !v1[3] )
    goto LABEL_79;
  v14 = v1[2];
  if ( v14 )
  {
    *(_DWORD *)(v14 + 92) |= 1u;
    if ( v1[25] )
      *(_DWORD *)(v1[2] + 92) |= 8u;
    if ( v1[89] )
      *(_DWORD *)(v1[2] + 92) |= 2u;
    if ( (v1[90] & 0x20000) != 0 )
      *(_DWORD *)(v1[2] + 92) |= 4u;
  }
  if ( !v1[3] )
  {
LABEL_79:
    v1[25] = 0;
    return -1;
  }
  return 0;
}
// 42B078: conditional instruction was optimized away because eax.4<23
// 4A4C28: using guessed type int (*xmlDefaultSAXLocator)();

//----- (0042B31D) --------------------------------------------------------
int __cdecl xmlParseExtParsedEnt(int *Block)
{
  int *v1; // esi
  void (__cdecl *v2)(int, int (**)()); // eax
  int v3; // eax
  int v4; // eax
  _BYTE *v5; // eax
  unsigned __int8 v6; // al
  void (__cdecl *v7)(int); // eax
  _BYTE *v8; // eax
  void (__cdecl *v9)(int); // eax

  v1 = Block;
  if ( !Block || !Block[9] )
    return -1;
  xmlDefaultSAXHandlerInit();
  sub_41F321((int)v1);
  if ( !v1[73] && *(_DWORD *)(v1[9] + 20) - *(_DWORD *)(v1[9] + 16) < 250 )
    sub_41FF5D((int)v1);
  if ( *v1 )
  {
    v2 = *(void (__cdecl **)(int, int (**)()))(*v1 + 44);
    if ( v2 )
      v2(v1[1], &xmlDefaultSAXLocator);
  }
  v3 = v1[9];
  if ( *(_DWORD *)(v3 + 20) - *(_DWORD *)(v3 + 16) >= 4 )
  {
    Block = **(int ***)(v3 + 16);
    v4 = xmlDetectCharEncoding((char *)&Block, 4);
    if ( v4 )
      xmlSwitchEncoding(v1, v4);
  }
  if ( !**(_BYTE **)(v1[9] + 16) )
    sub_41EC3F(4, v1, 0);
  if ( !v1[73] && *(_DWORD *)(v1[9] + 20) - *(_DWORD *)(v1[9] + 16) < 250 )
    sub_41FF5D((int)v1);
  v5 = *(_BYTE **)(v1[9] + 16);
  if ( *v5 == 60 && v5[1] == 63 && v5[2] == 120 && v5[3] == 109 && v5[4] == 108 )
  {
    if ( (v6 = v5[5], v6 == 32) || v6 >= 9u && v6 <= 0xAu || v6 == 13 )
    {
      xmlParseXMLDecl(v1);
      if ( v1[21] != 32 )
      {
        xmlSkipBlankChars((int)v1);
        goto LABEL_29;
      }
      return -1;
    }
  }
  v1[5] = (int)xmlCharStrdup("1.0");
LABEL_29:
  if ( *v1 )
  {
    v7 = *(void (__cdecl **)(int))(*v1 + 48);
    if ( v7 )
    {
      if ( !v1[53] )
        v7(v1[1]);
    }
  }
  v1[43] = 7;
  v1[26] = 0;
  v1[69] = 0;
  v1[62] = 0;
  xmlParseContent(v1);
  v8 = *(_BYTE **)(v1[9] + 16);
  if ( *v8 == 60 && v8[1] == 47 )
  {
    sub_41EC3F(85, v1, 0);
  }
  else if ( *v8 )
  {
    sub_41EC3F(86, v1, 0);
  }
  if ( *v1 )
  {
    v9 = *(void (__cdecl **)(int))(*v1 + 52);
    if ( v9 )
      v9(v1[1]);
  }
  return (v1[3] != 0) - 1;
}
// 4A4C28: using guessed type int (*xmlDefaultSAXLocator)();

//----- (0042B4D7) --------------------------------------------------------
int __usercall sub_42B4D7@<eax>(int a1@<ebx>, char a2, unsigned __int8 a3, unsigned __int8 a4)
{
  _DWORD *v4; // edx
  int v6; // esi
  int v7; // ecx
  int v8; // edi
  int *v9; // eax
  bool v10; // zf

  v4 = *(_DWORD **)(a1 + 36);
  if ( !v4 )
    return -1;
  v6 = v4[3];
  v7 = v4[4] - v6;
  if ( v7 < 0 )
    return -1;
  if ( *(_DWORD *)(a1 + 204) > v7 )
    v7 = *(_DWORD *)(a1 + 204);
  if ( *v4 )
  {
    v9 = *(int **)(*v4 + 16);
    v6 = *v9;
    v8 = v9[1];
  }
  else
  {
    v8 = v4[6];
  }
  if ( a4 )
  {
    v8 -= 2;
  }
  else if ( a3 )
  {
    --v8;
  }
  while ( 1 )
  {
    if ( v7 >= v8 )
    {
      *(_DWORD *)(a1 + 204) = v7;
      return -1;
    }
    if ( *(_BYTE *)(v6 + v7) == a2 )
    {
      if ( a4 )
      {
        if ( *(_BYTE *)(v6 + v7 + 1) != a3 )
          goto LABEL_21;
        v10 = *(_BYTE *)(v6 + v7 + 2) == a4;
      }
      else
      {
        if ( !a3 )
          break;
        v10 = *(_BYTE *)(v6 + v7 + 1) == a3;
      }
      if ( v10 )
        break;
    }
LABEL_21:
    ++v7;
  }
  *(_DWORD *)(a1 + 204) = 0;
  return v7 + v4[3] - v4[4];
}

//----- (0042B576) --------------------------------------------------------
unsigned int __usercall sub_42B576@<eax>(unsigned int result@<eax>, unsigned int *a2@<edi>, unsigned int *a3)
{
  unsigned int *v3; // ebx
  int v4; // ecx
  unsigned int v5; // edx
  unsigned int v6; // ecx
  char v7; // bl

  if ( !result )
    return xmlGenericError(xmlGenericErrorContext, "Internal error: xmlParseGetLasts\n");
  if ( !a2 )
    return xmlGenericError(xmlGenericErrorContext, "Internal error: xmlParseGetLasts\n");
  v3 = a3;
  if ( !a3 )
    return xmlGenericError(xmlGenericErrorContext, "Internal error: xmlParseGetLasts\n");
  if ( !*(_DWORD *)(result + 292) || *(_DWORD *)(result + 40) != 1 )
    goto LABEL_30;
  v4 = *(_DWORD *)(result + 36);
  v5 = *(_DWORD *)(v4 + 20);
  v6 = *(_DWORD *)(v4 + 12);
  for ( result = v5 - 1; result >= v6 && *(_BYTE *)result != 60; --result )
    ;
  if ( result < v6 )
  {
LABEL_30:
    *a2 = 0;
    *a3 = 0;
    return result;
  }
  *a2 = result++;
  if ( result >= v5 )
    goto LABEL_26;
  do
  {
    v7 = *(_BYTE *)result;
    if ( *(_BYTE *)result == 62 )
      break;
    if ( v7 == 39 )
    {
      if ( ++result >= v5 )
        break;
      do
      {
        if ( *(_BYTE *)result == 39 )
          break;
        ++result;
      }
      while ( result < v5 );
      goto LABEL_22;
    }
    if ( v7 == 34 )
    {
      if ( ++result >= v5 )
        break;
      do
      {
        if ( *(_BYTE *)result == 34 )
          break;
        ++result;
      }
      while ( result < v5 );
LABEL_22:
      if ( result >= v5 )
        break;
    }
    ++result;
  }
  while ( result < v5 );
  v3 = a3;
  if ( result < v5 )
  {
    *a3 = result;
    return result;
  }
LABEL_26:
  result = *a2;
  do
    --result;
  while ( result >= v6 && *(_BYTE *)result != 62 );
  *v3 = result >= v6 ? result : 0;
  return result;
}
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);

//----- (0042B64B) --------------------------------------------------------
int __usercall sub_42B64B@<eax>(int a1@<esi>, int a2)
{
  int v2; // edx
  int result; // eax
  int v4; // ebp
  char v5; // cl
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // [esp-4h] [ebp-18h]
  int v10; // [esp+Ch] [ebp-8h]
  int v11; // [esp+10h] [ebp-4h]

  if ( a1 )
  {
    v2 = a2;
    if ( a2 > 0 )
    {
      result = 0;
      v11 = 4;
      v10 = 3;
      v4 = 2;
      while ( 1 )
      {
        v5 = *(_BYTE *)(result + a1);
        if ( v5 < 0 )
        {
          if ( (v5 & 0xE0) == 0xC0 )
          {
            if ( v4 > v2 )
              return result;
            if ( (*(_BYTE *)(result + a1 + 1) & 0xC0) != 0x80 )
              return -result;
            v6 = *(_BYTE *)(result + a1 + 1) & 0x3F | ((v5 & 0x1F) << 6);
            if ( v6 >= 256 )
            {
              if ( v6 > 55295 && (v6 < 57344 || v6 > 65533) && (unsigned int)(v6 - 0x10000) > 0xFFFFF )
                return -result;
            }
            else if ( (v6 < 9 || v6 > 10) && v6 != 13 && v6 < 32 )
            {
              return -result;
            }
            v9 = 2;
          }
          else if ( (v5 & 0xF0) == 0xE0 )
          {
            if ( v10 > v2 )
              return result;
            if ( (*(_BYTE *)(result + a1 + 1) & 0xC0) != 0x80 || (*(_BYTE *)(result + a1 + 2) & 0xC0) != 0x80 )
              return -result;
            v7 = *(_BYTE *)(result + a1 + 2) & 0x3F | ((*(_BYTE *)(result + a1 + 1) & 0x3F | ((v5 & 0xF) << 6)) << 6);
            if ( v7 >= 256 )
            {
              if ( v7 > 55295 && (v7 < 57344 || v7 > 65533) && (unsigned int)(v7 - 0x10000) > 0xFFFFF )
                return -result;
            }
            else if ( (v7 < 9 || v7 > 10) && v7 != 13 && v7 < 32 )
            {
              return -result;
            }
            v9 = 3;
          }
          else
          {
            if ( (v5 & 0xF8) != 0xF0 )
              return -result;
            if ( v11 > v2 )
              return result;
            if ( (*(_BYTE *)(result + a1 + 1) & 0xC0) != 0x80
              || (*(_BYTE *)(result + a1 + 2) & 0xC0) != 0x80
              || (*(_BYTE *)(result + a1 + 3) & 0xC0) != 0x80 )
            {
              return -result;
            }
            v8 = *(_BYTE *)(result + a1 + 3) & 0x3F | ((*(_BYTE *)(result + a1 + 2) & 0x3F | ((*(_BYTE *)(result + a1 + 1) & 0x3F | ((v5 & 7) << 6)) << 6)) << 6);
            if ( v8 >= 256 )
            {
              if ( v8 > 55295 && (v8 < 57344 || v8 > 65533) && (unsigned int)(v8 - 0x10000) > 0xFFFFF )
                return -result;
            }
            else if ( (v8 < 9 || v8 > 10) && v8 != 13 && v8 < 32 )
            {
              return -result;
            }
            v9 = 4;
          }
          v10 += v9;
          result += v9;
          v4 += v9;
          v11 += v9;
        }
        else
        {
          if ( (unsigned __int8)v5 < 0x20u && v5 != 10 && v5 != 13 && v5 != 9 )
            return -result;
          ++result;
          ++v4;
          ++v10;
          ++v11;
        }
        v2 = a2;
        if ( result >= a2 )
          return result;
      }
    }
  }
  return 0;
}
// 42B668: conditional instruction was optimized away because %arg_0.4>=1

//----- (0042B8AE) --------------------------------------------------------
int __cdecl sub_42B8AE(int a1)
{
  int *Block; // ecx
  int *v2; // ebx
  int result; // eax
  int *v4; // eax
  int v5; // edi
  int v6; // ecx
  int v7; // esi
  int v8; // edi
  _BYTE *v9; // esi
  int v10; // ecx
  int v11; // edi
  char *v12; // eax
  char v13; // cl
  int v14; // eax
  _BYTE *v15; // eax
  void (__cdecl *v16)(int, int (**)()); // eax
  _BYTE *v17; // eax
  unsigned __int8 v18; // al
  int v19; // eax
  _BYTE *v20; // eax
  void (__cdecl *v21)(int); // eax
  bool v22; // zf
  void (__cdecl *v23)(int, int (**)()); // eax
  _BYTE *v24; // eax
  unsigned int v25; // ecx
  int v26; // edi
  unsigned __int8 *started; // eax
  int v28; // ecx
  unsigned __int8 *v29; // esi
  int v30; // eax
  _BYTE *v31; // edi
  int v32; // eax
  int v33; // eax
  int v34; // ecx
  void (__cdecl *v35)(int, unsigned __int8 *, char *, int); // eax
  void (__cdecl *v36)(int, unsigned __int8 *); // eax
  int v37; // ecx
  char *v38; // ecx
  unsigned int v39; // edx
  char v40; // cl
  char v41; // dl
  int v42; // eax
  int v43; // eax
  int v44; // eax
  int v45; // eax
  char *v46; // eax
  int v47; // edi
  int v48; // esi
  int v49; // eax
  int v50; // eax
  bool v51; // cc
  void (__cdecl *v52)(int, int, char *); // ecx
  void (__cdecl *v53)(int, int, char *); // eax
  char *v54; // ecx
  int v55; // eax
  int v56; // eax
  _DWORD *v57; // eax
  _BYTE *v58; // esi
  int v59; // ecx
  int v60; // ecx
  _BYTE *v61; // edi
  char v62; // dl
  char v63; // al
  int v64; // eax
  void (__cdecl *v65)(int, int, int, int); // eax
  _DWORD *v66; // eax
  int v67; // edi
  int v68; // ecx
  int v69; // ecx
  _BYTE *v70; // esi
  char v71; // dl
  _DWORD *v72; // eax
  int v73; // edi
  int v74; // ecx
  int v75; // ecx
  _BYTE *v76; // esi
  char v77; // dl
  int v78; // esi
  int *v79; // eax
  unsigned int v80; // edx
  int v81; // ecx
  char v82; // al
  int v83; // eax
  unsigned int v84; // edi
  unsigned __int8 *i; // edx
  unsigned __int8 v86; // al
  int v87; // eax
  void (__cdecl *v88)(int, int, int, int); // eax
  void (__cdecl *v89)(int, int (**)()); // eax
  int v90; // eax
  void (__cdecl *v91)(int); // eax
  int v92; // edi
  int v93; // esi
  int v94; // eax
  int v95; // edx
  int v96; // eax
  void (__cdecl *v97)(int, int, int); // ecx
  void (__cdecl *v98)(int, int, int); // eax
  unsigned int v99; // ecx
  int v100; // eax
  int v101; // eax
  int v102; // [esp-Ch] [ebp-5Ch]
  int v103; // [esp-Ch] [ebp-5Ch]
  int v104; // [esp+4h] [ebp-4Ch] BYREF
  int v105; // [esp+8h] [ebp-48h] BYREF
  char v106[4]; // [esp+Ch] [ebp-44h] BYREF
  unsigned int v107; // [esp+10h] [ebp-40h] BYREF
  int v108; // [esp+14h] [ebp-3Ch]
  unsigned int v109; // [esp+18h] [ebp-38h] BYREF
  unsigned int v110; // [esp+1Ch] [ebp-34h]
  char *v111; // [esp+20h] [ebp-30h] BYREF
  char v112; // [esp+27h] [ebp-29h]
  char Buffer[152]; // [esp+28h] [ebp-28h] BYREF

  v108 = 0;
  v2 = Block;
  result = Block[9];
  if ( !result )
    return result;
  if ( *(_DWORD *)(result + 16) - *(_DWORD *)(result + 12) > 4096 )
  {
    sub_41FF30(Block);
    v2[51] = 0;
  }
LABEL_4:
  sub_42B576((unsigned int)v2, &v107, &v109);
  while ( 2 )
  {
    if ( v2[21] && v2[53] == 1 )
      return 0;
    while ( !**(_BYTE **)(v2[9] + 16) && v2[10] > 1 )
      xmlPopInput(v2);
    v4 = (int *)v2[9];
    if ( !v4 )
      return v108;
    if ( *v4 )
    {
      v6 = *(_DWORD *)(*v4 + 20);
      if ( v6 && *(_DWORD *)(v6 + 4) )
      {
        v7 = v4[3] - **(_DWORD **)(*v4 + 16);
        v8 = v4[4] - v4[3];
        xmlParserInputBufferPush(*v4, 0, byte_47627C);
        *(_DWORD *)(v2[9] + 12) = v7 + **(_DWORD **)(*(_DWORD *)v2[9] + 16);
        *(_DWORD *)(v2[9] + 16) = v8 + *(_DWORD *)(v2[9] + 12);
        *(_DWORD *)(v2[9] + 20) = **(_DWORD **)(*(_DWORD *)v2[9] + 16)
                                + *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v2[9] + 16) + 4);
      }
      v4 = (int *)v2[9];
      v5 = *(_DWORD *)(*(_DWORD *)(*v4 + 16) + 4);
    }
    else
    {
      v5 = v4[6];
    }
    v9 = (_BYTE *)v4[4];
    v10 = v4[3];
    v11 = v10 + v5 - (_DWORD)v9;
    if ( v11 < 1 )
      return v108;
    switch ( v2[43] )
    {
      case -1:
        return v108;
      case 0:
        if ( v2[64] )
        {
          if ( v11 < 2 )
            return v108;
          v15 = (_BYTE *)v4[4];
          if ( !*v15 )
          {
            if ( *v2 )
            {
              v89 = *(void (__cdecl **)(int, int (**)()))(*v2 + 44);
              if ( v89 )
                v89(v2[1], &xmlDefaultSAXLocator);
            }
LABEL_320:
            sub_41EC3F(4, v2, 0);
            goto LABEL_321;
          }
          if ( *v15 == 60 && v15[1] == 63 )
          {
            if ( v11 < 5 || !a1 && sub_42B4D7((int)v2, 63, 0x3Eu, 0) < 0 )
              return v108;
            if ( *v2 )
            {
              v16 = *(void (__cdecl **)(int, int (**)()))(*v2 + 44);
              if ( v16 )
                v16(v2[1], &xmlDefaultSAXLocator);
            }
            v17 = *(_BYTE **)(v2[9] + 16);
            if ( v17[2] != 120
              || v17[3] != 109
              || v17[4] != 108
              || (v18 = v17[5], v18 != 32) && (v18 < 9u || v18 > 0xAu) && v18 != 13 )
            {
              v2[5] = (int)xmlCharStrdup("1.0");
              goto LABEL_45;
            }
            v108 += 5;
            xmlParseXMLDecl(v2);
            if ( v2[21] != 32 )
            {
              v19 = v2[9];
              v2[7] = *(_DWORD *)(v19 + 52);
              if ( !v2[6] )
              {
                v20 = *(_BYTE **)(v19 + 44);
                if ( v20 )
                  v2[6] = (int)xmlStrdup(v20);
              }
LABEL_45:
              if ( *v2 )
              {
                v21 = *(void (__cdecl **)(int))(*v2 + 48);
                if ( v21 )
                {
                  v22 = v2[53] == 0;
                  goto LABEL_56;
                }
              }
              goto LABEL_58;
            }
            v2[43] = -1;
            return 0;
          }
          if ( *v2 )
          {
            v23 = *(void (__cdecl **)(int, int (**)()))(*v2 + 44);
            if ( v23 )
              v23(v2[1], &xmlDefaultSAXLocator);
          }
          v24 = xmlCharStrdup("1.0");
          v2[5] = (int)v24;
          if ( v24 )
          {
            if ( *v2 )
            {
              v21 = *(void (__cdecl **)(int))(*v2 + 48);
              if ( v21 )
              {
                v22 = v2[53] == 0;
LABEL_56:
                if ( v22 )
                  v21(v2[1]);
              }
            }
LABEL_58:
            v2[43] = 1;
          }
          else
          {
            xmlErrMemory((int)v2, 0);
          }
        }
        else
        {
          if ( v11 < 4 )
            return v108;
          v12 = (char *)v4[4];
          v106[0] = *v12;
          v106[1] = v12[1];
          v13 = v12[2];
          v106[3] = v12[3];
          v106[2] = v13;
          v14 = xmlDetectCharEncoding(v106, 4);
          xmlSwitchEncoding(v2, v14);
        }
        continue;
      case 1:
        xmlSkipBlankChars((int)v2);
        v57 = (_DWORD *)v2[9];
        v58 = (_BYTE *)v57[4];
        if ( *v57 )
          v59 = *(_DWORD *)(*(_DWORD *)(*v57 + 16) + 4);
        else
          v59 = v57[6];
        v60 = v57[3] + v59 - (_DWORD)v58;
        if ( v60 < 2 )
          return v108;
        v61 = (_BYTE *)v57[4];
        v62 = v61[1];
        if ( *v61 != 60 )
          goto LABEL_227;
        if ( v62 == 63 )
        {
          if ( !a1 && sub_42B4D7((int)v2, 63, 0x3Eu, 0) < 0 )
            return v108;
          xmlParsePI(v2);
          goto LABEL_305;
        }
        if ( v62 != 33 )
          goto LABEL_227;
        v63 = v58[2];
        if ( v63 == 45 && v58[3] == 45 )
        {
          if ( !a1 && sub_42B4D7((int)v2, 45, 0x2Du, 0x3Eu) < 0 )
            return v108;
          xmlParseComment(v2);
          v2[43] = 1;
          goto LABEL_305;
        }
        if ( v63 != 68 || v58[3] != 79 || v58[4] != 67 || v58[5] != 84 || v58[6] != 89 || v58[7] != 80 || v58[8] != 69 )
        {
          if ( v60 < 9 )
            return v108;
LABEL_227:
          v2[43] = 6;
          v2[73] = 1;
          goto LABEL_4;
        }
        if ( !a1 && sub_42B4D7((int)v2, 62, 0, 0) < 0 )
          return v108;
        v2[54] = 1;
        xmlParseDocTypeDecl(v2);
        if ( **(_BYTE **)(v2[9] + 16) == 91 )
        {
LABEL_309:
          v2[43] = 3;
          continue;
        }
        v64 = *v2;
        v2[54] = 2;
        if ( v64 )
        {
          if ( !v2[53] )
          {
            v65 = *(void (__cdecl **)(int, int, int, int))(v64 + 104);
            if ( v65 )
              v65(v2[1], v2[55], v2[57], v2[56]);
          }
        }
        v2[54] = 0;
        sub_41F6ED((int)v2);
        goto LABEL_225;
      case 2:
        xmlGenericError(xmlGenericErrorContext, "PP: internal error, state == PI\n");
        goto LABEL_103;
      case 3:
        v78 = (int)&v9[-v10];
        v112 = 0;
        if ( v78 < 0 )
          return 0;
        if ( v2[51] > v78 )
          v78 = v2[51];
        v79 = *(int **)(*v4 + 16);
        v80 = v79[1];
        v81 = *v79;
        v110 = v80;
LABEL_266:
        if ( v78 >= v80 )
          return v108;
        if ( v112 )
        {
          if ( *(_BYTE *)(v81 + v78) == v112 )
            v112 = 0;
          goto LABEL_270;
        }
        v82 = *(_BYTE *)(v81 + v78);
        if ( v82 != 60
          || v78 + 4 >= v80
          || *(_BYTE *)(v81 + v78 + 1) != 33
          || *(_BYTE *)(v81 + v78 + 2) != 45
          || *(_BYTE *)(v81 + v78 + 3) != 45 )
        {
          if ( v82 == 34 )
          {
            v112 = 34;
            goto LABEL_270;
          }
          if ( v82 == 39 )
          {
            v112 = 39;
            goto LABEL_270;
          }
          if ( v82 != 93 )
            goto LABEL_270;
          if ( v78 + 1 >= v80 )
            return v108;
          if ( *(_BYTE *)(v81 + v78 + 1) == 93 )
          {
            ++v78;
            goto LABEL_270;
          }
          v84 = v78 + 1;
          for ( i = (unsigned __int8 *)(v81 + v78 + 1); ; ++i )
          {
            if ( v84 >= v110 )
              return v108;
            v86 = *i;
            if ( *i == 62 )
              break;
            if ( v86 != 32 && (v86 < 9u || v86 > 0xAu) && v86 != 13 )
              goto LABEL_270;
            ++v84;
          }
          sub_4281C3(v2);
          v87 = *v2;
          v2[54] = 2;
          if ( v87 )
          {
            if ( !v2[53] )
            {
              v88 = *(void (__cdecl **)(int, int, int, int))(v87 + 104);
              if ( v88 )
                v88(v2[1], v2[55], v2[57], v2[56]);
            }
          }
          v2[54] = 0;
          sub_41F6ED((int)v2);
          v2[43] = 4;
LABEL_305:
          v2[51] = 0;
          continue;
        }
        if ( v78 + 3 < v80 )
        {
          v111 = (char *)(2 - v81);
          v83 = v81 + v78 + 1;
          while ( *(_BYTE *)(v83 - 1) != 45 || *(_BYTE *)v83 != 45 || *(_BYTE *)(v83 + 1) != 62 )
          {
            ++v78;
            if ( (unsigned int)&v111[++v83] >= *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v2[9] + 16) + 4) )
              return v108;
          }
          v78 += 2;
LABEL_270:
          v80 = v110;
          ++v78;
          goto LABEL_266;
        }
        return v108;
      case 4:
        xmlSkipBlankChars((int)v2);
        v66 = (_DWORD *)v2[9];
        v67 = v66[4];
        if ( *v66 )
          v68 = *(_DWORD *)(*(_DWORD *)(*v66 + 16) + 4);
        else
          v68 = v66[6];
        v69 = v66[3] + v68 - v67;
        if ( v69 < 2 )
          return v108;
        v70 = (_BYTE *)v66[4];
        v71 = v70[1];
        if ( *v70 != 60 )
          goto LABEL_244;
        if ( v71 == 63 )
        {
          if ( !a1 && sub_42B4D7((int)v2, 63, 0x3Eu, 0) < 0 )
            return v108;
          xmlParsePI(v2);
          continue;
        }
        if ( v71 != 33 )
          goto LABEL_244;
        if ( *(_BYTE *)(v67 + 2) == 45 && *(_BYTE *)(v67 + 3) == 45 )
        {
          if ( !a1 && sub_42B4D7((int)v2, 45, 0x2Du, 0x3Eu) < 0 )
            return v108;
          xmlParseComment(v2);
LABEL_225:
          v2[43] = 4;
          continue;
        }
        if ( v69 < 4 )
          return v108;
LABEL_244:
        v22 = v2[73] == 0;
        v2[43] = 6;
        if ( v22 )
          v2[73] = 1;
        goto LABEL_4;
      case 5:
        xmlGenericError(xmlGenericErrorContext, "PP: internal error, state == COMMENT\n");
        goto LABEL_103;
      case 6:
        v25 = v2[82];
        v111 = 0;
        v105 = 0;
        v110 = v25;
        if ( v11 < 2 && v2[10] == 1 )
          return v108;
        if ( *v9 != 60 )
          goto LABEL_320;
        if ( a1 )
          goto LABEL_69;
        if ( v2[73] )
        {
          if ( !v109 || (unsigned int)v9 >= v109 )
            return v108;
        }
        else if ( sub_42B4D7((int)v2, 62, 0, 0) < 0 )
        {
          return v108;
        }
LABEL_69:
        if ( !v2[59] || (v26 = *(_DWORD *)v2[58], v26 == -2) )
          v26 = -1;
        sub_41FE7B(v26, (int)v2);
        if ( v2[81] )
        {
          started = sub_428FDD((int)v2, &v111, &v105, &v104);
        }
        else
        {
          started = xmlParseStartTag(v2);
          v28 = v102;
        }
        v29 = started;
        if ( v2[43] == -1 )
          return v108;
        if ( !started )
        {
          sub_41FEF7(v28, v2);
LABEL_321:
          v90 = *v2;
          v2[43] = -1;
          if ( v90 )
          {
            v91 = *(void (__cdecl **)(int))(v90 + 52);
            if ( v91 )
              v91(v2[1]);
          }
          return v108;
        }
        v30 = v2[9];
        v31 = *(_BYTE **)(v30 + 16);
        if ( *v31 != 47 || v31[1] != 62 )
        {
          if ( *v31 == 62 )
          {
            xmlNextChar(v2);
          }
          else
          {
            sub_41F152((int (__cdecl *)(int, char *, char))0x49, v2, "Couldn't find end of Start Tag %s\n", v29);
            nodePop(v2);
            sub_41FEF7(v37, v2);
          }
          if ( v2[81] )
            sub_41FCA8((int)v29, (int)v2, (int)v111, v105, v2[82] - v110);
          else
            namePush((int)v2, (int)v29);
          goto LABEL_103;
        }
        v2[50] += 2;
        *(_DWORD *)(v30 + 16) += 2;
        *(_DWORD *)(v2[9] + 32) += 2;
        if ( **(_BYTE **)(v2[9] + 16) == 37 )
          xmlParserHandlePEReference(v2);
        v32 = v2[9];
        if ( !**(_BYTE **)(v32 + 16) && xmlParserInputGrow((int *)v32, 250) <= 0 )
          xmlPopInput(v2);
        v33 = *v2;
        v34 = 0;
        if ( v2[81] )
        {
          if ( v33 )
          {
            v35 = *(void (__cdecl **)(int, unsigned __int8 *, char *, int))(v33 + 120);
            if ( v35 )
            {
              if ( !v2[53] )
                v35(v2[1], v29, v111, v105);
            }
          }
          if ( (int)(v2[82] - v110) > 0 )
            sub_41FA49(v2[82] - v110, (int)v2);
        }
        else if ( v33 )
        {
          v36 = *(void (__cdecl **)(int, unsigned __int8 *))(v33 + 60);
          if ( v36 )
          {
            if ( !v2[53] )
            {
              v36(v2[1], v29);
              v34 = v103;
            }
          }
        }
        sub_41FEF7(v34, v2);
LABEL_96:
        v2[43] = v2[47] != 0 ? 7 : 14;
        continue;
      case 7:
        if ( v11 < 2 && v2[10] == 1 )
          return v108;
        v38 = (char *)v4[4];
        v112 = *v38;
        v39 = v4[9];
        v111 = v38;
        v40 = v38[1];
        v110 = v39;
        if ( v112 != 60 )
          goto LABEL_135;
        if ( v40 == 47 )
        {
          v2[43] = 9;
          continue;
        }
        if ( v40 == 63 )
        {
          if ( !a1 && sub_42B4D7((int)v2, 63, 0x3Eu, 0) < 0 )
            return v108;
          xmlParsePI(v2);
LABEL_150:
          while ( !**(_BYTE **)(v2[9] + 16) && v2[10] > 1 )
            xmlPopInput(v2);
          v44 = v2[9];
          if ( v110 == *(_DWORD *)(v44 + 36) && v111 == *(char **)(v44 + 16) )
          {
            sub_41EC3F(1, v2, "detected an error in element content\n");
            v2[43] = -1;
          }
          continue;
        }
        if ( v40 != 33 )
        {
LABEL_316:
          v2[43] = 6;
          continue;
        }
        v41 = v9[2];
        if ( v41 == 45 && v9[3] == 45 )
        {
          if ( v11 < 4 )
            return v108;
          v4[4] += 4;
          v42 = sub_42B4D7((int)v2, 45, 0x2Du, 0x3Eu);
          *(_DWORD *)(v2[9] + 16) -= 4;
          if ( !a1 && v42 < 0 )
            return v108;
          xmlParseComment(v2);
          v2[43] = 7;
          goto LABEL_150;
        }
        if ( v9[1] != 33
          || v41 != 91
          || v9[3] != 67
          || v9[4] != 68
          || v9[5] != 65
          || v9[6] != 84
          || v9[7] != 65
          || v9[8] != 91 )
        {
          if ( v11 < 9 )
            return v108;
LABEL_135:
          if ( v112 == 38 )
          {
            if ( !a1 && sub_42B4D7((int)v2, 59, 0, 0) < 0 )
              return v108;
            xmlParseReference((int)v2);
          }
          else
          {
            if ( v2[10] == 1 && v11 < 300 && !a1 )
            {
              if ( v2[73] )
              {
                if ( !v107 || (unsigned int)v9 > v107 )
                  return v108;
              }
              else if ( sub_42B4D7((int)v2, 60, 0, 0) < 0 )
              {
                return v108;
              }
            }
            v2[51] = 0;
            xmlParseCharData(v2, 0);
          }
          goto LABEL_150;
        }
        v2[50] += 9;
        v4[4] += 9;
        *(_DWORD *)(v2[9] + 32) += 9;
        if ( **(_BYTE **)(v2[9] + 16) == 37 )
          xmlParserHandlePEReference(v2);
        v43 = v2[9];
        if ( !**(_BYTE **)(v43 + 16) && xmlParserInputGrow((int *)v43, 250) <= 0 )
          xmlPopInput(v2);
        v2[43] = 8;
        continue;
      case 8:
        v46 = (char *)sub_42B4D7((int)v2, 93, 0x5Du, 0x3Eu);
        v111 = v46;
        if ( (int)v46 < 0 )
        {
          if ( v11 < 302 )
            return v108;
          v92 = v2[9];
          v93 = *(_DWORD *)(v92 + 16);
          v94 = sub_42B64B(v93, 300);
          v95 = v94;
          v110 = v94;
          if ( v94 >= 0 )
          {
            v96 = *v2;
            if ( *v2 && !v2[53] )
            {
              v97 = *(void (__cdecl **)(int, int, int))(v96 + 100);
              if ( v97 )
              {
                v97(v2[1], v93, v95);
              }
              else
              {
                v98 = *(void (__cdecl **)(int, int, int))(v96 + 68);
                if ( v98 )
                  v98(v2[1], v93, v95);
              }
            }
            v99 = v110;
            if ( (int)v110 > 0 )
            {
              do
              {
                v100 = v2[9];
                if ( **(_BYTE **)(v100 + 16) == 10 )
                {
                  ++*(_DWORD *)(v100 + 28);
                  *(_DWORD *)(v2[9] + 32) = 1;
                }
                else
                {
                  ++*(_DWORD *)(v100 + 32);
                }
                ++v2[50];
                ++*(_DWORD *)(v2[9] + 16);
                --v99;
              }
              while ( v99 );
            }
            if ( **(_BYTE **)(v2[9] + 16) == 37 )
              xmlParserHandlePEReference(v2);
            v101 = v2[9];
            if ( !**(_BYTE **)(v101 + 16) && xmlParserInputGrow((int *)v101, 250) <= 0 )
              xmlPopInput(v2);
            v2[51] = 0;
            return v108;
          }
          *(_DWORD *)(v92 + 16) -= v94;
          goto LABEL_347;
        }
        v47 = v2[9];
        v48 = *(_DWORD *)(v47 + 16);
        v49 = sub_42B64B(v48, (int)v46);
        if ( v49 < 0 || (char *)v49 != v111 )
        {
          *(_DWORD *)(v2[9] + 16) -= v49;
LABEL_347:
          _snprintf(
            Buffer,
            0x95u,
            "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",
            **(unsigned __int8 **)(v2[9] + 16),
            *(unsigned __int8 *)(*(_DWORD *)(v2[9] + 16) + 1),
            *(unsigned __int8 *)(*(_DWORD *)(v2[9] + 16) + 2),
            *(unsigned __int8 *)(*(_DWORD *)(v2[9] + 16) + 3));
          _xmlErrEncoding(
            v2,
            (int (__cdecl *)(int, char *, char))9,
            "Input is not proper UTF-8, indicate encoding !\n%s",
            Buffer,
            0);
          return 0;
        }
        v50 = *v2;
        if ( *v2 )
        {
          v51 = (int)v111 <= 0;
          if ( v111 )
            goto LABEL_177;
          if ( !*(_DWORD *)(v50 + 100) || v2[53] )
          {
            v51 = (int)v111 <= 0;
LABEL_177:
            if ( !v51 && !v2[53] )
            {
              v52 = *(void (__cdecl **)(int, int, char *))(v50 + 100);
              if ( v52 )
              {
                v52(v2[1], v48, v111);
              }
              else
              {
                v53 = *(void (__cdecl **)(int, int, char *))(v50 + 68);
                if ( v53 )
                  v53(v2[1], v48, v111);
              }
            }
            goto LABEL_183;
          }
          if ( v48 - *(_DWORD *)(v47 + 12) >= 9 && !strncmp((const char *)(v48 - 9), "<![CDATA[", 9u) )
            (*(void (__cdecl **)(int, const char *, _DWORD))(*v2 + 100))(v2[1], byte_47627C, 0);
        }
LABEL_183:
        if ( (int)(v111 + 3) > 0 )
        {
          v54 = v111 + 3;
          do
          {
            v55 = v2[9];
            if ( **(_BYTE **)(v55 + 16) == 10 )
            {
              ++*(_DWORD *)(v55 + 28);
              *(_DWORD *)(v2[9] + 32) = 1;
            }
            else
            {
              ++*(_DWORD *)(v55 + 32);
            }
            ++v2[50];
            ++*(_DWORD *)(v2[9] + 16);
            --v54;
          }
          while ( v54 );
        }
        if ( **(_BYTE **)(v2[9] + 16) == 37 )
          xmlParserHandlePEReference(v2);
        v56 = v2[9];
        if ( !**(_BYTE **)(v56 + 16) && xmlParserInputGrow((int *)v56, 250) <= 0 )
          xmlPopInput(v2);
        v2[51] = 0;
LABEL_103:
        v2[43] = 7;
        continue;
      case 9:
        if ( v11 < 2 )
          return v108;
        if ( a1 )
          goto LABEL_161;
        if ( v2[73] )
        {
          if ( !v109 || (unsigned int)v9 >= v109 )
            return v108;
        }
        else if ( sub_42B4D7((int)v2, 62, 0, 0) < 0 )
        {
          return v108;
        }
LABEL_161:
        if ( v2[81] )
        {
          v45 = v2[86] + 12 * v2[47];
          sub_429A1C((int)v2, *(unsigned __int8 **)(v45 - 12), *(_DWORD *)(v45 - 8), 0, *(_DWORD *)(v45 - 4), 0);
          sub_41FD84(v2);
        }
        else
        {
          sub_4286F2((int)v2, 0);
        }
        if ( v2[43] != -1 )
          goto LABEL_96;
        continue;
      case 10:
        xmlGenericError(xmlGenericErrorContext, "PP: internal error, state == ENTITY_DECL\n");
        goto LABEL_309;
      case 11:
        xmlGenericError(xmlGenericErrorContext, "PP: internal error, state == ENTITY_VALUE\n");
        goto LABEL_103;
      case 12:
        xmlGenericError(xmlGenericErrorContext, "PP: internal error, state == ATTRIBUTE_VALUE\n");
        goto LABEL_316;
      case 13:
        xmlGenericError(xmlGenericErrorContext, "PP: internal error, state == SYSTEM_LITERAL\n");
        goto LABEL_316;
      case 14:
        xmlSkipBlankChars((int)v2);
        v72 = (_DWORD *)v2[9];
        v73 = v72[4];
        if ( *v72 )
          v74 = *(_DWORD *)(*(_DWORD *)(*v72 + 16) + 4);
        else
          v74 = v72[6];
        v75 = v72[3] + v74 - v73;
        if ( v75 < 2 )
          return v108;
        v76 = (_BYTE *)v72[4];
        v77 = v76[1];
        if ( *v76 != 60 )
          goto LABEL_349;
        if ( v77 == 63 )
        {
          if ( !a1 && sub_42B4D7((int)v2, 63, 0x3Eu, 0) < 0 )
            return v108;
          xmlParsePI(v2);
        }
        else
        {
          if ( v77 != 33 )
            goto LABEL_349;
          if ( *(_BYTE *)(v73 + 2) != 45 || *(_BYTE *)(v73 + 3) != 45 )
          {
            if ( v75 < 4 )
              return v108;
LABEL_349:
            sub_41EC3F(5, v2, 0);
            goto LABEL_321;
          }
          if ( !a1 && sub_42B4D7((int)v2, 45, 0x2Du, 0x3Eu) < 0 )
            return v108;
          xmlParseComment(v2);
        }
        v2[43] = 14;
        continue;
      case 15:
        xmlGenericError(xmlGenericErrorContext, "PP: internal error, state == IGNORE");
        goto LABEL_309;
      case 16:
        xmlGenericError(xmlGenericErrorContext, "PP: internal error, state == PUBLIC_LITERAL\n");
        goto LABEL_316;
      default:
        continue;
    }
  }
}
// 42B8C8: variable 'Block' is possibly undefined
// 42BC14: variable 'v102' is possibly undefined
// 42BCE8: variable 'v103' is possibly undefined
// 42BCEB: variable 'v34' is possibly undefined
// 42BD34: variable 'v37' is possibly undefined
// 42C6CF: variable 'v28' is possibly undefined
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);
// 4A4C28: using guessed type int (*xmlDefaultSAXLocator)();

//----- (0042C852) --------------------------------------------------------
int __cdecl xmlParseChunk(int *Block, _BYTE *Src, int a3, int a4)
{
  int result; // eax
  int *v6; // eax
  int v7; // esi
  int v8; // edi
  unsigned __int8 **v9; // eax
  unsigned int v10; // ecx
  unsigned int v11; // eax
  _DWORD *v12; // eax
  _DWORD *v13; // eax
  int v14; // ecx
  _DWORD *v15; // edx
  unsigned __int8 **v16; // eax
  int *v17; // eax
  _DWORD *v18; // eax
  int v19; // esi
  int v20; // esi
  int v21; // eax
  void (__cdecl *v22)(int); // eax
  int v23; // [esp+8h] [ebp-Ch]
  int v24; // [esp+Ch] [ebp-8h]
  int v25; // [esp+10h] [ebp-4h]
  int v26; // [esp+10h] [ebp-4h]
  unsigned __int8 *Blocka; // [esp+1Ch] [ebp+8h]

  v24 = 0;
  v25 = 0;
  if ( !Block )
    return 1;
  result = Block[21];
  if ( !result || Block[53] != 1 )
  {
    if ( !Block[43] )
      sub_41F321((int)Block);
    if ( a3 <= 0 )
      goto LABEL_33;
    if ( Src && !a4 && Src[a3 - 1] == 13 )
    {
      --a3;
      v24 = 1;
    }
    while ( 1 )
    {
      if ( a3 > 0 )
      {
        if ( Src )
        {
          v6 = (int *)Block[9];
          if ( v6 )
          {
            if ( *v6 )
              break;
          }
        }
      }
LABEL_33:
      if ( Block[43] == -1
        || (v12 = (_DWORD *)Block[9]) == 0
        || !*v12
        || (v13 = (_DWORD *)*v12, (v14 = v13[3]) == 0)
        || (v15 = (_DWORD *)v13[4]) == 0
        || (v16 = (unsigned __int8 **)v13[5]) == 0 )
      {
LABEL_42:
        sub_42B8AE(a4);
        goto LABEL_43;
      }
      if ( xmlCharEncInFunc(v14, v15, v16) < 0 )
      {
        xmlGenericError(xmlGenericErrorContext, "xmlParseChunk: encoder error\n");
        return 81;
      }
LABEL_40:
      if ( !v25 )
        goto LABEL_42;
      sub_42B8AE(0);
LABEL_43:
      if ( Block[21] && Block[53] == 1 )
        return Block[21];
      if ( !v25 )
      {
        if ( v24 == 1 )
        {
          v17 = (int *)Block[9];
          if ( v17 )
          {
            if ( *v17 )
              xmlParserInputBufferPush(*v17, 1, "\r");
          }
        }
        if ( a4 )
        {
          v18 = (_DWORD *)Block[9];
          v19 = 0;
          if ( v18 )
          {
            if ( *v18 )
              v20 = *(_DWORD *)(*(_DWORD *)(*v18 + 16) + 4);
            else
              v20 = v18[6];
            v19 = v18[3] + v20 - v18[4];
          }
          v21 = Block[43];
          if ( v21 != -1 && v21 != 14 )
            sub_41EC3F(5, Block, 0);
          if ( Block[43] == 14 && v19 > 0 )
            sub_41EC3F(5, Block, 0);
          if ( Block[43] != -1 && *Block )
          {
            v22 = *(void (__cdecl **)(int))(*Block + 52);
            if ( v22 )
              v22(Block[1]);
          }
          Block[43] = -1;
        }
        return Block[21];
      }
      Src += a3;
      a3 = v25;
      v25 = 0;
    }
    if ( Block[43] == -1 )
      goto LABEL_42;
    v7 = *v6;
    v8 = v6[4] - v6[3];
    v23 = v6[3] - **(_DWORD **)(*v6 + 16);
    if ( Block[43] || (v9 = *(unsigned __int8 ***)(v7 + 12)) == 0 )
    {
LABEL_31:
      if ( xmlParserInputBufferPush(v7, a3, Src) < 0 )
      {
        result = -1;
        Block[21] = -1;
        Block[53] = 1;
        return result;
      }
      *(_DWORD *)(Block[9] + 12) = v23 + **(_DWORD **)(*(_DWORD *)Block[9] + 16);
      *(_DWORD *)(Block[9] + 16) = v8 + *(_DWORD *)(Block[9] + 12);
      *(_DWORD *)(Block[9] + 20) = **(_DWORD **)(*(_DWORD *)Block[9] + 16)
                                 + *(_DWORD *)(*(_DWORD *)(*(_DWORD *)Block[9] + 16) + 4);
      goto LABEL_40;
    }
    v26 = 45;
    Blocka = *v9;
    if ( xmlStrcasestr(*v9, "UTF-16") || xmlStrcasestr(Blocka, "UTF16") )
    {
      v26 = 90;
    }
    else if ( xmlStrcasestr(Blocka, "UCS-4") || xmlStrcasestr(Blocka, "UCS4") )
    {
      v10 = 180;
LABEL_26:
      v11 = *(_DWORD *)(v7 + 32);
      if ( v11 < v10 )
        v10 -= v11;
      if ( a3 <= v10 )
      {
        v25 = 0;
      }
      else
      {
        v25 = a3 - v10;
        a3 = v10;
      }
      goto LABEL_31;
    }
    v10 = v26;
    goto LABEL_26;
  }
  return result;
}
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);

//----- (0042CB31) --------------------------------------------------------
int *__cdecl xmlCreatePushParserCtxt(_DWORD *a1, int a2, char *Src, int a4, char *Source)
{
  int **v5; // edi
  int *v7; // ebx
  int v8; // eax
  void *v9; // eax
  int ***v10; // eax
  int ***v11; // esi
  int *v12; // eax
  int v13; // edx
  int v14; // edi
  int v15; // esi
  int **v16; // eax
  int v17; // [esp-8h] [ebp-18h]
  int v18; // [esp-8h] [ebp-18h]
  int v19; // [esp+Ch] [ebp-4h]

  v19 = 0;
  if ( Src && a4 >= 4 )
    v19 = xmlDetectCharEncoding(Src, a4);
  v5 = (int **)xmlAllocParserInputBuffer(v19);
  if ( !v5 )
    return 0;
  v7 = xmlNewParserCtxt();
  if ( !v7 )
  {
    xmlErrMemory(0, "creating parser: out of memory\n");
    xmlFreeParserInputBuffer(v5);
    return 0;
  }
  v17 = 12 * v7[48];
  v7[91] = 1;
  v8 = xmlMalloc(v17);
  v7[86] = v8;
  if ( !v8 )
  {
LABEL_13:
    xmlErrMemory((int)v7, 0);
    xmlFreeParserInputBuffer(v5);
    xmlFreeParserCtxt(v7);
    return 0;
  }
  if ( a1 )
  {
    if ( (int (__cdecl **)(int, int, int, int))*v7 != &xmlDefaultSAXHandler )
      ((void (__cdecl *)(int))xmlFree)(*v7);
    v9 = (void *)xmlMalloc(128);
    *v7 = (int)v9;
    if ( !v9 )
      goto LABEL_13;
    memset(v9, 0, 0x80u);
    if ( a1[27] == -554844497 )
      v18 = 32;
    else
      v18 = 28;
    qmemcpy((void *)*v7, a1, 4 * v18);
    if ( a2 )
      v7[1] = a2;
  }
  if ( Source )
    v7[45] = xmlParserGetDirectory(Source);
  else
    v7[45] = 0;
  v10 = (int ***)xmlNewInputStream((int)v7);
  v11 = v10;
  if ( !v10 )
    goto LABEL_31;
  if ( !Source )
  {
    v10[1] = 0;
    goto LABEL_25;
  }
  v16 = (int **)xmlCanonicPath(Source);
  v11[1] = v16;
  if ( !v16 )
  {
LABEL_31:
    xmlFreeParserCtxt(v7);
    xmlFreeParserInputBuffer(v5);
    return 0;
  }
LABEL_25:
  *v11 = v5;
  v11[3] = (int **)*v5[4];
  v11[4] = (int **)*v5[4];
  v11[5] = (int **)(*v5[4] + v5[4][1]);
  inputPush((int)v7, v11);
  if ( a4 && Src )
  {
    v12 = (int *)v7[9];
    if ( v12 && *v12 )
    {
      v13 = v12[3];
      v14 = v13 - **(_DWORD **)(*v12 + 16);
      v15 = v12[4] - v13;
      xmlParserInputBufferPush(*v12, a4, Src);
      *(_DWORD *)(v7[9] + 12) = v14 + **(_DWORD **)(*(_DWORD *)v7[9] + 16);
      *(_DWORD *)(v7[9] + 16) = v15 + *(_DWORD *)(v7[9] + 12);
      *(_DWORD *)(v7[9] + 20) = **(_DWORD **)(*(_DWORD *)v7[9] + 16)
                              + *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v7[9] + 16) + 4);
    }
  }
  else
  {
    v7[64] = 0;
  }
  if ( v19 )
    xmlSwitchEncoding(v7, v19);
  return v7;
}
// 496494: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A4BB8: using guessed type int (__cdecl *xmlDefaultSAXHandler)(int, int, int, int);

//----- (0042CD41) --------------------------------------------------------
_DWORD *__cdecl xmlStopParser(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // ecx

  result = a1;
  if ( a1 )
  {
    v2 = a1[9];
    a1[43] = -1;
    a1[53] = 1;
    if ( v2 )
    {
      *(_DWORD *)(v2 + 16) = byte_47627C;
      result = (_DWORD *)a1[9];
      result[3] = result[4];
    }
  }
  return result;
}

//----- (0042CD72) --------------------------------------------------------
int *__cdecl xmlCreateIOParserCtxt(_DWORD *a1, int a2, void *Block, void (__cdecl *a4)(int), int a5, int a6)
{
  int *v7; // ebx
  void *v8; // eax
  int ***v9; // eax
  int v10; // [esp-10h] [ebp-10h]
  int **Blocka; // [esp+10h] [ebp+10h]

  if ( !Block )
    return 0;
  Blocka = (int **)xmlParserInputBufferCreateIO((int)Block, (int)a4, a5, a6);
  if ( !Blocka )
  {
    if ( a4 )
      a4(a5);
    return 0;
  }
  v7 = xmlNewParserCtxt();
  if ( !v7 )
  {
    xmlFreeParserInputBuffer(Blocka);
    return 0;
  }
  if ( a1 )
  {
    if ( (int (__cdecl **)(int, int, int, int))*v7 != &xmlDefaultSAXHandler )
      ((void (__cdecl *)(int))xmlFree)(*v7);
    v8 = (void *)xmlMalloc(128);
    *v7 = (int)v8;
    if ( !v8 )
    {
      xmlErrMemory((int)v7, 0);
      xmlFreeParserCtxt(v7);
      return 0;
    }
    memset(v8, 0, 0x80u);
    if ( a1[27] == -554844497 )
      v10 = 32;
    else
      v10 = 28;
    qmemcpy((void *)*v7, a1, 4 * v10);
    if ( a2 )
      v7[1] = a2;
  }
  v9 = (int ***)xmlNewIOInputStream(v7, (int)Blocka, a6);
  if ( v9 )
  {
    inputPush((int)v7, v9);
    return v7;
  }
  else
  {
    xmlFreeParserCtxt(v7);
    return 0;
  }
}
// 496494: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A4BB8: using guessed type int (__cdecl *xmlDefaultSAXHandler)(int, int, int, int);

//----- (0042CE5C) --------------------------------------------------------
int __cdecl xmlParseCtxtExternalEntity(int a1, char *a2, int a3, _DWORD *a4)
{
  int v4; // ebx
  int v6; // eax
  int *v7; // eax
  int *v8; // esi
  _DWORD *v9; // eax
  int v10; // edi
  int v11; // eax
  int v12; // eax
  char *v13; // eax
  int v14; // ebx
  int v15; // eax
  int v16; // eax
  int v17; // eax
  _BYTE *v18; // eax
  unsigned __int8 v19; // al
  int v20; // eax
  void **v21; // eax
  unsigned __int8 *v22; // eax
  unsigned __int8 *v23; // eax
  _BYTE *v24; // eax
  int v25; // eax
  int v26; // eax
  _DWORD *v27; // [esp-20h] [ebp-38h]
  _DWORD *v28; // [esp-14h] [ebp-2Ch]
  _DWORD *v29; // [esp-8h] [ebp-20h]
  _DWORD *v30; // [esp+0h] [ebp-18h]
  _DWORD *v31; // [esp+10h] [ebp-8h]
  int v32; // [esp+14h] [ebp-4h]

  v4 = a1;
  if ( !a1 )
    return -1;
  v6 = *(_DWORD *)(a1 + 248);
  if ( v6 > 40 && (*(_DWORD *)(a1 + 360) & 0x80000) == 0 || v6 > 1024 )
    return 89;
  if ( a4 )
    *a4 = 0;
  if ( !a2 && !a3 || !*(_DWORD *)(v4 + 8) )
    return -1;
  v7 = sub_42DF6E(v4, a2, a3, 0);
  v8 = v7;
  if ( !v7 )
    return -1;
  v32 = *v7;
  *v7 = *(_DWORD *)v4;
  sub_41F321((int)v7);
  v9 = xmlNewDoc("1.0");
  v10 = (int)v9;
  v31 = v9;
  if ( !v9 )
  {
    xmlFreeParserCtxt(v8);
    return -1;
  }
  v9[23] = 64;
  v11 = *(_DWORD *)(*(_DWORD *)(v4 + 8) + 80);
  if ( v11 )
  {
    v30 = *(_DWORD **)(*(_DWORD *)(v4 + 8) + 80);
    *(_DWORD *)(v10 + 80) = v11;
    xmlDictReference(v30);
  }
  v12 = *(_DWORD *)(v4 + 8);
  if ( v12 )
  {
    *(_DWORD *)(v10 + 44) = *(_DWORD *)(v12 + 44);
    *(_DWORD *)(v10 + 48) = *(_DWORD *)(*(_DWORD *)(v4 + 8) + 48);
  }
  if ( *(_DWORD *)(*(_DWORD *)(v4 + 8) + 72) )
    *(_DWORD *)(v10 + 72) = xmlStrdup(*(_BYTE **)(*(_DWORD *)(v4 + 8) + 72));
  v13 = (char *)xmlNewDocNode(v10, 0, "pseudoroot", 0);
  if ( v13 )
  {
    xmlAddChild((char *)v10, v13);
    nodePush((int)v8, *(_DWORD *)(v10 + 12));
    v15 = *(_DWORD *)(v4 + 8);
    if ( v15 )
    {
      v8[2] = v15;
      *(_DWORD *)(*(_DWORD *)(v10 + 12) + 32) = *(_DWORD *)(v4 + 8);
    }
    else
    {
      v8[2] = v10;
    }
    if ( !v8[73] && *(_DWORD *)(v8[9] + 20) - *(_DWORD *)(v8[9] + 16) < 250 )
      sub_41FF5D((int)v8);
    v16 = v8[9];
    if ( *(_DWORD *)(v16 + 20) - *(_DWORD *)(v16 + 16) >= 4 )
    {
      a1 = **(_DWORD **)(v16 + 16);
      v17 = xmlDetectCharEncoding((char *)&a1, 4);
      if ( v17 )
        xmlSwitchEncoding(v8, v17);
    }
    v18 = *(_BYTE **)(v8[9] + 16);
    if ( *v18 == 60 && v18[1] == 63 && v18[2] == 120 && v18[3] == 109 && v18[4] == 108 )
    {
      if ( (v19 = v18[5], v19 == 32) || v19 >= 9u && v19 <= 0xAu || v19 == 13 )
      {
        xmlParseTextDecl(v8);
        if ( xmlStrEqual(*(char **)(v4 + 20), "1.0") )
        {
          if ( !xmlStrEqual(*(char **)(v8[9] + 48), "1.0") )
          {
            sub_41EFC6((int (__cdecl *)(int, char *, char))0x6D, v8, "Version mismatch between document and entity\n");
            v10 = (int)v31;
          }
        }
      }
    }
    v20 = *(_DWORD *)(v4 + 4);
    if ( v20 == v4 )
      v8[1] = (int)v8;
    else
      v8[1] = v20;
    v8[43] = 7;
    v8[26] = *(_DWORD *)(v4 + 104);
    v8[25] = *(_DWORD *)(v4 + 100);
    v8[69] = *(_DWORD *)(v4 + 276);
    v8[62] = *(_DWORD *)(v4 + 248) + 1;
    v8[4] = *(_DWORD *)(v4 + 16);
    if ( v8[26] )
    {
      v8[28] = *(_DWORD *)(v4 + 112);
      v8[29] = *(_DWORD *)(v4 + 116);
    }
    else
    {
      v8[28] = 0;
      v8[29] = 0;
    }
    v21 = (void **)v8[74];
    v8[33] = 0;
    v8[31] = 0;
    v8[32] = 0;
    v8[30] = 0;
    if ( v21 )
      xmlDictFree(v21);
    v29 = *(_DWORD **)(v4 + 296);
    v8[74] = (int)v29;
    v22 = xmlDictLookup(v29, "xml", 3);
    v28 = (_DWORD *)v8[74];
    v8[78] = (int)v22;
    v23 = xmlDictLookup(v28, "xmlns", 5);
    v27 = (_DWORD *)v8[74];
    v8[79] = (int)v23;
    v8[80] = (int)xmlDictLookup(v27, "http://www.w3.org/XML/1998/namespace", 36);
    v8[91] = *(_DWORD *)(v4 + 364);
    v8[87] = *(_DWORD *)(v4 + 348);
    v8[88] = *(_DWORD *)(v4 + 352);
    v8[70] = *(_DWORD *)(v4 + 280);
    xmlParseContent(v8);
    *(_DWORD *)(v4 + 104) = v8[26];
    *(_DWORD *)(v4 + 100) = v8[25];
    v24 = *(_BYTE **)(v8[9] + 16);
    if ( *v24 == 60 && v24[1] == 47 )
    {
      sub_41EC3F(85, v8, 0);
    }
    else if ( *v24 )
    {
      sub_41EC3F(86, v8, 0);
    }
    if ( v8[13] != *(_DWORD *)(v10 + 12) )
      sub_41EC3F(85, v8, 0);
    if ( v8[3] )
    {
      if ( a4 )
      {
        v26 = *(_DWORD *)(*(_DWORD *)(v10 + 12) + 12);
        *a4 = v26;
        while ( v26 )
        {
          *(_DWORD *)(v26 + 20) = 0;
          v26 = *(_DWORD *)(v26 + 24);
        }
        *(_DWORD *)(*(_DWORD *)(v10 + 12) + 12) = 0;
      }
      v25 = 0;
    }
    else
    {
      v25 = v8[21];
      if ( !v25 )
        v25 = 1;
    }
    *v8 = v32;
    v8[74] = 0;
    v8[87] = 0;
    v8[88] = 0;
    v14 = v25;
  }
  else
  {
    *v8 = v32;
    v14 = -1;
  }
  xmlFreeParserCtxt(v8);
  *(_DWORD *)(v10 + 44) = 0;
  *(_DWORD *)(v10 + 48) = 0;
  xmlFreeDoc((void *)v10);
  return v14;
}

//----- (0042D227) --------------------------------------------------------
int __usercall sub_42D227@<eax>(int a1@<eax>, _DWORD *a2, int a3, int a4, int a5, char *a6, int a7, _DWORD *a8)
{
  int *v10; // eax
  int *v11; // esi
  int v12; // edx
  char *v13; // edi
  char *v14; // eax
  int v15; // ebx
  int v16; // eax
  int v17; // eax
  int v18; // eax
  _BYTE *v19; // eax
  unsigned __int8 v20; // al
  _BYTE *v21; // eax
  int v22; // eax
  int v23; // ecx
  _DWORD *v24; // [esp-8h] [ebp-18h]
  int v25; // [esp+8h] [ebp-8h]
  char *v26; // [esp+Ch] [ebp-4h] BYREF
  int v27; // [esp+24h] [ebp+14h]

  v25 = 0;
  if ( a5 > 40 && (!a2 || (a2[90] & 0x80000) == 0) || a5 > 1024 )
    return 89;
  if ( a8 )
    *a8 = 0;
  if ( !a6 && !a7 || !a1 )
    return 1;
  v10 = sub_42DF6E((int)a2, a6, a7, 0);
  v11 = v10;
  if ( !v10 )
    return 27;
  v10[1] = (int)v10;
  if ( a2 )
  {
    v10[68] = a2[68];
    v10[69] = a2[69];
    v10[26] = a2[26];
    v10[24] = a2[24];
    v10[17] = a2[17];
    v10[18] = a2[18];
    v10[19] = a2[19];
    v10[20] = a2[20];
  }
  else
  {
    v10[68] = 0;
    v10[26] = 0;
    v10[24] = 2;
    v10[69] = 0;
  }
  if ( a3 )
  {
    v12 = *v10;
    *v10 = a3;
    v25 = v12;
    if ( a4 )
      v10[1] = a4;
  }
  sub_41F321((int)v10);
  v13 = (char *)xmlNewDoc("1.0");
  if ( v13 )
  {
    *((_DWORD *)v13 + 23) = 64;
    *((_DWORD *)v13 + 11) = *(_DWORD *)(a1 + 44);
    *((_DWORD *)v13 + 12) = *(_DWORD *)(a1 + 48);
    v24 = *(_DWORD **)(a1 + 80);
    *((_DWORD *)v13 + 20) = v24;
    xmlDictReference(v24);
    if ( *(_DWORD *)(a1 + 72) )
      *((_DWORD *)v13 + 18) = xmlStrdup(*(_BYTE **)(a1 + 72));
    v14 = (char *)xmlNewDocNode((int)v13, 0, "pseudoroot", 0);
    v26 = v14;
    if ( v14 )
    {
      xmlAddChild(v13, v14);
      nodePush((int)v11, *((_DWORD *)v13 + 3));
      v16 = (int)v26;
      v11[2] = a1;
      *(_DWORD *)(v16 + 32) = a1;
      if ( !v11[73] && *(_DWORD *)(v11[9] + 20) - *(_DWORD *)(v11[9] + 16) < 250 )
        sub_41FF5D((int)v11);
      v17 = v11[9];
      if ( *(_DWORD *)(v17 + 20) - *(_DWORD *)(v17 + 16) >= 4 )
      {
        v26 = **(char ***)(v17 + 16);
        v18 = xmlDetectCharEncoding((char *)&v26, 4);
        if ( v18 )
          xmlSwitchEncoding(v11, v18);
      }
      v19 = *(_BYTE **)(v11[9] + 16);
      if ( *v19 == 60 && v19[1] == 63 && v19[2] == 120 && v19[3] == 109 && v19[4] == 108 )
      {
        if ( (v20 = v19[5], v20 == 32) || v20 >= 9u && v20 <= 0xAu || v20 == 13 )
          xmlParseTextDecl(v11);
      }
      v11[43] = 7;
      v11[62] = a5;
      xmlParseContent(v11);
      v21 = *(_BYTE **)(v11[9] + 16);
      if ( *v21 == 60 && v21[1] == 47 )
      {
        sub_41EC3F(85, v11, 0);
      }
      else if ( *v21 )
      {
        sub_41EC3F(86, v11, 0);
      }
      if ( v11[13] != *((_DWORD *)v13 + 3) )
        sub_41EC3F(85, v11, 0);
      if ( v11[3] )
      {
        if ( a8 )
        {
          v22 = *(_DWORD *)(*((_DWORD *)v13 + 3) + 12);
          *a8 = v22;
          while ( v22 )
          {
            *(_DWORD *)(v22 + 20) = 0;
            v22 = *(_DWORD *)(v22 + 24);
          }
          *(_DWORD *)(*((_DWORD *)v13 + 3) + 12) = 0;
        }
        v27 = 0;
      }
      else if ( v11[21] )
      {
        v27 = v11[21];
      }
      else
      {
        v27 = 1;
      }
      if ( a2 )
        a2[110] += v11[110];
      v23 = v11[9];
      if ( v23 )
      {
        a2[111] += *(_DWORD *)(v23 + 36);
        a2[111] += *(_DWORD *)(v11[9] + 16) - *(_DWORD *)(v11[9] + 12);
      }
      if ( v11[97] )
        xmlCopyError((int)(v11 + 96), a2 + 96);
      if ( a3 )
        *v11 = v25;
      a2[18] = v11[18];
      a2[19] = v11[19];
      a2[20] = v11[20];
      v15 = v27;
      v11[18] = 0;
      v11[19] = 0;
      v11[20] = 0;
    }
    else
    {
      if ( a3 )
        *v11 = v25;
      v11[18] = 0;
      v11[19] = 0;
      v11[20] = 0;
      v15 = 1;
    }
    xmlFreeParserCtxt(v11);
    *((_DWORD *)v13 + 11) = 0;
    *((_DWORD *)v13 + 12) = 0;
    xmlFreeDoc(v13);
    return v15;
  }
  else
  {
    v11[18] = 0;
    v11[19] = 0;
    v11[20] = 0;
    xmlFreeParserCtxt(v11);
    return 1;
  }
}

//----- (0042D58D) --------------------------------------------------------
int __cdecl xmlParseExternalEntity(int a1, int a2, int a3, int a4, char *a5, int a6, _DWORD *a7)
{
  return sub_42D227(a1, 0, a2, a3, a4, a5, a6, a7);
}

//----- (0042D5B1) --------------------------------------------------------
int __cdecl xmlParseBalancedChunkMemory(_DWORD *a1, int a2, int a3, int a4, _BYTE *a5, _DWORD *a6)
{
  return xmlParseBalancedChunkMemoryRecover(a1, a2, a3, a4, a5, a6, 0);
}

//----- (0042D5D2) --------------------------------------------------------
int __usercall sub_42D5D2@<eax>(int *a1@<eax>, _BYTE *a2, int a3, _DWORD *a4)
{
  int v5; // eax
  int v7; // eax
  int *MemoryParserCtxt; // esi
  unsigned __int8 *v9; // eax
  unsigned __int8 *v10; // eax
  int v11; // eax
  _DWORD *v12; // eax
  char *v13; // eax
  int v14; // eax
  _BYTE *v15; // eax
  int v16; // eax
  int v17; // eax
  _DWORD *v18; // [esp-28h] [ebp-44h]
  _DWORD *v19; // [esp-1Ch] [ebp-38h]
  _DWORD *v20; // [esp-10h] [ebp-2Ch]
  _DWORD *v21; // [esp-8h] [ebp-24h]
  int v22; // [esp+8h] [ebp-14h]
  int v23; // [esp+Ch] [ebp-10h]
  int v24; // [esp+10h] [ebp-Ch]
  int i; // [esp+14h] [ebp-8h]
  int v26; // [esp+14h] [ebp-8h]
  void *Block; // [esp+18h] [ebp-4h]

  v5 = a1[62];
  Block = 0;
  v23 = 0;
  v22 = 0;
  if ( v5 > 40 && (a1[90] & 0x80000) == 0 || v5 > 1024 )
    return 89;
  if ( a4 )
    *a4 = 0;
  if ( !a2 )
    return 1;
  v7 = xmlStrlen(a2);
  MemoryParserCtxt = xmlCreateMemoryParserCtxt(a2, v7);
  if ( !MemoryParserCtxt )
    return 27;
  if ( a3 )
    MemoryParserCtxt[1] = a3;
  else
    MemoryParserCtxt[1] = (int)MemoryParserCtxt;
  if ( MemoryParserCtxt[74] )
    xmlDictFree((void **)MemoryParserCtxt[74]);
  v20 = (_DWORD *)a1[74];
  MemoryParserCtxt[74] = (int)v20;
  v9 = xmlDictLookup(v20, "xml", 3);
  v19 = (_DWORD *)MemoryParserCtxt[74];
  MemoryParserCtxt[78] = (int)v9;
  v10 = xmlDictLookup(v19, "xmlns", 5);
  v18 = (_DWORD *)MemoryParserCtxt[74];
  MemoryParserCtxt[79] = (int)v10;
  MemoryParserCtxt[80] = (int)xmlDictLookup(v18, "http://www.w3.org/XML/1998/namespace", 36);
  for ( i = 0; i < a1[82]; i += 2 )
    sub_41F940(*(_DWORD *)(a1[84] + 4 * i), MemoryParserCtxt, *(_DWORD *)(a1[84] + 4 * i + 4));
  v24 = *MemoryParserCtxt;
  *MemoryParserCtxt = *a1;
  sub_41F321((int)MemoryParserCtxt);
  MemoryParserCtxt[4] = a1[4];
  MemoryParserCtxt[90] = a1[90];
  MemoryParserCtxt[68] = a1[68];
  v11 = a1[2];
  if ( v11 )
  {
    MemoryParserCtxt[2] = v11;
    v23 = *(_DWORD *)(v11 + 12);
    v22 = *(_DWORD *)(v11 + 16);
  }
  else
  {
    v12 = xmlNewDoc("1.0");
    Block = v12;
    if ( !v12 )
    {
      *MemoryParserCtxt = v24;
      MemoryParserCtxt[74] = 0;
      xmlFreeParserCtxt(MemoryParserCtxt);
      return 1;
    }
    v12[23] = 64;
    v21 = (_DWORD *)MemoryParserCtxt[74];
    v12[20] = v21;
    xmlDictReference(v21);
    MemoryParserCtxt[2] = (int)Block;
  }
  v13 = (char *)xmlNewDocNode(MemoryParserCtxt[2], 0, "pseudoroot", 0);
  if ( !v13 )
  {
    *MemoryParserCtxt = v24;
    MemoryParserCtxt[74] = 0;
    xmlFreeParserCtxt(MemoryParserCtxt);
    if ( Block )
      xmlFreeDoc(Block);
    return 1;
  }
  *(_DWORD *)(MemoryParserCtxt[2] + 12) = 0;
  *(_DWORD *)(MemoryParserCtxt[2] + 16) = 0;
  xmlAddChild((char *)MemoryParserCtxt[2], v13);
  nodePush((int)MemoryParserCtxt, *(_DWORD *)(MemoryParserCtxt[2] + 12));
  MemoryParserCtxt[43] = 7;
  MemoryParserCtxt[62] = a1[62] + 1;
  MemoryParserCtxt[26] = 0;
  v14 = a1[69];
  MemoryParserCtxt[69] = v14;
  if ( a1[26] || a1[4] )
    MemoryParserCtxt[69] = v14 | 8;
  MemoryParserCtxt[91] = a1[91];
  MemoryParserCtxt[87] = a1[87];
  MemoryParserCtxt[88] = a1[88];
  xmlParseContent(MemoryParserCtxt);
  v15 = *(_BYTE **)(MemoryParserCtxt[9] + 16);
  if ( *v15 == 60 && v15[1] == 47 )
  {
    sub_41EC3F(85, MemoryParserCtxt, 0);
  }
  else if ( *v15 )
  {
    sub_41EC3F(86, MemoryParserCtxt, 0);
  }
  if ( MemoryParserCtxt[13] != *(_DWORD *)(MemoryParserCtxt[2] + 12) )
    sub_41EC3F(85, MemoryParserCtxt, 0);
  if ( MemoryParserCtxt[3] )
  {
    v26 = 0;
  }
  else if ( MemoryParserCtxt[21] )
  {
    v26 = MemoryParserCtxt[21];
  }
  else
  {
    v26 = 1;
  }
  if ( a4 && !v26 )
  {
    v16 = *(_DWORD *)(*(_DWORD *)(MemoryParserCtxt[2] + 12) + 12);
    *a4 = v16;
    while ( v16 )
    {
      *(_DWORD *)(v16 + 20) = 0;
      v16 = *(_DWORD *)(v16 + 24);
    }
    *(_DWORD *)(*(_DWORD *)(MemoryParserCtxt[2] + 12) + 12) = 0;
  }
  v17 = MemoryParserCtxt[2];
  if ( v17 )
  {
    xmlFreeNode(*(char **)(v17 + 12));
    *(_DWORD *)(MemoryParserCtxt[2] + 12) = v23;
    *(_DWORD *)(MemoryParserCtxt[2] + 16) = v22;
  }
  a1[110] += MemoryParserCtxt[110];
  if ( MemoryParserCtxt[97] )
    xmlCopyError((int)(MemoryParserCtxt + 96), a1 + 96);
  *MemoryParserCtxt = v24;
  MemoryParserCtxt[74] = 0;
  MemoryParserCtxt[87] = 0;
  MemoryParserCtxt[88] = 0;
  xmlFreeParserCtxt(MemoryParserCtxt);
  if ( Block )
    xmlFreeDoc(Block);
  return v26;
}

//----- (0042D940) --------------------------------------------------------
int __cdecl xmlParseInNodeContext(int a1, _BYTE *a2, int a3, int a4, _DWORD **a5)
{
  _DWORD *v5; // ecx
  int v6; // eax
  int v7; // eax
  _DWORD *v9; // ebx
  int *MemoryParserCtxt; // eax
  int *v11; // edi
  _DWORD *v12; // esi
  const char **CharEncodingHandler; // eax
  char *v14; // eax
  _DWORD *v15; // eax
  int *v16; // ebx
  _DWORD *v17; // eax
  unsigned __int8 *v18; // esi
  unsigned __int8 *v19; // eax
  _BYTE *v20; // eax
  int v21; // eax
  _DWORD *v22; // eax
  char *Block; // [esp+Ch] [ebp-18h]
  int v25; // [esp+10h] [ebp-14h]
  int v26; // [esp+14h] [ebp-10h]
  _DWORD *v27; // [esp+18h] [ebp-Ch]
  int *v28; // [esp+1Ch] [ebp-8h]
  _DWORD *v29; // [esp+20h] [ebp-4h]
  int v30; // [esp+20h] [ebp-4h]

  v26 = 0;
  if ( !a5 )
    return 1;
  v5 = (_DWORD *)a1;
  if ( !a1 )
    return 1;
  if ( !a2 )
    return 1;
  if ( a3 < 0 )
    return 1;
  v6 = *(_DWORD *)(a1 + 4);
  if ( v6 <= 0 || v6 > 5 && (v6 <= 6 || v6 > 9 && v6 != 13) )
    return 1;
  do
  {
    v7 = v5[1];
    if ( v7 == 1 )
      break;
    if ( v7 == 9 )
      break;
    if ( v7 == 13 )
      break;
    a1 = v5[5];
    v5 = (_DWORD *)a1;
  }
  while ( a1 );
  if ( !v5 )
    return 1;
  if ( v5[1] == 1 )
  {
    v9 = (_DWORD *)v5[8];
    v29 = v9;
  }
  else
  {
    v29 = v5;
    v9 = v5;
  }
  if ( !v9 || v9[1] != 9 )
    return 1;
  MemoryParserCtxt = xmlCreateMemoryParserCtxt(a2, a3);
  v11 = MemoryParserCtxt;
  if ( !MemoryParserCtxt )
    return 2;
  if ( v9[20] )
  {
    v12 = MemoryParserCtxt + 74;
    if ( MemoryParserCtxt[74] )
      xmlDictFree((void **)MemoryParserCtxt[74]);
    *v12 = v9[20];
  }
  else
  {
    a4 |= 0x1000u;
  }
  if ( v9[15] )
  {
    if ( v11[6] )
      ((void (__cdecl *)(int))xmlFree)(v11[6]);
    v11[6] = (int)xmlStrdup((_BYTE *)v9[15]);
    CharEncodingHandler = (const char **)xmlFindCharEncodingHandler((const char *)v9[15]);
    if ( !CharEncodingHandler )
      return 32;
    xmlSwitchToEncoding(v11, CharEncodingHandler);
  }
  sub_42E9D0(a4, v11, 0);
  sub_41F321((int)v11);
  v11[2] = (int)v9;
  v14 = (char *)xmlNewComment(0);
  Block = v14;
  if ( !v14 )
  {
    xmlFreeParserCtxt(v11);
    return 2;
  }
  xmlAddChild((char *)a1, v14);
  if ( *(_DWORD *)(a1 + 4) == 1 )
  {
    nodePush((int)v11, a1);
    v15 = (_DWORD *)a1;
    v27 = (_DWORD *)a1;
    while ( v15[1] == 1 )
    {
      v16 = (int *)v15[12];
      v28 = v16;
      if ( v16 )
      {
        while ( 1 )
        {
          v17 = (_DWORD *)v11[74];
          if ( v17 )
          {
            v18 = xmlDictLookup(v17, (char *)v16[3], -1);
            v19 = xmlDictLookup((_DWORD *)v11[74], (char *)v16[2], -1);
          }
          else
          {
            v18 = (unsigned __int8 *)v16[3];
            v19 = (unsigned __int8 *)v16[2];
          }
          v25 = (int)v19;
          if ( !sub_428877(v11, (int)v18) )
          {
            sub_41F940((int)v18, v11, v25);
            ++v26;
            v16 = v28;
          }
          v28 = (int *)*v16;
          if ( !*v16 )
            break;
          v16 = (int *)*v16;
        }
        v15 = v27;
      }
      v9 = v29;
      v27 = (_DWORD *)v15[5];
      if ( !v27 )
        break;
      v15 = (_DWORD *)v15[5];
    }
    v11[43] = 7;
  }
  if ( v11[26] || v11[4] )
    v11[69] |= 8u;
  xmlParseContent(v11);
  sub_41FA49(v26, (int)v11);
  v20 = *(_BYTE **)(v11[9] + 16);
  if ( *v20 == 60 && v20[1] == 47 )
  {
    sub_41EC3F(85, v11, 0);
  }
  else
  {
    if ( !*v20 )
      goto LABEL_62;
    sub_41EC3F(86, v11, 0);
  }
  v9 = v29;
LABEL_62:
  v21 = v11[13];
  if ( v21 && v21 != a1 )
  {
    sub_41EC3F(85, v11, 0);
    v11[3] = 0;
    v9 = v29;
  }
  if ( v11[3] )
  {
    v30 = 0;
  }
  else if ( v11[21] )
  {
    v30 = v11[21];
  }
  else
  {
    v30 = 1;
  }
  v22 = (_DWORD *)*((_DWORD *)Block + 6);
  *((_DWORD *)Block + 6) = 0;
  *(_DWORD *)(a1 + 16) = Block;
  if ( v22 )
    v22[7] = 0;
  *a5 = v22;
  while ( v22 )
  {
    v22[5] = 0;
    v22 = (_DWORD *)v22[6];
  }
  xmlUnlinkNode((int)Block);
  xmlFreeNode(Block);
  if ( v30 )
  {
    xmlFreeNodeList(*a5);
    *a5 = 0;
  }
  if ( v9[20] )
    v11[74] = 0;
  xmlFreeParserCtxt(v11);
  return v30;
}
// 496494: invalid function type has been ignored

//----- (0042DC45) --------------------------------------------------------
int __cdecl xmlParseBalancedChunkMemoryRecover(_DWORD *a1, int a2, int a3, int a4, _BYTE *a5, _DWORD *a6, int a7)
{
  int v8; // eax
  int *MemoryParserCtxt; // esi
  int v10; // ecx
  _DWORD *v11; // eax
  int v12; // edi
  int v13; // ebx
  unsigned __int8 *v14; // eax
  unsigned __int8 *v15; // eax
  char *v16; // eax
  int v17; // esi
  int v18; // eax
  _BYTE *v19; // eax
  _DWORD *v20; // eax
  _DWORD *v21; // [esp-34h] [ebp-40h]
  _DWORD *v22; // [esp-28h] [ebp-34h]
  _DWORD *v23; // [esp-10h] [ebp-1Ch]
  int v24; // [esp+4h] [ebp-8h]
  int v25; // [esp+8h] [ebp-4h]
  _DWORD *v26; // [esp+8h] [ebp-4h]
  int v27; // [esp+20h] [ebp+14h]
  int v28; // [esp+20h] [ebp+14h]

  v24 = 0;
  if ( a4 > 40 )
    return 89;
  if ( a6 )
    *a6 = 0;
  if ( !a5 )
    return -1;
  v8 = xmlStrlen(a5);
  MemoryParserCtxt = xmlCreateMemoryParserCtxt(a5, v8);
  if ( !MemoryParserCtxt )
    return -1;
  MemoryParserCtxt[1] = (int)MemoryParserCtxt;
  if ( a2 )
  {
    v10 = *MemoryParserCtxt;
    *MemoryParserCtxt = a2;
    v24 = v10;
    if ( a3 )
      MemoryParserCtxt[1] = a3;
  }
  v11 = xmlNewDoc("1.0");
  v12 = (int)v11;
  if ( !v11 )
  {
    xmlFreeParserCtxt(MemoryParserCtxt);
    return -1;
  }
  v13 = (int)a1;
  v11[23] = 64;
  if ( a1 && a1[20] )
  {
    xmlDictFree((void **)MemoryParserCtxt[74]);
    v23 = (_DWORD *)a1[20];
    MemoryParserCtxt[74] = (int)v23;
    xmlDictReference(v23);
    v14 = xmlDictLookup((_DWORD *)MemoryParserCtxt[74], "xml", 3);
    v22 = (_DWORD *)MemoryParserCtxt[74];
    MemoryParserCtxt[78] = (int)v14;
    v15 = xmlDictLookup(v22, "xmlns", 5);
    v21 = (_DWORD *)MemoryParserCtxt[74];
    MemoryParserCtxt[79] = (int)v15;
    MemoryParserCtxt[80] = (int)xmlDictLookup(v21, "http://www.w3.org/XML/1998/namespace", 36);
    MemoryParserCtxt[91] = 1;
  }
  else
  {
    sub_42E9D0(4096, MemoryParserCtxt, 0);
  }
  if ( a1 )
  {
    *(_DWORD *)(v12 + 44) = a1[11];
    *(_DWORD *)(v12 + 48) = a1[12];
  }
  v16 = (char *)xmlNewDocNode(v12, 0, "pseudoroot", 0);
  v25 = (int)v16;
  if ( v16 )
  {
    xmlAddChild((char *)v12, v16);
    nodePush((int)MemoryParserCtxt, v25);
    MemoryParserCtxt[2] = v12;
    if ( a1 )
    {
      *(_DWORD *)(*(_DWORD *)(v12 + 12) + 32) = a1;
      xmlSearchNsByHref((int)a1, a1, "http://www.w3.org/XML/1998/namespace");
      *(_DWORD *)(v12 + 52) = a1[13];
    }
    MemoryParserCtxt[26] = 0;
    MemoryParserCtxt[69] = 0;
    MemoryParserCtxt[43] = 7;
    MemoryParserCtxt[62] = a4;
    sub_41F321((int)MemoryParserCtxt);
    if ( a1 )
    {
      v18 = a1[3];
      a1[3] = 0;
      v27 = v18;
      xmlParseContent(MemoryParserCtxt);
      a1[3] = v27;
    }
    else
    {
      xmlParseContent(MemoryParserCtxt);
    }
    v19 = *(_BYTE **)(MemoryParserCtxt[9] + 16);
    if ( *v19 == 60 && v19[1] == 47 )
    {
      sub_41EC3F(85, MemoryParserCtxt, 0);
    }
    else
    {
      if ( !*v19 )
      {
LABEL_36:
        if ( MemoryParserCtxt[13] != *(_DWORD *)(v12 + 12) )
        {
          sub_41EC3F(85, MemoryParserCtxt, 0);
          v13 = (int)a1;
        }
        if ( MemoryParserCtxt[3] )
        {
          v28 = 0;
        }
        else if ( MemoryParserCtxt[21] )
        {
          v28 = MemoryParserCtxt[21];
        }
        else
        {
          v28 = 1;
        }
        if ( a6 && (!v28 || a7 == 1) )
        {
          v20 = *(_DWORD **)(*(_DWORD *)(v12 + 12) + 12);
          v26 = v20;
          *a6 = v20;
          if ( v20 )
          {
            while ( 1 )
            {
              xmlSetTreeDoc(v20, v13);
              v26[5] = 0;
              v26 = (_DWORD *)v26[6];
              if ( !v26 )
                break;
              v20 = v26;
            }
          }
          *(_DWORD *)(*(_DWORD *)(v12 + 12) + 12) = 0;
        }
        if ( a2 )
          *MemoryParserCtxt = v24;
        xmlFreeParserCtxt(MemoryParserCtxt);
        v17 = v28;
        *(_DWORD *)(v12 + 44) = 0;
        *(_DWORD *)(v12 + 48) = 0;
        *(_DWORD *)(v12 + 52) = 0;
        goto LABEL_24;
      }
      sub_41EC3F(86, MemoryParserCtxt, 0);
    }
    v13 = (int)a1;
    goto LABEL_36;
  }
  if ( a2 )
    *MemoryParserCtxt = v24;
  xmlFreeParserCtxt(MemoryParserCtxt);
  *(_DWORD *)(v12 + 44) = 0;
  *(_DWORD *)(v12 + 48) = 0;
  v17 = -1;
LABEL_24:
  xmlFreeDoc((void *)v12);
  return v17;
}

//----- (0042DEF8) --------------------------------------------------------
int __cdecl xmlSAXParseEntity(int a1, char *a2)
{
  int *FileParserCtxt; // esi
  int v4; // edi

  FileParserCtxt = xmlCreateFileParserCtxt(a2);
  if ( !FileParserCtxt )
    return 0;
  if ( a1 )
  {
    if ( *FileParserCtxt )
      ((void (__cdecl *)(int))xmlFree)(*FileParserCtxt);
    *FileParserCtxt = a1;
    FileParserCtxt[1] = 0;
  }
  xmlParseExtParsedEnt(FileParserCtxt);
  if ( FileParserCtxt[3] )
  {
    v4 = FileParserCtxt[2];
  }
  else
  {
    v4 = 0;
    xmlFreeDoc((void *)FileParserCtxt[2]);
    FileParserCtxt[2] = 0;
  }
  if ( a1 )
    *FileParserCtxt = 0;
  xmlFreeParserCtxt(FileParserCtxt);
  return v4;
}
// 496494: invalid function type has been ignored

//----- (0042DF60) --------------------------------------------------------
int __cdecl xmlParseEntity(char *a1)
{
  return xmlSAXParseEntity(0, a1);
}

//----- (0042DF6E) --------------------------------------------------------
int *__usercall sub_42DF6E@<eax>(int a1@<eax>, char *Source, int a3, _BYTE *a4)
{
  int *v5; // eax
  int *v6; // esi
  char *v8; // eax
  char *v9; // edi
  int ***v10; // eax
  int v11; // eax
  int ***ExternalEntity; // eax
  int Directory; // eax

  v5 = xmlNewParserCtxt();
  v6 = v5;
  if ( !v5 )
    return 0;
  if ( a1 )
  {
    v5[90] = *(_DWORD *)(a1 + 360);
    v5[68] = *(_DWORD *)(a1 + 272);
  }
  v8 = (char *)xmlBuildURI(Source, a4);
  v9 = v8;
  if ( v8 )
  {
    ExternalEntity = (int ***)xmlLoadExternalEntity(v8, a3, (int)v6);
    if ( !ExternalEntity )
    {
      ((void (__cdecl *)(char *))xmlFree)(v9);
      xmlFreeParserCtxt(v6);
      return 0;
    }
    inputPush((int)v6, ExternalEntity);
    if ( v6[45] )
      Directory = 0;
    else
      Directory = xmlParserGetDirectory(v9);
    if ( !v6[45] && Directory )
      v6[45] = Directory;
    ((void (__cdecl *)(char *))xmlFree)(v9);
  }
  else
  {
    v10 = (int ***)xmlLoadExternalEntity(Source, a3, (int)v6);
    if ( !v10 )
    {
      xmlFreeParserCtxt(v6);
      return 0;
    }
    inputPush((int)v6, v10);
    if ( v6[45] )
      v11 = 0;
    else
      v11 = xmlParserGetDirectory(Source);
    if ( !v6[45] )
    {
      if ( v11 )
        v6[45] = v11;
    }
  }
  return v6;
}
// 496494: invalid function type has been ignored

//----- (0042E062) --------------------------------------------------------
int *__cdecl xmlCreateEntityParserCtxt(char *a1, int a2, _BYTE *a3)
{
  return sub_42DF6E(0, a1, a2, a3);
}

//----- (0042E069) --------------------------------------------------------
int *__cdecl xmlCreateURLParserCtxt(char *Source, int a2)
{
  int *v2; // esi
  int ***ExternalEntity; // eax
  int Directory; // eax

  v2 = xmlNewParserCtxt();
  if ( !v2 )
  {
    xmlErrMemory(0, "cannot allocate parser context");
    return 0;
  }
  if ( a2 )
    sub_42E9D0(a2, v2, 0);
  v2[70] = 1;
  ExternalEntity = (int ***)xmlLoadExternalEntity(Source, 0, (int)v2);
  if ( !ExternalEntity )
  {
    xmlFreeParserCtxt(v2);
    return 0;
  }
  inputPush((int)v2, ExternalEntity);
  if ( !v2[45] )
  {
    Directory = xmlParserGetDirectory(Source);
    if ( !v2[45] )
    {
      if ( Directory )
        v2[45] = Directory;
    }
  }
  return v2;
}

//----- (0042E0F4) --------------------------------------------------------
int *__cdecl xmlCreateFileParserCtxt(char *a1)
{
  return xmlCreateURLParserCtxt(a1, 0);
}

//----- (0042E102) --------------------------------------------------------
int __cdecl xmlSAXParseFileWithData(int a1, char *Source, int a3, int a4)
{
  int *FileParserCtxt; // esi
  int v6; // edi
  int v7; // eax

  xmlInitParser();
  FileParserCtxt = xmlCreateFileParserCtxt(Source);
  if ( !FileParserCtxt )
    return 0;
  if ( a1 )
  {
    if ( *FileParserCtxt )
      ((void (__cdecl *)(int))xmlFree)(*FileParserCtxt);
    *FileParserCtxt = a1;
  }
  sub_41F321((int)FileParserCtxt);
  if ( a4 )
    FileParserCtxt[68] = a4;
  if ( !FileParserCtxt[45] )
    FileParserCtxt[45] = xmlParserGetDirectory(Source);
  FileParserCtxt[72] = a3;
  xmlParseDocument(FileParserCtxt);
  if ( FileParserCtxt[3] || a3 )
  {
    v6 = FileParserCtxt[2];
    if ( v6 )
    {
      v7 = *(_DWORD *)(*(_DWORD *)FileParserCtxt[9] + 24);
      if ( v7 <= 0 )
        *(_DWORD *)(v6 + 36) = v7;
      else
        *(_DWORD *)(v6 + 36) = 9;
    }
  }
  else
  {
    v6 = 0;
    xmlFreeDoc((void *)FileParserCtxt[2]);
    FileParserCtxt[2] = 0;
  }
  if ( a1 )
    *FileParserCtxt = 0;
  xmlFreeParserCtxt(FileParserCtxt);
  return v6;
}
// 496494: invalid function type has been ignored

//----- (0042E1C0) --------------------------------------------------------
int __cdecl xmlSAXParseFile(int a1, char *a2, int a3)
{
  return xmlSAXParseFileWithData(a1, a2, a3, 0);
}

//----- (0042E1D7) --------------------------------------------------------
int __cdecl xmlRecoverDoc(_BYTE *a1)
{
  return xmlSAXParseDoc(0, a1, 1);
}

//----- (0042E1E8) --------------------------------------------------------
int __cdecl xmlParseFile(char *a1)
{
  return xmlSAXParseFile(0, a1, 0);
}

//----- (0042E1F9) --------------------------------------------------------
int __cdecl xmlRecoverFile(char *a1)
{
  return xmlSAXParseFile(0, a1, 1);
}

//----- (0042E20A) --------------------------------------------------------
void __cdecl xmlSetupParserForBuffer(_DWORD *a1, int **a2, char *Source)
{
  int ***v3; // esi

  if ( a1 && a2 )
  {
    v3 = (int ***)xmlNewInputStream((int)a1);
    if ( v3 )
    {
      xmlClearParserCtxt(a1);
      if ( Source )
        v3[1] = (int **)xmlCanonicPath(Source);
      v3[3] = a2;
      v3[4] = a2;
      v3[5] = (int **)((char *)a2 + xmlStrlen(a2));
      inputPush((int)a1, v3);
    }
    else
    {
      xmlErrMemory(0, "parsing new buffer: out of memory\n");
      xmlClearParserCtxt(a1);
    }
  }
}

//----- (0042E277) --------------------------------------------------------
int __cdecl xmlSAXUserParseFile(int a1, int a2, char *a3)
{
  int *FileParserCtxt; // esi
  int v5; // [esp+4h] [ebp-4h]

  FileParserCtxt = xmlCreateFileParserCtxt(a3);
  if ( !FileParserCtxt )
    return -1;
  if ( (int (__cdecl **)(int, int, int, int))*FileParserCtxt != &xmlDefaultSAXHandler )
    ((void (__cdecl *)(int))xmlFree)(*FileParserCtxt);
  *FileParserCtxt = a1;
  sub_41F321((int)FileParserCtxt);
  if ( a2 )
    FileParserCtxt[1] = a2;
  xmlParseDocument(FileParserCtxt);
  if ( FileParserCtxt[3] )
  {
    v5 = 0;
  }
  else if ( FileParserCtxt[21] )
  {
    v5 = FileParserCtxt[21];
  }
  else
  {
    v5 = -1;
  }
  if ( a1 )
    *FileParserCtxt = 0;
  if ( FileParserCtxt[2] )
  {
    xmlFreeDoc((void *)FileParserCtxt[2]);
    FileParserCtxt[2] = 0;
  }
  xmlFreeParserCtxt(FileParserCtxt);
  return v5;
}
// 496494: invalid function type has been ignored
// 4A4BB8: using guessed type int (__cdecl *xmlDefaultSAXHandler)(int, int, int, int);

//----- (0042E300) --------------------------------------------------------
int *__cdecl xmlCreateMemoryParserCtxt(_BYTE *Src, int a2)
{
  int *result; // eax
  int *v3; // edi
  int **Mem; // esi
  int ***v5; // eax

  if ( !Src || a2 <= 0 )
    return 0;
  result = xmlNewParserCtxt();
  v3 = result;
  if ( result )
  {
    Mem = (int **)xmlParserInputBufferCreateMem(Src, a2, 0);
    if ( Mem )
    {
      v5 = (int ***)xmlNewInputStream((int)v3);
      if ( v5 )
      {
        v5[1] = 0;
        *v5 = Mem;
        v5[3] = (int **)*Mem[4];
        v5[4] = (int **)*Mem[4];
        v5[5] = (int **)(*Mem[4] + Mem[4][1]);
        inputPush((int)v3, v5);
        return v3;
      }
      else
      {
        xmlFreeParserInputBuffer(Mem);
        xmlFreeParserCtxt(v3);
        return 0;
      }
    }
    else
    {
      xmlFreeParserCtxt(v3);
      return 0;
    }
  }
  return result;
}

//----- (0042E38B) --------------------------------------------------------
int *__cdecl xmlSAXParseMemoryWithData(int a1, _BYTE *a2, int a3, int a4, int a5)
{
  int *result; // eax
  int v6; // esi
  int v7; // edi

  xmlInitParser();
  result = xmlCreateMemoryParserCtxt(a2, a3);
  v6 = (int)result;
  if ( result )
  {
    if ( a1 )
    {
      if ( *result )
        ((void (__cdecl *)(int))xmlFree)(*result);
      *(_DWORD *)v6 = a1;
    }
    sub_41F321(v6);
    if ( a5 )
      *(_DWORD *)(v6 + 272) = a5;
    v7 = a4;
    *(_DWORD *)(v6 + 288) = a4;
    xmlParseDocument((int *)v6);
    if ( *(_DWORD *)(v6 + 12) || a4 )
    {
      v7 = *(_DWORD *)(v6 + 8);
    }
    else
    {
      xmlFreeDoc(*(void **)(v6 + 8));
      *(_DWORD *)(v6 + 8) = 0;
    }
    if ( a1 )
      *(_DWORD *)v6 = 0;
    xmlFreeParserCtxt((_DWORD *)v6);
    return (int *)v7;
  }
  return result;
}
// 496494: invalid function type has been ignored

//----- (0042E412) --------------------------------------------------------
int *__cdecl xmlSAXParseMemory(int a1, _BYTE *a2, int a3, int a4)
{
  return xmlSAXParseMemoryWithData(a1, a2, a3, a4, 0);
}

//----- (0042E42D) --------------------------------------------------------
int *__cdecl xmlParseMemory(_BYTE *a1, int a2)
{
  return xmlSAXParseMemory(0, a1, a2, 0);
}

//----- (0042E442) --------------------------------------------------------
int *__cdecl xmlRecoverMemory(_BYTE *a1, int a2)
{
  return xmlSAXParseMemory(0, a1, a2, 1);
}

//----- (0042E457) --------------------------------------------------------
int __cdecl xmlSAXUserParseMemory(int a1, int a2, _BYTE *a3, int a4)
{
  int *MemoryParserCtxt; // esi
  int v6; // [esp+4h] [ebp-4h]

  xmlInitParser();
  MemoryParserCtxt = xmlCreateMemoryParserCtxt(a3, a4);
  if ( !MemoryParserCtxt )
    return -1;
  if ( (int (__cdecl **)(int, int, int, int))*MemoryParserCtxt != &xmlDefaultSAXHandler )
    ((void (__cdecl *)(int))xmlFree)(*MemoryParserCtxt);
  *MemoryParserCtxt = a1;
  sub_41F321((int)MemoryParserCtxt);
  if ( a2 )
    MemoryParserCtxt[1] = a2;
  xmlParseDocument(MemoryParserCtxt);
  if ( MemoryParserCtxt[3] )
  {
    v6 = 0;
  }
  else if ( MemoryParserCtxt[21] )
  {
    v6 = MemoryParserCtxt[21];
  }
  else
  {
    v6 = -1;
  }
  if ( a1 )
    *MemoryParserCtxt = 0;
  if ( MemoryParserCtxt[2] )
  {
    xmlFreeDoc((void *)MemoryParserCtxt[2]);
    MemoryParserCtxt[2] = 0;
  }
  xmlFreeParserCtxt(MemoryParserCtxt);
  return v6;
}
// 496494: invalid function type has been ignored
// 4A4BB8: using guessed type int (__cdecl *xmlDefaultSAXHandler)(int, int, int, int);

//----- (0042E4E9) --------------------------------------------------------
int *__cdecl xmlCreateDocParserCtxt(_BYTE *a1)
{
  int v2; // eax
  _BYTE *v3; // edx

  if ( !a1 )
    return 0;
  v2 = xmlStrlen(a1);
  return xmlCreateMemoryParserCtxt(v3, v2);
}
// 42E4FC: variable 'v3' is possibly undefined

//----- (0042E505) --------------------------------------------------------
int __cdecl xmlSAXParseDoc(int a1, _BYTE *a2, int a3)
{
  int *DocParserCtxt; // esi
  int v5; // [esp+4h] [ebp-4h]
  int v6; // [esp+14h] [ebp+Ch]

  v5 = 0;
  if ( !a2 )
    return 0;
  DocParserCtxt = xmlCreateDocParserCtxt(a2);
  if ( !DocParserCtxt )
    return 0;
  if ( a1 )
  {
    v5 = *DocParserCtxt;
    *DocParserCtxt = a1;
    DocParserCtxt[1] = 0;
  }
  sub_41F321((int)DocParserCtxt);
  xmlParseDocument(DocParserCtxt);
  if ( DocParserCtxt[3] || a3 )
  {
    v6 = DocParserCtxt[2];
  }
  else
  {
    v6 = 0;
    xmlFreeDoc((void *)DocParserCtxt[2]);
    DocParserCtxt[2] = 0;
  }
  if ( a1 )
    *DocParserCtxt = v5;
  xmlFreeParserCtxt(DocParserCtxt);
  return v6;
}

//----- (0042E583) --------------------------------------------------------
int __cdecl xmlParseDoc(_BYTE *a1)
{
  return xmlSAXParseDoc(0, a1, 0);
}

//----- (0042E594) --------------------------------------------------------
int xmlInitParser()
{
  int result; // eax

  if ( !dword_4A9C10 )
  {
    xmlInitGlobals();
    if ( (char *)xmlGenericError == (char *)sub_431949 || !xmlGenericError )
      xmlGenericError = (int (*)(_DWORD, const char *, ...))sub_431949;
    xmlInitMemory();
    xmlInitializeDict();
    xmlInitCharEncodingHandlers();
    xmlDefaultSAXHandlerInit();
    xmlRegisterDefaultInputCallbacks();
    result = xmlRegisterDefaultOutputCallbacks();
    dword_4A9C10 = 1;
  }
  return result;
}
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);
// 4A9C10: using guessed type int dword_4A9C10;

//----- (0042E5E3) --------------------------------------------------------
void xmlCleanupParser()
{
  if ( dword_4A9C10 )
  {
    xmlCleanupCharEncodingHandlers();
    xmlDictCleanup();
    xmlCleanupInputCallbacks();
    xmlCleanupOutputCallbacks();
    xmlCleanupGlobals();
    xmlResetLastError();
    xmlCleanupMemory();
    dword_4A9C10 = 0;
  }
}
// 4A9C10: using guessed type int dword_4A9C10;

//----- (0042E617) --------------------------------------------------------
void __cdecl xmlCtxtReset(_DWORD *a1)
{
  int v1; // ebx
  int ***i; // eax
  _DWORD *v3; // ecx
  unsigned int v4; // ebp
  unsigned int v5; // ebp
  unsigned int v6; // ebp
  unsigned int v7; // ebp
  unsigned int v8; // ebp
  void *v9; // eax
  _DWORD *v10; // eax
  _DWORD *v11; // eax

  if ( a1 )
  {
    v1 = a1[74];
    for ( i = (int ***)inputPop(a1); i; i = (int ***)inputPop(a1) )
      xmlFreeInputStream(i);
    v3 = (_DWORD *)a1[61];
    a1[10] = 0;
    a1[9] = 0;
    a1[59] = 0;
    if ( v3 )
    {
      *v3 = -1;
      a1[58] = a1[61];
    }
    else
    {
      a1[58] = 0;
    }
    v4 = a1[5];
    a1[14] = 0;
    a1[13] = 0;
    a1[47] = 0;
    a1[46] = 0;
    if ( v4 && (!v1 || !xmlDictOwns(v1, v4)) )
      ((void (__cdecl *)(unsigned int))xmlFree)(v4);
    v5 = a1[6];
    a1[5] = 0;
    if ( v5 && (!v1 || !xmlDictOwns(v1, v5)) )
      ((void (__cdecl *)(unsigned int))xmlFree)(v5);
    v6 = a1[45];
    a1[6] = 0;
    if ( v6 && (!v1 || !xmlDictOwns(v1, v6)) )
      ((void (__cdecl *)(unsigned int))xmlFree)(v6);
    v7 = a1[56];
    a1[45] = 0;
    if ( v7 && (!v1 || !xmlDictOwns(v1, v7)) )
      ((void (__cdecl *)(unsigned int))xmlFree)(v7);
    v8 = a1[57];
    a1[56] = 0;
    if ( v8 && (!v1 || !xmlDictOwns(v1, v8)) )
      ((void (__cdecl *)(unsigned int))xmlFree)(v8);
    v9 = (void *)a1[2];
    a1[57] = 0;
    if ( v9 )
      xmlFreeDoc(v9);
    a1[7] = -1;
    a1[3] = 1;
    a1[89] = 1;
    a1[25] = 1;
    a1[64] = 1;
    a1[2] = 0;
    a1[22] = 0;
    a1[23] = 0;
    a1[8] = 0;
    a1[24] = 0;
    a1[43] = 0;
    a1[44] = 0;
    a1[53] = 0;
    a1[17] = 0;
    a1[50] = 0;
    a1[51] = 0;
    a1[54] = 0;
    a1[21] = 0;
    a1[62] = 0;
    a1[71] = 0;
    a1[110] = 0;
    a1[111] = 0;
    xmlInitNodeInfoSeq(a1 + 18);
    v10 = (_DWORD *)a1[87];
    if ( v10 )
    {
      xmlHashFree(v10, (void (__cdecl *)(int, _DWORD))xmlFree);
      a1[87] = 0;
    }
    v11 = (_DWORD *)a1[88];
    if ( v11 )
    {
      xmlHashFree(v11, 0);
      a1[88] = 0;
    }
    if ( a1[97] )
      xmlResetError(a1 + 96);
  }
}
// 496494: invalid function type has been ignored

//----- (0042E816) --------------------------------------------------------
int __cdecl xmlCtxtResetPush(int *a1, char *a2, int a3, char *Source, char *Src)
{
  int **v6; // ebx
  int v7; // eax
  int ***v8; // eax
  int ***v9; // esi
  int *v10; // eax
  int v11; // edx
  int v12; // ebx
  int v13; // esi
  const char **CharEncodingHandler; // eax
  int v15; // [esp+8h] [ebp-4h]

  v15 = 0;
  if ( !a1 )
    return 1;
  if ( !Src && a2 && a3 >= 4 )
    v15 = xmlDetectCharEncoding(a2, a3);
  v6 = (int **)xmlAllocParserInputBuffer(v15);
  if ( !v6 )
    return 1;
  xmlCtxtReset(a1);
  if ( !a1[86] )
  {
    v7 = xmlMalloc(12 * a1[48]);
    a1[86] = v7;
    if ( !v7 )
    {
      xmlErrMemory((int)a1, 0);
      xmlFreeParserInputBuffer(v6);
      return 1;
    }
  }
  if ( Source )
    a1[45] = xmlParserGetDirectory(Source);
  else
    a1[45] = 0;
  v8 = (int ***)xmlNewInputStream((int)a1);
  v9 = v8;
  if ( !v8 )
  {
    xmlFreeParserInputBuffer(v6);
    return 1;
  }
  if ( Source )
    v8[1] = (int **)xmlCanonicPath(Source);
  else
    v8[1] = 0;
  *v9 = v6;
  v9[3] = (int **)*v6[4];
  v9[4] = (int **)*v6[4];
  v9[5] = (int **)(*v6[4] + v6[4][1]);
  inputPush((int)a1, v9);
  if ( a3 > 0 )
  {
    if ( a2 )
    {
      v10 = (int *)a1[9];
      if ( v10 )
      {
        if ( *v10 )
        {
          v11 = v10[3];
          v12 = v11 - **(_DWORD **)(*v10 + 16);
          v13 = v10[4] - v11;
          xmlParserInputBufferPush(*v10, a3, a2);
          *(_DWORD *)(a1[9] + 12) = v12 + **(_DWORD **)(*(_DWORD *)a1[9] + 16);
          *(_DWORD *)(a1[9] + 16) = v13 + *(_DWORD *)(a1[9] + 12);
          *(_DWORD *)(a1[9] + 20) = **(_DWORD **)(*(_DWORD *)a1[9] + 16)
                                  + *(_DWORD *)(*(_DWORD *)(*(_DWORD *)a1[9] + 16) + 4);
        }
      }
    }
  }
  if ( Src )
  {
    if ( a1[6] )
      ((void (__cdecl *)(int))xmlFree)(a1[6]);
    a1[6] = (int)xmlStrdup(Src);
    CharEncodingHandler = (const char **)xmlFindCharEncodingHandler(Src);
    if ( CharEncodingHandler )
      xmlSwitchToEncoding(a1, CharEncodingHandler);
    else
      sub_41F152((int (__cdecl *)(int, char *, char))0x20, a1, "Unsupported encoding %s\n", Src);
  }
  else if ( v15 )
  {
    xmlSwitchEncoding(a1, v15);
  }
  return 0;
}
// 496494: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (0042E9D0) --------------------------------------------------------
int __usercall sub_42E9D0@<eax>(int a1@<eax>, _DWORD *a2@<esi>, _BYTE *Src)
{
  int v5; // ecx

  if ( !a2 )
    return -1;
  if ( Src )
  {
    if ( a2[6] )
      ((void (__cdecl *)(_DWORD))xmlFree)(a2[6]);
    a2[6] = xmlStrdup(Src);
  }
  if ( (a1 & 1) != 0 )
  {
    --a1;
    a2[90] |= 1u;
    a2[72] = 1;
  }
  else
  {
    a2[72] = 0;
  }
  if ( (a1 & 4) != 0 )
  {
    a1 -= 4;
    a2[90] |= 4u;
    a2[69] = 2;
  }
  else
  {
    a2[69] = 0;
  }
  if ( (a1 & 8) != 0 )
  {
    a2[69] |= 4u;
    a1 -= 8;
    a2[90] |= 8u;
  }
  if ( (a1 & 2) != 0 )
  {
    a1 -= 2;
    a2[90] |= 2u;
    a2[4] = 1;
  }
  else
  {
    a2[4] = 0;
  }
  if ( (a1 & 0x80u) == 0 )
  {
    a2[67] = 0;
  }
  else
  {
    a1 -= 128;
    a2[90] |= 0x80u;
    a2[67] = 1;
  }
  if ( (a1 & 0x100) != 0 )
  {
    v5 = *a2;
    a2[52] = 0;
    *(_DWORD *)(v5 + 72) = xmlUnlockLibrary;
    a1 -= 256;
    a2[90] |= 0x100u;
  }
  else
  {
    a2[52] = 1;
  }
  if ( (a1 & 0x10) != 0 )
  {
    a2[26] = 1;
    if ( (a1 & 0x40) != 0 )
      a2[29] = 0;
    if ( (a1 & 0x20) != 0 )
      a2[28] = 0;
    a1 -= 16;
    a2[90] |= 0x10u;
  }
  else
  {
    a2[26] = 0;
  }
  if ( (a1 & 0x40) != 0 )
  {
    *(_DWORD *)(*a2 + 84) = 0;
    a1 -= 64;
  }
  if ( (a1 & 0x20) != 0 )
  {
    *(_DWORD *)(*a2 + 88) = 0;
    *(_DWORD *)(*a2 + 92) = 0;
    a1 -= 32;
  }
  if ( (a1 & 0x200) != 0 )
  {
    *(_DWORD *)(*a2 + 56) = xmlSAX2StartElement;
    *(_DWORD *)(*a2 + 60) = xmlSAX2EndElement;
    *(_DWORD *)(*a2 + 116) = 0;
    *(_DWORD *)(*a2 + 120) = 0;
    *(_DWORD *)(*a2 + 108) = 1;
    a1 -= 512;
    a2[90] |= 0x200u;
  }
  if ( (a1 & 0x1000) != 0 )
  {
    a1 -= 4096;
    a2[90] |= 0x1000u;
    a2[91] = 0;
  }
  else
  {
    a2[91] = 1;
  }
  if ( (a1 & 0x4000) != 0 )
  {
    *(_DWORD *)(*a2 + 100) = 0;
    a1 -= 0x4000;
    a2[90] |= 0x4000u;
  }
  if ( (a1 & 0x2000) != 0 )
  {
    a2[90] |= 0x2000u;
    a1 -= 0x2000;
  }
  if ( (a1 & 0x800) != 0 )
  {
    a2[90] |= 0x800u;
    a1 -= 2048;
  }
  if ( (a1 & 0x10000) != 0 )
  {
    a2[90] |= 0x10000u;
    a1 -= 0x10000;
  }
  if ( (a1 & 0x20000) != 0 )
  {
    a2[90] |= 0x20000u;
    a1 -= 0x20000;
  }
  if ( (a1 & 0x40000) != 0 )
  {
    a2[90] |= 0x40000u;
    a1 -= 0x40000;
  }
  if ( (a1 & 0x80000) != 0 )
  {
    a2[90] |= 0x80000u;
    a1 -= 0x80000;
  }
  if ( (a1 & 0x100000) != 0 )
  {
    a2[90] |= 0x100000u;
    a1 -= 0x100000;
  }
  if ( (a1 & 0x200000) != 0 )
  {
    a2[90] |= 0x200000u;
    a1 -= 0x200000;
  }
  a2[70] = 1;
  return a1;
}
// 496494: invalid function type has been ignored
// 43FED0: using guessed type int xmlUnlockLibrary();

//----- (0042EBF0) --------------------------------------------------------
int __cdecl xmlCtxtUseOptions(_DWORD *a1, int a2)
{
  return sub_42E9D0(a2, a1, 0);
}

//----- (0042EC03) --------------------------------------------------------
int __usercall sub_42EC03@<eax>(int *Block@<ecx>, int a2@<eax>, _BYTE *Src, char *a4, int a5)
{
  const char **CharEncodingHandler; // eax
  int v7; // eax
  int v8; // edi

  sub_42E9D0(a2, Block, a4);
  if ( a4 )
  {
    CharEncodingHandler = (const char **)xmlFindCharEncodingHandler(a4);
    if ( CharEncodingHandler )
      xmlSwitchToEncoding(Block, CharEncodingHandler);
  }
  if ( Src )
  {
    v7 = Block[9];
    if ( v7 )
    {
      if ( !*(_DWORD *)(v7 + 4) )
        *(_DWORD *)(Block[9] + 4) = xmlStrdup(Src);
    }
  }
  xmlParseDocument(Block);
  if ( Block[3] || Block[72] )
  {
    v8 = Block[2];
  }
  else
  {
    v8 = 0;
    if ( Block[2] )
      xmlFreeDoc((void *)Block[2]);
  }
  Block[2] = 0;
  if ( !a5 )
    xmlFreeParserCtxt(Block);
  return v8;
}

//----- (0042EC90) --------------------------------------------------------
int __cdecl xmlReadDoc(_BYTE *a1, _BYTE *a2, char *a3, int a4)
{
  int *DocParserCtxt; // ecx

  if ( a1 && (DocParserCtxt = xmlCreateDocParserCtxt(a1)) != 0 )
    return sub_42EC03(DocParserCtxt, a4, a2, a3, 0);
  else
    return 0;
}

//----- (0042ECC1) --------------------------------------------------------
int *__cdecl xmlReadFile(char *a1, char *a2, int a3)
{
  int *result; // eax

  result = xmlCreateURLParserCtxt(a1, a3);
  if ( result )
    return (int *)sub_42EC03(result, a3, 0, a2, 0);
  return result;
}

//----- (0042ECEC) --------------------------------------------------------
int *__cdecl xmlReadMemory(_BYTE *a1, int a2, _BYTE *a3, char *a4, int a5)
{
  int *result; // eax

  result = xmlCreateMemoryParserCtxt(a1, a2);
  if ( result )
    return (int *)sub_42EC03(result, a5, a3, a4, 0);
  return result;
}

//----- (0042ED19) --------------------------------------------------------
int __cdecl xmlReadFd(int a1, _BYTE *a2, char *a3, int a4)
{
  int **Fd; // eax
  int **v6; // esi
  int *v7; // eax
  int *v8; // edi
  int ***v9; // eax

  if ( a1 < 0 )
    return 0;
  Fd = (int **)xmlParserInputBufferCreateFd(a1, 0);
  v6 = Fd;
  if ( !Fd )
    return 0;
  Fd[2] = 0;
  v7 = xmlNewParserCtxt();
  v8 = v7;
  if ( !v7 )
  {
    xmlFreeParserInputBuffer(v6);
    return 0;
  }
  v9 = (int ***)xmlNewIOInputStream(v7, (int)v6, 0);
  if ( !v9 )
  {
    xmlFreeParserInputBuffer(v6);
    xmlFreeParserCtxt(v8);
    return 0;
  }
  inputPush((int)v8, v9);
  return sub_42EC03(v8, a4, a2, a3, 0);
}

//----- (0042ED96) --------------------------------------------------------
int __cdecl xmlReadIO(int a1, void (__cdecl *a2)(int), int a3, _BYTE *a4, char *a5, int a6)
{
  int **IO; // edi
  int *v8; // eax
  int *v9; // esi
  int ***v10; // eax

  if ( !a1 )
    return 0;
  IO = (int **)xmlParserInputBufferCreateIO(a1, (int)a2, a3, 0);
  if ( IO )
  {
    v8 = xmlNewParserCtxt();
    v9 = v8;
    if ( v8 )
    {
      v10 = (int ***)xmlNewIOInputStream(v8, (int)IO, 0);
      if ( v10 )
      {
        inputPush((int)v9, v10);
        return sub_42EC03(v9, a6, a4, a5, 0);
      }
      xmlFreeParserInputBuffer(IO);
      xmlFreeParserCtxt(v9);
    }
    else
    {
      xmlFreeParserInputBuffer(IO);
    }
    return 0;
  }
  if ( a2 )
    a2(a3);
  return 0;
}

//----- (0042EE23) --------------------------------------------------------
int __cdecl xmlCtxtReadDoc(int *Block, char *ArgList, _BYTE *a3, char *a4, int a5)
{
  int ***v6; // eax

  if ( !ArgList )
    return 0;
  if ( !Block )
    return 0;
  xmlCtxtReset(Block);
  v6 = (int ***)xmlNewStringInputStream(Block, ArgList);
  if ( !v6 )
    return 0;
  inputPush((int)Block, v6);
  return sub_42EC03(Block, a5, a3, a4, 1);
}
// 42EE23: using guessed type char *ArgList;

//----- (0042EE71) --------------------------------------------------------
int __cdecl xmlCtxtReadFile(int *Block, char *Source, char *a3, int a4)
{
  int ***ExternalEntity; // eax

  if ( !Source )
    return 0;
  if ( !Block )
    return 0;
  xmlCtxtReset(Block);
  ExternalEntity = (int ***)xmlLoadExternalEntity(Source, 0, (int)Block);
  if ( !ExternalEntity )
    return 0;
  inputPush((int)Block, ExternalEntity);
  return sub_42EC03(Block, a4, 0, a3, 1);
}

//----- (0042EEC0) --------------------------------------------------------
int __cdecl xmlCtxtReadMemory(int *Block, _BYTE *Src, int a3, _BYTE *a4, char *a5, int a6)
{
  int **Mem; // eax
  int **v8; // esi
  int ***v9; // eax

  if ( !Block || !Src )
    return 0;
  xmlCtxtReset(Block);
  Mem = (int **)xmlParserInputBufferCreateMem(Src, a3, 0);
  v8 = Mem;
  if ( !Mem )
    return 0;
  v9 = (int ***)xmlNewIOInputStream(Block, (int)Mem, 0);
  if ( !v9 )
  {
    xmlFreeParserInputBuffer(v8);
    return 0;
  }
  inputPush((int)Block, v9);
  return sub_42EC03(Block, a6, a4, a5, 1);
}

//----- (0042EF2D) --------------------------------------------------------
int __cdecl xmlCtxtReadFd(int *Block, int a2, _BYTE *a3, char *a4, int a5)
{
  int **Fd; // eax
  int **v7; // esi
  int ***v8; // eax

  if ( a2 < 0 )
    return 0;
  if ( !Block )
    return 0;
  xmlCtxtReset(Block);
  Fd = (int **)xmlParserInputBufferCreateFd(a2, 0);
  v7 = Fd;
  if ( !Fd )
    return 0;
  Fd[2] = 0;
  v8 = (int ***)xmlNewIOInputStream(Block, (int)Fd, 0);
  if ( !v8 )
  {
    xmlFreeParserInputBuffer(v7);
    return 0;
  }
  inputPush((int)Block, v8);
  return sub_42EC03(Block, a5, a3, a4, 1);
}

//----- (0042EF9F) --------------------------------------------------------
int __cdecl xmlCtxtReadIO(int *Block, int a2, void (__cdecl *a3)(int), int a4, _BYTE *a5, char *a6, int a7)
{
  int **IO; // eax
  int **v9; // esi
  int ***v10; // eax

  if ( !a2 )
    return 0;
  if ( !Block )
    return 0;
  xmlCtxtReset(Block);
  IO = (int **)xmlParserInputBufferCreateIO(a2, (int)a3, a4, 0);
  v9 = IO;
  if ( !IO )
  {
    if ( a3 )
      a3(a4);
    return 0;
  }
  v10 = (int ***)xmlNewIOInputStream(Block, (int)IO, 0);
  if ( !v10 )
  {
    xmlFreeParserInputBuffer(v9);
    return 0;
  }
  inputPush((int)Block, v10);
  return sub_42EC03(Block, a7, a5, a6, 1);
}

//----- (0042F020) --------------------------------------------------------
_BYTE *__cdecl xmlStrndup(void *Src, int Size)
{
  _BYTE *v2; // eax
  _BYTE *v3; // edi

  if ( !Src || Size < 0 )
    return 0;
  v2 = (_BYTE *)xmlMallocAtomic(Size + 1);
  v3 = v2;
  if ( !v2 )
  {
    xmlErrMemory(0, 0);
    return 0;
  }
  memcpy(v2, Src, Size);
  v3[Size] = 0;
  return v3;
}
// 49B2BC: using guessed type int (__cdecl *xmlMallocAtomic)(size_t Size);

//----- (0042F066) --------------------------------------------------------
_BYTE *__cdecl xmlStrdup(_BYTE *Src)
{
  _BYTE *result; // eax

  result = Src;
  if ( Src )
  {
    if ( *Src )
    {
      do
        ++result;
      while ( *result );
    }
    return xmlStrndup(Src, result - Src);
  }
  return result;
}

//----- (0042F088) --------------------------------------------------------
int __cdecl xmlCharStrndup(int a1, int a2)
{
  int v2; // ebx
  int result; // eax
  _BYTE *v4; // ecx
  char v5; // dl

  v2 = 0;
  if ( !a1 || a2 < 0 )
    return 0;
  result = xmlMallocAtomic(a2 + 1);
  if ( !result )
  {
    xmlErrMemory(0, 0);
    return 0;
  }
  if ( a2 <= 0 )
  {
LABEL_11:
    *(_BYTE *)(result + a2) = 0;
  }
  else
  {
    v4 = (_BYTE *)result;
    while ( 1 )
    {
      v5 = v4[a1 - result];
      *v4 = v5;
      if ( !v5 )
        break;
      ++v2;
      ++v4;
      if ( v2 >= a2 )
        goto LABEL_11;
    }
  }
  return result;
}
// 49B2BC: using guessed type int (__cdecl *xmlMallocAtomic)(size_t Size);

//----- (0042F0D8) --------------------------------------------------------
_BYTE *__cdecl xmlCharStrdup(_BYTE *a1)
{
  _BYTE *result; // eax

  result = a1;
  if ( a1 )
  {
    if ( *a1 )
    {
      do
        ++result;
      while ( *result );
    }
    return (_BYTE *)xmlCharStrndup((int)a1, result - a1);
  }
  return result;
}

//----- (0042F0FA) --------------------------------------------------------
int __cdecl xmlStrcmp(unsigned __int8 *a1, char *a2)
{
  char *v2; // edx
  unsigned __int8 *v3; // esi
  int result; // eax
  char v5; // cl

  v2 = a2;
  v3 = a1;
  if ( a1 == (unsigned __int8 *)a2 )
    return 0;
  if ( !a1 )
    return -1;
  if ( !a2 )
    return 1;
  do
  {
    v5 = *v2;
    result = *v3++ - (unsigned __int8)*v2;
    if ( result )
      break;
    ++v2;
  }
  while ( v5 );
  return result;
}

//----- (0042F135) --------------------------------------------------------
int __cdecl xmlStrEqual(char *a1, char *a2)
{
  char *v2; // ecx
  char *v3; // esi
  char v5; // dl
  char v6; // al

  v2 = a2;
  v3 = a1;
  if ( a1 == a2 )
    return 1;
  if ( a1 && a2 )
  {
    while ( 1 )
    {
      v5 = *v3;
      v6 = *v2;
      ++v3;
      if ( v5 != *v2 )
        break;
      ++v2;
      if ( !v6 )
        return 1;
    }
  }
  return 0;
}

//----- (0042F161) --------------------------------------------------------
int __cdecl xmlStrQEqual(char *a1, char *a2, char *a3)
{
  char *v3; // esi
  char *v5; // edi
  char *v6; // eax
  char v7; // dl
  char v8; // cl
  char v9; // cl
  char *v10; // eax
  char v11; // dl
  char v12; // cl

  v3 = a1;
  if ( !a1 )
    return xmlStrEqual(a2, a3);
  v5 = a2;
  if ( a2 )
  {
    v6 = a3;
    if ( a3 )
    {
      while ( 1 )
      {
        v7 = *v3;
        v8 = *v6;
        ++v3;
        if ( v7 != *v6 )
          break;
        ++v6;
        if ( !v8 || !*v3 )
        {
          v9 = *v6;
          v10 = v6 + 1;
          if ( v9 == 58 )
          {
            while ( 1 )
            {
              v11 = *v5;
              v12 = *v10;
              ++v5;
              if ( v11 != *v10 )
                break;
              ++v10;
              if ( !v12 )
                return 1;
            }
          }
          return 0;
        }
      }
    }
  }
  return 0;
}

//----- (0042F1BE) --------------------------------------------------------
int __cdecl xmlStrncmp(unsigned __int8 *a1, char *a2, int a3)
{
  int result; // eax
  char *v4; // edx
  unsigned __int8 *v5; // esi
  char v6; // cl

  if ( a3 <= 0 )
    return 0;
  v4 = a2;
  v5 = a1;
  if ( a1 == (unsigned __int8 *)a2 )
    return 0;
  if ( !a1 )
    return -1;
  if ( !a2 )
    return 1;
  do
  {
    v6 = *v4;
    result = *v5++ - (unsigned __int8)*v4;
    if ( result )
      break;
    if ( !--a3 )
      break;
    ++v4;
  }
  while ( v6 );
  return result;
}

//----- (0042F209) --------------------------------------------------------
int __cdecl xmlStrcasecmp(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // edx
  unsigned __int8 *v3; // esi
  int result; // eax
  char v5; // cl

  v2 = a2;
  v3 = a1;
  if ( a1 == a2 )
    return 0;
  if ( !a1 )
    return -1;
  if ( !a2 )
    return 1;
  do
  {
    v5 = *v2;
    result = (unsigned __int8)byte_47C500[*v3++] - (unsigned __int8)byte_47C500[*v2];
    if ( result )
      break;
    ++v2;
  }
  while ( v5 );
  return result;
}

//----- (0042F252) --------------------------------------------------------
int __cdecl xmlStrncasecmp(unsigned __int8 *a1, char *a2, int a3)
{
  int result; // eax
  char *v4; // edx
  unsigned __int8 *v5; // esi
  char v6; // cl

  if ( a3 <= 0 )
    return 0;
  v4 = a2;
  v5 = a1;
  if ( a1 == (unsigned __int8 *)a2 )
    return 0;
  if ( !a1 )
    return -1;
  if ( !a2 )
    return 1;
  do
  {
    v6 = *v4;
    result = (unsigned __int8)byte_47C500[*v5++] - (unsigned __int8)byte_47C500[(unsigned __int8)*v4];
    if ( result )
      break;
    if ( !--a3 )
      break;
    ++v4;
  }
  while ( v6 );
  return result;
}

//----- (0042F2AB) --------------------------------------------------------
_BYTE *__cdecl xmlStrchr(_BYTE *a1, char a2)
{
  _BYTE *result; // eax

  result = a1;
  if ( a1 )
  {
    while ( *result )
    {
      if ( *result == a2 )
        return result;
      ++result;
    }
  }
  return 0;
}

//----- (0042F2C5) --------------------------------------------------------
unsigned __int8 *__cdecl xmlStrstr(unsigned __int8 *a1, char *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 v4; // al
  char v5; // bl
  int v6; // [esp+Ch] [ebp+8h]

  v2 = a1;
  if ( !a1 )
    return 0;
  if ( !a2 )
    return 0;
  v6 = xmlStrlen(a2);
  if ( !v6 )
    return v2;
  v4 = *v2;
  if ( !*v2 )
    return 0;
  v5 = *a2;
  while ( v4 != v5 || xmlStrncmp(v2, a2, v6) )
  {
    v4 = *++v2;
    if ( !*v2 )
      return 0;
  }
  return v2;
}

//----- (0042F322) --------------------------------------------------------
unsigned __int8 *__cdecl xmlStrcasestr(unsigned __int8 *a1, char *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 v4; // al
  char v5; // bl
  int v6; // [esp+Ch] [ebp+8h]

  v2 = a1;
  if ( !a1 )
    return 0;
  if ( !a2 )
    return 0;
  v6 = xmlStrlen(a2);
  if ( !v6 )
    return v2;
  v4 = *v2;
  if ( !*v2 )
    return 0;
  v5 = byte_47C500[(unsigned __int8)*a2];
  while ( byte_47C500[v4] != v5 || xmlStrncasecmp(v2, a2, v6) )
  {
    v4 = *++v2;
    if ( !*v2 )
      return 0;
  }
  return v2;
}

//----- (0042F38D) --------------------------------------------------------
_BYTE *__cdecl xmlStrsub(_BYTE *Src, int a2, int Size)
{
  _BYTE *v3; // eax
  int v5; // ecx

  v3 = Src;
  if ( !Src || a2 < 0 || Size < 0 )
    return 0;
  v5 = 0;
  if ( a2 > 0 )
  {
    while ( *v3 )
    {
      ++v3;
      if ( ++v5 >= a2 )
        goto LABEL_8;
    }
    return 0;
  }
LABEL_8:
  if ( !*v3 )
    return 0;
  return xmlStrndup(v3, Size);
}

//----- (0042F3CA) --------------------------------------------------------
int __cdecl xmlStrlen(_BYTE *a1)
{
  _BYTE *v1; // ecx
  int result; // eax

  v1 = a1;
  result = 0;
  if ( a1 && *a1 )
  {
    do
    {
      ++v1;
      ++result;
    }
    while ( *v1 );
  }
  return result;
}

//----- (0042F3E1) --------------------------------------------------------
_BYTE *__cdecl xmlStrncat(_BYTE *Block, void *Src, int Size)
{
  int v4; // edi
  int v5; // eax
  int v6; // ebx
  void *v7; // edi

  if ( !Src || !Size )
    return Block;
  if ( Size < 0 )
    return 0;
  if ( !Block )
    return xmlStrndup(Src, Size);
  v4 = xmlStrlen(Block);
  v5 = xmlRealloc(Block, v4 + Size + 1);
  v6 = v5;
  if ( !v5 )
  {
    xmlErrMemory(0, 0);
    return Block;
  }
  v7 = (void *)(v5 + v4);
  memcpy(v7, Src, Size);
  *((_BYTE *)v7 + Size) = 0;
  return (_BYTE *)v6;
}
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);

//----- (0042F456) --------------------------------------------------------
char *__cdecl xmlStrncatNew(_BYTE *Src, _BYTE *a2, signed int Size)
{
  int v3; // edi
  int v5; // esi
  char *v6; // eax
  char *v7; // ebx
  char *v8; // esi

  v3 = Size;
  if ( Size < 0 )
    v3 = xmlStrlen(a2);
  if ( !a2 || !v3 )
    return xmlStrdup(Src);
  if ( !Src )
    return xmlStrndup(a2, v3);
  v5 = xmlStrlen(Src);
  v6 = (char *)xmlMalloc(v5 + v3 + 1);
  v7 = v6;
  if ( v6 )
  {
    memcpy(v6, Src, v5);
    v8 = &v7[v5];
    memcpy(v8, a2, v3);
    v8[v3] = 0;
    return v7;
  }
  else
  {
    xmlErrMemory(0, 0);
    return xmlStrndup(Src, v5);
  }
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (0042F4EB) --------------------------------------------------------
_BYTE *__cdecl xmlStrcat(_BYTE *Block, _BYTE *Src)
{
  _BYTE *v2; // eax

  v2 = Src;
  if ( !Src )
    return Block;
  if ( !Block )
    return xmlStrdup(Src);
  if ( *Src )
  {
    do
      ++v2;
    while ( *v2 );
  }
  return xmlStrncat(Block, Src, v2 - Src);
}

//----- (0042F524) --------------------------------------------------------
int xmlStrPrintf(char *Buffer, size_t BufferCount, char *Format, ...)
{
  int result; // eax
  va_list va; // [esp+18h] [ebp+14h] BYREF

  va_start(va, Format);
  if ( !Buffer || !Format )
    return -1;
  result = _vsnprintf(Buffer, BufferCount, Format, va);
  Buffer[BufferCount - 1] = 0;
  return result;
}

//----- (0042F558) --------------------------------------------------------
int __cdecl xmlStrVPrintf(char *Buffer, size_t BufferCount, char *Format, va_list ArgList)
{
  int result; // eax

  if ( !Buffer || !Format )
    return -1;
  result = _vsnprintf(Buffer, BufferCount, Format, ArgList);
  Buffer[BufferCount - 1] = 0;
  return result;
}

//----- (0042F58B) --------------------------------------------------------
int __cdecl xmlUTF8Size(unsigned __int8 *a1)
{
  unsigned __int8 v1; // dl
  int result; // eax
  unsigned __int8 v3; // cl

  if ( !a1 )
    return -1;
  v1 = *a1;
  if ( *a1 < 0x80u )
    return 1;
  if ( (v1 & 0x40) == 0 )
    return -1;
  result = 2;
  v3 = 32;
  while ( (v1 & v3) != 0 )
  {
    ++result;
    v3 >>= 1;
    if ( !v3 )
      return -1;
  }
  return result;
}

//----- (0042F5B5) --------------------------------------------------------
int __cdecl xmlUTF8Charcmp(unsigned __int8 *a1, char *a2)
{
  int v3; // eax

  if ( !a1 )
    return -(a2 != 0);
  v3 = xmlUTF8Size(a1);
  return xmlStrncmp(a1, a2, v3);
}

//----- (0042F5E0) --------------------------------------------------------
int __cdecl xmlUTF8Strlen(char *a1)
{
  char *v1; // ecx
  int v2; // esi
  char v4; // dl

  v1 = a1;
  v2 = 0;
  if ( !a1 )
    return -1;
  while ( 1 )
  {
    v4 = *v1;
    if ( !*v1 )
      break;
    if ( *v1 >= 0 )
    {
      ++v1;
    }
    else
    {
      if ( (v1[1] & 0xC0) != 0x80 )
        return -1;
      if ( (v4 & 0xE0) == 0xE0 )
      {
        if ( (v1[2] & 0xC0) != 0x80 )
          return -1;
        if ( (v4 & 0xF0) == 0xF0 )
        {
          if ( (v4 & 0xF8) != 0xF0 || (v1[3] & 0xC0) != 0x80 )
            return -1;
          v1 += 4;
        }
        else
        {
          v1 += 3;
        }
      }
      else
      {
        v1 += 2;
      }
    }
    ++v2;
  }
  return v2;
}

//----- (0042F63E) --------------------------------------------------------
int __cdecl xmlGetUTF8Char(unsigned __int8 *a1, int *a2)
{
  int v2; // edi
  int result; // eax
  unsigned __int8 v4; // cl
  int v5; // eax

  if ( !a1 )
    goto LABEL_15;
  if ( !a2 )
    return -1;
  v2 = *a2;
  if ( *a2 < 1 )
  {
LABEL_15:
    if ( a2 )
      *a2 = 0;
    return -1;
  }
  result = *a1;
  if ( (result & 0x80u) != 0 )
  {
    if ( v2 >= 2 && (a1[1] & 0xC0) == 0x80 )
    {
      if ( (result & 0xE0) != 0xE0 )
      {
        *a2 = 2;
        v4 = a1[1];
        v5 = *a1 & 0x1F;
        return v4 & 0x3F | (v5 << 6);
      }
      if ( v2 >= 3 && (a1[2] & 0xC0) == 0x80 )
      {
        if ( (result & 0xF0) != 0xF0 )
        {
          *a2 = 3;
          v4 = a1[2];
          v5 = a1[1] & 0x3F | ((*a1 & 0xF) << 6);
          return v4 & 0x3F | (v5 << 6);
        }
        if ( v2 >= 4 && (result & 0xF8) == 0xF0 && (a1[3] & 0xC0) == 0x80 )
        {
          *a2 = 4;
          v4 = a1[3];
          v5 = a1[2] & 0x3F | ((a1[1] & 0x3F | ((*a1 & 7) << 6)) << 6);
          return v4 & 0x3F | (v5 << 6);
        }
      }
    }
    goto LABEL_15;
  }
  *a2 = 1;
  return result;
}

//----- (0042F736) --------------------------------------------------------
int __cdecl xmlCheckUTF8(char *a1)
{
  int result; // eax
  char i; // dl

  result = 0;
  if ( a1 )
  {
    for ( i = *a1; ; i = a1[result] )
    {
      if ( !i )
        return 1;
      if ( i < 0 )
      {
        if ( (i & 0xE0) == 0xC0 )
        {
          if ( (a1[result + 1] & 0xC0) != 0x80 )
            return 0;
          result += 2;
        }
        else if ( (i & 0xF0) == 0xE0 )
        {
          if ( (a1[result + 1] & 0xC0) != 0x80 || (a1[result + 2] & 0xC0) != 0x80 )
            return 0;
          result += 3;
        }
        else
        {
          if ( (i & 0xF8) != 0xF0
            || (a1[result + 1] & 0xC0) != 0x80
            || (a1[result + 2] & 0xC0) != 0x80
            || (a1[result + 3] & 0xC0) != 0x80 )
          {
            return 0;
          }
          result += 4;
        }
      }
      else
      {
        ++result;
      }
    }
  }
  return result;
}

//----- (0042F7CD) --------------------------------------------------------
_BYTE *__cdecl xmlUTF8Strsize(char *a1, int a2)
{
  char *v2; // eax
  char v4; // cl
  bool i; // zf

  v2 = a1;
  if ( !a1 || a2 <= 0 )
    return 0;
  do
  {
    v4 = *v2;
    --a2;
    if ( !*v2 )
      break;
    ++v2;
    for ( i = v4 >= 0; !i; i = *v2 == 0 )
    {
      v4 *= 2;
      if ( v4 >= 0 )
        break;
      ++v2;
    }
  }
  while ( a2 > 0 );
  return (_BYTE *)(v2 - a1);
}

//----- (0042F80C) --------------------------------------------------------
void *__cdecl xmlUTF8Strndup(char *Src, int a2)
{
  _BYTE *v2; // esi
  void *v3; // eax
  void *v4; // edi

  if ( !Src || a2 < 0 )
    return 0;
  v2 = xmlUTF8Strsize(Src, a2);
  v3 = (void *)xmlMallocAtomic((size_t)(v2 + 1));
  v4 = v3;
  if ( !v3 )
  {
    xmlGenericError(xmlGenericErrorContext, "malloc of %ld byte failed\n", a2 + 1);
    return 0;
  }
  memcpy(v3, Src, (size_t)v2);
  v2[(_DWORD)v4] = 0;
  return v4;
}
// 49B2BC: using guessed type int (__cdecl *xmlMallocAtomic)(size_t Size);
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);

//----- (0042F86F) --------------------------------------------------------
char *__cdecl xmlUTF8Strpos(char *a1, int a2)
{
  char *result; // eax
  int v3; // esi
  char v4; // cl
  bool i; // zf
  char v6; // dl

  result = a1;
  if ( a1 )
  {
    v3 = a2;
    if ( a2 >= 0 )
    {
      if ( !a2 )
        return result;
      while ( 1 )
      {
        v4 = *result;
        --v3;
        ++result;
        if ( !v4 )
          break;
        if ( v4 < 0 )
        {
          for ( i = (v4 & 0xC0) == 0xC0; i; i = v6 == (char)0x80 )
          {
            v4 *= 2;
            if ( v4 >= 0 )
              goto LABEL_10;
            v6 = *result++ & 0xC0;
          }
          return 0;
        }
LABEL_10:
        if ( !v3 )
          return result;
      }
    }
    return 0;
  }
  return result;
}

//----- (0042F8B2) --------------------------------------------------------
int __cdecl xmlUTF8Strloc(unsigned __int8 *a1, char *a2)
{
  unsigned __int8 *v2; // esi
  int i; // edi
  bool j; // zf
  char v5; // al
  char v6; // bl
  _BYTE *v8; // [esp+14h] [ebp+4h]

  v2 = a1;
  if ( a1 && a2 )
  {
    v8 = xmlUTF8Strsize(a2, 1);
    for ( i = 0; ; ++i )
    {
      v6 = *v2;
      if ( !*v2 )
        break;
      if ( !xmlStrncmp(v2, a2, (int)v8) )
        return i;
      ++v2;
      if ( v6 < 0 )
      {
        for ( j = (v6 & 0xC0) == 0xC0; j; j = v5 == (char)0x80 )
        {
          v6 *= 2;
          if ( v6 >= 0 )
            goto LABEL_10;
          v5 = *v2++ & 0xC0;
        }
        return -1;
      }
LABEL_10:
      ;
    }
  }
  return -1;
}

//----- (0042F919) --------------------------------------------------------
void *__cdecl xmlUTF8Strsub(char *Src, int a2, int a3)
{
  char *v3; // ecx
  int v5; // esi
  char v6; // al
  bool i; // zf
  char v8; // bl

  v3 = Src;
  if ( !Src || a2 < 0 || a3 < 0 )
    return 0;
  v5 = 0;
  if ( a2 <= 0 )
    return xmlUTF8Strndup(v3, a3);
  while ( 1 )
  {
    v6 = *v3++;
    if ( !v6 )
      return 0;
    if ( v6 < 0 )
    {
      for ( i = (v6 & 0xC0) == 0xC0; i; i = v8 == (char)0x80 )
      {
        v6 *= 2;
        if ( v6 >= 0 )
          goto LABEL_12;
        v8 = *v3++ & 0xC0;
      }
      return 0;
    }
LABEL_12:
    if ( ++v5 >= a2 )
      return xmlUTF8Strndup(v3, a3);
  }
}

//----- (0042F97B) --------------------------------------------------------
int (__cdecl *__cdecl sub_42F97B(_BYTE *Src))(int, char *Format, char ArgList)
{
  int v1; // ecx
  int (__cdecl *v2)(int, char *, char); // esi
  int *v3; // ebx
  FILE *v4; // edx
  int v5; // edi

  v2 = 0;
  v3 = 0;
  v4 = 0;
  if ( v1 )
  {
    v2 = *(int (__cdecl **)(int, char *, char))(v1 + 4);
    v4 = *(FILE **)v1;
    v5 = *(_DWORD *)(v1 + 28);
    if ( (v5 == -1412623820 || v5 == -1412623819) && (unsigned int)(v1 - (_DWORD)v4 - 1) <= 0xF8 )
      v3 = *(int **)v1;
  }
  if ( Src )
    return _xmlRaiseError(0, v2, v4, v3, 0, 23, 2, 3, 0, 0, Src, 0, 0, 0, 0, "Memory allocation failed : %s\n", Src);
  else
    return _xmlRaiseError(0, v2, v4, v3, 0, 23, 2, 3, 0, 0, 0, 0, 0, 0, 0, "Memory allocation failed\n");
}
// 42F987: variable 'v1' is possibly undefined

//----- (0042FA00) --------------------------------------------------------
int (__cdecl *__usercall sub_42FA00@<eax>(int a1@<eax>, const char *ArgList))(int, char *Format, char ArgList)
{
  int (__cdecl *v2)(int, char *, char); // esi
  int *v3; // ebx
  FILE *v4; // edx
  int v5; // edi

  v2 = 0;
  v3 = 0;
  v4 = 0;
  if ( a1 )
  {
    v2 = *(int (__cdecl **)(int, char *, char))(a1 + 4);
    v4 = *(FILE **)a1;
    v5 = *(_DWORD *)(a1 + 28);
    if ( (v5 == -1412623820 || v5 == -1412623819) && (unsigned int)(a1 - (_DWORD)v4 - 1) <= 0xF8 )
      v3 = *(int **)a1;
  }
  return _xmlRaiseError(0, v2, v4, v3, 0, 23, 1, 2, 0, 0, 0, 0, 0, 0, 0, "%s", ArgList);
}

//----- (0042FA5A) --------------------------------------------------------
int *__cdecl xmlNewDocElementContent(int a1, char *Src, int Size)
{
  char *v4; // ebx
  int *v5; // esi
  char *v6; // edi
  unsigned __int8 *v7; // eax
  _DWORD *v8; // [esp+0h] [ebp-4h]

  v8 = 0;
  if ( a1 )
    v8 = *(_DWORD **)(a1 + 80);
  if ( Size != 1 )
  {
    if ( Size == 2 )
    {
      v4 = Src;
      if ( !Src )
        sub_42FA00(0, "xmlNewElementContent : name == NULL !\n");
      goto LABEL_12;
    }
    if ( Size <= 2 || Size > 4 )
    {
      sub_42FA00(0, "Internal: ELEMENT content corrupted invalid type\n");
      return 0;
    }
  }
  v4 = Src;
  if ( Src )
    sub_42FA00(0, "xmlNewElementContent : name != NULL !\n");
LABEL_12:
  v5 = (int *)xmlMalloc(28);
  if ( v5 )
  {
    memset(v5, 0, 0x1Cu);
    *v5 = Size;
    v5[1] = 1;
    if ( v4 )
    {
      v6 = (char *)xmlSplitQName3(v4, &Size);
      if ( v6 )
      {
        if ( v8 )
        {
          v5[6] = (int)xmlDictLookup(v8, v4, Size);
          v7 = xmlDictLookup(v8, v6, -1);
        }
        else
        {
          v5[6] = (int)xmlStrndup(v4, Size);
          v7 = xmlStrdup(v6);
        }
      }
      else if ( v8 )
      {
        v7 = xmlDictLookup(v8, v4, -1);
      }
      else
      {
        v7 = xmlStrdup(v4);
      }
      v5[2] = (int)v7;
    }
    return v5;
  }
  else
  {
    sub_42F97B("malloc failed");
    return 0;
  }
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (0042FB65) --------------------------------------------------------
int *__cdecl xmlNewElementContent(char *Src, int Size)
{
  return xmlNewDocElementContent(0, Src, Size);
}

//----- (0042FB78) --------------------------------------------------------
_DWORD *__cdecl xmlCopyDocElementContent(int a1, _DWORD *a2)
{
  _DWORD *v4; // esi
  char *v5; // eax
  unsigned __int8 *v6; // eax
  char *v7; // eax
  unsigned __int8 *v8; // eax
  int v9; // eax
  _DWORD *v10; // ebx
  _DWORD *v11; // esi
  char *v12; // eax
  unsigned __int8 *v13; // eax
  char *v14; // eax
  unsigned __int8 *v15; // eax
  int v16; // eax
  _DWORD *v17; // [esp+4h] [ebp-8h]
  _DWORD *v18; // [esp+8h] [ebp-4h]
  _DWORD *v19; // [esp+18h] [ebp+Ch]

  v18 = 0;
  if ( !a2 )
    return 0;
  if ( a1 )
    v18 = *(_DWORD **)(a1 + 80);
  v4 = (_DWORD *)xmlMalloc(28);
  v19 = v4;
  if ( v4 )
  {
    memset(v4, 0, 0x1Cu);
    *v4 = *a2;
    v4[1] = a2[1];
    v5 = (char *)a2[2];
    if ( v5 )
    {
      if ( v18 )
        v6 = xmlDictLookup(v18, v5, -1);
      else
        v6 = xmlStrdup(v5);
      v4[2] = v6;
    }
    v7 = (char *)a2[6];
    if ( v7 )
    {
      if ( v18 )
        v8 = xmlDictLookup(v18, v7, -1);
      else
        v8 = xmlStrdup(v7);
      v4[6] = v8;
    }
    if ( a2[3] )
      v4[3] = xmlCopyDocElementContent(a1, a2[3]);
    v9 = v4[3];
    if ( v9 )
      *(_DWORD *)(v9 + 20) = v4;
    v10 = (_DWORD *)a2[4];
    if ( !v10 )
      return v4;
    v17 = v4;
    while ( 1 )
    {
      v11 = (_DWORD *)xmlMalloc(28);
      if ( !v11 )
        break;
      memset(v11, 0, 0x1Cu);
      *v11 = *v10;
      v11[1] = v10[1];
      v17[4] = v11;
      v12 = (char *)v10[2];
      if ( v12 )
      {
        if ( v18 )
          v13 = xmlDictLookup(v18, v12, -1);
        else
          v13 = xmlStrdup(v12);
        v11[2] = v13;
      }
      v14 = (char *)v10[6];
      if ( v14 )
      {
        if ( v18 )
          v15 = xmlDictLookup(v18, v14, -1);
        else
          v15 = xmlStrdup(v14);
        v11[6] = v15;
      }
      if ( v10[3] )
        v11[3] = xmlCopyDocElementContent(a1, v10[3]);
      v16 = v11[3];
      if ( v16 )
        *(_DWORD *)(v16 + 20) = v19;
      v10 = (_DWORD *)v10[4];
      v17 = v11;
      if ( !v10 )
        return v19;
    }
    v4 = v19;
  }
  sub_42F97B("malloc failed");
  return v4;
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (0042FD0A) --------------------------------------------------------
_DWORD *__cdecl xmlCopyElementContent(_DWORD *a1)
{
  return xmlCopyDocElementContent(0, a1);
}

//----- (0042FD18) --------------------------------------------------------
int (__cdecl *__cdecl xmlFreeDocElementContent(int a1, void *Block))(int, char *Format, char ArgList)
{
  int (__cdecl *result)(int, char *, char); // eax
  void *v3; // esi
  void *v4; // ebx
  int v5; // edi
  int v6; // edi
  int v7; // [esp+0h] [ebp-4h]

  result = (int (__cdecl *)(int, char *, char))a1;
  v7 = 0;
  if ( a1 )
  {
    result = *(int (__cdecl **)(int, char *, char))(a1 + 80);
    v7 = (int)result;
  }
  v3 = Block;
  if ( Block )
  {
    while ( 1 )
    {
      v4 = (void *)*((_DWORD *)v3 + 4);
      if ( (unsigned int)(*(_DWORD *)v3 - 1) > 3 )
        break;
      if ( *((_DWORD *)v3 + 3) )
        xmlFreeDocElementContent(a1, *((void **)v3 + 3));
      if ( v7 )
      {
        v5 = *((_DWORD *)v3 + 2);
        if ( v5 && !xmlDictOwns(v7, *((_DWORD *)v3 + 2)) )
          ((void (__cdecl *)(int))xmlFree)(v5);
        v6 = *((_DWORD *)v3 + 6);
        if ( v6 )
        {
          if ( !xmlDictOwns(v7, *((_DWORD *)v3 + 6)) )
            ((void (__cdecl *)(int))xmlFree)(v6);
        }
      }
      else
      {
        if ( *((_DWORD *)v3 + 2) )
          ((void (__cdecl *)(_DWORD))xmlFree)(*((_DWORD *)v3 + 2));
        if ( *((_DWORD *)v3 + 6) )
          ((void (__cdecl *)(_DWORD))xmlFree)(*((_DWORD *)v3 + 6));
      }
      result = (int (__cdecl *)(int, char *, char))((int (__cdecl *)(void *))xmlFree)(v3);
      v3 = v4;
      if ( !v4 )
        return result;
    }
    return sub_42FA00(0, "Internal: ELEMENT content corrupted invalid type\n");
  }
  return result;
}
// 496494: invalid function type has been ignored

//----- (0042FDDD) --------------------------------------------------------
int (__cdecl *__cdecl xmlFreeElementContent(void *Block))(int, char *Format, char ArgList)
{
  return xmlFreeDocElementContent(0, Block);
}

//----- (0042FDEB) --------------------------------------------------------
void __cdecl sub_42FDEB(int *a1, int a2, int a3)
{
  _DWORD *v3; // eax
  _DWORD *v4; // eax
  bool v5; // zf
  _DWORD *v6; // eax

  if ( !a2 )
    return;
  if ( a3 )
    xmlBufferWriteChar(a1, "(");
  switch ( *(_DWORD *)a2 )
  {
    case 1:
      xmlBufferWriteChar(a1, "#PCDATA");
      goto LABEL_29;
    case 2:
      if ( *(_DWORD *)(a2 + 24) )
      {
        xmlBufferWriteCHAR(a1, *(_BYTE **)(a2 + 24));
        xmlBufferWriteChar(a1, ":");
      }
      xmlBufferWriteCHAR(a1, *(_BYTE **)(a2 + 8));
      goto LABEL_29;
    case 3:
      v6 = *(_DWORD **)(a2 + 12);
      if ( *v6 == 4 || *v6 == 3 )
        sub_42FDEB(a1, v6, 1);
      else
        sub_42FDEB(a1, v6, 0);
      xmlBufferWriteChar(a1, " , ");
      v4 = *(_DWORD **)(a2 + 16);
      if ( *v4 == 4 )
        goto LABEL_24;
      v5 = *v4 == 3;
      goto LABEL_15;
    case 4:
      v3 = *(_DWORD **)(a2 + 12);
      if ( *v3 == 4 || *v3 == 3 )
        sub_42FDEB(a1, v3, 1);
      else
        sub_42FDEB(a1, v3, 0);
      xmlBufferWriteChar(a1, " | ");
      v4 = *(_DWORD **)(a2 + 16);
      if ( *v4 == 3 )
        goto LABEL_24;
      v5 = *v4 == 4;
LABEL_15:
      if ( !v5 || v4[1] == 1 )
      {
        sub_42FDEB(a1, v4, 0);
        goto LABEL_29;
      }
LABEL_24:
      sub_42FDEB(a1, v4, 1);
      goto LABEL_29;
  }
  sub_42FA00(0, "Internal: ELEMENT content corrupted invalid type\n");
LABEL_29:
  if ( a3 )
    xmlBufferWriteChar(a1, ")");
  switch ( *(_DWORD *)(a2 + 4) )
  {
    case 2:
      xmlBufferWriteChar(a1, "?");
      break;
    case 3:
      xmlBufferWriteChar(a1, "*");
      break;
    case 4:
      xmlBufferWriteChar(a1, "+");
      break;
  }
}

//----- (0042FF38) --------------------------------------------------------
void __cdecl xmlSnprintfElementContent(char *a1, int a2, _DWORD *a3, int a4)
{
  _DWORD *v4; // edx
  unsigned int v5; // eax
  _DWORD *v6; // eax
  unsigned int v7; // eax
  int *v8; // eax
  int v9; // ecx
  bool v10; // zf
  _DWORD *v11; // eax
  unsigned int v12; // eax
  const char *v13; // esi
  char *v14; // esi
  char *v15; // edi
  const char *v16; // esi
  int v17; // [esp+0h] [ebp-4h]

  v4 = a3;
  if ( !a3 )
    return;
  v5 = strlen(a1);
  v17 = a2 - v5;
  if ( (int)(a2 - v5) < 50 )
  {
    if ( (int)(a2 - v5) > 4 && a1[v5 - 1] != 46 )
      goto LABEL_40;
    return;
  }
  if ( a4 )
    strcat(a1, "(");
  switch ( *a3 )
  {
    case 1:
      strcat(a1, "#PCDATA");
      break;
    case 2:
      v13 = (const char *)a3[6];
      if ( v13 )
      {
        if ( v17 < xmlStrlen((_BYTE *)a3[6]) + 10 )
          goto LABEL_40;
        strcat(a1, v13);
        strcat(a1, ":");
      }
      v14 = (char *)v4[2];
      if ( v17 >= xmlStrlen(v14) + 10 )
      {
        if ( v14 )
          strcat(a1, v14);
        break;
      }
LABEL_40:
      strcat(a1, " ...");
      return;
    case 3:
      v11 = (_DWORD *)a3[3];
      if ( *v11 == 4 || *v11 == 3 )
        xmlSnprintfElementContent(a1, a2, v11, 1);
      else
        xmlSnprintfElementContent(a1, a2, v11, 0);
      v12 = strlen(a1);
      if ( (int)(a2 - v12) < 50 )
      {
        if ( (int)(a2 - v12) > 4 && a1[v12 - 1] != 46 )
          goto LABEL_40;
        return;
      }
      strcat(a1, " , ");
      v8 = (int *)a3[4];
      v9 = *v8;
      v10 = *v8 == 4;
LABEL_21:
      if ( !v10 && v8[1] == 1 || v9 == 2 )
        xmlSnprintfElementContent(a1, a2, v8, 0);
      else
        xmlSnprintfElementContent(a1, a2, v8, 1);
      v4 = a3;
      break;
    case 4:
      v6 = (_DWORD *)a3[3];
      if ( *v6 == 4 || *v6 == 3 )
        xmlSnprintfElementContent(a1, a2, v6, 1);
      else
        xmlSnprintfElementContent(a1, a2, v6, 0);
      v7 = strlen(a1);
      if ( (int)(a2 - v7) < 50 )
      {
        if ( (int)(a2 - v7) > 4 && a1[v7 - 1] != 46 )
          goto LABEL_40;
        return;
      }
      strcat(a1, " | ");
      v8 = (int *)a3[4];
      v9 = *v8;
      v10 = *v8 == 3;
      goto LABEL_21;
  }
  if ( a4 )
    strcat(a1, ")");
  switch ( v4[1] )
  {
    case 2:
      v15 = &a1[strlen(a1)];
      v16 = "?";
      break;
    case 3:
      v15 = &a1[strlen(a1)];
      v16 = "*";
      break;
    case 4:
      v15 = &a1[strlen(a1)];
      v16 = "+";
      break;
    default:
      return;
  }
  *(_WORD *)v15 = *(_WORD *)v16;
}
// 430147: variable 'v4' is possibly undefined

//----- (0043020C) --------------------------------------------------------
int __cdecl sub_43020C(void *Block)
{
  int result; // eax

  if ( Block )
  {
    xmlUnlinkNode((int)Block);
    xmlFreeDocElementContent(*((_DWORD *)Block + 8), *((void **)Block + 10));
    if ( *((_DWORD *)Block + 2) )
      ((void (__cdecl *)(_DWORD))xmlFree)(*((_DWORD *)Block + 2));
    if ( *((_DWORD *)Block + 12) )
      ((void (__cdecl *)(_DWORD))xmlFree)(*((_DWORD *)Block + 12));
    return ((int (__cdecl *)(void *))xmlFree)(Block);
  }
  return result;
}
// 496494: invalid function type has been ignored

//----- (00430251) --------------------------------------------------------
_DWORD *__cdecl xmlAddElementDecl(int a1, _DWORD *a2, char *Src, int a4, _DWORD *a5)
{
  _BYTE *v7; // eax
  _BYTE *v8; // ebx
  int v9; // eax
  _DWORD *v10; // ecx
  int v11; // eax
  char *v12; // ebx
  int v13; // eax
  int v14; // eax
  _DWORD *v15; // esi
  int v16; // eax
  int v17; // eax
  _DWORD *v18; // esi
  _DWORD *v19; // eax
  _BYTE *v20; // eax
  int v21; // eax
  _DWORD *v22; // eax
  int v23; // ecx
  int v24; // [esp+8h] [ebp-Ch]
  void ***Dict; // [esp+Ch] [ebp-8h]
  void *Block; // [esp+10h] [ebp-4h] BYREF
  void *v27; // [esp+20h] [ebp+Ch]

  v24 = 0;
  if ( !a2 || !Src )
    return 0;
  switch ( a4 )
  {
    case 1:
      if ( a5 )
      {
        sub_42FA00(a1, "xmlAddElementDecl: content != NULL for EMPTY\n");
        return 0;
      }
      break;
    case 2:
      if ( a5 )
      {
        sub_42FA00(a1, "xmlAddElementDecl: content != NULL for ANY\n");
        return 0;
      }
      break;
    case 3:
      if ( !a5 )
      {
        sub_42FA00(a1, "xmlAddElementDecl: content == NULL for MIXED\n");
        return 0;
      }
      break;
    case 4:
      if ( !a5 )
      {
        sub_42FA00(a1, "xmlAddElementDecl: content == NULL for ELEMENT\n");
        return 0;
      }
      break;
    default:
      sub_42FA00(a1, "Internal: ELEMENT decl corrupted invalid type\n");
      return 0;
  }
  v7 = xmlSplitQName2(Src, &Block);
  v8 = v7;
  v27 = v7;
  if ( v7 )
    Src = v7;
  Dict = (void ***)a2[10];
  if ( !Dict )
  {
    v9 = a2[8];
    v10 = 0;
    if ( v9 )
      v10 = *(_DWORD **)(v9 + 80);
    Dict = (void ***)xmlHashCreateDict(0, v10);
    a2[10] = Dict;
    if ( !Dict )
    {
      sub_42F97B("xmlAddElementDecl: Table creation failed!\n");
      if ( v8 )
        ((void (__cdecl *)(_BYTE *))xmlFree)(v8);
      if ( Block )
        ((void (__cdecl *)(void *))xmlFree)(Block);
      return 0;
    }
  }
  v11 = a2[8];
  v12 = (char *)Block;
  if ( v11 )
  {
    v13 = *(_DWORD *)(v11 + 44);
    if ( v13 )
    {
      v14 = xmlHashLookup3(*(_DWORD **)(v13 + 40), Src, (char *)Block, 0);
      v15 = (_DWORD *)v14;
      if ( v14 )
      {
        if ( !*(_DWORD *)(v14 + 36) )
        {
          v16 = *(_DWORD *)(v14 + 44);
          v15[11] = 0;
          v24 = v16;
          xmlHashRemoveEntry2(*(_DWORD **)(*(_DWORD *)(a2[8] + 44) + 40), Src, v12, 0);
          sub_43020C(v15);
        }
      }
    }
  }
  v17 = xmlHashLookup3(Dict, Src, v12, 0);
  v18 = (_DWORD *)v17;
  if ( v17 )
  {
    if ( !*(_DWORD *)(v17 + 36) )
    {
      if ( v12 )
        ((void (__cdecl *)(char *))xmlFree)(v12);
      goto LABEL_53;
    }
LABEL_38:
    if ( v27 )
      ((void (__cdecl *)(void *))xmlFree)(v27);
    if ( v12 )
      ((void (__cdecl *)(char *))xmlFree)(v12);
    return 0;
  }
  v19 = (_DWORD *)xmlMalloc(56);
  v18 = v19;
  if ( !v19 )
  {
    sub_42F97B("malloc failed");
    goto LABEL_38;
  }
  memset(v19, 0, 0x38u);
  v18[1] = 15;
  v20 = xmlStrdup(Src);
  v18[2] = v20;
  if ( !v20 )
  {
    sub_42F97B("malloc failed");
    if ( v27 )
      ((void (__cdecl *)(void *))xmlFree)(v27);
    if ( v12 )
      ((void (__cdecl *)(char *))xmlFree)(v12);
    ((void (__cdecl *)(_DWORD *))xmlFree)(v18);
    return 0;
  }
  v18[12] = v12;
  if ( xmlHashAddEntry2(Dict, (unsigned __int8 *)Src, (unsigned __int8 *)v12, v18) )
  {
    sub_43020C(v18);
    if ( v27 )
      ((void (__cdecl *)(void *))xmlFree)(v27);
    return 0;
  }
  v18[11] = v24;
LABEL_53:
  v18[9] = a4;
  if ( a1 && ((v21 = *(_DWORD *)(a1 + 28), v21 == -1412623820) || v21 == -1412623819) )
  {
    v18[10] = a5;
    if ( a5 )
      a5[5] = 1;
  }
  else
  {
    v18[10] = xmlCopyDocElementContent(a2[8], a5);
  }
  v18[5] = a2;
  v18[8] = a2[8];
  v22 = a2 + 4;
  v23 = a2[4];
  if ( v23 )
  {
    *(_DWORD *)(v23 + 24) = v18;
    v18[7] = *v22;
  }
  else
  {
    a2[3] = v18;
  }
  *v22 = v18;
  if ( v27 )
    ((void (__cdecl *)(void *))xmlFree)(v27);
  return v18;
}
// 496494: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (004304EF) --------------------------------------------------------
void __cdecl xmlFreeElementTable(_DWORD *Block)
{
  xmlHashFree(Block, (void (__cdecl *)(int, _DWORD))sub_43020C);
}

//----- (00430500) --------------------------------------------------------
_DWORD *__cdecl sub_430500(int a1)
{
  _DWORD *v1; // eax
  _DWORD *v2; // esi
  _DWORD *v4; // eax

  v1 = (_DWORD *)xmlMalloc(56);
  v2 = v1;
  if ( v1 )
  {
    memset(v1, 0, 0x38u);
    v2[1] = 15;
    v2[9] = *(_DWORD *)(a1 + 36);
    if ( *(_DWORD *)(a1 + 8) )
      v2[2] = xmlStrdup(*(_BYTE **)(a1 + 8));
    else
      v2[2] = 0;
    if ( *(_DWORD *)(a1 + 48) )
      v2[12] = xmlStrdup(*(_BYTE **)(a1 + 48));
    else
      v2[12] = 0;
    v4 = xmlCopyElementContent(*(_DWORD **)(a1 + 40));
    v2[11] = 0;
    v2[10] = v4;
    return v2;
  }
  else
  {
    sub_42F97B("malloc failed");
    return 0;
  }
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (00430583) --------------------------------------------------------
void ***__cdecl xmlCopyElementTable(_DWORD *a1)
{
  return xmlHashCopy(a1, (int (__cdecl *)(int, int))sub_430500);
}

//----- (00430594) --------------------------------------------------------
void __cdecl xmlDumpElementDecl(int *a1, int a2)
{
  if ( a1 && a2 )
  {
    if ( *(_DWORD *)(a2 + 36) == 1 )
    {
      xmlBufferWriteChar(a1, "<!ELEMENT ");
      if ( *(_DWORD *)(a2 + 48) )
      {
        xmlBufferWriteCHAR(a1, *(_BYTE **)(a2 + 48));
        xmlBufferWriteChar(a1, ":");
      }
      xmlBufferWriteCHAR(a1, *(_BYTE **)(a2 + 8));
      xmlBufferWriteChar(a1, " EMPTY>\n");
    }
    else if ( *(_DWORD *)(a2 + 36) == 2 )
    {
      xmlBufferWriteChar(a1, "<!ELEMENT ");
      if ( *(_DWORD *)(a2 + 48) )
      {
        xmlBufferWriteCHAR(a1, *(_BYTE **)(a2 + 48));
        xmlBufferWriteChar(a1, ":");
      }
      xmlBufferWriteCHAR(a1, *(_BYTE **)(a2 + 8));
      xmlBufferWriteChar(a1, " ANY>\n");
    }
    else if ( (unsigned int)(*(_DWORD *)(a2 + 36) - 3) < 2 )
    {
      xmlBufferWriteChar(a1, "<!ELEMENT ");
      if ( *(_DWORD *)(a2 + 48) )
      {
        xmlBufferWriteCHAR(a1, *(_BYTE **)(a2 + 48));
        xmlBufferWriteChar(a1, ":");
      }
      xmlBufferWriteCHAR(a1, *(_BYTE **)(a2 + 8));
      xmlBufferWriteChar(a1, " ");
      sub_42FDEB(a1, *(_DWORD *)(a2 + 40), 1);
      xmlBufferWriteChar(a1, ">\n");
    }
    else
    {
      sub_42FA00(0, "Internal: ELEMENT struct corrupted invalid type\n");
    }
  }
}

//----- (004306A7) --------------------------------------------------------
void __cdecl sub_4306A7(int a1, int *a2)
{
  xmlDumpElementDecl(a2, a1);
}

//----- (004306B7) --------------------------------------------------------
void __cdecl xmlDumpElementTable(int a1, _DWORD *a2)
{
  if ( a1 )
  {
    if ( a2 )
      xmlHashScan(a2, (int)sub_4306A7, a1);
  }
}

//----- (004306DB) --------------------------------------------------------
_DWORD *__cdecl xmlCreateEnumeration(_BYTE *Src)
{
  _DWORD *v1; // esi

  v1 = (_DWORD *)xmlMalloc(8);
  if ( v1 )
  {
    *v1 = 0;
    v1[1] = 0;
    if ( Src )
      v1[1] = xmlStrdup(Src);
    return v1;
  }
  else
  {
    sub_42F97B("malloc failed");
    return 0;
  }
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (0043071C) --------------------------------------------------------
int __cdecl xmlFreeEnumeration(void **Block)
{
  int result; // eax

  if ( Block )
  {
    if ( *Block )
      xmlFreeEnumeration(*Block);
    if ( Block[1] )
      ((void (__cdecl *)(void *))xmlFree)(Block[1]);
    return ((int (__cdecl *)(void **))xmlFree)(Block);
  }
  return result;
}
// 496494: invalid function type has been ignored

//----- (0043074B) --------------------------------------------------------
_DWORD *__cdecl xmlCopyEnumeration(int a1)
{
  _DWORD *Enumeration; // eax
  _DWORD *v3; // edi

  if ( !a1 )
    return 0;
  Enumeration = xmlCreateEnumeration(*(_BYTE **)(a1 + 4));
  v3 = Enumeration;
  if ( *(_DWORD *)a1 )
    *Enumeration = xmlCopyEnumeration(*(_DWORD *)a1);
  else
    *Enumeration = 0;
  return v3;
}

//----- (0043077D) --------------------------------------------------------
int __usercall sub_43077D@<eax>(int result@<eax>, int *a2@<edi>)
{
  int v2; // esi

  v2 = result;
  if ( a2 )
  {
    while ( v2 )
    {
      xmlBufferWriteCHAR(a2, *(_BYTE **)(v2 + 4));
      if ( !*(_DWORD *)v2 )
        return xmlBufferWriteChar(a2, ")");
      result = xmlBufferWriteChar(a2, " | ");
      v2 = *(_DWORD *)v2;
    }
  }
  return result;
}

//----- (004307B8) --------------------------------------------------------
void __cdecl sub_4307B8(void *Block)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edi
  int v4; // edi
  int v5; // edi
  int v6; // edi

  if ( Block )
  {
    v1 = *((_DWORD *)Block + 8);
    if ( v1 )
      v2 = *(_DWORD *)(v1 + 80);
    else
      v2 = 0;
    xmlUnlinkNode((int)Block);
    if ( *((_DWORD *)Block + 13) )
      xmlFreeEnumeration(*((void ***)Block + 13));
    if ( v2 )
    {
      v3 = *((_DWORD *)Block + 15);
      if ( v3 && !xmlDictOwns(v2, *((_DWORD *)Block + 15)) )
        ((void (__cdecl *)(int))xmlFree)(v3);
      v4 = *((_DWORD *)Block + 2);
      if ( v4 && !xmlDictOwns(v2, *((_DWORD *)Block + 2)) )
        ((void (__cdecl *)(int))xmlFree)(v4);
      v5 = *((_DWORD *)Block + 14);
      if ( v5 && !xmlDictOwns(v2, *((_DWORD *)Block + 14)) )
        ((void (__cdecl *)(int))xmlFree)(v5);
      v6 = *((_DWORD *)Block + 12);
      if ( v6 )
      {
        if ( !xmlDictOwns(v2, *((_DWORD *)Block + 12)) )
          ((void (__cdecl *)(int))xmlFree)(v6);
      }
    }
    else
    {
      if ( *((_DWORD *)Block + 15) )
        ((void (__cdecl *)(_DWORD))xmlFree)(*((_DWORD *)Block + 15));
      if ( *((_DWORD *)Block + 2) )
        ((void (__cdecl *)(_DWORD))xmlFree)(*((_DWORD *)Block + 2));
      if ( *((_DWORD *)Block + 12) )
        ((void (__cdecl *)(_DWORD))xmlFree)(*((_DWORD *)Block + 12));
      if ( *((_DWORD *)Block + 14) )
        ((void (__cdecl *)(_DWORD))xmlFree)(*((_DWORD *)Block + 14));
    }
    ((void (__cdecl *)(void *))xmlFree)(Block);
  }
}
// 496494: invalid function type has been ignored

//----- (004308A1) --------------------------------------------------------
void *__cdecl xmlAddAttributeDecl(
        int a1,
        _DWORD *a2,
        char *a3,
        char *Src,
        char *a5,
        int a6,
        int a7,
        char *a8,
        void **Block)
{
  _DWORD *v11; // eax
  int v12; // eax
  _DWORD *v13; // eax
  void *v14; // eax
  void *v15; // esi
  unsigned __int8 *v16; // eax
  unsigned __int8 *v17; // eax
  _DWORD *v18; // edi
  char *v19; // eax
  int v20; // edi
  char *v21; // eax
  _DWORD *v22; // eax
  int v23; // ecx
  _DWORD *v24; // [esp+8h] [ebp-4h]
  void ***Dict; // [esp+18h] [ebp+Ch]
  int v26; // [esp+18h] [ebp+Ch]

  v24 = 0;
  if ( !a2
    || !Src
    || !a3
    || (v11 = (_DWORD *)a2[8]) != 0
    && (v24 = (_DWORD *)v11[20], (_DWORD *)v11[12] == a2)
    && (v12 = v11[11]) != 0
    && (v13 = *(_DWORD **)(v12 + 44)) != 0
    && xmlHashLookup3(v13, Src, a5, a3) )
  {
    xmlFreeEnumeration(Block);
    return 0;
  }
  Dict = (void ***)a2[11];
  if ( !Dict )
  {
    Dict = (void ***)xmlHashCreateDict(0, v24);
    a2[11] = Dict;
    if ( !Dict )
    {
      sub_42F97B("xmlAddAttributeDecl: Table creation failed!\n");
      xmlFreeEnumeration(Block);
      return 0;
    }
  }
  v14 = (void *)xmlMalloc(64);
  v15 = v14;
  if ( !v14 )
  {
    sub_42F97B("malloc failed");
    xmlFreeEnumeration(Block);
    return 0;
  }
  memset(v14, 0, 0x40u);
  *((_DWORD *)v15 + 1) = 16;
  *((_DWORD *)v15 + 10) = a6;
  *((_DWORD *)v15 + 8) = a2[8];
  if ( v24 )
  {
    *((_DWORD *)v15 + 2) = xmlDictLookup(v24, Src, -1);
    *((_DWORD *)v15 + 14) = xmlDictLookup(v24, a5, -1);
    v16 = xmlDictLookup(v24, a3, -1);
  }
  else
  {
    *((_DWORD *)v15 + 2) = xmlStrdup(Src);
    *((_DWORD *)v15 + 14) = xmlStrdup(a5);
    v16 = xmlStrdup(a3);
  }
  *((_DWORD *)v15 + 15) = v16;
  *((_DWORD *)v15 + 11) = a7;
  *((_DWORD *)v15 + 13) = Block;
  if ( a8 )
  {
    if ( v24 )
      v17 = xmlDictLookup(v24, a8, -1);
    else
      v17 = xmlStrdup(a8);
    *((_DWORD *)v15 + 12) = v17;
  }
  if ( xmlHashAddEntry3(
         Dict,
         *((unsigned __int8 **)v15 + 2),
         *((unsigned __int8 **)v15 + 14),
         *((char **)v15 + 15),
         v15) < 0 )
  {
    sub_4307B8(v15);
    return 0;
  }
  v18 = sub_431712((int)a2, a3);
  v26 = (int)v18;
  if ( v18 )
  {
    if ( xmlStrEqual(*((char **)v15 + 2), "xmlns")
      || (v19 = (char *)*((_DWORD *)v15 + 14)) != 0 && xmlStrEqual(v19, "xmlns") )
    {
      *((_DWORD *)v15 + 9) = v18[11];
      v18[11] = v15;
    }
    else
    {
      v20 = v18[11];
      if ( !v20 )
        goto LABEL_39;
      while ( 1 )
      {
        if ( !xmlStrEqual(*(char **)(v20 + 8), "xmlns") )
        {
          v21 = (char *)*((_DWORD *)v15 + 14);
          if ( !v21 || !xmlStrEqual(v21, "xmlns") )
            break;
        }
        if ( !*(_DWORD *)(v20 + 36) )
          break;
        v20 = *(_DWORD *)(v20 + 36);
      }
      if ( v20 )
      {
        *((_DWORD *)v15 + 9) = *(_DWORD *)(v20 + 36);
        *(_DWORD *)(v20 + 36) = v15;
      }
      else
      {
LABEL_39:
        *((_DWORD *)v15 + 9) = *(_DWORD *)(v26 + 44);
        *(_DWORD *)(v26 + 44) = v15;
      }
    }
  }
  v22 = a2 + 4;
  *((_DWORD *)v15 + 5) = a2;
  v23 = a2[4];
  if ( v23 )
  {
    *(_DWORD *)(v23 + 24) = v15;
    *((_DWORD *)v15 + 7) = *v22;
  }
  else
  {
    a2[3] = v15;
  }
  *v22 = v15;
  return v15;
}
// 430ABC: conditional instruction was optimized away because eax.4!=0
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (00430B09) --------------------------------------------------------
void __cdecl xmlFreeAttributeTable(_DWORD *Block)
{
  xmlHashFree(Block, (void (__cdecl *)(int, _DWORD))sub_4307B8);
}

//----- (00430B1A) --------------------------------------------------------
_DWORD *__cdecl sub_430B1A(int a1)
{
  _DWORD *v1; // eax
  _DWORD *v2; // esi
  _BYTE *v4; // edi

  v1 = (_DWORD *)xmlMalloc(64);
  v2 = v1;
  if ( v1 )
  {
    memset(v1, 0, 0x40u);
    v2[1] = 16;
    v2[10] = *(_DWORD *)(a1 + 40);
    v2[11] = *(_DWORD *)(a1 + 44);
    v2[13] = xmlCopyEnumeration(*(_DWORD *)(a1 + 52));
    if ( *(_DWORD *)(a1 + 60) )
      v2[15] = xmlStrdup(*(_BYTE **)(a1 + 60));
    if ( *(_DWORD *)(a1 + 8) )
      v2[2] = xmlStrdup(*(_BYTE **)(a1 + 8));
    if ( *(_DWORD *)(a1 + 56) )
      v2[14] = xmlStrdup(*(_BYTE **)(a1 + 56));
    v4 = *(_BYTE **)(a1 + 48);
    if ( v4 )
      v2[12] = xmlStrdup(v4);
    return v2;
  }
  else
  {
    sub_42F97B("malloc failed");
    return 0;
  }
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (00430BB4) --------------------------------------------------------
void ***__cdecl xmlCopyAttributeTable(_DWORD *a1)
{
  return xmlHashCopy(a1, (int (__cdecl *)(int, int))sub_430B1A);
}

//----- (00430BC5) --------------------------------------------------------
void __cdecl xmlDumpAttributeDecl(int *a1, int a2)
{
  if ( a1 && a2 )
  {
    xmlBufferWriteChar(a1, "<!ATTLIST ");
    xmlBufferWriteCHAR(a1, *(_BYTE **)(a2 + 60));
    xmlBufferWriteChar(a1, " ");
    if ( *(_DWORD *)(a2 + 56) )
    {
      xmlBufferWriteCHAR(a1, *(_BYTE **)(a2 + 56));
      xmlBufferWriteChar(a1, ":");
    }
    xmlBufferWriteCHAR(a1, *(_BYTE **)(a2 + 8));
    switch ( *(_DWORD *)(a2 + 40) )
    {
      case 1:
        xmlBufferWriteChar(a1, " CDATA");
        break;
      case 2:
        xmlBufferWriteChar(a1, " ID");
        break;
      case 3:
        xmlBufferWriteChar(a1, " IDREF");
        break;
      case 4:
        xmlBufferWriteChar(a1, " IDREFS");
        break;
      case 5:
        xmlBufferWriteChar(a1, " ENTITY");
        break;
      case 6:
        xmlBufferWriteChar(a1, " ENTITIES");
        break;
      case 7:
        xmlBufferWriteChar(a1, " NMTOKEN");
        break;
      case 8:
        xmlBufferWriteChar(a1, " NMTOKENS");
        break;
      case 9:
        xmlBufferWriteChar(a1, " (");
        goto LABEL_16;
      case 0xA:
        xmlBufferWriteChar(a1, " NOTATION (");
LABEL_16:
        sub_43077D(*(_DWORD *)(a2 + 52), a1);
        break;
      default:
        sub_42FA00(0, "Internal: ATTRIBUTE struct corrupted invalid type\n");
        break;
    }
    if ( *(_DWORD *)(a2 + 44) != 1 )
    {
      switch ( *(_DWORD *)(a2 + 44) )
      {
        case 2:
          xmlBufferWriteChar(a1, " #REQUIRED");
          break;
        case 3:
          xmlBufferWriteChar(a1, " #IMPLIED");
          break;
        case 4:
          xmlBufferWriteChar(a1, " #FIXED");
          break;
        default:
          sub_42FA00(0, "Internal: ATTRIBUTE struct corrupted invalid def\n");
          break;
      }
    }
    if ( *(_DWORD *)(a2 + 48) )
    {
      xmlBufferWriteChar(a1, " ");
      xmlBufferWriteQuotedString(a1, *(_BYTE **)(a2 + 48));
    }
    xmlBufferWriteChar(a1, ">\n");
  }
}

//----- (00430D41) --------------------------------------------------------
void __cdecl xmlDumpAttributeTable(int a1, _DWORD *a2)
{
  if ( a1 )
  {
    if ( a2 )
      xmlHashScan(a2, (int)sub_430D31, a1);
  }
}
// 430D31: using guessed type int sub_430D31();

//----- (00430D65) --------------------------------------------------------
int __cdecl sub_430D65(_DWORD *Block)
{
  int result; // eax

  if ( Block )
  {
    if ( *Block )
      ((void (__cdecl *)(_DWORD))xmlFree)(*Block);
    if ( Block[1] )
      ((void (__cdecl *)(_DWORD))xmlFree)(Block[1]);
    if ( Block[2] )
      ((void (__cdecl *)(_DWORD))xmlFree)(Block[2]);
    return ((int (__cdecl *)(_DWORD *))xmlFree)(Block);
  }
  return result;
}
// 496494: invalid function type has been ignored

//----- (00430DA4) --------------------------------------------------------
_DWORD *__cdecl xmlAddNotationDecl(int a1, int a2, unsigned __int8 *Src, _BYTE *a4, _BYTE *a5)
{
  void ***Dict; // ebx
  int v7; // eax
  _DWORD *v8; // ecx
  _DWORD *v9; // esi

  if ( !a2 || !Src || !a4 && !a5 )
    return 0;
  Dict = *(void ****)(a2 + 36);
  if ( !Dict )
  {
    v7 = *(_DWORD *)(a2 + 32);
    v8 = 0;
    if ( v7 )
      v8 = *(_DWORD **)(v7 + 80);
    Dict = (void ***)xmlHashCreateDict(0, v8);
    *(_DWORD *)(a2 + 36) = Dict;
    if ( !Dict )
    {
      sub_42F97B("xmlAddNotationDecl: Table creation failed!\n");
      return 0;
    }
  }
  v9 = (_DWORD *)xmlMalloc(12);
  if ( !v9 )
  {
    sub_42F97B("malloc failed");
    return 0;
  }
  *v9 = 0;
  v9[1] = 0;
  v9[2] = 0;
  *v9 = xmlStrdup(Src);
  if ( a5 )
    v9[2] = xmlStrdup(a5);
  if ( a4 )
    v9[1] = xmlStrdup(a4);
  if ( xmlHashAddEntry(Dict, Src, v9) )
  {
    sub_430D65(v9);
    return 0;
  }
  return v9;
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (00430E6C) --------------------------------------------------------
void __cdecl xmlFreeNotationTable(_DWORD *Block)
{
  xmlHashFree(Block, (void (__cdecl *)(int, _DWORD))sub_430D65);
}

//----- (00430E7D) --------------------------------------------------------
_DWORD *__cdecl sub_430E7D(int a1)
{
  _DWORD *v1; // esi
  _BYTE *v3; // edi

  v1 = (_DWORD *)xmlMalloc(12);
  if ( v1 )
  {
    if ( *(_DWORD *)a1 )
      *v1 = xmlStrdup(*(_BYTE **)a1);
    else
      *v1 = 0;
    if ( *(_DWORD *)(a1 + 4) )
      v1[1] = xmlStrdup(*(_BYTE **)(a1 + 4));
    else
      v1[1] = 0;
    v3 = *(_BYTE **)(a1 + 8);
    if ( v3 )
      v1[2] = xmlStrdup(v3);
    else
      v1[2] = 0;
    return v1;
  }
  else
  {
    sub_42F97B("malloc failed");
    return 0;
  }
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (00430EEA) --------------------------------------------------------
void ***__cdecl xmlCopyNotationTable(_DWORD *a1)
{
  return xmlHashCopy(a1, (int (__cdecl *)(int, int))sub_430E7D);
}

//----- (00430EFB) --------------------------------------------------------
int __cdecl xmlDumpNotationDecl(int *a1, _BYTE **a2)
{
  int result; // eax

  if ( a1 && a2 )
  {
    xmlBufferWriteChar(a1, "<!NOTATION ");
    xmlBufferWriteCHAR(a1, *a2);
    if ( a2[1] )
    {
      xmlBufferWriteChar(a1, " PUBLIC ");
      xmlBufferWriteQuotedString(a1, a2[1]);
      if ( a2[2] )
      {
        xmlBufferWriteChar(a1, " ");
        xmlBufferWriteQuotedString(a1, a2[2]);
      }
    }
    else
    {
      xmlBufferWriteChar(a1, " SYSTEM ");
      xmlBufferWriteQuotedString(a1, a2[2]);
    }
    return xmlBufferWriteChar(a1, " >\n");
  }
  return result;
}

//----- (00430F7D) --------------------------------------------------------
int __cdecl sub_430F7D(_BYTE **a1, int *a2)
{
  return xmlDumpNotationDecl(a2, a1);
}

//----- (00430F8D) --------------------------------------------------------
void __cdecl xmlDumpNotationTable(int a1, _DWORD *a2)
{
  if ( a1 )
  {
    if ( a2 )
      xmlHashScan(a2, (int)sub_430F7D, a1);
  }
}

//----- (00430FB1) --------------------------------------------------------
void __cdecl sub_430FB1(_DWORD *Block)
{
  int v1; // ebx
  int v2; // eax
  int v3; // edi
  int v4; // edi

  v1 = 0;
  if ( Block )
  {
    v2 = Block[5];
    if ( v2 )
      v1 = *(_DWORD *)(v2 + 80);
    v3 = Block[1];
    if ( v3 && (!v1 || !xmlDictOwns(v1, Block[1])) )
      ((void (__cdecl *)(int))xmlFree)(v3);
    v4 = Block[3];
    if ( v4 && (!v1 || !xmlDictOwns(v1, Block[3])) )
      ((void (__cdecl *)(int))xmlFree)(v4);
    ((void (__cdecl *)(_DWORD *))xmlFree)(Block);
  }
}
// 496494: invalid function type has been ignored

//----- (00431014) --------------------------------------------------------
_DWORD *__cdecl xmlAddID(int a1, int a2, unsigned __int8 *Src, int a4)
{
  _DWORD *v6; // esi
  _DWORD *v7; // edi
  unsigned __int8 *v8; // eax
  void ***Dict; // [esp+10h] [ebp+Ch]

  if ( !a2 || !Src )
    return 0;
  if ( !a4 )
    return 0;
  Dict = *(void ****)(a2 + 64);
  if ( !Dict )
  {
    Dict = (void ***)xmlHashCreateDict(0, *(_DWORD **)(a2 + 80));
    *(_DWORD *)(a2 + 64) = Dict;
    if ( !Dict )
    {
      sub_42F97B("xmlAddID: Table creation failed!\n");
      return 0;
    }
  }
  v6 = (_DWORD *)xmlMalloc(24);
  if ( !v6 )
  {
    sub_42F97B("malloc failed");
    return 0;
  }
  v6[1] = xmlStrdup(Src);
  v6[5] = a2;
  if ( a1 && *(_DWORD *)(a1 + 44) )
  {
    v7 = *(_DWORD **)(a2 + 80);
    if ( v7 )
      v8 = xmlDictLookup(v7, *(char **)(a4 + 8), -1);
    else
      v8 = xmlStrdup(*(_BYTE **)(a4 + 8));
    v6[2] = 0;
    v6[3] = v8;
  }
  else
  {
    v6[3] = 0;
    v6[2] = a4;
  }
  v6[4] = xmlGetLineNo(*(_DWORD *)(a4 + 20));
  if ( xmlHashAddEntry(Dict, Src, v6) < 0 )
  {
    sub_430FB1(v6);
    return 0;
  }
  *(_DWORD *)(a4 + 40) = 2;
  return v6;
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (0043110A) --------------------------------------------------------
void __cdecl xmlFreeIDTable(_DWORD *Block)
{
  xmlHashFree(Block, (void (__cdecl *)(int, _DWORD))sub_430FB1);
}

//----- (0043111B) --------------------------------------------------------
int __cdecl xmlIsID(_DWORD *a1, int a2, int a3)
{
  int v3; // edx
  char *v4; // esi
  int v5; // eax
  int v7; // eax
  const char *v8; // eax
  const char *v9; // eax
  char *v10; // edi
  int v11; // eax
  const char *v12; // eax
  const char *v13; // eax
  char *v14; // esi
  int v15; // ebx
  int DtdAttrDesc; // [esp+18h] [ebp-70h]
  char v17[52]; // [esp+1Ch] [ebp-6Ch] BYREF
  char v18[52]; // [esp+50h] [ebp-38h] BYREF

  v3 = a3;
  if ( a3 )
  {
    v4 = *(char **)(a3 + 8);
    if ( v4 )
    {
      v5 = *(_DWORD *)(a3 + 36);
      if ( v5 && *(_DWORD *)(v5 + 12) && !strcmp(v4, "id") && !strcmp(*(const char **)(v5 + 12), "xml") )
        return 1;
      if ( a1 )
      {
        if ( a1[11] || a1[12] )
        {
          if ( a1[1] != 13 )
          {
            if ( a2 )
            {
              v7 = *(_DWORD *)(a2 + 36);
              DtdAttrDesc = 0;
              if ( v7 && (v8 = *(const char **)(v7 + 12)) != 0 )
              {
                v9 = xmlBuildQName(*(const char **)(a2 + 8), v8, v18, 50);
                v3 = a3;
                v10 = (char *)v9;
              }
              else
              {
                v10 = *(char **)(a2 + 8);
              }
              v11 = *(_DWORD *)(v3 + 36);
              if ( v11 && (v12 = *(const char **)(v11 + 12)) != 0 )
              {
                v13 = xmlBuildQName(*(const char **)(v3 + 8), v12, v17, 50);
                v3 = a3;
                v14 = (char *)v13;
              }
              else
              {
                v14 = *(char **)(v3 + 8);
              }
              if ( v10 && v14 )
              {
                DtdAttrDesc = xmlGetDtdAttrDesc(a1[11], v10, v14);
                if ( !DtdAttrDesc )
                {
                  v15 = a1[12];
                  if ( v15 )
                    DtdAttrDesc = xmlGetDtdAttrDesc(v15, v10, v14);
                }
                v3 = a3;
              }
              if ( v14 != v17 && v14 != *(char **)(v3 + 8) )
                ((void (__cdecl *)(char *))xmlFree)(v14);
              if ( v10 != v18 && v10 != *(char **)(a2 + 8) )
                ((void (__cdecl *)(char *))xmlFree)(v10);
              if ( DtdAttrDesc && *(_DWORD *)(DtdAttrDesc + 40) == 2 )
                return 1;
            }
            return 0;
          }
        }
        else if ( a1[1] != 13 )
        {
          return 0;
        }
        if ( xmlStrEqual("id", v4) || xmlStrEqual("name", v4) && (!a2 || xmlStrEqual(*(char **)(a2 + 8), "a")) )
          return 1;
      }
    }
  }
  return 0;
}
// 496494: invalid function type has been ignored

//----- (004312DD) --------------------------------------------------------
int __cdecl xmlRemoveID(_DWORD *a1, int a2)
{
  _DWORD *v3; // ebx
  char *String; // eax
  char *v5; // edi
  int v6; // eax

  if ( !a1 )
    return -1;
  if ( !a2 )
    return -1;
  v3 = (_DWORD *)a1[16];
  if ( !v3 )
    return -1;
  String = xmlNodeListGetString(a1, *(_DWORD *)(a2 + 12), 1);
  v5 = String;
  if ( String )
  {
    v6 = xmlHashLookup3(v3, String, 0, 0);
    if ( v6 && *(_DWORD *)(v6 + 8) == a2 )
    {
      xmlHashRemoveEntry(v3, v5, (void (__cdecl *)(int, _DWORD))sub_430FB1);
      ((void (__cdecl *)(char *))xmlFree)(v5);
      *(_DWORD *)(a2 + 40) = 0;
      return 0;
    }
    ((void (__cdecl *)(char *))xmlFree)(v5);
  }
  return -1;
}
// 496494: invalid function type has been ignored

//----- (0043135D) --------------------------------------------------------
int __cdecl xmlGetID(int a1, char *a2)
{
  int result; // eax
  _DWORD *v3; // eax
  int v4; // eax

  if ( !a1 )
    return 0;
  if ( !a2 )
    return 0;
  v3 = *(_DWORD **)(a1 + 64);
  if ( !v3 )
    return 0;
  v4 = xmlHashLookup3(v3, a2, 0, 0);
  if ( !v4 )
    return 0;
  result = *(_DWORD *)(v4 + 8);
  if ( !result )
    return a1;
  return result;
}

//----- (00431398) --------------------------------------------------------
int __cdecl sub_431398(int a1)
{
  int result; // eax
  int v2; // esi

  result = xmlLinkGetData(a1);
  v2 = result;
  if ( result )
  {
    if ( *(_DWORD *)(result + 4) )
      ((void (__cdecl *)(_DWORD))xmlFree)(*(_DWORD *)(result + 4));
    if ( *(_DWORD *)(v2 + 12) )
      ((void (__cdecl *)(_DWORD))xmlFree)(*(_DWORD *)(v2 + 12));
    return ((int (__cdecl *)(int))xmlFree)(v2);
  }
  return result;
}
// 496494: invalid function type has been ignored

//----- (004313D3) --------------------------------------------------------
int __cdecl sub_4313D3(_DWORD **Block)
{
  int result; // eax

  if ( Block )
    return xmlListDelete(Block);
  return result;
}

//----- (004313E0) --------------------------------------------------------
int __cdecl sub_4313E0(int a1, int *a2)
{
  if ( *(_DWORD *)(a1 + 8) != a2[1] )
    return 1;
  xmlListRemoveFirst(*a2, a1);
  return 0;
}

//----- (00431401) --------------------------------------------------------
_DWORD *__cdecl xmlAddRef(int a1, int a2, char *Src, int a4)
{
  void ***Dict; // ebx
  _DWORD *v6; // esi
  _BYTE *v7; // eax
  _DWORD **v8; // edi
  _DWORD *v9; // eax

  if ( !a2 || !Src )
    return 0;
  if ( !a4 )
    return 0;
  Dict = *(void ****)(a2 + 68);
  if ( !Dict )
  {
    Dict = (void ***)xmlHashCreateDict(0, *(_DWORD **)(a2 + 80));
    *(_DWORD *)(a2 + 68) = Dict;
    if ( !Dict )
    {
      sub_42F97B("xmlAddRef: Table creation failed!\n");
      return 0;
    }
  }
  v6 = (_DWORD *)xmlMalloc(20);
  if ( !v6 )
  {
    sub_42F97B("malloc failed");
    return 0;
  }
  v6[1] = xmlStrdup(Src);
  if ( a1 && *(_DWORD *)(a1 + 44) )
  {
    v7 = xmlStrdup(*(_BYTE **)(a4 + 8));
    v6[2] = 0;
    v6[3] = v7;
  }
  else
  {
    v6[3] = 0;
    v6[2] = a4;
  }
  v6[4] = xmlGetLineNo(*(_DWORD *)(a4 + 20));
  v8 = (_DWORD **)xmlHashLookup3(Dict, Src, 0, 0);
  if ( !v8 )
  {
    v9 = xmlListCreate((int)sub_431398, (int)xmlSAX2GetPublicId);
    v8 = (_DWORD **)v9;
    if ( !v9 )
    {
      sub_42FA00(0, "xmlAddRef: Reference list creation failed!\n");
LABEL_23:
      if ( v6[1] )
        ((void (__cdecl *)(_DWORD))xmlFree)(v6[1]);
      if ( v6[3] )
        ((void (__cdecl *)(_DWORD))xmlFree)(v6[3]);
      ((void (__cdecl *)(_DWORD *))xmlFree)(v6);
      return 0;
    }
    if ( xmlHashAddEntry(Dict, (unsigned __int8 *)Src, v9) < 0 )
    {
      xmlListDelete(v8);
      sub_42FA00(0, "xmlAddRef: Reference list insertion failed!\n");
      goto LABEL_23;
    }
  }
  if ( xmlListAppend(v8, (int)v6) )
  {
    sub_42FA00(0, "xmlAddRef: Reference list insertion failed!\n");
    goto LABEL_23;
  }
  return v6;
}
// 496494: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (00431548) --------------------------------------------------------
void __cdecl xmlFreeRefTable(_DWORD *Block)
{
  xmlHashFree(Block, (void (__cdecl *)(int, _DWORD))sub_4313D3);
}

//----- (00431559) --------------------------------------------------------
int __cdecl xmlIsRef(_DWORD *a1, int a2, int a3)
{
  _DWORD *v4; // esi
  int v5; // eax
  int DtdAttrDesc; // eax
  int v7; // esi
  int v8; // eax

  if ( !a3 )
    return 0;
  v4 = a1;
  if ( !a1 )
  {
    v4 = *(_DWORD **)(a3 + 32);
    if ( !v4 )
      return 0;
  }
  v5 = v4[11];
  if ( !v5 && !v4[12] )
    return 0;
  if ( v4[1] == 13 )
    return 0;
  if ( a2 )
  {
    DtdAttrDesc = xmlGetDtdAttrDesc(v5, *(char **)(a2 + 8), *(char **)(a3 + 8));
    if ( DtdAttrDesc
      || (v7 = v4[12]) != 0 && (DtdAttrDesc = xmlGetDtdAttrDesc(v7, *(char **)(a2 + 8), *(char **)(a3 + 8))) != 0 )
    {
      v8 = *(_DWORD *)(DtdAttrDesc + 40);
      if ( v8 == 3 || v8 == 4 )
        return 1;
    }
  }
  return 0;
}

//----- (004315DA) --------------------------------------------------------
int __cdecl xmlRemoveRef(_DWORD *Block, int a2)
{
  _DWORD *v3; // edi
  char *String; // eax
  _DWORD **v5; // esi
  int v6; // esi
  int v7[2]; // [esp+0h] [ebp-8h] BYREF
  unsigned __int8 *Blocka; // [esp+10h] [ebp+8h]

  if ( !Block )
    return -1;
  if ( !a2 )
    return -1;
  v3 = (_DWORD *)Block[17];
  if ( !v3 )
    return -1;
  String = xmlNodeListGetString(Block, *(_DWORD *)(a2 + 12), 1);
  Blocka = (unsigned __int8 *)String;
  if ( !String )
    return -1;
  v5 = (_DWORD **)xmlHashLookup3(v3, String, 0, 0);
  if ( v5 )
  {
    v7[0] = (int)v5;
    v7[1] = a2;
    xmlListWalk(v5, (int (__cdecl *)(_DWORD, int))sub_4313E0, (int)v7);
    if ( xmlListEmpty(v5) )
      xmlHashUpdateEntry(v3, Blocka, 0, (void (__cdecl *)(_DWORD, char *))sub_4313D3);
    v6 = 0;
  }
  else
  {
    v6 = -1;
  }
  ((void (__cdecl *)(unsigned __int8 *))xmlFree)(Blocka);
  return v6;
}
// 496494: invalid function type has been ignored

//----- (0043167C) --------------------------------------------------------
int __cdecl xmlGetRefs(int a1, char *a2)
{
  _DWORD *v3; // eax

  if ( a1 && a2 && (v3 = *(_DWORD **)(a1 + 68)) != 0 )
    return xmlHashLookup3(v3, a2, 0, 0);
  else
    return 0;
}

//----- (004316A6) --------------------------------------------------------
int __cdecl xmlGetDtdElementDesc(int a1, char *a2)
{
  char *v2; // edi
  _DWORD *v3; // esi
  char *v4; // eax
  char *v5; // ebx
  int v6; // esi
  void *Block; // [esp+8h] [ebp-4h] BYREF

  Block = 0;
  if ( !a1 )
    return 0;
  v2 = a2;
  if ( !a2 )
    return 0;
  v3 = *(_DWORD **)(a1 + 40);
  if ( !v3 )
    return 0;
  v4 = xmlSplitQName2(a2, &Block);
  v5 = v4;
  if ( v4 )
    v2 = v4;
  v6 = xmlHashLookup3(v3, v2, (char *)Block, 0);
  if ( Block )
    ((void (__cdecl *)(void *))xmlFree)(Block);
  if ( v5 )
    ((void (__cdecl *)(char *))xmlFree)(v5);
  return v6;
}
// 496494: invalid function type has been ignored

//----- (00431712) --------------------------------------------------------
_DWORD *__usercall sub_431712@<eax>(int a1@<eax>, char *Src)
{
  int v4; // eax
  _DWORD *v5; // ecx
  _DWORD *Dict; // eax
  void ***v7; // edi
  _BYTE *v8; // eax
  _DWORD *v9; // esi
  _DWORD *v10; // eax
  _BYTE *v11; // eax
  _BYTE *v12; // eax
  unsigned __int8 *v13; // [esp-20h] [ebp-30h]
  _BYTE *v14; // [esp-18h] [ebp-28h]
  void *v15; // [esp+8h] [ebp-8h]
  void *Block; // [esp+Ch] [ebp-4h] BYREF

  Block = 0;
  if ( !a1 )
    return 0;
  if ( !*(_DWORD *)(a1 + 40) )
  {
    v4 = *(_DWORD *)(a1 + 32);
    v5 = 0;
    if ( v4 )
      v5 = *(_DWORD **)(v4 + 80);
    Dict = xmlHashCreateDict(0, v5);
    *(_DWORD *)(a1 + 40) = Dict;
    if ( !Dict )
    {
      sub_42F97B("element table allocation failed");
      return 0;
    }
  }
  v7 = *(void ****)(a1 + 40);
  v8 = xmlSplitQName2(Src, &Block);
  v15 = v8;
  if ( v8 )
    Src = v8;
  v9 = (_DWORD *)xmlHashLookup3(v7, Src, (char *)Block, 0);
  if ( !v9 )
  {
    v10 = (_DWORD *)xmlMalloc(56);
    v9 = v10;
    if ( !v10 )
    {
      sub_42F97B("malloc failed");
      return 0;
    }
    memset(v10, 0, 0x38u);
    v9[1] = 15;
    v11 = xmlStrdup(Src);
    v14 = Block;
    v9[2] = v11;
    v12 = xmlStrdup(v14);
    v13 = (unsigned __int8 *)Block;
    v9[12] = v12;
    v9[9] = 0;
    xmlHashAddEntry2(v7, (unsigned __int8 *)Src, v13, v9);
  }
  if ( Block )
    ((void (__cdecl *)(void *))xmlFree)(Block);
  if ( v15 )
    ((void (__cdecl *)(void *))xmlFree)(v15);
  return v9;
}
// 496494: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (0043180B) --------------------------------------------------------
int __cdecl xmlGetDtdQElementDesc(int a1, char *a2, char *a3)
{
  _DWORD *v4; // eax

  if ( a1 && (v4 = *(_DWORD **)(a1 + 40)) != 0 )
    return xmlHashLookup3(v4, a2, a3, 0);
  else
    return 0;
}

//----- (00431831) --------------------------------------------------------
int __cdecl xmlGetDtdAttrDesc(int a1, char *a2, char *a3)
{
  int result; // eax
  _DWORD *v4; // esi
  char *v5; // eax
  char *v6; // edi
  int v7; // esi
  void *Block; // [esp+0h] [ebp-4h] BYREF

  result = a1;
  Block = 0;
  if ( a1 )
  {
    v4 = *(_DWORD **)(a1 + 44);
    if ( v4 )
    {
      v5 = xmlSplitQName2(a3, &Block);
      v6 = v5;
      if ( !v5 )
        return xmlHashLookup3(v4, a3, 0, a2);
      v7 = xmlHashLookup3(v4, v5, (char *)Block, a2);
      if ( Block )
        ((void (__cdecl *)(void *))xmlFree)(Block);
      ((void (__cdecl *)(char *))xmlFree)(v6);
      return v7;
    }
    else
    {
      return 0;
    }
  }
  return result;
}
// 496494: invalid function type has been ignored

//----- (004318A5) --------------------------------------------------------
int __cdecl xmlGetDtdQAttrDesc(int a1, char *a2, char *a3, char *a4)
{
  _DWORD *v5; // eax

  if ( a1 && (v5 = *(_DWORD **)(a1 + 44)) != 0 )
    return xmlHashLookup3(v5, a3, a4, a2);
  else
    return 0;
}

//----- (004318CD) --------------------------------------------------------
int __cdecl xmlGetDtdNotationDesc(int a1, char *a2)
{
  _DWORD *v3; // eax

  if ( a1 && (v3 = *(_DWORD **)(a1 + 36)) != 0 )
    return xmlHashLookup3(v3, a2, 0, 0);
  else
    return 0;
}

//----- (004318F1) --------------------------------------------------------
int __cdecl xmlIsMixedElement(int a1, char *a2)
{
  int v2; // eax
  int DtdElementDesc; // eax
  int v4; // eax
  int v5; // eax

  if ( a1
    && (v2 = *(_DWORD *)(a1 + 44)) != 0
    && ((DtdElementDesc = xmlGetDtdElementDesc(v2, a2)) != 0
     || (v4 = *(_DWORD *)(a1 + 48)) != 0 && (DtdElementDesc = xmlGetDtdElementDesc(v4, a2)) != 0)
    && (v5 = *(_DWORD *)(DtdElementDesc + 36)) != 0 )
  {
    return v5 != 4;
  }
  else
  {
    return -1;
  }
}

//----- (00431949) --------------------------------------------------------
int sub_431949(int a1, char *Format, ...)
{
  FILE *v2; // eax
  va_list va; // [esp+Ch] [ebp+Ch] BYREF

  va_start(va, Format);
  v2 = xmlGenericErrorContext;
  if ( !xmlGenericErrorContext )
  {
    v2 = (FILE *)(sub_44F01A() + 16);
    xmlGenericErrorContext = v2;
  }
  return vfprintf(v2, Format, va);
}

//----- (00431972) --------------------------------------------------------
int (*__cdecl initGenericErrorDefaultFunc(_DWORD *a1))(_DWORD, const char *, ...)
{
  int (*result)(_DWORD, const char *, ...); // eax

  result = (int (*)(_DWORD, const char *, ...))a1;
  if ( a1 )
  {
    result = (int (*)(_DWORD, const char *, ...))*a1;
    xmlGenericError = (int (*)(_DWORD, const char *, ...))*a1;
  }
  else
  {
    xmlGenericError = (int (*)(_DWORD, const char *, ...))sub_431949;
  }
  return result;
}
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);

//----- (0043198D) --------------------------------------------------------
int (*__cdecl xmlSetGenericErrorFunc(FILE *a1, int (*a2)(_DWORD, const char *, ...)))(_DWORD, const char *, ...)
{
  int (*result)(_DWORD, const char *, ...); // eax

  xmlGenericErrorContext = a1;
  result = a2;
  xmlGenericError = a2;
  if ( !a2 )
    xmlGenericError = (int (*)(_DWORD, const char *, ...))sub_431949;
  return result;
}
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);

//----- (004319AE) --------------------------------------------------------
int __cdecl xmlSetStructuredErrorFunc(int a1, int a2)
{
  int result; // eax

  xmlStructuredErrorContext = a1;
  result = a2;
  xmlStructuredError = a2;
  return result;
}
// 4A9CCC: using guessed type int xmlStructuredError;
// 4A9CDC: using guessed type int xmlStructuredErrorContext;

//----- (004319C1) --------------------------------------------------------
int __cdecl xmlParserPrintFileInfo(int a1)
{
  int result; // eax
  const char *v2; // ecx
  int v3; // [esp-4h] [ebp-4h]

  result = a1;
  if ( a1 )
  {
    v2 = *(const char **)(a1 + 4);
    v3 = *(_DWORD *)(a1 + 28);
    if ( v2 )
      return xmlGenericError(xmlGenericErrorContext, "%s:%d: ", v2, v3);
    else
      return xmlGenericError(xmlGenericErrorContext, "Entity: line %d: ", v3);
  }
  return result;
}
// 4A4B9C: invalid function type has been ignored
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);

//----- (004319FE) --------------------------------------------------------
int __usercall sub_4319FE@<eax>(int a1@<edx>, void (*a2)(int, const char *, ...), int a3)
{
  int result; // eax
  unsigned int v4; // esi
  char *i; // eax
  unsigned int v6; // edi
  unsigned int v7; // edi
  unsigned int v8; // esi
  char *j; // edx
  char v10; // cl
  unsigned int v11; // edx
  char *k; // eax
  unsigned int v13; // ecx
  char v14[84]; // [esp+8h] [ebp-58h] BYREF

  result = a3;
  if ( a1 )
  {
    v4 = *(_DWORD *)(a1 + 12);
    for ( i = *(char **)(a1 + 16); (unsigned int)i > v4 && (*i == 10 || *i == 13); --i )
      ;
    v6 = 0;
    do
    {
      ++v6;
      if ( (unsigned int)i <= v4 )
        break;
      if ( *i == 10 )
        goto LABEL_14;
      if ( *i == 13 )
        break;
      --i;
    }
    while ( v6 < 0x50 );
    if ( *i == 10 || *i == 13 )
LABEL_14:
      ++i;
    v7 = *(_DWORD *)(a1 + 16) - (_DWORD)i;
    v8 = 0;
    for ( j = v14; ; ++j )
    {
      v10 = *i;
      if ( !*i || v10 == 10 || v10 == 13 || v8 >= 0x50 )
        break;
      *j = v10;
      ++i;
      ++v8;
    }
    *j = 0;
    a2(a3, "%s\n", v14);
    v11 = 0;
    for ( k = v14; v11 < v7; ++k )
    {
      v13 = v11++;
      if ( v13 >= 0x4F || !*k )
        break;
      if ( *k != 9 )
        *k = 32;
    }
    *k = 94;
    k[1] = 0;
    return ((int (*)(int, const char *, ...))a2)(a3, "%s\n", v14);
  }
  return result;
}

//----- (00431AE7) --------------------------------------------------------
int __cdecl xmlParserPrintFileContext(int a1)
{
  return sub_4319FE(a1, (void (*)(int, const char *, ...))xmlGenericError, (int)xmlGenericErrorContext);
}
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);

//----- (00431AFF) --------------------------------------------------------
int __usercall sub_431AFF@<eax>(
        _DWORD *a1@<edx>,
        _BYTE *a2@<ecx>,
        int *a3,
        int (__cdecl *a4)(int, char *Format, char ArgList),
        FILE *a5)
{
  int result; // eax
  int (__cdecl *v6)(int, char *, char); // esi
  int v8; // ebx
  int v9; // ecx
  int v10; // eax
  int v11; // ecx
  int v12; // eax
  int v13; // ecx
  int v14; // eax
  int v15; // edx
  int v16; // edx
  int v17; // eax
  _BYTE *v18; // edx
  int v19; // edx
  signed int v20; // ecx
  signed int v21; // eax
  int v22; // [esp+8h] [ebp-54h]
  int v25; // [esp+18h] [ebp-44h]
  int v26; // [esp+1Ch] [ebp-40h]
  int v27; // [esp+20h] [ebp-3Ch]
  int v28; // [esp+24h] [ebp-38h]
  int v29; // [esp+28h] [ebp-34h]
  int v30; // [esp+28h] [ebp-34h]
  signed int v31; // [esp+28h] [ebp-34h]
  char v32[152]; // [esp+2Ch] [ebp-30h] BYREF

  result = (int)a3;
  v6 = a4;
  v29 = 0;
  v28 = 0;
  v25 = 0;
  if ( a3 )
  {
    if ( !a4 )
    {
      v6 = xmlGenericError[0];
      a5 = xmlGenericErrorContext;
    }
    v27 = a3[5];
    v26 = *a3;
    v8 = a3[4];
    v22 = a3[3];
    v9 = a3[12];
    if ( a3[1] )
    {
      if ( v9 && *(_DWORD *)(v9 + 4) == 1 )
        v29 = *(_DWORD *)(v9 + 8);
      if ( a1 )
      {
        v10 = a1[9];
        v28 = v10;
        if ( v10 )
        {
          v11 = a1[9];
          if ( !*(_DWORD *)(v10 + 4) )
          {
            v12 = a1[10];
            if ( v12 > 1 )
            {
              v25 = a1[9];
              v28 = *(_DWORD *)(a1[12] + 4 * v12 - 8);
              v11 = v28;
            }
          }
          if ( v11 )
          {
            v13 = *(_DWORD *)(v28 + 4);
            if ( v13 )
            {
              ((void (*)(FILE *, const char *, ...))v6)(a5, "%s:%d: ", v13, *(_DWORD *)(v28 + 28));
            }
            else if ( v27 && v26 == 1 )
            {
              ((void (*)(FILE *, const char *, ...))v6)(a5, "Entity: line %d: ", *(_DWORD *)(v28 + 28));
            }
          }
        }
      }
      else if ( v8 )
      {
        ((void (*)(FILE *, const char *, ...))v6)(a5, "%s:%d: ", v8, v27);
      }
      else if ( v27 && v26 == 1 )
      {
        ((void (*)(FILE *, const char *, ...))v6)(a5, "Entity: line %d: ", v27);
      }
      if ( v29 )
        ((void (*)(FILE *, const char *, ...))v6)(a5, "element %s: ", v29);
      switch ( v26 )
      {
        case 1:
        case 13:
          ((void (__cdecl *)(FILE *, const char *))v6)(a5, "parser ");
          break;
        case 3:
          ((void (__cdecl *)(FILE *, const char *))v6)(a5, "namespace ");
          break;
        case 4:
        case 23:
          ((void (__cdecl *)(FILE *, const char *))v6)(a5, "validity ");
          break;
        case 5:
          ((void (__cdecl *)(FILE *, const char *))v6)(a5, "HTML parser ");
          break;
        case 6:
          ((void (__cdecl *)(FILE *, const char *))v6)(a5, "memory ");
          break;
        case 7:
          ((void (__cdecl *)(FILE *, const char *))v6)(a5, "output ");
          break;
        case 8:
          ((void (__cdecl *)(FILE *, const char *))v6)(a5, "I/O ");
          break;
        case 11:
          ((void (__cdecl *)(FILE *, const char *))v6)(a5, "XInclude ");
          break;
        case 12:
          ((void (__cdecl *)(FILE *, const char *))v6)(a5, "XPath ");
          break;
        case 14:
          ((void (__cdecl *)(FILE *, const char *))v6)(a5, "regexp ");
          break;
        case 16:
          ((void (__cdecl *)(FILE *, const char *))v6)(a5, "Schemas parser ");
          break;
        case 17:
          ((void (__cdecl *)(FILE *, const char *))v6)(a5, "Schemas validity ");
          break;
        case 18:
          ((void (__cdecl *)(FILE *, const char *))v6)(a5, "Relax-NG parser ");
          break;
        case 19:
          ((void (__cdecl *)(FILE *, const char *))v6)(a5, "Relax-NG validity ");
          break;
        case 20:
          ((void (__cdecl *)(FILE *, const char *))v6)(a5, "Catalog ");
          break;
        case 21:
          ((void (__cdecl *)(FILE *, const char *))v6)(a5, "C14N ");
          break;
        case 22:
          ((void (__cdecl *)(FILE *, const char *))v6)(a5, "XSLT ");
          break;
        case 26:
          ((void (__cdecl *)(FILE *, const char *))v6)(a5, "module ");
          break;
        case 27:
          ((void (__cdecl *)(FILE *, const char *))v6)(a5, "encoding ");
          break;
        default:
          break;
      }
      if ( v22 )
      {
        if ( v22 == 1 )
        {
          ((void (__cdecl *)(FILE *, const char *))v6)(a5, "warning : ");
        }
        else if ( (unsigned int)(v22 - 2) <= 1 )
        {
          ((void (__cdecl *)(FILE *, const char *))v6)(a5, "error : ");
        }
      }
      else
      {
        ((void (__cdecl *)(FILE *, const char *))v6)(a5, ": ");
      }
      if ( a2 )
      {
        v14 = xmlStrlen(a2);
        if ( v14 <= 0 || *(_BYTE *)(v15 + v14 - 1) == 10 )
          result = v6((int)a5, "%s", v15);
        else
          result = v6((int)a5, "%s\n", v15);
      }
      else
      {
        result = v6((int)a5, "%s\n", (char)"out of memory error");
      }
      if ( !a1 )
        goto LABEL_67;
      result = sub_4319FE(v28, (void (*)(int, const char *, ...))v6, (int)a5);
      v16 = v25;
      if ( !v25 )
        goto LABEL_67;
      v17 = *(_DWORD *)(v25 + 4);
      if ( v17 )
      {
        ((void (*)(FILE *, const char *, ...))v6)(a5, "%s:%d: \n", v17, *(_DWORD *)(v25 + 28));
      }
      else
      {
        if ( !v27 || v26 != 1 )
          goto LABEL_66;
        ((void (*)(FILE *, const char *, ...))v6)(a5, "Entity: line %d: \n", *(_DWORD *)(v25 + 28));
      }
      v16 = v25;
LABEL_66:
      result = sub_4319FE(v16, (void (*)(int, const char *, ...))v6, (int)a5);
LABEL_67:
      if ( v26 == 12 )
      {
        result = (int)a3;
        v18 = (_BYTE *)a3[6];
        if ( v18 )
        {
          result = a3[9];
          v30 = result;
          if ( result < 100 )
          {
            result = xmlStrlen(v18);
            if ( v30 < result )
            {
              ((void (*)(FILE *, const char *, ...))v6)(a5, "%s\n", v19);
              v20 = a3[9];
              v21 = 0;
              v31 = v20;
              if ( v20 > 0 )
              {
                memset(v32, 32, v20);
                v21 = v31;
              }
              v32[v21] = 94;
              v32[v21 + 1] = 0;
              return ((int (*)(FILE *, const char *, ...))v6)(a5, "%s\n", v32);
            }
          }
        }
      }
    }
  }
  return result;
}
// 431CF1: variable 'v15' is possibly undefined
// 431D90: variable 'v19' is possibly undefined
// 4A4B9C: using guessed type int (__cdecl *xmlGenericError[2])(int, char *Format, char ArgList);

//----- (00431E4B) --------------------------------------------------------
int (__cdecl *_xmlRaiseError(
        int (__cdecl *a1)(FILE *, int *),
        int (__cdecl *a2)(int, char *Format, char ArgList),
        FILE *a3,
        int *a4,
        int (__cdecl *a5)(int, char *Format, char ArgList),
        int a6,
        int a7,
        int a8,
        _BYTE *a9,
        int a10,
        _BYTE *Src,
        _BYTE *a12,
        _BYTE *a13,
        int a14,
        int a15,
        char *Format,
        ...))(int, char *Format, char ArgList)
{
  int (__cdecl *result)(int, char *, char); // eax
  int *v17; // esi
  int v18; // eax
  int (__cdecl *v19)(FILE *, int *); // eax
  int v20; // edi
  int v21; // ebx
  int v22; // eax
  int v23; // eax
  _DWORD *v24; // eax
  int v25; // ecx
  int v26; // ecx
  int v27; // eax
  int i; // eax
  int v29; // eax
  _BYTE *v30; // eax
  _BYTE *v31; // eax
  int v32; // eax
  int v33; // eax
  FILE *v34; // ecx
  int *v35; // [esp+4h] [ebp-10h]
  int (__cdecl *v36)(int, char *, char); // [esp+8h] [ebp-Ch]
  int (__cdecl *v37)(int, char *, char); // [esp+Ch] [ebp-8h]
  char *Block; // [esp+10h] [ebp-4h]
  va_list va; // [esp+5Ch] [ebp+48h] BYREF

  va_start(va, Format);
  result = a5;
  v35 = 0;
  v37 = a5;
  v17 = &xmlLastError;
  v36 = 0;
  if ( !a7 || !xmlGetWarningsDefaultValue && a8 == 1 )
    return result;
  if ( a6 != 1 && a6 != 5 && a6 != 4 && a6 != 3 && a6 != 8 && a6 != 23 )
  {
LABEL_16:
    if ( a1 )
      goto LABEL_19;
    goto LABEL_17;
  }
  v35 = a4;
  if ( a1 )
    goto LABEL_19;
  if ( a4 )
  {
    v18 = *a4;
    if ( *a4 )
    {
      if ( *(_DWORD *)(v18 + 108) == -554844497 )
      {
        v19 = *(int (__cdecl **)(FILE *, int *))(v18 + 124);
        if ( v19 )
        {
          a1 = v19;
          a3 = (FILE *)a4[1];
          goto LABEL_16;
        }
      }
    }
  }
LABEL_17:
  a1 = (int (__cdecl *)(FILE *, int *))xmlStructuredError;
  if ( xmlStructuredError )
    a3 = (FILE *)xmlStructuredErrorContext;
LABEL_19:
  if ( Format )
  {
    v20 = 150;
    v21 = -1;
    Block = (char *)xmlMalloc(150);
    if ( Block )
    {
      do
      {
        v22 = _vsnprintf(Block, v20, Format, va);
        if ( v22 <= -1 )
        {
          v20 += 100;
        }
        else
        {
          if ( v22 < v20 )
          {
            if ( v21 == v22 )
              break;
            v21 = v22;
          }
          v20 += v22 + 1;
        }
        v23 = xmlRealloc(Block, v20);
        if ( !v23 )
          break;
        Block = (char *)v23;
      }
      while ( v20 < 64000 );
    }
  }
  else
  {
    Block = xmlStrdup("No error message provided");
  }
  if ( v35 )
  {
    if ( !a9 )
    {
      v24 = (_DWORD *)v35[9];
      if ( v24 )
      {
        if ( !v24[1] )
        {
          v25 = v35[10];
          if ( v25 > 1 )
            v24 = *(_DWORD **)(v35[12] + 4 * v25 - 8);
        }
        if ( v24 )
        {
          a9 = (_BYTE *)v24[1];
          a10 = v24[7];
          a15 = v24[8];
        }
      }
    }
    v17 = v35 + 96;
  }
  else
  {
    v26 = (int)a5;
    if ( a5 && !a9 )
    {
      v27 = *((_DWORD *)a5 + 8);
      if ( v27 && *(_DWORD *)(v27 + 72) )
        v36 = a5;
      for ( i = 0; i < 10; ++i )
      {
        if ( !v26 )
          break;
        if ( *(_DWORD *)(v26 + 4) == 1 )
          break;
        v26 = *(_DWORD *)(v26 + 20);
        v37 = (int (__cdecl *)(int, char *, char))v26;
      }
      if ( !v36 )
      {
        if ( !v26 )
          goto LABEL_56;
        v29 = *(_DWORD *)(v26 + 32);
        if ( v29 && *(_DWORD *)(v29 + 72) )
          v36 = (int (__cdecl *)(int, char *, char))v26;
      }
      if ( v26 && *(_DWORD *)(v26 + 4) == 1 )
        a10 = *(unsigned __int16 *)(v26 + 56);
    }
  }
LABEL_56:
  xmlResetError(v17);
  *v17 = a6;
  v17[1] = a7;
  v17[2] = (int)Block;
  v17[3] = a8;
  if ( a9 )
  {
    v30 = xmlStrdup(a9);
LABEL_63:
    v17[4] = (int)v30;
    goto LABEL_64;
  }
  if ( v36 )
  {
    v31 = xmlStrdup(*(_BYTE **)(*((_DWORD *)v36 + 8) + 72));
    v17[4] = (int)v31;
    if ( !v31 )
    {
      if ( v37 )
      {
        v32 = *((_DWORD *)v37 + 8);
        if ( v32 )
        {
          v30 = xmlStrdup(*(_BYTE **)(v32 + 72));
          goto LABEL_63;
        }
      }
    }
  }
LABEL_64:
  v17[5] = a10;
  if ( Src )
    v17[6] = (int)xmlStrdup(Src);
  if ( a12 )
    v17[7] = (int)xmlStrdup(a12);
  if ( a13 )
    v17[8] = (int)xmlStrdup(a13);
  v17[9] = a14;
  v17[10] = a15;
  v17[12] = (int)v37;
  v17[11] = (int)a4;
  if ( v17 != &xmlLastError )
    xmlCopyError((int)v17, &xmlLastError);
  if ( a1 )
    return (int (__cdecl *)(int, char *, char))a1(a3, v17);
  result = a2;
  if ( v35 )
  {
    if ( !a2 )
    {
      if ( !xmlStructuredError )
      {
        v33 = *v35;
        if ( *v35 )
        {
          if ( a8 == 1 )
            result = *(int (__cdecl **)(int, char *, char))(v33 + 84);
          else
            result = *(int (__cdecl **)(int, char *, char))(v33 + 88);
          v34 = (FILE *)v35[1];
          goto LABEL_85;
        }
      }
LABEL_83:
      v34 = a3;
      result = (int (__cdecl *)(int, char *, char))xmlGenericError;
      if ( !a3 )
        v34 = xmlGenericErrorContext;
LABEL_85:
      if ( !result )
        return result;
      goto LABEL_88;
    }
  }
  else if ( !a2 )
  {
    goto LABEL_83;
  }
  v34 = a3;
LABEL_88:
  if ( (char *)result == (char *)xmlParserError
    || (char *)result == (char *)xmlParserWarning
    || (char *)result == (char *)xmlParserValidityError
    || (char *)result == (char *)xmlParserValidityWarning )
  {
    return (int (__cdecl *)(int, char *, char))sub_431AFF(v35, Block, v17, 0, 0);
  }
  if ( (char *)result == (char *)fprintf || (char *)result == (char *)sub_431949 )
    return (int (__cdecl *)(int, char *, char))sub_431AFF(v35, Block, v17, result, v34);
  return (int (__cdecl *)(int, char *, char))((int (*)(FILE *, const char *, ...))result)(v34, "%s", Block);
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);
// 4A4B8C: using guessed type int xmlGetWarningsDefaultValue;
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);
// 4A9CCC: using guessed type int xmlStructuredError;
// 4A9CDC: using guessed type int xmlStructuredErrorContext;
// 4AE060: using guessed type _DWORD xmlLastError;

//----- (0043216F) --------------------------------------------------------
int (__cdecl *__cdecl _xmlSimpleError(
        int a1,
        int a2,
        int (__cdecl *a3)(int, char *Format, char ArgList),
        char *Format,
        _BYTE *Src))(int, char *Format, char ArgList)
{
  if ( a2 != 2 )
    return _xmlRaiseError(0, 0, 0, 0, a3, a1, a2, 2, 0, 0, Src, 0, 0, 0, 0, Format, Src);
  if ( Src )
    return _xmlRaiseError(0, 0, 0, 0, a3, a1, 2, 3, 0, 0, Src, 0, 0, 0, 0, "Memory allocation failed : %s\n", Src);
  return _xmlRaiseError(0, 0, 0, 0, a3, a1, 2, 3, 0, 0, 0, 0, 0, 0, 0, "Memory allocation failed\n");
}

//----- (004321E1) --------------------------------------------------------
int xmlParserError(_DWORD *a1, char *Format, ...)
{
  int v2; // ebx
  int v3; // eax
  int v4; // esi
  char *v5; // edi
  int v6; // eax
  int v7; // eax
  int result; // eax
  int v9; // [esp+8h] [ebp-8h]
  int v10; // [esp+Ch] [ebp-4h]
  va_list ArgList; // [esp+20h] [ebp+10h] BYREF

  va_start(ArgList, Format);
  v2 = 0;
  v10 = 0;
  if ( a1 )
  {
    v2 = a1[9];
    if ( v2 )
    {
      if ( !*(_DWORD *)(v2 + 4) )
      {
        v3 = a1[10];
        if ( v3 > 1 )
        {
          v10 = a1[9];
          v2 = *(_DWORD *)(a1[12] + 4 * v3 - 8);
        }
      }
    }
    xmlParserPrintFileInfo(v2);
  }
  xmlGenericError(xmlGenericErrorContext, "error: ");
  v9 = -1;
  v4 = 150;
  v5 = (char *)xmlMalloc(150);
  if ( v5 )
  {
    do
    {
      v6 = _vsnprintf(v5, v4, Format, ArgList);
      if ( v6 <= -1 )
      {
        v4 += 100;
      }
      else
      {
        if ( v6 < v4 )
        {
          if ( v9 == v6 )
            break;
          v9 = v6;
        }
        v4 += v6 + 1;
      }
      v7 = xmlRealloc(v5, v4);
      if ( !v7 )
        break;
      v5 = (char *)v7;
    }
    while ( v4 < 64000 );
  }
  result = xmlGenericError(xmlGenericErrorContext, "%s", v5);
  if ( v5 )
    result = ((int (__cdecl *)(char *))xmlFree)(v5);
  if ( a1 )
  {
    result = xmlParserPrintFileContext(v2);
    if ( v10 )
    {
      xmlParserPrintFileInfo(v10);
      xmlGenericError(xmlGenericErrorContext, "\n");
      return xmlParserPrintFileContext(v10);
    }
  }
  return result;
}
// 496494: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);

//----- (004322E7) --------------------------------------------------------
int xmlParserWarning(_DWORD *a1, char *Format, ...)
{
  int v2; // ebx
  int v3; // eax
  int v4; // esi
  char *v5; // edi
  int v6; // eax
  int v7; // eax
  int result; // eax
  int v9; // [esp+8h] [ebp-8h]
  int v10; // [esp+Ch] [ebp-4h]
  va_list ArgList; // [esp+20h] [ebp+10h] BYREF

  va_start(ArgList, Format);
  v2 = 0;
  v10 = 0;
  if ( a1 )
  {
    v2 = a1[9];
    if ( v2 )
    {
      if ( !*(_DWORD *)(v2 + 4) )
      {
        v3 = a1[10];
        if ( v3 > 1 )
        {
          v10 = a1[9];
          v2 = *(_DWORD *)(a1[12] + 4 * v3 - 8);
        }
      }
    }
    xmlParserPrintFileInfo(v2);
  }
  xmlGenericError(xmlGenericErrorContext, "warning: ");
  v9 = -1;
  v4 = 150;
  v5 = (char *)xmlMalloc(150);
  if ( v5 )
  {
    do
    {
      v6 = _vsnprintf(v5, v4, Format, ArgList);
      if ( v6 <= -1 )
      {
        v4 += 100;
      }
      else
      {
        if ( v6 < v4 )
        {
          if ( v9 == v6 )
            break;
          v9 = v6;
        }
        v4 += v6 + 1;
      }
      v7 = xmlRealloc(v5, v4);
      if ( !v7 )
        break;
      v5 = (char *)v7;
    }
    while ( v4 < 64000 );
  }
  result = xmlGenericError(xmlGenericErrorContext, "%s", v5);
  if ( v5 )
    result = ((int (__cdecl *)(char *))xmlFree)(v5);
  if ( a1 )
  {
    result = xmlParserPrintFileContext(v2);
    if ( v10 )
    {
      xmlParserPrintFileInfo(v10);
      xmlGenericError(xmlGenericErrorContext, "\n");
      return xmlParserPrintFileContext(v10);
    }
  }
  return result;
}
// 496494: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);

//----- (004323ED) --------------------------------------------------------
int xmlParserValidityError(_DWORD *a1, char *Format, ...)
{
  int v2; // ebx
  int v3; // eax
  int v4; // edx
  int v5; // eax
  int v6; // esi
  char *v7; // edi
  int v8; // eax
  int v9; // eax
  int result; // eax
  int v11; // [esp+8h] [ebp-4h]
  va_list ArgList; // [esp+1Ch] [ebp+10h] BYREF

  va_start(ArgList, Format);
  v2 = 0;
  v3 = xmlStrlen(Format);
  if ( v3 <= 1 || *(_BYTE *)(v3 + v4 - 2) == 58 )
  {
    dword_4A9C14 = 1;
  }
  else
  {
    if ( a1 )
    {
      v2 = a1[9];
      if ( !*(_DWORD *)(v2 + 4) )
      {
        v5 = a1[10];
        if ( v5 > 1 )
          v2 = *(_DWORD *)(a1[12] + 4 * v5 - 8);
      }
      if ( !dword_4A9C14 )
        xmlParserPrintFileInfo(v2);
    }
    xmlGenericError(xmlGenericErrorContext, "validity error: ");
    dword_4A9C14 = 0;
  }
  v11 = -1;
  v6 = 150;
  v7 = (char *)xmlMalloc(150);
  if ( v7 )
  {
    do
    {
      v8 = _vsnprintf(v7, v6, Format, ArgList);
      if ( v8 <= -1 )
      {
        v6 += 100;
      }
      else
      {
        if ( v8 < v6 )
        {
          if ( v11 == v8 )
            break;
          v11 = v8;
        }
        v6 += v8 + 1;
      }
      v9 = xmlRealloc(v7, v6);
      if ( !v9 )
        break;
      v7 = (char *)v9;
    }
    while ( v6 < 64000 );
  }
  result = xmlGenericError(xmlGenericErrorContext, "%s", v7);
  if ( v7 )
    result = ((int (__cdecl *)(char *))xmlFree)(v7);
  if ( a1 )
  {
    if ( v2 )
      return xmlParserPrintFileContext(v2);
  }
  return result;
}
// 496494: invalid function type has been ignored
// 432408: variable 'v4' is possibly undefined
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);
// 4A9C14: using guessed type int dword_4A9C14;

//----- (004324EE) --------------------------------------------------------
int xmlParserValidityWarning(_DWORD *a1, char *Format, ...)
{
  int v2; // ebx
  int v3; // eax
  int v4; // edx
  int v5; // eax
  int v6; // esi
  char *v7; // edi
  int v8; // eax
  int v9; // eax
  int result; // eax
  int v11; // [esp+4h] [ebp-4h]
  va_list ArgList; // [esp+18h] [ebp+10h] BYREF

  va_start(ArgList, Format);
  v2 = 0;
  v3 = xmlStrlen(Format);
  if ( a1 && v3 && *(_BYTE *)(v3 + v4 - 1) != 58 )
  {
    v2 = a1[9];
    if ( !*(_DWORD *)(v2 + 4) )
    {
      v5 = a1[10];
      if ( v5 > 1 )
        v2 = *(_DWORD *)(a1[12] + 4 * v5 - 8);
    }
    xmlParserPrintFileInfo(v2);
  }
  xmlGenericError(xmlGenericErrorContext, "validity warning: ");
  v11 = -1;
  v6 = 150;
  v7 = (char *)xmlMalloc(150);
  if ( v7 )
  {
    do
    {
      v8 = _vsnprintf(v7, v6, Format, ArgList);
      if ( v8 <= -1 )
      {
        v6 += 100;
      }
      else
      {
        if ( v8 < v6 )
        {
          if ( v11 == v8 )
            break;
          v11 = v8;
        }
        v6 += v8 + 1;
      }
      v9 = xmlRealloc(v7, v6);
      if ( !v9 )
        break;
      v7 = (char *)v9;
    }
    while ( v6 < 64000 );
  }
  result = xmlGenericError(xmlGenericErrorContext, "%s", v7);
  if ( v7 )
    result = ((int (__cdecl *)(char *))xmlFree)(v7);
  if ( a1 )
    return xmlParserPrintFileContext(v2);
  return result;
}
// 496494: invalid function type has been ignored
// 43250A: variable 'v4' is possibly undefined
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);

//----- (004325D2) --------------------------------------------------------
void *xmlGetLastError()
{
  return dword_4AE064 != 0 ? &xmlLastError : 0;
}
// 4AE064: using guessed type int dword_4AE064;

//----- (004325E1) --------------------------------------------------------
void *__cdecl xmlResetError(_DWORD *a1)
{
  void *result; // eax

  if ( a1 && a1[1] )
  {
    if ( a1[2] )
      ((void (__cdecl *)(_DWORD))xmlFree)(a1[2]);
    if ( a1[4] )
      ((void (__cdecl *)(_DWORD))xmlFree)(a1[4]);
    if ( a1[6] )
      ((void (__cdecl *)(_DWORD))xmlFree)(a1[6]);
    if ( a1[7] )
      ((void (__cdecl *)(_DWORD))xmlFree)(a1[7]);
    if ( a1[8] )
      ((void (__cdecl *)(_DWORD))xmlFree)(a1[8]);
    result = memset(a1, 0, 0x34u);
    a1[1] = 0;
  }
  return result;
}
// 496494: invalid function type has been ignored

//----- (0043264E) --------------------------------------------------------
void *xmlResetLastError()
{
  void *result; // eax

  if ( dword_4AE064 )
    return xmlResetError(&xmlLastError);
  return result;
}
// 4AE060: using guessed type _DWORD xmlLastError;
// 4AE064: using guessed type int dword_4AE064;

//----- (00432663) --------------------------------------------------------
int __cdecl xmlCtxtGetLastError(int a1)
{
  if ( a1 && *(_DWORD *)(a1 + 388) )
    return a1 + 384;
  else
    return 0;
}

//----- (0043267D) --------------------------------------------------------
void *__cdecl xmlCtxtResetLastError(_DWORD *a1)
{
  void *result; // eax

  result = a1;
  if ( a1 )
  {
    a1[21] = 0;
    if ( a1[97] )
      return xmlResetError(a1 + 96);
  }
  return result;
}

//----- (0043269F) --------------------------------------------------------
int __cdecl xmlCopyError(int a1, _DWORD *a2)
{
  _BYTE *v3; // ebx
  _BYTE *v5; // [esp+8h] [ebp-Ch]
  _BYTE *v6; // [esp+Ch] [ebp-8h]
  _BYTE *v7; // [esp+10h] [ebp-4h]
  _BYTE *v8; // [esp+1Ch] [ebp+8h]

  if ( !a1 || !a2 )
    return -1;
  v3 = xmlStrdup(*(_BYTE **)(a1 + 8));
  v8 = xmlStrdup(*(_BYTE **)(a1 + 16));
  v7 = xmlStrdup(*(_BYTE **)(a1 + 24));
  v6 = xmlStrdup(*(_BYTE **)(a1 + 28));
  v5 = xmlStrdup(*(_BYTE **)(a1 + 32));
  if ( a2[2] )
    ((void (__cdecl *)(_DWORD))xmlFree)(a2[2]);
  if ( a2[4] )
    ((void (__cdecl *)(_DWORD))xmlFree)(a2[4]);
  if ( a2[6] )
    ((void (__cdecl *)(_DWORD))xmlFree)(a2[6]);
  if ( a2[7] )
    ((void (__cdecl *)(_DWORD))xmlFree)(a2[7]);
  if ( a2[8] )
    ((void (__cdecl *)(_DWORD))xmlFree)(a2[8]);
  *a2 = *(_DWORD *)a1;
  a2[1] = *(_DWORD *)(a1 + 4);
  a2[3] = *(_DWORD *)(a1 + 12);
  a2[5] = *(_DWORD *)(a1 + 20);
  a2[12] = *(_DWORD *)(a1 + 48);
  a2[9] = *(_DWORD *)(a1 + 36);
  a2[10] = *(_DWORD *)(a1 + 40);
  a2[12] = *(_DWORD *)(a1 + 48);
  a2[11] = *(_DWORD *)(a1 + 44);
  a2[4] = v8;
  a2[6] = v7;
  a2[7] = v6;
  a2[2] = v3;
  a2[8] = v5;
  return 0;
}
// 496494: invalid function type has been ignored

//----- (0043279D) --------------------------------------------------------
int (__cdecl *__cdecl sub_43279D(_BYTE *a1))(int, char *Format, char ArgList)
{
  return _xmlSimpleError(2, 2, 0, 0, a1);
}

//----- (004327B2) --------------------------------------------------------
int (__cdecl *__cdecl sub_4327B2(int a1, char *a2))(int, char *Format, char ArgList)
{
  return _xmlSimpleError(2, a1, 0, a2, 0);
}

//----- (004327C9) --------------------------------------------------------
void __usercall sub_4327C9(int a1@<esi>)
{
  int v1; // ebx
  int v2; // eax
  int v3; // eax
  int v4; // edi
  int v5; // edi
  int v6; // edi
  int v7; // edi
  int v8; // edi
  int v9; // edi

  v1 = 0;
  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 32);
    if ( v2 )
      v1 = *(_DWORD *)(v2 + 80);
    v3 = *(_DWORD *)(a1 + 12);
    if ( v3 && *(_DWORD *)(a1 + 68) == 1 && a1 == *(_DWORD *)(v3 + 20) )
      xmlFreeNodeList(*(void **)(a1 + 12));
    if ( v1 )
    {
      v4 = *(_DWORD *)(a1 + 8);
      if ( v4 && !xmlDictOwns(v1, *(_DWORD *)(a1 + 8)) )
        ((void (__cdecl *)(int))xmlFree)(v4);
      v5 = *(_DWORD *)(a1 + 52);
      if ( v5 && !xmlDictOwns(v1, *(_DWORD *)(a1 + 52)) )
        ((void (__cdecl *)(int))xmlFree)(v5);
      v6 = *(_DWORD *)(a1 + 56);
      if ( v6 && !xmlDictOwns(v1, *(_DWORD *)(a1 + 56)) )
        ((void (__cdecl *)(int))xmlFree)(v6);
      v7 = *(_DWORD *)(a1 + 64);
      if ( v7 && !xmlDictOwns(v1, *(_DWORD *)(a1 + 64)) )
        ((void (__cdecl *)(int))xmlFree)(v7);
      v8 = *(_DWORD *)(a1 + 40);
      if ( v8 && !xmlDictOwns(v1, *(_DWORD *)(a1 + 40)) )
        ((void (__cdecl *)(int))xmlFree)(v8);
      v9 = *(_DWORD *)(a1 + 36);
      if ( v9 )
      {
        if ( !xmlDictOwns(v1, *(_DWORD *)(a1 + 36)) )
          ((void (__cdecl *)(int))xmlFree)(v9);
      }
    }
    else
    {
      if ( *(_DWORD *)(a1 + 8) )
        ((void (__cdecl *)(_DWORD))xmlFree)(*(_DWORD *)(a1 + 8));
      if ( *(_DWORD *)(a1 + 52) )
        ((void (__cdecl *)(_DWORD))xmlFree)(*(_DWORD *)(a1 + 52));
      if ( *(_DWORD *)(a1 + 56) )
        ((void (__cdecl *)(_DWORD))xmlFree)(*(_DWORD *)(a1 + 56));
      if ( *(_DWORD *)(a1 + 64) )
        ((void (__cdecl *)(_DWORD))xmlFree)(*(_DWORD *)(a1 + 64));
      if ( *(_DWORD *)(a1 + 40) )
        ((void (__cdecl *)(_DWORD))xmlFree)(*(_DWORD *)(a1 + 40));
      if ( *(_DWORD *)(a1 + 36) )
        ((void (__cdecl *)(_DWORD))xmlFree)(*(_DWORD *)(a1 + 36));
    }
    ((void (__cdecl *)(int))xmlFree)(a1);
  }
}
// 496494: invalid function type has been ignored

//----- (00432908) --------------------------------------------------------
_DWORD *__usercall sub_432908@<eax>(char *a1@<ebx>, _DWORD *a2@<edi>, char *Src, int a4, char *a5, _BYTE *a6)
{
  _DWORD *v6; // eax
  _DWORD *v7; // esi
  unsigned __int8 *v9; // eax
  int v10; // eax
  char *v11; // edx
  unsigned __int8 *v12; // eax

  v6 = (_DWORD *)xmlMalloc(76);
  v7 = v6;
  if ( !v6 )
  {
    sub_43279D("xmlCreateEntity: malloc failed");
    return 0;
  }
  memset(v6, 0, 0x4Cu);
  v7[18] = 0;
  v7[1] = 17;
  v7[12] = a4;
  if ( a2 )
  {
    v7[2] = xmlDictLookup(a2, Src, -1);
    if ( a1 )
      v7[13] = xmlDictLookup(a2, a1, -1);
    if ( !a5 )
      goto LABEL_13;
    v9 = xmlDictLookup(a2, a5, -1);
  }
  else
  {
    v7[2] = xmlStrdup(Src);
    if ( a1 )
      v7[13] = xmlStrdup(a1);
    if ( !a5 )
      goto LABEL_13;
    v9 = xmlStrdup(a5);
  }
  v7[14] = v9;
LABEL_13:
  if ( a6 )
  {
    v10 = xmlStrlen(a6);
    v7[11] = v10;
    if ( a2 && v10 < 5 )
      v12 = xmlDictLookup(a2, v11, v10);
    else
      v12 = xmlStrndup(v11, v10);
    v7[10] = v12;
  }
  else
  {
    v7[11] = 0;
    v7[10] = 0;
  }
  v7[16] = 0;
  v7[9] = 0;
  v7[17] = 0;
  return v7;
}
// 4329D2: variable 'v11' is possibly undefined
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (00432A02) --------------------------------------------------------
_DWORD *__usercall sub_432A02@<eax>(_DWORD *a1@<eax>, char *a2, int a3, char *a4, char *a5, _BYTE *a6)
{
  _DWORD *v6; // edi
  int v9; // eax
  void ***v10; // eax
  _DWORD *v11; // edi
  void ***v12; // [esp+Ch] [ebp-4h]

  v6 = 0;
  if ( !a2 || !a1 )
    return 0;
  v9 = a1[8];
  if ( v9 )
    v6 = *(_DWORD **)(v9 + 80);
  if ( a3 <= 0 )
    return 0;
  if ( a3 <= 3 )
  {
    if ( !a1[12] )
      a1[12] = xmlHashCreateDict(0, v6);
    v10 = (void ***)a1[12];
  }
  else
  {
    if ( a3 > 5 )
      return 0;
    if ( !a1[15] )
      a1[15] = xmlHashCreateDict(0, v6);
    v10 = (void ***)a1[15];
  }
  v12 = v10;
  if ( !v10 )
    return 0;
  v11 = sub_432908(a4, v6, a2, a3, a5, a6);
  if ( !v11 )
    return 0;
  v11[8] = a1[8];
  if ( xmlHashAddEntry(v12, (unsigned __int8 *)a2, v11) )
  {
    sub_4327C9((int)v11);
    return 0;
  }
  return v11;
}

//----- (00432AB4) --------------------------------------------------------
void *__cdecl xmlGetPredefinedEntity(char *a1)
{
  char v1; // al

  if ( a1 )
  {
    v1 = *a1;
    if ( *a1 == 97 )
    {
      if ( xmlStrEqual(a1, "amp") )
        return &unk_4A4DD8;
      if ( xmlStrEqual(a1, "apos") )
        return &unk_4A4E78;
    }
    else if ( v1 == 103 )
    {
      if ( xmlStrEqual(a1, "gt") )
        return &unk_4A4D88;
    }
    else if ( v1 == 108 )
    {
      if ( xmlStrEqual(a1, "lt") )
        return &unk_4A4D30;
    }
    else if ( v1 == 113 && xmlStrEqual(a1, "quot") )
    {
      return &unk_4A4E28;
    }
  }
  return 0;
}

//----- (00432B4F) --------------------------------------------------------
_DWORD *__cdecl xmlAddDtdEntity(int a1, char *a2, int a3, char *a4, char *a5, _BYTE *a6)
{
  _DWORD *result; // eax
  _DWORD *v7; // esi
  _DWORD *v8; // ecx
  int v9; // edx

  if ( !a1 )
  {
    sub_4327B2(521, "xmlAddDtdEntity: document is NULL");
    return 0;
  }
  v7 = *(_DWORD **)(a1 + 48);
  if ( !v7 )
  {
    sub_4327B2(522, "xmlAddDtdEntity: document without external subset");
    return 0;
  }
  result = sub_432A02(v7, a2, a3, a4, a5, a6);
  if ( !result )
    return 0;
  result[5] = v7;
  result[8] = v7[8];
  v8 = v7 + 4;
  v9 = v7[4];
  if ( v9 )
  {
    *(_DWORD *)(v9 + 24) = result;
    result[7] = *v8;
  }
  else
  {
    v7[3] = result;
  }
  *v8 = result;
  return result;
}

//----- (00432BCE) --------------------------------------------------------
_DWORD *__cdecl xmlAddDocEntity(int a1, char *a2, int a3, char *a4, char *a5, _BYTE *a6)
{
  _DWORD *result; // eax
  _DWORD *v7; // esi
  _DWORD *v8; // ecx
  int v9; // edx

  if ( !a1 )
  {
    sub_4327B2(521, "xmlAddDocEntity: document is NULL");
    return 0;
  }
  v7 = *(_DWORD **)(a1 + 44);
  if ( !v7 )
  {
    sub_4327B2(522, "xmlAddDocEntity: document without internal subset");
    return 0;
  }
  result = sub_432A02(v7, a2, a3, a4, a5, a6);
  if ( !result )
    return 0;
  result[5] = v7;
  result[8] = v7[8];
  v8 = v7 + 4;
  v9 = v7[4];
  if ( v9 )
  {
    *(_DWORD *)(v9 + 24) = result;
    result[7] = *v8;
  }
  else
  {
    v7[3] = result;
  }
  *v8 = result;
  return result;
}

//----- (00432C4D) --------------------------------------------------------
_DWORD *__cdecl xmlNewEntity(int a1, char *a2, int a3, char *a4, char *a5, _BYTE *a6)
{
  _DWORD *v6; // edi
  _DWORD *result; // eax

  v6 = 0;
  if ( a1 )
  {
    if ( *(_DWORD *)(a1 + 44) )
      return xmlAddDocEntity(a1, a2, a3, a4, a5, a6);
    v6 = *(_DWORD **)(a1 + 80);
  }
  result = sub_432908(a4, v6, a2, a3, a5, a6);
  if ( result )
    result[8] = a1;
  return result;
}

//----- (00432CA1) --------------------------------------------------------
int __cdecl xmlGetParameterEntity(int a1, char *a2)
{
  int v2; // eax
  _DWORD *v3; // eax
  int result; // eax
  int v5; // eax
  _DWORD *v6; // eax

  if ( !a1 )
    return 0;
  v2 = *(_DWORD *)(a1 + 44);
  if ( !v2 || (v3 = *(_DWORD **)(v2 + 60)) == 0 || (result = xmlHashLookup3(v3, a2, 0, 0)) == 0 )
  {
    v5 = *(_DWORD *)(a1 + 48);
    if ( v5 )
    {
      v6 = *(_DWORD **)(v5 + 60);
      if ( v6 )
        return xmlHashLookup3(v6, a2, 0, 0);
    }
    return 0;
  }
  return result;
}

//----- (00432CF2) --------------------------------------------------------
int __cdecl xmlGetDtdEntity(int a1, char *a2)
{
  int v2; // eax
  _DWORD *v3; // eax

  if ( a1 && (v2 = *(_DWORD *)(a1 + 48)) != 0 && (v3 = *(_DWORD **)(v2 + 48)) != 0 )
    return xmlHashLookup3(v3, a2, 0, 0);
  else
    return 0;
}

//----- (00432D1D) --------------------------------------------------------
void *__cdecl xmlGetDocEntity(_DWORD *a1, char *a2)
{
  int v2; // eax
  _DWORD *v3; // eax
  void *result; // eax
  int v5; // eax
  _DWORD *v6; // eax

  if ( !a1 )
    return xmlGetPredefinedEntity(a2);
  v2 = a1[11];
  if ( !v2 || (v3 = *(_DWORD **)(v2 + 48)) == 0 || (result = (void *)xmlHashLookup3(v3, a2, 0, 0)) == 0 )
  {
    if ( a1[10] == 1 )
      return xmlGetPredefinedEntity(a2);
    v5 = a1[12];
    if ( !v5 )
      return xmlGetPredefinedEntity(a2);
    v6 = *(_DWORD **)(v5 + 48);
    if ( !v6 )
      return xmlGetPredefinedEntity(a2);
    result = (void *)xmlHashLookup3(v6, a2, 0, 0);
    if ( !result )
      return xmlGetPredefinedEntity(a2);
  }
  return result;
}

//----- (00432D7E) --------------------------------------------------------
char *__cdecl xmlEncodeEntitiesReentrant(int a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // ebx
  char *result; // eax
  char *v4; // esi
  int v5; // edi
  int v6; // eax
  char v7; // al
  _BYTE *v8; // esi
  _BYTE *v9; // esi
  _BYTE *v10; // esi
  int v11; // edi
  char v12; // cl
  char *v13; // eax
  unsigned __int8 v14; // cl
  int v15; // eax
  int v16; // eax
  int v17; // edi
  char v18; // cl
  char *v19; // eax
  char v20; // al
  char *v21; // ecx
  char v22; // cl
  char *v23; // eax
  int v24; // [esp-8h] [ebp-3Ch]
  SIZE_T v25; // [esp+Ch] [ebp-28h]
  BOOL v26; // [esp+10h] [ebp-24h]
  char *Block; // [esp+14h] [ebp-20h]
  char v28[12]; // [esp+18h] [ebp-1Ch] BYREF
  char Buffer[10]; // [esp+24h] [ebp-10h] BYREF
  char v30; // [esp+2Eh] [ebp-6h]

  v26 = 0;
  v2 = a2;
  if ( !a2 )
    return 0;
  if ( a1 )
    v26 = *(_DWORD *)(a1 + 4) == 13;
  v25 = 1000;
  v4 = (char *)xmlMalloc(1000);
  Block = v4;
  if ( !v4 )
  {
    sub_43279D("xmlEncodeEntitiesReentrant: malloc failed");
    return 0;
  }
  if ( !*a2 )
  {
LABEL_70:
    result = Block;
    *v4 = 0;
    return result;
  }
  while ( 1 )
  {
    v5 = v4 - Block;
    if ( v4 - Block <= (int)(v25 - 100) )
      goto LABEL_11;
    v25 *= 2;
    v6 = xmlRealloc(Block, v25);
    Block = (char *)v6;
    if ( !v6 )
      break;
    v4 = (char *)(v5 + v6);
LABEL_11:
    v7 = *v2;
    if ( *v2 == 60 )
    {
      *v4 = 38;
      v8 = v4 + 1;
      *v8 = 108;
LABEL_13:
      v9 = v8 + 1;
      *v9 = 116;
LABEL_14:
      v4 = v9 + 1;
      *v4 = 59;
LABEL_67:
      ++v4;
      goto LABEL_68;
    }
    if ( v7 == 62 )
    {
      *v4 = 38;
      v8 = v4 + 1;
      *v8 = 103;
      goto LABEL_13;
    }
    if ( v7 == 38 )
    {
      *v4 = 38;
      v10 = v4 + 1;
      *v10++ = 97;
      *v10 = 109;
      v9 = v10 + 1;
      *v9 = 112;
      goto LABEL_14;
    }
    if ( v7 > 31 || v7 == 10 || v7 == 9 || v26 && v7 == 13 )
      goto LABEL_66;
    if ( (unsigned __int8)v7 < 0x80u )
    {
      if ( v7 == 13 )
      {
        _snprintf(v28, 0xBu, "&#%d;", 13);
        v22 = v28[0];
        v28[10] = 0;
        v23 = v28;
        while ( v22 )
        {
          *v4++ = v22;
          v22 = *++v23;
        }
      }
      goto LABEL_68;
    }
    if ( (v11 = a1) != 0 && *(_DWORD *)(a1 + 60) || v26 )
    {
LABEL_66:
      *v4 = v7;
      goto LABEL_67;
    }
    if ( (unsigned __int8)v7 >= 0xC0u )
    {
      if ( (unsigned __int8)v7 < 0xE0u )
      {
        v14 = v2[1];
        v15 = v7 & 0x1F;
        v24 = 2;
        goto LABEL_41;
      }
      if ( (unsigned __int8)v7 < 0xF0u )
      {
        v15 = v2[1] & 0x3F | ((v7 & 0xF) << 6);
        v14 = v2[2];
        v24 = 3;
        goto LABEL_41;
      }
      if ( (unsigned __int8)v7 < 0xF8u )
      {
        v15 = v2[2] & 0x3F | ((v2[1] & 0x3F | ((v7 & 7) << 6)) << 6);
        v14 = v2[3];
        v24 = 4;
LABEL_41:
        v16 = v14 & 0x3F | (v15 << 6);
        v17 = v24;
        if ( v16 >= 256 )
        {
          if ( v16 <= 55295 || v16 >= 57344 && v16 <= 65533 || (unsigned int)(v16 - 0x10000) <= 0xFFFFF )
          {
LABEL_54:
            _snprintf(Buffer, 0xBu, "&#x%X;", v16);
            v20 = Buffer[0];
            v30 = 0;
            v21 = Buffer;
            while ( v20 )
            {
              *v4++ = v20;
              v20 = *++v21;
            }
            v2 += v17;
            goto LABEL_69;
          }
        }
        else if ( v16 >= 9 && v16 <= 10 || v16 == 13 || v16 >= 32 )
        {
          goto LABEL_54;
        }
        v11 = a1;
      }
      sub_4327B2(9, "xmlEncodeEntitiesReentrant : char out of range\n");
      if ( v11 )
        *(_DWORD *)(v11 + 60) = xmlStrdup("ISO-8859-1");
      _snprintf(Buffer, 0xBu, "&#%d;", *v2);
      v18 = Buffer[0];
      v30 = 0;
      v19 = Buffer;
      while ( v18 )
      {
        *v4++ = v18;
        v18 = *++v19;
      }
      goto LABEL_68;
    }
    sub_4327B2(5032, "xmlEncodeEntitiesReentrant : input not UTF-8");
    if ( a1 )
      *(_DWORD *)(a1 + 60) = xmlStrdup("ISO-8859-1");
    _snprintf(Buffer, 0xBu, "&#%d;", *v2);
    v12 = Buffer[0];
    v30 = 0;
    v13 = Buffer;
    while ( v12 )
    {
      *v4++ = v12;
      v12 = *++v13;
    }
LABEL_68:
    ++v2;
LABEL_69:
    if ( !*v2 )
      goto LABEL_70;
  }
  sub_43279D("xmlEncodeEntitiesReentrant: realloc failed");
  return 0;
}
// 43301A: conditional instruction was optimized away because al.1 is in (B..1F)
// 433022: conditional instruction was optimized away because al.1 is in (<9u|B..C|E..1F)
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);

//----- (00433084) --------------------------------------------------------
_BYTE *__cdecl xmlEncodeSpecialChars(int a1, char *a2)
{
  char *v2; // ebx
  _BYTE *result; // eax
  SIZE_T v4; // edi
  _BYTE *v5; // ecx
  int v6; // esi
  char v7; // dl
  _BYTE *v8; // ecx
  _BYTE *v9; // ecx
  _BYTE *v10; // ecx
  _BYTE *v11; // ecx
  _BYTE *v12; // ecx

  v2 = a2;
  if ( !a2 )
    return 0;
  v4 = 1000;
  result = (_BYTE *)xmlMalloc(1000);
  if ( !result )
  {
    sub_43279D("xmlEncodeSpecialChars: malloc failed");
    return 0;
  }
  v5 = result;
  if ( !*a2 )
  {
LABEL_23:
    *v5 = 0;
    return result;
  }
  while ( 1 )
  {
    v6 = v5 - result;
    if ( v5 - result <= (int)(v4 - 10) )
      goto LABEL_9;
    v4 *= 2;
    result = (_BYTE *)xmlRealloc(result, v4);
    if ( !result )
      break;
    v5 = &result[v6];
LABEL_9:
    v7 = *v2;
    if ( *v2 == 60 )
    {
      *v5 = 38;
      v8 = v5 + 1;
      *v8 = 108;
LABEL_11:
      v9 = v8 + 1;
      *v9 = 116;
      goto LABEL_12;
    }
    switch ( v7 )
    {
      case '>':
        *v5 = 38;
        v8 = v5 + 1;
        *v8 = 103;
        goto LABEL_11;
      case '&':
        *v5 = 38;
        v10 = v5 + 1;
        *v10++ = 97;
        *v10 = 109;
        v9 = v10 + 1;
        *v9 = 112;
        goto LABEL_12;
      case '"':
        *v5 = 38;
        v11 = v5 + 1;
        *v11++ = 113;
        *v11 = 117;
        v8 = v11 + 1;
        *v8 = 111;
        goto LABEL_11;
    }
    if ( v7 != 13 )
    {
      *v5 = v7;
      goto LABEL_22;
    }
    *v5 = 38;
    v12 = v5 + 1;
    *v12++ = 35;
    *v12 = 49;
    v9 = v12 + 1;
    *v9 = 51;
LABEL_12:
    v5 = v9 + 1;
    *v5 = 59;
LABEL_22:
    ++v5;
    if ( !*++v2 )
      goto LABEL_23;
  }
  sub_43279D("xmlEncodeEntitiesReentrant: realloc failed");
  return 0;
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);

//----- (00433168) --------------------------------------------------------
_DWORD *xmlCreateEntitiesTable()
{
  return xmlHashCreate(0);
}

//----- (00433171) --------------------------------------------------------
void __cdecl sub_433171(int a1)
{
  if ( a1 )
    sub_4327C9(a1);
}

//----- (00433181) --------------------------------------------------------
void __cdecl xmlFreeEntitiesTable(_DWORD *Block)
{
  xmlHashFree(Block, (void (__cdecl *)(int, _DWORD))sub_433171);
}

//----- (00433192) --------------------------------------------------------
_DWORD *__cdecl sub_433192(int a1)
{
  _DWORD *v1; // eax
  _DWORD *v2; // esi
  _BYTE *v4; // edi

  v1 = (_DWORD *)xmlMalloc(76);
  v2 = v1;
  if ( v1 )
  {
    memset(v1, 0, 0x4Cu);
    v2[1] = 17;
    v2[12] = *(_DWORD *)(a1 + 48);
    if ( *(_DWORD *)(a1 + 8) )
      v2[2] = xmlStrdup(*(_BYTE **)(a1 + 8));
    if ( *(_DWORD *)(a1 + 52) )
      v2[13] = xmlStrdup(*(_BYTE **)(a1 + 52));
    if ( *(_DWORD *)(a1 + 56) )
      v2[14] = xmlStrdup(*(_BYTE **)(a1 + 56));
    if ( *(_DWORD *)(a1 + 40) )
      v2[10] = xmlStrdup(*(_BYTE **)(a1 + 40));
    if ( *(_DWORD *)(a1 + 36) )
      v2[9] = xmlStrdup(*(_BYTE **)(a1 + 36));
    v4 = *(_BYTE **)(a1 + 64);
    if ( v4 )
      v2[16] = xmlStrdup(v4);
    return v2;
  }
  else
  {
    sub_43279D("xmlCopyEntity:: malloc failed");
    return 0;
  }
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (0043323B) --------------------------------------------------------
void ***__cdecl xmlCopyEntitiesTable(_DWORD *a1)
{
  return xmlHashCopy(a1, (int (__cdecl *)(int, int))sub_433192);
}

//----- (0043324C) --------------------------------------------------------
void __usercall sub_43324C(_BYTE *a1@<eax>, int *a2@<edi>)
{
  _BYTE *v2; // esi
  _BYTE *v3; // eax

  v2 = a1;
  if ( a2[3] == 2 )
    return;
  if ( !xmlStrchr(a1, 37) )
  {
    xmlBufferWriteQuotedString(a2, v2);
    return;
  }
  xmlBufferCCat(a2, "\"");
  v3 = v2;
  if ( !*v2 )
    goto LABEL_17;
  do
  {
    if ( *v2 == 34 )
    {
      if ( v3 != v2 )
        xmlBufferAdd(a2, v3, v2 - v3);
      xmlBufferAdd(a2, "&quot;", 6);
LABEL_12:
      v3 = ++v2;
      continue;
    }
    if ( *v2 == 37 )
    {
      if ( v3 != v2 )
        xmlBufferAdd(a2, v3, v2 - v3);
      xmlBufferAdd(a2, "&#x25;", 6);
      goto LABEL_12;
    }
    ++v2;
  }
  while ( *v2 );
  if ( v3 != v2 )
    xmlBufferAdd(a2, v3, v2 - v3);
LABEL_17:
  xmlBufferCCat(a2, "\"");
}

//----- (004332FF) --------------------------------------------------------
void __cdecl xmlDumpEntityDecl(int *a1, int a2)
{
  if ( a1 && a2 )
  {
    switch ( *(_DWORD *)(a2 + 48) )
    {
      case 1:
        xmlBufferWriteChar(a1, "<!ENTITY ");
        break;
      case 2:
        xmlBufferWriteChar(a1, "<!ENTITY ");
LABEL_10:
        xmlBufferWriteCHAR(a1, *(_BYTE **)(a2 + 8));
        if ( *(_DWORD *)(a2 + 52) )
        {
          xmlBufferWriteChar(a1, " PUBLIC ");
          xmlBufferWriteQuotedString(a1, *(_BYTE **)(a2 + 52));
          xmlBufferWriteChar(a1, " ");
          xmlBufferWriteQuotedString(a1, *(_BYTE **)(a2 + 56));
        }
        else
        {
          xmlBufferWriteChar(a1, " SYSTEM ");
          xmlBufferWriteQuotedString(a1, *(_BYTE **)(a2 + 56));
        }
LABEL_16:
        xmlBufferWriteChar(a1, ">\n");
        return;
      case 3:
        xmlBufferWriteChar(a1, "<!ENTITY ");
        xmlBufferWriteCHAR(a1, *(_BYTE **)(a2 + 8));
        if ( *(_DWORD *)(a2 + 52) )
        {
          xmlBufferWriteChar(a1, " PUBLIC ");
          xmlBufferWriteQuotedString(a1, *(_BYTE **)(a2 + 52));
          xmlBufferWriteChar(a1, " ");
          xmlBufferWriteQuotedString(a1, *(_BYTE **)(a2 + 56));
        }
        else
        {
          xmlBufferWriteChar(a1, " SYSTEM ");
          xmlBufferWriteQuotedString(a1, *(_BYTE **)(a2 + 56));
        }
        if ( *(_DWORD *)(a2 + 40) )
        {
          xmlBufferWriteChar(a1, " NDATA ");
          if ( *(_DWORD *)(a2 + 36) )
            xmlBufferWriteCHAR(a1, *(_BYTE **)(a2 + 36));
          else
            xmlBufferWriteCHAR(a1, *(_BYTE **)(a2 + 40));
        }
        goto LABEL_16;
      case 4:
        xmlBufferWriteChar(a1, "<!ENTITY % ");
        break;
      case 5:
        xmlBufferWriteChar(a1, "<!ENTITY % ");
        goto LABEL_10;
      default:
        sub_4327B2(535, "xmlDumpEntitiesDecl: internal: unknown type entity type");
        return;
    }
    xmlBufferWriteCHAR(a1, *(_BYTE **)(a2 + 8));
    xmlBufferWriteChar(a1, " ");
    if ( *(_DWORD *)(a2 + 36) )
      xmlBufferWriteQuotedString(a1, *(_BYTE **)(a2 + 36));
    else
      sub_43324C(*(_BYTE **)(a2 + 40), a1);
    goto LABEL_16;
  }
}

//----- (0043349E) --------------------------------------------------------
void __cdecl sub_43349E(int a1, int *a2)
{
  xmlDumpEntityDecl(a2, a1);
}

//----- (004334AE) --------------------------------------------------------
void __cdecl xmlDumpEntitiesTable(int a1, _DWORD *a2)
{
  xmlHashScan(a2, (int)sub_43349E, a1);
}

//----- (004334C4) --------------------------------------------------------
int __cdecl xmlCheckVersion(int a1)
{
  FILE *v1; // eax
  int result; // eax

  xmlInitParser();
  if ( a1 / 10000 != 2 )
  {
    xmlGenericError(
      xmlGenericErrorContext,
      "Fatal: program compiled against libxml %d using libxml %d\n",
      a1 / 10000,
      2);
    v1 = (FILE *)sub_44F01A();
    fprintf(v1 + 2, "Fatal: program compiled against libxml %d using libxml %d\n", a1 / 10000, 2);
  }
  result = a1 / 100;
  if ( a1 / 100 > 208 )
    return xmlGenericError(
             xmlGenericErrorContext,
             "Warning: program compiled against libxml %d using older %d\n",
             result,
             208);
  return result;
}
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);

//----- (00433535) --------------------------------------------------------
#error "4335AA: call analysis failed (funcsize=53)"

//----- (004335B3) --------------------------------------------------------
int (__cdecl *__cdecl _xmlErrEncoding(
        int *a1,
        int (__cdecl *a2)(int, char *Format, char ArgList),
        char *Format,
        _BYTE *Src,
        _BYTE *a5))(int, char *Format, char ArgList)
{
  int (__cdecl *result)(int, char *, char); // eax

  result = a2;
  if ( a1 )
  {
    if ( a1[53] && a1[43] == -1 )
      return result;
    a1[21] = (int)a2;
  }
  result = _xmlRaiseError(0, 0, 0, a1, 0, 1, (int)a2, 3, 0, 0, Src, a5, 0, 0, 0, Format, Src, a5);
  if ( a1 )
  {
    a1[3] = 0;
    if ( !a1[72] )
      a1[53] = 1;
  }
  return result;
}

//----- (0043361B) --------------------------------------------------------
int (__cdecl *__usercall sub_43361B@<eax>(int *a1@<edi>, char *Format, _BYTE *Src))(int, char *Format, char ArgList)
{
  int (__cdecl *result)(int, char *, char); // eax

  if ( a1 )
  {
    if ( a1[53] && a1[43] == -1 )
      return result;
    a1[21] = 1;
  }
  result = _xmlRaiseError(0, 0, 0, a1, 0, 1, 1, 3, 0, 0, Src, 0, 0, 0, 0, Format, Src);
  if ( a1 )
  {
    a1[3] = 0;
    if ( !a1[72] )
      a1[53] = 1;
  }
  return result;
}

//----- (00433675) --------------------------------------------------------
int __usercall sub_433675@<eax>(int *a1@<edi>, char *Format, int ArgList)
{
  int result; // eax

  result = 9;
  if ( a1 )
  {
    if ( a1[53] && a1[43] == -1 )
      return result;
    a1[21] = 9;
  }
  result = (int)_xmlRaiseError(0, 0, 0, a1, 0, 1, 9, 3, 0, 0, 0, 0, 0, ArgList, 0, Format, ArgList);
  if ( a1 )
  {
    a1[3] = 0;
    if ( !a1[72] )
      a1[53] = 1;
  }
  return result;
}

//----- (004336D2) --------------------------------------------------------
BOOL __cdecl xmlIsLetter(signed int a1)
{
  if ( a1 >= 256 )
  {
    if ( xmlCharInRange(a1, xmlIsBaseCharGroup) )
      return 1;
  }
  else if ( a1 >= 65 && a1 <= 90
         || a1 >= 97 && a1 <= 122
         || a1 >= 192 && a1 <= 214
         || a1 >= 216 && a1 <= 246
         || a1 >= 248 )
  {
    return 1;
  }
  return a1 >= 256 && (a1 >= 19968 && a1 <= 40869 || a1 == 12295 || a1 >= 12321 && a1 <= 12329);
}
// 47C2A4: using guessed type _DWORD xmlIsBaseCharGroup[2];

//----- (00433764) --------------------------------------------------------
int __cdecl xmlParserInputRead(_DWORD *a1, int a2)
{
  int result; // eax
  _DWORD *v3; // ecx
  int v4; // eax
  int v5; // eax
  int v6; // edi
  _DWORD *v7; // ecx
  int v8; // edx

  if ( !a1 )
    return -1;
  v3 = (_DWORD *)*a1;
  if ( !*a1 )
    return -1;
  if ( !a1[3] )
    return -1;
  v4 = a1[4];
  if ( !v4 || !v3[4] || !v3[1] )
    return -1;
  v5 = xmlBufferShrink(v3[4], v4 - *(_DWORD *)v3[4]);
  if ( v5 > 0 )
  {
    a1[4] -= v5;
    a1[9] += v5;
  }
  result = xmlParserInputBufferRead((_DWORD *)*a1, a2);
  v6 = a1[3];
  v7 = (_DWORD *)*a1;
  if ( v6 != **(_DWORD **)(*a1 + 16) )
  {
    v8 = a1[4] - v6;
    a1[3] = *(_DWORD *)v7[4];
    a1[4] = v8 + *(_DWORD *)v7[4];
  }
  a1[5] = *(_DWORD *)v7[4] + *(_DWORD *)(v7[4] + 4);
  return result;
}

//----- (004337E7) --------------------------------------------------------
int __cdecl xmlParserInputGrow(int *a1, int a2)
{
  int result; // eax
  int v3; // ecx
  int v4; // edi
  int v5; // eax
  int v6; // edx
  int v7; // edi
  int v8; // ecx
  int v9; // edx

  if ( !a1 )
    return -1;
  v3 = *a1;
  if ( !*a1 )
    return -1;
  v4 = a1[3];
  if ( !v4 )
    return -1;
  v5 = a1[4];
  if ( !v5 )
    return -1;
  v6 = *(_DWORD *)(v3 + 16);
  if ( !v6 )
    return -1;
  if ( *(_DWORD *)(v6 + 4) > (unsigned int)(v5 - v4 + 250) || !*(_DWORD *)(v3 + 4) )
    return 0;
  result = xmlParserInputBufferGrow(v3, a2);
  v7 = a1[3];
  v8 = *a1;
  if ( v7 != **(_DWORD **)(*a1 + 16) )
  {
    v9 = a1[4] - v7;
    a1[3] = **(_DWORD **)(v8 + 16);
    a1[4] = v9 + **(_DWORD **)(v8 + 16);
  }
  a1[5] = **(_DWORD **)(v8 + 16) + *(_DWORD *)(*(_DWORD *)(v8 + 16) + 4);
  return result;
}

//----- (00433869) --------------------------------------------------------
void __cdecl xmlParserInputShrink(_DWORD *a1)
{
  _DWORD *v1; // eax
  int v2; // ecx
  _DWORD *v3; // edx
  int v4; // ecx
  int v5; // eax
  int v6; // eax
  int v7; // edx
  int v8; // ecx

  if ( a1 )
  {
    v1 = (_DWORD *)*a1;
    if ( *a1 )
    {
      if ( a1[3] )
      {
        v2 = a1[4];
        if ( v2 )
        {
          v3 = (_DWORD *)v1[4];
          if ( v3 )
          {
            v4 = v2 - *v3;
            if ( v4 > 250 )
            {
              v5 = xmlBufferShrink((int)v3, v4 - 80);
              if ( v5 > 0 )
              {
                a1[4] -= v5;
                a1[9] += v5;
              }
              v1 = (_DWORD *)*a1;
              a1[5] = **(_DWORD **)(*a1 + 16) + *(_DWORD *)(*(_DWORD *)(*a1 + 16) + 4);
            }
            if ( *(_DWORD *)(v1[4] + 4) <= 0xFAu )
            {
              xmlParserInputBufferRead(v1, 500);
              v6 = *a1;
              v7 = a1[3];
              if ( v7 != **(_DWORD **)(*a1 + 16) )
              {
                v8 = a1[4] - v7;
                a1[3] = **(_DWORD **)(v6 + 16);
                a1[4] = v8 + **(_DWORD **)(v6 + 16);
              }
              a1[5] = **(_DWORD **)(v6 + 16) + *(_DWORD *)(*(_DWORD *)(v6 + 16) + 4);
            }
          }
        }
      }
    }
  }
}

//----- (0043390D) --------------------------------------------------------
void __cdecl xmlNextChar(int *a1)
{
  int *v1; // eax
  _BYTE *v2; // ecx
  int v3; // eax
  int *v4; // eax
  char *v5; // esi
  char *v6; // ecx
  char v7; // bl
  int v8; // eax
  char v9; // dl
  char v10; // cl
  char v11; // al
  unsigned int v12; // eax
  int v13; // eax
  int v14; // eax
  char Buffer[152]; // [esp+4h] [ebp-9Ch] BYREF

  if ( !a1 )
    return;
  if ( a1[43] == -1 )
    return;
  v1 = (int *)a1[9];
  if ( !v1 )
    return;
  v2 = (_BYTE *)v1[4];
  if ( a1[64] != 1 )
  {
    if ( *v2 == 10 )
    {
      ++v1[7];
      *(_DWORD *)(a1[9] + 32) = 1;
    }
    else
    {
      ++v1[8];
    }
    v4 = (int *)a1[9];
    goto LABEL_44;
  }
  if ( *v2 || xmlParserInputGrow(v1, 250) > 0 || a1[43] == 5 )
  {
    v3 = a1[9];
    if ( **(_BYTE **)(v3 + 16) == 10 )
    {
      ++*(_DWORD *)(v3 + 28);
      *(_DWORD *)(a1[9] + 32) = 1;
    }
    else
    {
      ++*(_DWORD *)(v3 + 32);
    }
    v4 = (int *)a1[9];
    v5 = (char *)v4[4];
    v6 = v5;
    v7 = *v5;
    if ( *v5 < 0 )
    {
      if ( v7 == -64 )
        goto LABEL_27;
      if ( !v5[1] )
      {
        xmlParserInputGrow(v4, 250);
        v4 = (int *)a1[9];
        v5 = (char *)v4[4];
        v6 = v5;
      }
      if ( (v6[1] & 0xC0) != 0x80 )
        goto LABEL_27;
      if ( (v7 & 0xE0) == 0xE0 )
      {
        if ( !v6[2] )
        {
          xmlParserInputGrow(v4, 250);
          v4 = (int *)a1[9];
          v5 = (char *)v4[4];
          v6 = v5;
        }
        if ( (v6[2] & 0xC0) == 0x80 )
        {
          if ( (v7 & 0xF0) != 0xF0 )
          {
            v4[4] += 3;
            v11 = *v6;
            v9 = v6[1];
            v10 = v6[2];
            v8 = v11 & 0xF;
LABEL_33:
            v12 = v10 & 0x3F | ((v9 & 0x3F | (v8 << 6)) << 6);
            if ( v12 > 0xD7FF && v12 < 0xE000 || v12 > 0xFFFD && v12 < 0x10000 || v12 >= 0x110000 )
              sub_433675(a1, "Char 0x%X out of allowed range\n", v12);
            goto LABEL_45;
          }
          if ( !v6[3] )
          {
            xmlParserInputGrow(v4, 250);
            v4 = (int *)a1[9];
            v5 = (char *)v4[4];
            v6 = v5;
          }
          if ( (v7 & 0xF8) == 0xF0 && (v6[3] & 0xC0) == 0x80 )
          {
            v4[4] += 4;
            v8 = v6[1] & 0x3F | ((*v6 & 7) << 6);
            v9 = v6[2];
            v10 = v6[3];
            goto LABEL_33;
          }
        }
LABEL_27:
        if ( v4 && v4[5] - (int)v5 >= 4 )
        {
          _snprintf(
            Buffer,
            0x95u,
            "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",
            *(unsigned __int8 *)v4[4],
            *(unsigned __int8 *)(v4[4] + 1),
            *(unsigned __int8 *)(v4[4] + 2),
            *(unsigned __int8 *)(v4[4] + 3));
          _xmlErrEncoding(
            a1,
            (int (__cdecl *)(int, char *, char))9,
            "Input is not proper UTF-8, indicate encoding !\n%s",
            Buffer,
            0);
        }
        else
        {
          _xmlErrEncoding(
            a1,
            (int (__cdecl *)(int, char *, char))9,
            "Input is not proper UTF-8, indicate encoding !\n",
            0,
            0);
        }
        a1[64] = 10;
        ++*(_DWORD *)(a1[9] + 16);
        return;
      }
      v4[4] += 2;
LABEL_45:
      v13 = a1[9];
      ++a1[50];
      if ( !**(_BYTE **)(v13 + 16) )
        xmlParserInputGrow((int *)v13, 250);
      goto LABEL_47;
    }
LABEL_44:
    ++v4[4];
    goto LABEL_45;
  }
  xmlPopInput(a1);
LABEL_47:
  if ( **(_BYTE **)(a1[9] + 16) == 37 && !a1[8] )
    xmlParserHandlePEReference(a1);
  v14 = a1[9];
  if ( !**(_BYTE **)(v14 + 16) && xmlParserInputGrow((int *)v14, 250) <= 0 )
    xmlPopInput(a1);
}
// 420686: using guessed type _DWORD __cdecl xmlParserHandlePEReference(_DWORD);

//----- (00433BCB) --------------------------------------------------------
int __cdecl xmlCurrentChar(int *a1, _DWORD *a2)
{
  int *v2; // esi
  char *v3; // eax
  char v5; // dl
  unsigned int v6; // esi
  bool v7; // cf
  int v8; // eax
  int v9; // eax
  int v10; // eax
  _BYTE *v11; // ecx
  int v12; // eax
  unsigned __int8 *v13; // ecx
  char v14; // [esp+Fh] [ebp-2Dh]
  char Buffer[152]; // [esp+10h] [ebp-2Ch] BYREF

  if ( !a1 )
    return 0;
  if ( !a2 )
    return 0;
  v2 = (int *)a1[9];
  if ( !v2 || a1[43] == -1 )
    return 0;
  v3 = (char *)v2[4];
  if ( *v3 >= 32 )
  {
LABEL_6:
    *a2 = 1;
    return **(unsigned __int8 **)(a1[9] + 16);
  }
  if ( a1[64] == 1 )
  {
    v5 = *v3;
    v14 = *v3;
    if ( *v3 < 0 )
    {
      if ( (v5 & 0x40) == 0 || v5 == -64 )
        goto LABEL_39;
      if ( !v3[1] )
      {
        xmlParserInputGrow(v2, 250);
        v2 = (int *)a1[9];
        v3 = (char *)v2[4];
        v5 = v14;
      }
      if ( (v3[1] & 0xC0) != 0x80 )
        goto LABEL_39;
      if ( (v5 & 0xE0) == 0xE0 )
      {
        if ( !v3[2] )
        {
          xmlParserInputGrow(v2, 250);
          v2 = (int *)a1[9];
          v3 = (char *)v2[4];
          v5 = v14;
        }
        if ( (v3[2] & 0xC0) != 0x80 )
          goto LABEL_39;
        if ( (v5 & 0xF0) == 0xF0 )
        {
          if ( !v3[3] )
          {
            xmlParserInputGrow(v2, 250);
            v3 = *(char **)(a1[9] + 16);
            v5 = v14;
          }
          if ( (v5 & 0xF8) == 0xF0 && (v3[3] & 0xC0) == 0x80 )
          {
            *a2 = 4;
            v6 = v3[3] & 0x3F | ((v3[2] & 0x3F | ((v3[1] & 0x3F | ((*v3 & 7) << 6)) << 6)) << 6);
            v7 = v6 < 0x10000;
            goto LABEL_26;
          }
LABEL_39:
          v8 = a1[9];
          if ( *(_DWORD *)(v8 + 20) - *(_DWORD *)(v8 + 16) >= 4 )
          {
            _snprintf(
              Buffer,
              0x95u,
              "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",
              **(unsigned __int8 **)(v8 + 16),
              *(unsigned __int8 *)(*(_DWORD *)(v8 + 16) + 1),
              *(unsigned __int8 *)(*(_DWORD *)(v8 + 16) + 2),
              *(unsigned __int8 *)(*(_DWORD *)(v8 + 16) + 3));
            _xmlErrEncoding(
              a1,
              (int (__cdecl *)(int, char *, char))9,
              "Input is not proper UTF-8, indicate encoding !\n%s",
              Buffer,
              0);
            a1[64] = 10;
            goto LABEL_6;
          }
          *a2 = 0;
          return 0;
        }
        *a2 = 3;
        v6 = v3[2] & 0x3F | ((v3[1] & 0x3F | ((*v3 & 0xF) << 6)) << 6);
        v7 = v6 < 0x800;
      }
      else
      {
        *a2 = 2;
        v6 = v3[1] & 0x3F | ((*v3 & 0x1F) << 6);
        v7 = v6 < 0x80;
      }
LABEL_26:
      if ( !v7 )
      {
        if ( v6 >= 0x100 )
        {
          if ( v6 <= 0xD7FF || v6 >= 0xE000 && v6 <= 0xFFFD || v6 - 0x10000 <= 0xFFFFF )
            return v6;
        }
        else if ( v6 >= 9 && v6 <= 0xA || v6 == 13 || v6 >= 0x20 )
        {
          return v6;
        }
        sub_433675(a1, "Char 0x%X out of allowed range\n", v6);
        return v6;
      }
      goto LABEL_39;
    }
    *a2 = 1;
    v9 = a1[9];
    if ( !**(_BYTE **)(v9 + 16) )
      xmlParserInputGrow((int *)v9, 250);
    v10 = a1[9];
    v11 = *(_BYTE **)(v10 + 16);
    if ( !*v11 && *(_DWORD *)(v10 + 20) > (unsigned int)v11 )
      sub_433675(a1, "Char 0x0 out of allowed range\n", 0);
  }
  else
  {
    *a2 = 1;
  }
  v12 = a1[9];
  v13 = *(unsigned __int8 **)(v12 + 16);
  if ( *v13 != 13 )
    return *v13;
  if ( v13[1] == 10 )
  {
    ++a1[50];
    ++*(_DWORD *)(v12 + 16);
  }
  return 10;
}

//----- (00433EBA) --------------------------------------------------------
unsigned int __cdecl xmlStringCurrentChar(int *a1, unsigned __int8 *a2, _DWORD *a3)
{
  char v3; // al
  int v4; // ebx
  unsigned __int8 v5; // al
  int v6; // eax
  unsigned int v8; // ebx
  char Buffer[152]; // [esp+Ch] [ebp-9Ch] BYREF

  if ( !a3 || !a2 )
    return 0;
  if ( a1 && a1[64] != 1 || (v3 = *a2, (*a2 & 0x80u) == 0) )
  {
    *a3 = 1;
    return *a2;
  }
  if ( (a2[1] & 0xC0) != 0x80 )
    goto LABEL_13;
  if ( (v3 & 0xE0) != 0xE0 )
  {
    *a3 = 2;
    v5 = a2[1];
    v4 = *a2 & 0x1F;
LABEL_21:
    v8 = v5 & 0x3F | (v4 << 6);
    if ( v8 >= 0x100 )
    {
      if ( v8 <= 0xD7FF || v8 >= 0xE000 && v8 <= 0xFFFD || v8 - 0x10000 <= 0xFFFFF )
        return v8;
    }
    else if ( v8 >= 9 && v8 <= 0xA || v8 == 13 || v8 >= 0x20 )
    {
      return v8;
    }
    sub_433675(a1, "Char 0x%X out of allowed range\n", v8);
    return v8;
  }
  if ( (a2[2] & 0xC0) != 0x80 )
    goto LABEL_13;
  if ( (v3 & 0xF0) != 0xF0 )
  {
    *a3 = 3;
    v4 = a2[1] & 0x3F | ((*a2 & 0xF) << 6);
    v5 = a2[2];
    goto LABEL_21;
  }
  if ( (v3 & 0xF8) == 0xF0 && (a2[3] & 0xC0) == 0x80 )
  {
    *a3 = 4;
    v4 = a2[2] & 0x3F | ((a2[1] & 0x3F | ((*a2 & 7) << 6)) << 6);
    v5 = a2[3];
    goto LABEL_21;
  }
LABEL_13:
  if ( !a1 || !a1[9] || (v6 = a1[9], *(_DWORD *)(v6 + 20) - *(_DWORD *)(v6 + 16) < 4) )
  {
    *a3 = 0;
    return 0;
  }
  _snprintf(
    Buffer,
    0x95u,
    "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",
    **(unsigned __int8 **)(v6 + 16),
    *(unsigned __int8 *)(*(_DWORD *)(v6 + 16) + 1),
    *(unsigned __int8 *)(*(_DWORD *)(v6 + 16) + 2),
    *(unsigned __int8 *)(*(_DWORD *)(v6 + 16) + 3));
  _xmlErrEncoding(
    a1,
    (int (__cdecl *)(int, char *, char))9,
    "Input is not proper UTF-8, indicate encoding !\n%s",
    Buffer,
    0);
  *a3 = 1;
  return *a2;
}

//----- (00434087) --------------------------------------------------------
int __cdecl xmlCopyCharMultiByte(_BYTE *a1, int a2)
{
  _BYTE *v3; // eax
  int v4; // esi
  char v5; // cl
  int v6; // [esp-4h] [ebp-Ch]

  if ( !a1 )
    return 0;
  if ( a2 < 128 )
  {
    *a1 = a2;
    return 1;
  }
  else
  {
    if ( a2 >= 2048 )
    {
      if ( a2 >= 0x10000 )
      {
        if ( a2 >= 1114112 )
        {
          sub_433675(0, "Internal error, xmlCopyCharMultiByte 0x%X out of bound\n", a2);
          return 0;
        }
        v5 = (a2 >> 18) | 0xF0;
        v6 = 12;
      }
      else
      {
        v5 = (a2 >> 12) | 0xE0;
        v6 = 6;
      }
      *a1 = v5;
      v4 = v6;
      v3 = a1 + 1;
    }
    else
    {
      *a1 = (a2 >> 6) | 0xC0;
      v3 = a1 + 1;
      v4 = 0;
    }
    do
    {
      *v3++ = (a2 >> v4) & 0x3F | 0x80;
      v4 -= 6;
    }
    while ( v4 >= 0 );
    return v3 - a1;
  }
}

//----- (00434117) --------------------------------------------------------
int __cdecl xmlCopyChar(int a1, _BYTE *a2, int a3)
{
  if ( !a2 )
    return 0;
  if ( a3 >= 128 )
    return xmlCopyCharMultiByte(a2, a3);
  *a2 = a3;
  return 1;
}

//----- (0043413D) --------------------------------------------------------
int __cdecl xmlSwitchEncoding(int *a1, int a2)
{
  int result; // eax
  int v3; // edi
  int v4; // esi
  _BYTE *v5; // eax
  int v6; // eax
  _BYTE *v7; // ecx
  const char **CharEncodingHandler; // eax
  int v9; // eax
  _BYTE *v10; // eax
  int v11; // [esp-8h] [ebp-10h]

  result = -1;
  v3 = -1;
  if ( a1 )
  {
    switch ( a2 )
    {
      case -1:
        _xmlErrEncoding(a1, (int (__cdecl *)(int, char *, char))0x1F, "encoding unknown\n", 0, 0);
        return -1;
      case 0:
        goto LABEL_39;
      case 1:
        a1[64] = 1;
        v4 = a1[9];
        if ( v4 )
        {
          v5 = *(_BYTE **)(v4 + 16);
          if ( *v5 == 0xEF && v5[1] == 0xBB && v5[2] == 0xBF )
            *(_DWORD *)(v4 + 16) += 3;
        }
        return 0;
      case 2:
      case 3:
        v6 = a1[9];
        if ( v6 )
        {
          v7 = *(_BYTE **)(v6 + 16);
          if ( v7 )
          {
            if ( *v7 == 0xEF && v7[1] == 0xBB && v7[2] == 0xBF )
              *(_DWORD *)(v6 + 16) += 3;
          }
        }
        goto LABEL_15;
      case 4:
      case 5:
      case 7:
      case 8:
        v3 = 180;
        break;
      case 6:
      case 10:
      case 11:
      case 12:
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 21:
      case 22:
        v11 = 45;
        goto LABEL_18;
      case 9:
LABEL_15:
        v11 = 90;
LABEL_18:
        v3 = v11;
        break;
      default:
        break;
    }
    CharEncodingHandler = (const char **)xmlGetCharEncodingHandler(a2);
    if ( !CharEncodingHandler )
    {
      if ( a2 <= 9 )
      {
        switch ( a2 )
        {
          case 9:
            _xmlErrEncoding(a1, (int (__cdecl *)(int, char *, char))0x20, "encoding not supported %s\n", "UCS2", 0);
            break;
          case 4:
            _xmlErrEncoding(
              a1,
              (int (__cdecl *)(int, char *, char))0x20,
              "encoding not supported %s\n",
              "USC4 little endian",
              0);
            break;
          case 5:
            _xmlErrEncoding(
              a1,
              (int (__cdecl *)(int, char *, char))0x20,
              "encoding not supported %s\n",
              "USC4 big endian",
              0);
            break;
          case 6:
            _xmlErrEncoding(a1, (int (__cdecl *)(int, char *, char))0x20, "encoding not supported %s\n", "EBCDIC", 0);
            break;
          case 7:
            _xmlErrEncoding(a1, (int (__cdecl *)(int, char *, char))0x20, "encoding not supported %s\n", "UCS4 2143", 0);
            break;
          case 8:
            _xmlErrEncoding(a1, (int (__cdecl *)(int, char *, char))0x20, "encoding not supported %s\n", "UCS4 3412", 0);
            break;
        }
        return -1;
      }
      if ( a2 > 18 )
      {
        switch ( a2 )
        {
          case 19:
            _xmlErrEncoding(
              a1,
              (int (__cdecl *)(int, char *, char))0x20,
              "encoding not supported %s\n",
              "ISO-2022-JP",
              0);
            break;
          case 20:
            _xmlErrEncoding(a1, (int (__cdecl *)(int, char *, char))0x20, "encoding not supported %s\n", "Shift_JIS", 0);
            break;
          case 21:
            _xmlErrEncoding(a1, (int (__cdecl *)(int, char *, char))0x20, "encoding not supported %s\n", "EUC-JP", 0);
            break;
          case 22:
LABEL_39:
            a1[64] = 1;
            return 0;
        }
        return -1;
      }
      if ( a1[10] == 1 && !a1[6] )
      {
        v9 = a1[9];
        if ( v9 )
        {
          v10 = *(_BYTE **)(v9 + 44);
          if ( v10 )
            a1[6] = (int)xmlStrdup(v10);
        }
      }
      a1[64] = a2;
      return 0;
    }
    a1[64] = 1;
    return sub_4344CF(a1, CharEncodingHandler, v3);
  }
  return result;
}
// 434262: conditional instruction was optimized away because ebx.4>=A

//----- (00434321) --------------------------------------------------------
int __usercall sub_434321@<eax>(const char **a1@<edx>, _DWORD *a2@<ebx>, int *a3, int a4)
{
  int v5; // eax
  const char **v6; // ecx
  int v7; // edx
  int v8; // eax
  _BYTE *v9; // eax
  _BYTE *v10; // eax
  const char *v11; // edx
  _BYTE *v12; // eax
  unsigned int v13; // esi
  int v14; // eax
  int v15; // edi
  int v16; // esi
  int v17; // eax
  int v18; // ecx
  int v19; // eax

  if ( !a1 || !a2 )
    return -1;
  v5 = *a2;
  if ( *a2 )
  {
    v6 = *(const char ***)(v5 + 12);
    if ( v6 )
    {
      if ( v6 != a1 )
      {
        xmlCharEncCloseFunc(*(_DWORD **)(v5 + 12));
        *(_DWORD *)(*a2 + 12) = v7;
      }
      return 0;
    }
    *(_DWORD *)(v5 + 12) = a1;
    v8 = *(_DWORD *)(*a2 + 16);
    if ( !v8 || !*(_DWORD *)(v8 + 4) )
      return 0;
    if ( *a1 )
    {
      if ( !strcmp(*a1, "UTF-16LE") || !strcmp(*a1, "UTF-16") )
      {
        v9 = (_BYTE *)a2[4];
        if ( *v9 == 0xFF && v9[1] == 0xFE )
          a2[4] = v9 + 2;
      }
      if ( *a1 )
      {
        if ( !strcmp(*a1, "UTF-16BE") )
        {
          v10 = (_BYTE *)a2[4];
          if ( *v10 == 0xFE && v10[1] == 0xFF )
            a2[4] = v10 + 2;
        }
        v11 = *a1;
        if ( v11 )
        {
          if ( !strcmp(v11, "UTF-8") )
          {
            v12 = (_BYTE *)a2[4];
            if ( *v12 == 0xEF && v12[1] == 0xBB && v12[2] == 0xBF )
              a2[4] = v12 + 3;
          }
        }
      }
    }
    v13 = a2[4] - a2[3];
    xmlBufferShrink(*(_DWORD *)(*a2 + 16), v13);
    *(_DWORD *)(*a2 + 20) = *(_DWORD *)(*a2 + 16);
    *(_DWORD *)(*a2 + 16) = xmlBufferCreate();
    *(_DWORD *)(*a2 + 32) = v13;
    v14 = *a2;
    v15 = *(_DWORD *)(*a2 + 20);
    v16 = *(_DWORD *)(v15 + 4);
    if ( a3[8] )
      v17 = xmlCharEncInFunc(*(_DWORD *)(v14 + 12), *(_DWORD **)(v14 + 16), (unsigned __int8 **)v15);
    else
      v17 = sub_43B279((_DWORD *)v15, *(_DWORD **)(v14 + 16), *(_DWORD *)(v14 + 12), a4);
    if ( v17 < 0 )
    {
      sub_43361B(a3, "switching encoding: encoder error\n", 0);
      return -1;
    }
    *(_DWORD *)(*a2 + 32) += v16 - *(_DWORD *)(*(_DWORD *)(*a2 + 20) + 4);
    v18 = *a2;
    v19 = **(_DWORD **)(*a2 + 16);
    a2[4] = v19;
    a2[3] = v19;
    a2[5] = v19 + *(_DWORD *)(*(_DWORD *)(v18 + 16) + 4);
  }
  else if ( !a2[6] )
  {
    sub_43361B(a3, "switching encoding : no input\n", 0);
    return -1;
  }
  return 0;
}
// 434354: variable 'v7' is possibly undefined

//----- (004344B7) --------------------------------------------------------
int __cdecl xmlSwitchInputEncoding(int *a1, _DWORD *a2, const char **a3)
{
  return sub_434321(a3, a2, a1, -1);
}

//----- (004344CF) --------------------------------------------------------
int __usercall sub_4344CF@<eax>(int *a1@<eax>, const char **a2@<edx>, int a3)
{
  _DWORD *v4; // ebx
  int result; // eax

  if ( a2 )
  {
    v4 = (_DWORD *)a1[9];
    if ( v4 )
    {
      result = sub_434321(a2, v4, a1, a3);
      a1[64] = 1;
      return result;
    }
    sub_43361B(a1, "xmlSwitchToEncoding : no input\n", 0);
  }
  return -1;
}

//----- (0043450A) --------------------------------------------------------
int __cdecl xmlSwitchToEncoding(int *a1, const char **a2)
{
  return sub_4344CF(a1, a2, -1);
}

//----- (0043451B) --------------------------------------------------------
int __cdecl xmlFreeInputStream(int ***Block)
{
  int **v1; // ecx
  int result; // eax

  if ( Block )
  {
    if ( Block[1] )
      ((void (__cdecl *)(int **))xmlFree)(Block[1]);
    if ( Block[2] )
      ((void (__cdecl *)(int **))xmlFree)(Block[2]);
    if ( Block[11] )
      ((void (__cdecl *)(int **))xmlFree)(Block[11]);
    if ( Block[12] )
      ((void (__cdecl *)(int **))xmlFree)(Block[12]);
    v1 = Block[10];
    if ( v1 && Block[3] )
      ((void (__cdecl *)(int **))v1)(Block[3]);
    if ( *Block )
      xmlFreeParserInputBuffer(*Block);
    return ((int (__cdecl *)(int ***))xmlFree)(Block);
  }
  return result;
}
// 496494: invalid function type has been ignored

//----- (00434589) --------------------------------------------------------
_DWORD *__cdecl xmlNewInputStream(int a1)
{
  _DWORD *v1; // eax
  _DWORD *v2; // esi

  v1 = (_DWORD *)xmlMalloc(60);
  v2 = v1;
  if ( v1 )
  {
    memset(v1, 0, 0x3Cu);
    v2[13] = -1;
    v2[7] = 1;
    v2[8] = 1;
    if ( a1 )
      v2[14] = (*(_DWORD *)(a1 + 464))++;
    return v2;
  }
  else
  {
    xmlErrMemory(a1, "couldn't allocate a new input stream\n");
    return 0;
  }
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (004345DF) --------------------------------------------------------
_DWORD *__cdecl xmlNewIOInputStream(int *a1, int a2, int a3)
{
  _DWORD *result; // eax
  _DWORD *v4; // esi

  if ( !a2 )
    return 0;
  if ( xmlParserDebugEntities )
    xmlGenericError(xmlGenericErrorContext, "new input from I/O\n");
  result = xmlNewInputStream((int)a1);
  v4 = result;
  if ( result )
  {
    result[1] = 0;
    *result = a2;
    result[3] = **(_DWORD **)(a2 + 16);
    result[4] = **(_DWORD **)(a2 + 16);
    result[5] = result[3] + *(_DWORD *)(*(_DWORD *)(a2 + 16) + 4);
    if ( a3 )
      xmlSwitchEncoding(a1, a3);
    return v4;
  }
  return result;
}
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);
// 4A9C7C: using guessed type int xmlParserDebugEntities;

//----- (00434655) --------------------------------------------------------
int __cdecl xmlNewEntityInputStream(int *a1, int a2)
{
  _DWORD *v3; // edi
  int v4; // eax

  if ( !a2 )
  {
    sub_43361B(a1, "xmlNewEntityInputStream entity = NULL\n", 0);
    return 0;
  }
  if ( xmlParserDebugEntities )
    xmlGenericError(xmlGenericErrorContext, "new input from entity: %s\n", *(const char **)(a2 + 8));
  if ( *(_DWORD *)(a2 + 40) )
  {
    v3 = xmlNewInputStream((int)a1);
    if ( !v3 )
      return 0;
    if ( *(_DWORD *)(a2 + 64) )
      v3[1] = xmlStrdup(*(_BYTE **)(a2 + 64));
    v3[3] = *(_DWORD *)(a2 + 40);
    v3[4] = *(_DWORD *)(a2 + 40);
    v4 = *(_DWORD *)(a2 + 44);
    v3[6] = v4;
    v3[5] = v4 + *(_DWORD *)(a2 + 40);
    return (int)v3;
  }
  else
  {
    if ( *(_DWORD *)(a2 + 48) == 1 )
    {
      sub_43361B(a1, "Internal entity %s without content !\n", *(_BYTE **)(a2 + 8));
      return 0;
    }
    if ( *(_DWORD *)(a2 + 48) != 2 )
    {
      if ( *(_DWORD *)(a2 + 48) == 3 )
      {
        sub_43361B(a1, "Cannot parse entity %s\n", *(_BYTE **)(a2 + 8));
        return 0;
      }
      if ( *(_DWORD *)(a2 + 48) == 4 )
      {
        sub_43361B(a1, "Internal parameter entity %s without content !\n", *(_BYTE **)(a2 + 8));
        return 0;
      }
      if ( *(_DWORD *)(a2 + 48) != 5 )
      {
        if ( *(_DWORD *)(a2 + 48) == 6 )
          sub_43361B(a1, "Predefined entity %s without content !\n", *(_BYTE **)(a2 + 8));
        return 0;
      }
    }
    return xmlLoadExternalEntity(*(char **)(a2 + 64), *(_DWORD *)(a2 + 52), (int)a1);
  }
}
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);
// 4A9C7C: using guessed type int xmlParserDebugEntities;

//----- (00434735) --------------------------------------------------------
int __cdecl xmlNewStringInputStream(int *a1, char *ArgList)
{
  _DWORD *v3; // eax
  int v4; // eax
  int v5; // edx

  if ( ArgList )
  {
    if ( xmlParserDebugEntities )
      xmlGenericError(xmlGenericErrorContext, "new fixed input: %.30s\n", ArgList);
    v3 = xmlNewInputStream((int)a1);
    if ( v3 )
    {
      v3[3] = ArgList;
      v3[4] = ArgList;
      v4 = xmlStrlen(ArgList);
      *(_DWORD *)(v5 + 24) = v4;
      *(_DWORD *)(v5 + 20) = &ArgList[v4];
      return v5;
    }
    else
    {
      xmlErrMemory((int)a1, "couldn't allocate a new input stream\n");
      return 0;
    }
  }
  else
  {
    sub_43361B(a1, "xmlNewStringInputStream string = NULL\n", 0);
    return 0;
  }
}
// 4347A2: variable 'v5' is possibly undefined
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);
// 4A9C7C: using guessed type int xmlParserDebugEntities;

//----- (004347AF) --------------------------------------------------------
int *__cdecl xmlNewInputFromFile(int *a1, char *ArgList)
{
  _DWORD *FilenameValue; // eax
  _DWORD *v4; // ebx
  int *v5; // eax
  int *v6; // esi
  _BYTE *v7; // eax
  char *v8; // eax
  char *v9; // edi
  _BYTE *Directory; // ebx
  int v11; // eax

  if ( xmlParserDebugEntities )
    xmlGenericError(xmlGenericErrorContext, "new input from file: %s\n", ArgList);
  if ( !a1 )
    return 0;
  if ( xmlParserInputBufferCreateFilenameValue )
    FilenameValue = (_DWORD *)xmlParserInputBufferCreateFilenameValue(ArgList, 0);
  else
    FilenameValue = sub_43C40D((int)ArgList, 0);
  v4 = FilenameValue;
  if ( !FilenameValue )
  {
    if ( ArgList )
      sub_43BAB2(a1, "failed to load external entity \"%s\"\n", ArgList);
    else
      sub_43BAB2(a1, "failed to load external entity: NULL filename \n", 0);
    return 0;
  }
  v5 = xmlNewInputStream((int)a1);
  v6 = v5;
  if ( !v5 )
    return 0;
  v7 = (_BYTE *)v5[1];
  *v6 = (int)v4;
  if ( v7 )
    v8 = xmlStrdup(v7);
  else
    v8 = xmlStrdup(ArgList);
  v9 = v8;
  Directory = (_BYTE *)xmlParserGetDirectory(v8);
  if ( v6[1] )
    ((void (__cdecl *)(int))xmlFree)(v6[1]);
  v6[1] = (int)xmlCanonicPath(v9);
  if ( v9 )
    ((void (__cdecl *)(char *))xmlFree)(v9);
  v11 = *v6;
  v6[2] = (int)Directory;
  v6[3] = **(_DWORD **)(v11 + 16);
  v6[4] = **(_DWORD **)(v11 + 16);
  v6[5] = v6[3] + *(_DWORD *)(*(_DWORD *)(v11 + 16) + 4);
  if ( !a1[45] && Directory )
    a1[45] = (int)xmlStrdup(Directory);
  return v6;
}
// 4A9CBC: invalid function type has been ignored
// 496494: invalid function type has been ignored
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);
// 4A9C7C: using guessed type int xmlParserDebugEntities;
// 4A9CBC: using guessed type int (__cdecl *xmlParserInputBufferCreateFilenameValue)(_DWORD, _DWORD);

//----- (004348BE) --------------------------------------------------------
int __cdecl xmlInitParserCtxt(int *a1)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int ***i; // eax
  int v6; // eax
  int v7; // eax
  _DWORD *v8; // eax
  int v9; // ecx

  if ( !a1 )
  {
    sub_43361B(0, "Got NULL parser context\n", 0);
    return -1;
  }
  xmlSAXVersion(&xmlDefaultSAXHandler, 1);
  if ( !a1[74] && (v2 = xmlDictCreate(), (a1[74] = v2) == 0) || !*a1 && (v3 = xmlMalloc(128), (*a1 = v3) == 0) )
  {
    xmlErrMemory(0, "cannot initialize parser context\n");
    return -1;
  }
  xmlSAXVersion(*a1, 2);
  a1[76] = 0;
  a1[75] = 0;
  if ( !a1[12] )
  {
    v4 = xmlMalloc(20);
    a1[12] = v4;
    a1[11] = 5;
    if ( !v4 )
    {
      xmlErrMemory(0, "cannot initialize parser context\n");
LABEL_12:
      a1[10] = 0;
      a1[11] = 0;
      a1[9] = 0;
      return -1;
    }
  }
  for ( i = (int ***)inputPop(a1); i; i = (int ***)inputPop(a1) )
    xmlFreeInputStream(i);
  a1[7] = -1;
  a1[10] = 0;
  a1[9] = 0;
  a1[5] = 0;
  a1[6] = 0;
  a1[22] = 0;
  a1[23] = 0;
  a1[8] = 0;
  a1[24] = 0;
  a1[43] = 0;
  a1[44] = 0;
  a1[45] = 0;
  if ( !a1[16] )
  {
    v6 = xmlMalloc(40);
    a1[16] = v6;
    a1[15] = 10;
    if ( !v6 )
    {
      xmlErrMemory(0, "cannot initialize parser context\n");
      a1[14] = 0;
      a1[15] = 0;
      a1[13] = 0;
      goto LABEL_12;
    }
  }
  a1[14] = 0;
  a1[13] = 0;
  if ( !a1[49] )
  {
    v7 = xmlMalloc(40);
    a1[49] = v7;
    a1[48] = 10;
    if ( !v7 )
    {
      xmlErrMemory(0, "cannot initialize parser context\n");
      a1[14] = 0;
      a1[15] = 0;
      a1[13] = 0;
      a1[10] = 0;
      a1[11] = 0;
      a1[9] = 0;
      a1[47] = 0;
      a1[48] = 0;
      a1[46] = 0;
      return -1;
    }
  }
  a1[47] = 0;
  a1[46] = 0;
  if ( !a1[61] )
  {
    a1[61] = xmlMalloc(40);
    a1[60] = 10;
  }
  v8 = (_DWORD *)a1[61];
  if ( !v8 )
  {
    xmlErrMemory(0, "cannot initialize parser context\n");
    a1[14] = 0;
    a1[15] = 0;
    a1[13] = 0;
    a1[10] = 0;
    a1[11] = 0;
    a1[9] = 0;
    a1[47] = 0;
    a1[48] = 0;
    a1[46] = 0;
    a1[59] = 0;
    a1[60] = 0;
    a1[58] = 0;
    return -1;
  }
  a1[59] = 1;
  a1[60] = 10;
  *v8 = -1;
  a1[58] = a1[61];
  a1[1] = (int)a1;
  a1[2] = 0;
  a1[3] = 1;
  a1[89] = 1;
  a1[25] = 1;
  a1[69] = xmlLoadExtDtdDefaultValue;
  a1[26] = xmlDoValidityCheckingDefaultValue;
  a1[67] = xmlPedanticParserDefaultValue;
  a1[70] = xmlLineNumbersDefaultValue;
  v9 = xmlKeepBlanksDefaultValue;
  a1[52] = xmlKeepBlanksDefaultValue;
  if ( !v9 )
    *(_DWORD *)(*a1 + 72) = xmlUnlockLibrary;
  a1[34] = -1412623820;
  a1[27] = (int)a1;
  a1[28] = (int)xmlParserValidityError;
  a1[29] = (int)xmlParserValidityWarning;
  if ( a1[26] )
  {
    a1[29] = xmlGetWarningsDefaultValue != 0 ? (unsigned int)xmlParserValidityWarning : 0;
    a1[32] = 0;
  }
  a1[4] = xmlSubstituteEntitiesDefaultValue;
  a1[17] = 0;
  a1[50] = 0;
  a1[51] = 0;
  a1[54] = 0;
  a1[21] = 0;
  a1[62] = 0;
  a1[64] = 1;
  a1[71] = 0;
  a1[110] = 0;
  a1[116] = 1;
  xmlInitNodeInfoSeq(a1 + 18);
  return 0;
}
// 43F2A1: using guessed type _DWORD __cdecl xmlSAXVersion(_DWORD, _DWORD);
// 43FED0: using guessed type int xmlUnlockLibrary();
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A4B8C: using guessed type int xmlGetWarningsDefaultValue;
// 4A4B94: using guessed type int xmlKeepBlanksDefaultValue;
// 4A4BB8: using guessed type int (__cdecl *xmlDefaultSAXHandler)(int, int, int, int);
// 4A9C84: using guessed type int xmlDoValidityCheckingDefaultValue;
// 4A9C8C: using guessed type int xmlLoadExtDtdDefaultValue;
// 4A9C94: using guessed type int xmlPedanticParserDefaultValue;
// 4A9C9C: using guessed type int xmlLineNumbersDefaultValue;
// 4A9CA4: using guessed type int xmlSubstituteEntitiesDefaultValue;

//----- (00434BCE) --------------------------------------------------------
void __cdecl xmlFreeParserCtxt(_DWORD *Block)
{
  int ***i; // eax
  _DWORD *v2; // eax
  _DWORD *v3; // eax
  int v4; // eax
  int v5; // edi
  int v6; // eax
  int v7; // edi

  if ( Block )
  {
    for ( i = (int ***)inputPop(Block); i; i = (int ***)inputPop(Block) )
      xmlFreeInputStream(i);
    if ( Block[61] )
      ((void (__cdecl *)(_DWORD))xmlFree)(Block[61]);
    if ( Block[49] )
      ((void (__cdecl *)(_DWORD))xmlFree)(Block[49]);
    if ( Block[16] )
      ((void (__cdecl *)(_DWORD))xmlFree)(Block[16]);
    if ( Block[115] )
      ((void (__cdecl *)(_DWORD))xmlFree)(Block[115]);
    if ( Block[12] )
      ((void (__cdecl *)(_DWORD))xmlFree)(Block[12]);
    if ( Block[5] )
      ((void (__cdecl *)(_DWORD))xmlFree)(Block[5]);
    if ( Block[6] )
      ((void (__cdecl *)(_DWORD))xmlFree)(Block[6]);
    if ( Block[56] )
      ((void (__cdecl *)(_DWORD))xmlFree)(Block[56]);
    if ( Block[57] )
      ((void (__cdecl *)(_DWORD))xmlFree)(Block[57]);
    if ( *Block && (int (__cdecl **)(int, int, int, int))*Block != &xmlDefaultSAXHandler )
      ((void (__cdecl *)(_DWORD))xmlFree)(*Block);
    if ( Block[45] )
      ((void (__cdecl *)(_DWORD))xmlFree)(Block[45]);
    if ( Block[33] )
      ((void (__cdecl *)(_DWORD))xmlFree)(Block[33]);
    if ( Block[75] )
      ((void (__cdecl *)(_DWORD))xmlFree)(Block[75]);
    if ( Block[74] )
      xmlDictFree((void **)Block[74]);
    if ( Block[84] )
      ((void (__cdecl *)(_DWORD))xmlFree)(Block[84]);
    if ( Block[86] )
      ((void (__cdecl *)(_DWORD))xmlFree)(Block[86]);
    if ( Block[85] )
      ((void (__cdecl *)(_DWORD))xmlFree)(Block[85]);
    v2 = (_DWORD *)Block[87];
    if ( v2 )
      xmlHashFree(v2, (void (__cdecl *)(int, _DWORD))xmlFree);
    v3 = (_DWORD *)Block[88];
    if ( v3 )
      xmlHashFree(v3, 0);
    v4 = Block[93];
    if ( v4 )
    {
      do
      {
        v5 = *(_DWORD *)(v4 + 24);
        ((void (__cdecl *)(int))xmlFree)(v4);
        v4 = v5;
      }
      while ( v5 );
    }
    v6 = Block[95];
    if ( v6 )
    {
      do
      {
        v7 = *(_DWORD *)(v6 + 24);
        ((void (__cdecl *)(int))xmlFree)(v6);
        v6 = v7;
      }
      while ( v7 );
    }
    if ( Block[98] )
      ((void (__cdecl *)(_DWORD))xmlFree)(Block[98]);
    if ( Block[100] )
      ((void (__cdecl *)(_DWORD))xmlFree)(Block[100]);
    if ( Block[102] )
      ((void (__cdecl *)(_DWORD))xmlFree)(Block[102]);
    if ( Block[103] )
      ((void (__cdecl *)(_DWORD))xmlFree)(Block[103]);
    if ( Block[104] )
      ((void (__cdecl *)(_DWORD))xmlFree)(Block[104]);
    ((void (__cdecl *)(_DWORD *))xmlFree)(Block);
  }
}
// 496494: invalid function type has been ignored
// 4A4BB8: using guessed type int (__cdecl *xmlDefaultSAXHandler)(int, int, int, int);

//----- (00434DE5) --------------------------------------------------------
int *xmlNewParserCtxt()
{
  int *v0; // eax
  int *v1; // esi

  v0 = (int *)xmlMalloc(468);
  v1 = v0;
  if ( !v0 )
  {
    xmlErrMemory(0, "cannot allocate parser context\n");
    return 0;
  }
  memset(v0, 0, 0x1D4u);
  if ( xmlInitParserCtxt(v1) < 0 )
  {
    xmlFreeParserCtxt(v1);
    return 0;
  }
  return v1;
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (00434E2E) --------------------------------------------------------
void __cdecl xmlClearParserCtxt(_DWORD *a1)
{
  if ( a1 )
  {
    xmlClearNodeInfoSeq(a1 + 18);
    xmlCtxtReset(a1);
  }
}

//----- (00434E4A) --------------------------------------------------------
_DWORD *__cdecl xmlParserFindNodeInfo(int a1, unsigned int a2)
{
  unsigned int NodeInfoIndex; // eax
  _DWORD *result; // eax

  if ( !a1 )
    return 0;
  if ( !a2 )
    return 0;
  NodeInfoIndex = xmlParserFindNodeInfoIndex(a1 + 72, a2);
  if ( NodeInfoIndex >= *(_DWORD *)(a1 + 76) )
    return 0;
  result = (_DWORD *)(*(_DWORD *)(a1 + 80) + 20 * NodeInfoIndex);
  if ( *result != a2 )
    return 0;
  return result;
}

//----- (00434E7E) --------------------------------------------------------
_DWORD *__cdecl xmlInitNodeInfoSeq(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  if ( a1 )
  {
    a1[1] = 0;
    *a1 = 0;
    a1[2] = 0;
  }
  return result;
}

//----- (00434E91) --------------------------------------------------------
_DWORD *__cdecl xmlClearNodeInfoSeq(_DWORD *a1)
{
  _DWORD *result; // eax

  if ( a1 )
  {
    if ( a1[2] )
      ((void (__cdecl *)(_DWORD))xmlFree)(a1[2]);
    return xmlInitNodeInfoSeq(a1);
  }
  return result;
}
// 496494: invalid function type has been ignored

//----- (00434EB2) --------------------------------------------------------
int __cdecl xmlParserFindNodeInfoIndex(int a1, unsigned int a2)
{
  int result; // eax
  unsigned int v3; // edx
  unsigned int v4; // edi
  unsigned int v5; // esi
  int v6; // [esp+4h] [ebp-4h]

  result = 0;
  v6 = 0;
  if ( !a1 || !a2 )
    return -1;
  v3 = *(_DWORD *)(a1 + 4);
  v4 = 1;
  if ( v3 )
  {
    do
    {
      if ( v6 )
        break;
      result = v4 + ((v3 - v4) >> 1);
      v5 = *(_DWORD *)(20 * result + *(_DWORD *)(a1 + 8) - 20);
      if ( a2 == v5 )
      {
        v6 = 1;
      }
      else if ( a2 >= v5 )
      {
        v4 = result + 1;
      }
      else
      {
        v3 = result - 1;
      }
    }
    while ( v4 <= v3 );
    if ( result )
    {
      if ( *(_DWORD *)(20 * result + *(_DWORD *)(a1 + 8) - 20) >= a2 )
        --result;
    }
  }
  return result;
}

//----- (00434F2A) --------------------------------------------------------
void __cdecl xmlParserAddNodeInfo(int a1, unsigned int *a2)
{
  unsigned int v3; // edi
  _DWORD *v4; // esi
  unsigned int NodeInfoIndex; // eax
  int v6; // ecx
  _DWORD *v7; // edx
  void *v8; // ecx
  int v9; // eax
  unsigned int v10; // ecx
  int v11; // edx
  char *v12; // edi
  bool v13; // zf
  SIZE_T v14; // [esp-Ch] [ebp-10h]
  int v15; // [esp+Ch] [ebp+8h]
  int v16; // [esp+Ch] [ebp+8h]

  if ( a1 && a2 )
  {
    v3 = *a2;
    v4 = (_DWORD *)(a1 + 72);
    NodeInfoIndex = xmlParserFindNodeInfoIndex(a1 + 72, *a2);
    v15 = NodeInfoIndex;
    if ( NodeInfoIndex < *(_DWORD *)(a1 + 76) )
    {
      v6 = *(_DWORD *)(a1 + 80);
      if ( v6 )
      {
        v7 = (_DWORD *)(v6 + 20 * NodeInfoIndex);
        if ( *v7 == v3 )
        {
          qmemcpy(v7, a2, 0x14u);
          return;
        }
      }
    }
    if ( (unsigned int)(*(_DWORD *)(a1 + 76) + 1) > *v4 )
    {
      if ( !*v4 )
        *v4 = 2;
      v8 = *(void **)(a1 + 80);
      v14 = 40 * *v4;
      if ( v8 )
        v9 = xmlRealloc(v8, v14);
      else
        v9 = xmlMalloc(v14);
      if ( !v9 )
      {
        xmlErrMemory(a1, "failed to allocate buffer\n");
        return;
      }
      *v4 *= 2;
      *(_DWORD *)(a1 + 80) = v9;
      NodeInfoIndex = v15;
    }
    v10 = *(_DWORD *)(a1 + 76);
    if ( v10 > NodeInfoIndex )
    {
      v11 = 20 * v10;
      v16 = v10 - NodeInfoIndex;
      do
      {
        v12 = (char *)(v11 + *(_DWORD *)(a1 + 80));
        v11 -= 20;
        v13 = v16-- == 1;
        qmemcpy(v12, v12 - 20, 0x14u);
      }
      while ( !v13 );
    }
    qmemcpy((void *)(20 * NodeInfoIndex + *(_DWORD *)(a1 + 80)), a2, 0x14u);
    ++*(_DWORD *)(a1 + 76);
  }
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);

//----- (00435009) --------------------------------------------------------
int __cdecl xmlPedanticParserDefault(int a1)
{
  int result; // eax

  result = xmlPedanticParserDefaultValue;
  xmlPedanticParserDefaultValue = a1;
  return result;
}
// 4A9C94: using guessed type int xmlPedanticParserDefaultValue;

//----- (00435019) --------------------------------------------------------
int __cdecl xmlLineNumbersDefault(int a1)
{
  int result; // eax

  result = xmlLineNumbersDefaultValue;
  xmlLineNumbersDefaultValue = a1;
  return result;
}
// 4A9C9C: using guessed type int xmlLineNumbersDefaultValue;

//----- (00435029) --------------------------------------------------------
int __cdecl xmlSubstituteEntitiesDefault(int a1)
{
  int result; // eax

  result = xmlSubstituteEntitiesDefaultValue;
  xmlSubstituteEntitiesDefaultValue = a1;
  return result;
}
// 4A9CA4: using guessed type int xmlSubstituteEntitiesDefaultValue;

//----- (00435039) --------------------------------------------------------
int __cdecl xmlKeepBlanksDefault(int a1)
{
  int result; // eax

  result = xmlKeepBlanksDefaultValue;
  xmlKeepBlanksDefaultValue = a1;
  if ( !a1 )
    xmlIndentTreeOutput = 1;
  return result;
}
// 4A4B94: using guessed type int xmlKeepBlanksDefaultValue;
// 4A4BA4: using guessed type int xmlIndentTreeOutput;

//----- (00435057) --------------------------------------------------------
int __usercall sub_435057@<eax>(_BYTE *a1@<eax>, char *a2@<ecx>, int a3, _BYTE *a4)
{
  unsigned int v5; // eax
  _BYTE *v6; // edi
  char v7; // dl
  int v8; // edi
  int v9; // edx
  int v10; // edx

  v5 = 0;
  v6 = a4;
  if ( a2 )
  {
    v7 = *a2;
    v5 = 30 * (unsigned __int8)*a2;
    if ( *a2 )
    {
      do
      {
        ++a2;
        v8 = v7 + (v5 >> 3) + 32 * v5;
        v7 = *a2;
        v5 ^= v8;
      }
      while ( *a2 );
      v6 = a4;
    }
  }
  if ( a1 )
  {
    while ( *a1 )
    {
      v9 = (char)*a1++ + (v5 >> 3) + 32 * v5;
      v5 ^= v9;
    }
  }
  if ( v6 )
  {
    while ( *v6 )
    {
      v10 = (char)*v6++ + (v5 >> 3) + 32 * v5;
      v5 ^= v10;
    }
  }
  return v5 % *(_DWORD *)(a3 + 4);
}

//----- (004350DF) --------------------------------------------------------
int __usercall sub_4350DF@<eax>(
        unsigned __int8 *a1@<eax>,
        char *a2@<ecx>,
        int a3,
        _BYTE *a4,
        _BYTE *a5,
        _BYTE *a6,
        _BYTE *a7)
{
  _BYTE *v7; // edi
  _BYTE *v8; // esi
  int v9; // eax
  unsigned int v10; // eax
  char v11; // dl
  int v12; // edi
  int v13; // edx
  int v14; // edx
  _BYTE *v15; // edx
  int v16; // esi
  _BYTE *v17; // edx
  int v18; // esi
  _BYTE *v19; // edx
  int v20; // esi

  v7 = a4;
  v8 = a1;
  if ( a2 )
    v9 = (unsigned __int8)*a2;
  else
    v9 = *a1;
  v10 = 30 * v9;
  if ( a2 )
  {
    v11 = *a2;
    if ( *a2 )
    {
      do
      {
        ++a2;
        v12 = v11 + (v10 >> 3) + 32 * v10;
        v11 = *a2;
        v10 ^= v12;
      }
      while ( *a2 );
      v7 = a4;
    }
    v10 ^= 32 * v10 + (v10 >> 3) + 58;
  }
  if ( v8 )
  {
    while ( *v8 )
    {
      v13 = (char)*v8++ + (v10 >> 3) + 32 * v10;
      v10 ^= v13;
    }
  }
  if ( v7 )
  {
    while ( *v7 )
    {
      v14 = (char)*v7++ + (v10 >> 3) + 32 * v10;
      v10 ^= v14;
    }
    v10 ^= 32 * v10 + (v10 >> 3) + 58;
  }
  v15 = a5;
  if ( a5 )
  {
    while ( *v15 )
    {
      v16 = (char)*v15++ + (v10 >> 3) + 32 * v10;
      v10 ^= v16;
    }
  }
  v17 = a6;
  if ( a6 )
  {
    while ( *v17 )
    {
      v18 = (char)*v17++ + (v10 >> 3) + 32 * v10;
      v10 ^= v18;
    }
    v10 ^= 32 * v10 + (v10 >> 3) + 58;
  }
  v19 = a7;
  if ( a7 )
  {
    while ( *v19 )
    {
      v20 = (char)*v19++ + (v10 >> 3) + 32 * v10;
      v10 ^= v20;
    }
  }
  return v10 % *(_DWORD *)(a3 + 4);
}

//----- (00435206) --------------------------------------------------------
_DWORD *__cdecl xmlHashCreate(int a1)
{
  int v1; // edi
  _DWORD *v2; // eax
  _DWORD *v3; // esi
  size_t v4; // edi
  void *v5; // eax

  v1 = a1;
  if ( a1 <= 0 )
    v1 = 256;
  v2 = (_DWORD *)xmlMalloc(16);
  v3 = v2;
  if ( v2 )
  {
    v2[3] = 0;
    v2[2] = 0;
    v2[1] = v1;
    v4 = 24 * v1;
    v5 = (void *)xmlMalloc(v4);
    *v3 = v5;
    if ( v5 )
    {
      memset(v5, 0, v4);
      return v3;
    }
    ((void (__cdecl *)(_DWORD *))xmlFree)(v3);
  }
  return 0;
}
// 496494: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (0043525D) --------------------------------------------------------
_DWORD *__cdecl xmlHashCreateDict(int a1, _DWORD *a2)
{
  _DWORD *v2; // esi

  v2 = xmlHashCreate(a1);
  if ( v2 )
  {
    v2[3] = a2;
    xmlDictReference(a2);
  }
  return v2;
}

//----- (00435280) --------------------------------------------------------
int __usercall sub_435280@<eax>(int a1@<eax>, void ***a2@<ebx>)
{
  void **v4; // eax
  char *v5; // esi
  int v6; // eax
  bool v7; // zf
  _BYTE **v8; // esi
  _BYTE *v9; // edi
  int v10; // eax
  void **v11; // edx
  _BYTE *v12; // [esp+4h] [ebp-14h]
  int v13; // [esp+8h] [ebp-10h]
  char *v14; // [esp+Ch] [ebp-Ch]
  void **v15; // [esp+Ch] [ebp-Ch]
  char *Block; // [esp+10h] [ebp-8h]
  void *Blocka; // [esp+10h] [ebp-8h]
  void **v18; // [esp+14h] [ebp-4h]

  if ( !a2 )
    return -1;
  if ( a1 < 8 )
    return -1;
  if ( a1 > 0x4000 )
    return -1;
  v13 = (int)a2[1];
  v18 = *a2;
  if ( !*a2 )
    return -1;
  v4 = (void **)xmlMalloc(24 * a1);
  *a2 = v4;
  if ( v4 )
  {
    memset(v4, 0, 24 * a1);
    a2[1] = (void **)a1;
    if ( v13 > 0 )
    {
      v5 = (char *)(v18 + 3);
      v14 = (char *)(v18 + 3);
      Block = (char *)v13;
      do
      {
        if ( *((_DWORD *)v5 + 2) )
        {
          v6 = 6 * sub_435057(*((_BYTE **)v5 - 1), *((char **)v5 - 2), (int)a2, *(_BYTE **)v5);
          qmemcpy(&(*a2)[v6], v5 - 12, 0x18u);
          (*a2)[v6] = 0;
          v5 = v14;
        }
        v5 += 24;
        v7 = Block-- == (char *)1;
        v14 = v5;
      }
      while ( !v7 );
      v15 = v18;
      do
      {
        v8 = (_BYTE **)*v15;
        Blocka = *v15;
        if ( *v15 )
        {
          while ( 1 )
          {
            v9 = *v8;
            v12 = *v8;
            v10 = 6 * sub_435057(v8[2], v8[1], (int)a2, v8[3]);
            v11 = &(*a2)[v10];
            if ( v11[5] )
            {
              *v8 = *v11;
              (*a2)[v10] = v8;
            }
            else
            {
              qmemcpy(v11, v8, 0x18u);
              (*a2)[v10] = 0;
              ((void (__cdecl *)(void *))xmlFree)(Blocka);
              v9 = v12;
            }
            Blocka = v9;
            if ( !v9 )
              break;
            v8 = (_BYTE **)v9;
          }
        }
        v15 += 6;
        --v13;
      }
      while ( v13 );
    }
    ((void (__cdecl *)(void **))xmlFree)(v18);
    return 0;
  }
  else
  {
    *a2 = v18;
    return -1;
  }
}
// 496494: invalid function type has been ignored
// 435336: conditional instruction was optimized away because %var_10.4>=1
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (004353BB) --------------------------------------------------------
void __cdecl xmlHashFree(_DWORD *Block, void (__cdecl *a2)(int, _DWORD))
{
  bool v3; // cc
  _DWORD *v4; // esi
  int v5; // eax
  _DWORD *v6; // [esp+8h] [ebp-10h]
  int v7; // [esp+Ch] [ebp-Ch]
  int v8; // [esp+10h] [ebp-8h]
  int v9; // [esp+14h] [ebp-4h]
  char *Blocka; // [esp+20h] [ebp+8h]

  if ( Block )
  {
    if ( *Block )
    {
      v3 = Block[1] <= 0;
      Blocka = (char *)Block[2];
      v8 = 0;
      if ( !v3 )
      {
        v9 = 0;
        do
        {
          if ( (int)Blocka <= 0 )
            break;
          v4 = (_DWORD *)(v9 + *Block);
          if ( v4[5] )
          {
            v7 = 1;
            do
            {
              v6 = (_DWORD *)*v4;
              if ( a2 )
              {
                v5 = v4[4];
                if ( v5 )
                  a2(v5, v4[1]);
              }
              if ( !Block[3] )
              {
                if ( v4[1] )
                  ((void (__cdecl *)(_DWORD))xmlFree)(v4[1]);
                if ( v4[2] )
                  ((void (__cdecl *)(_DWORD))xmlFree)(v4[2]);
                if ( v4[3] )
                  ((void (__cdecl *)(_DWORD))xmlFree)(v4[3]);
              }
              v4[4] = 0;
              if ( !v7 )
                ((void (__cdecl *)(_DWORD *))xmlFree)(v4);
              v4 = v6;
              --Blocka;
              v7 = 0;
            }
            while ( v6 );
          }
          ++v8;
          v9 += 24;
        }
        while ( v8 < Block[1] );
      }
      ((void (__cdecl *)(_DWORD))xmlFree)(*Block);
    }
    if ( Block[3] )
      xmlDictFree((void **)Block[3]);
    ((void (__cdecl *)(_DWORD *))xmlFree)(Block);
  }
}
// 496494: invalid function type has been ignored

//----- (004354A8) --------------------------------------------------------
int __cdecl xmlHashAddEntry(void ***a1, unsigned __int8 *Src, void *a3)
{
  return xmlHashAddEntry3(a1, Src, 0, 0, a3);
}

//----- (004354C1) --------------------------------------------------------
int __cdecl xmlHashAddEntry2(void ***a1, unsigned __int8 *Src, unsigned __int8 *a3, void *a4)
{
  return xmlHashAddEntry3(a1, Src, a3, 0, a4);
}

//----- (004354DC) --------------------------------------------------------
int __cdecl xmlHashUpdateEntry(_DWORD *a1, unsigned __int8 *Src, int a3, void (__cdecl *a4)(_DWORD, char *))
{
  return xmlHashUpdateEntry3(a1, Src, 0, 0, a3, a4);
}

//----- (004354F9) --------------------------------------------------------
int __cdecl xmlHashUpdateEntry2(
        _DWORD *a1,
        unsigned __int8 *Src,
        unsigned __int8 *a3,
        int a4,
        void (__cdecl *a5)(_DWORD, char *))
{
  return xmlHashUpdateEntry3(a1, Src, a3, 0, a4, a5);
}

//----- (00435517) --------------------------------------------------------
int __cdecl xmlHashLookup(_DWORD *a1, char *a2)
{
  return xmlHashLookup3(a1, a2, 0, 0);
}

//----- (0043552C) --------------------------------------------------------
int __cdecl xmlHashLookup2(_DWORD *a1, char *a2, char *a3)
{
  return xmlHashLookup3(a1, a2, a3, 0);
}

//----- (00435543) --------------------------------------------------------
int __cdecl xmlHashQLookup(_DWORD *a1, char *a2, unsigned __int8 *a3)
{
  return xmlHashQLookup3(a1, a2, a3, 0, 0, 0, 0);
}

//----- (0043555E) --------------------------------------------------------
int __cdecl xmlHashQLookup2(_DWORD *a1, char *a2, unsigned __int8 *a3, char *a4, char *a5)
{
  return xmlHashQLookup3(a1, a2, a3, a4, a5, 0, 0);
}

//----- (0043557E) --------------------------------------------------------
int __cdecl xmlHashAddEntry3(void ***a1, unsigned __int8 *Src, unsigned __int8 *a3, char *a4, void *a5)
{
  void **v5; // esi
  void **v6; // esi
  unsigned __int8 *v7; // ebx
  void **v8; // esi
  void **v10; // edi
  _DWORD *v11; // esi
  _DWORD *v12; // edi
  int v13; // eax
  void ***v14; // ecx
  _BYTE *v15; // eax
  unsigned int v16; // [esp+Ch] [ebp-4h]

  v16 = 0;
  if ( !a1 || !Src )
    return -1;
  v5 = a1[3];
  if ( v5 )
  {
    if ( !xmlDictOwns((int)v5, (unsigned int)Src) )
    {
      Src = xmlDictLookup(v5, (char *)Src, -1);
      if ( !Src )
        return -1;
    }
    if ( a3 )
    {
      v6 = a1[3];
      if ( !xmlDictOwns((int)v6, (unsigned int)a3) )
      {
        a3 = xmlDictLookup(v6, (char *)a3, -1);
        if ( !a3 )
          return -1;
      }
    }
    v7 = (unsigned __int8 *)a4;
    if ( a4 )
    {
      v8 = a1[3];
      if ( !xmlDictOwns((int)v8, (unsigned int)a4) )
      {
        v7 = xmlDictLookup(v8, a4, -1);
        if ( !v7 )
          return -1;
      }
    }
  }
  else
  {
    v7 = (unsigned __int8 *)a4;
  }
  v10 = &(*a1)[6 * sub_435057(a3, (char *)Src, (int)a1, v7)];
  if ( !v10[5] )
  {
    v11 = 0;
    goto LABEL_36;
  }
  v11 = v10;
  if ( a1[3] )
  {
    while ( *v11 )
    {
      if ( (unsigned __int8 *)v11[1] == Src && (unsigned __int8 *)v11[2] == a3 && (unsigned __int8 *)v11[3] == v7 )
        return -1;
      ++v16;
      v11 = (_DWORD *)*v11;
    }
    if ( (unsigned __int8 *)v11[1] == Src && (unsigned __int8 *)v11[2] == a3 && (unsigned __int8 *)v11[3] == v7 )
      return -1;
  }
  else
  {
    while ( 1 )
    {
      v12 = (_DWORD *)*v11;
      v13 = xmlStrEqual((char *)v11[1], (char *)Src);
      if ( !v12 )
        break;
      if ( v13 && xmlStrEqual((char *)v11[2], (char *)a3) && xmlStrEqual((char *)v11[3], (char *)v7) )
        return -1;
      ++v16;
      v11 = v12;
    }
    if ( v13 && xmlStrEqual((char *)v11[2], (char *)a3) && xmlStrEqual((char *)v11[3], (char *)v7) )
      return -1;
  }
  v10 = (void **)xmlMalloc(24);
  if ( !v10 )
    return -1;
LABEL_36:
  v14 = a1;
  if ( a1[3] )
  {
    v10[1] = Src;
    v10[2] = a3;
    v10[3] = v7;
  }
  else
  {
    v10[1] = xmlStrdup(Src);
    v10[2] = xmlStrdup(a3);
    v15 = xmlStrdup(v7);
    v14 = a1;
    v10[3] = v15;
  }
  *v10 = 0;
  v10[4] = a5;
  v10[5] = (void *)1;
  if ( v11 )
    *v11 = v10;
  v14[2] = (void **)((char *)v14[2] + 1);
  if ( v16 > 8 )
    sub_435280(8 * (_DWORD)v14[1], v14);
  return 0;
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (00435782) --------------------------------------------------------
int __cdecl xmlHashUpdateEntry3(
        _DWORD *a1,
        unsigned __int8 *Src,
        unsigned __int8 *a3,
        unsigned __int8 *a4,
        int a5,
        void (__cdecl *a6)(_DWORD, char *))
{
  _DWORD *v6; // esi
  _DWORD *v7; // esi
  _DWORD *v8; // esi
  int v9; // eax
  _DWORD *v10; // edi
  int v11; // esi
  bool v12; // zf
  char *v14; // edi
  unsigned __int8 *v15; // eax

  if ( a1 && Src )
  {
    v6 = (_DWORD *)a1[3];
    if ( !v6
      || (xmlDictOwns((int)v6, (unsigned int)Src) || (Src = xmlDictLookup(v6, (char *)Src, -1)) != 0)
      && (!a3
       || (v7 = (_DWORD *)a1[3], xmlDictOwns((int)v7, (unsigned int)a3))
       || (a3 = xmlDictLookup(v7, (char *)a3, -1)) != 0)
      && (!a4
       || (v8 = (_DWORD *)a1[3], xmlDictOwns((int)v8, (unsigned int)a4))
       || (a4 = xmlDictLookup(v8, (char *)a4, -1)) != 0) )
    {
      v9 = 24 * sub_435057(a3, (char *)Src, (int)a1, a4);
      v10 = (_DWORD *)(v9 + *a1);
      v11 = 0;
      if ( !v10[5] )
        goto LABEL_51;
      v11 = v9 + *a1;
      if ( !a1[3] )
      {
        while ( 1 )
        {
          if ( !*(_DWORD *)v11 )
          {
            v14 = *(char **)(v11 + 4);
            if ( !xmlStrEqual(v14, (char *)Src)
              || !xmlStrEqual(*(char **)(v11 + 8), (char *)a3)
              || !xmlStrEqual(*(char **)(v11 + 12), (char *)a4) )
            {
              goto LABEL_42;
            }
            if ( a6 )
              a6(*(_DWORD *)(v11 + 16), v14);
            goto LABEL_28;
          }
          if ( xmlStrEqual(*(char **)(v11 + 4), (char *)Src)
            && xmlStrEqual(*(char **)(v11 + 8), (char *)a3)
            && xmlStrEqual(*(char **)(v11 + 12), (char *)a4) )
          {
            break;
          }
          v11 = *(_DWORD *)v11;
        }
        v12 = a6 == 0;
LABEL_26:
        if ( v12 )
          goto LABEL_28;
        goto LABEL_27;
      }
      while ( *(_DWORD *)v11 )
      {
        if ( *(unsigned __int8 **)(v11 + 4) == Src
          && *(unsigned __int8 **)(v11 + 8) == a3
          && *(unsigned __int8 **)(v11 + 12) == a4 )
        {
          v12 = a6 == 0;
          goto LABEL_26;
        }
        v11 = *(_DWORD *)v11;
      }
      if ( *(unsigned __int8 **)(v11 + 4) == Src
        && *(unsigned __int8 **)(v11 + 8) == a3
        && *(unsigned __int8 **)(v11 + 12) == a4 )
      {
        if ( !a6 )
          goto LABEL_28;
LABEL_27:
        a6(*(_DWORD *)(v11 + 16), *(char **)(v11 + 4));
LABEL_28:
        *(_DWORD *)(v11 + 16) = a5;
        return 0;
      }
LABEL_42:
      v10 = (_DWORD *)xmlMalloc(24);
      if ( v10 )
      {
LABEL_51:
        if ( a1[3] )
        {
          v10[1] = Src;
          v10[2] = a3;
          v15 = a4;
        }
        else
        {
          v10[1] = xmlStrdup(Src);
          v10[2] = xmlStrdup(a3);
          v15 = xmlStrdup(a4);
        }
        *v10 = 0;
        v10[3] = v15;
        v10[4] = a5;
        v10[5] = 1;
        ++a1[2];
        if ( v11 )
          *(_DWORD *)v11 = v10;
        return 0;
      }
    }
  }
  return -1;
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (004359C4) --------------------------------------------------------
int __cdecl xmlHashLookup3(_DWORD *a1, char *a2, char *a3, char *a4)
{
  int v5; // eax
  int v6; // esi
  _DWORD *i; // eax

  if ( !a1 )
    return 0;
  if ( !a2 )
    return 0;
  v5 = 24 * sub_435057(a3, a2, (int)a1, a4);
  v6 = v5 + *a1;
  if ( *(_DWORD *)(v6 + 20) )
  {
    if ( !a1[3] )
      goto LABEL_19;
    for ( i = (_DWORD *)(v5 + *a1); i; i = (_DWORD *)*i )
    {
      if ( (char *)i[1] == a2 && (char *)i[2] == a3 && (char *)i[3] == a4 )
        return i[4];
    }
LABEL_19:
    while ( v6 )
    {
      if ( xmlStrEqual(*(char **)(v6 + 4), a2)
        && xmlStrEqual(*(char **)(v6 + 8), a3)
        && xmlStrEqual(*(char **)(v6 + 12), a4) )
      {
        return *(_DWORD *)(v6 + 16);
      }
      v6 = *(_DWORD *)v6;
    }
  }
  return 0;
}

//----- (00435A73) --------------------------------------------------------
int __cdecl xmlHashQLookup3(_DWORD *a1, char *a2, unsigned __int8 *a3, char *a4, char *a5, char *a6, char *a7)
{
  int v7; // eax
  int i; // esi

  if ( a1 )
  {
    if ( a3 )
    {
      v7 = *a1 + 24 * sub_4350DF(a3, a2, (int)a1, a4, a5, a6, a7);
      if ( *(_DWORD *)(v7 + 20) )
      {
        for ( i = v7; i; i = *(_DWORD *)i )
        {
          if ( xmlStrQEqual(a2, (char *)a3, *(char **)(i + 4))
            && xmlStrQEqual(a4, a5, *(char **)(i + 8))
            && xmlStrQEqual(a6, a7, *(char **)(i + 12)) )
          {
            return *(_DWORD *)(i + 16);
          }
        }
      }
    }
  }
  return 0;
}

//----- (00435AFF) --------------------------------------------------------
int __cdecl sub_435AFF(int a1, int a2, int a3)
{
  return (*(int (__cdecl **)(int, _DWORD, int))a2)(a1, *(_DWORD *)(a2 + 4), a3);
}

//----- (00435B14) --------------------------------------------------------
void __cdecl xmlHashScan(_DWORD *a1, int a2, int a3)
{
  int v3[2]; // [esp+0h] [ebp-8h] BYREF

  v3[1] = a3;
  v3[0] = a2;
  xmlHashScanFull(a1, (void (__cdecl *)(int, int, _DWORD, _DWORD, _DWORD))sub_435AFF, (int)v3);
}

//----- (00435B3B) --------------------------------------------------------
void __cdecl xmlHashScanFull(_DWORD *a1, void (__cdecl *a2)(int, int, _DWORD, _DWORD, _DWORD), int a3)
{
  _DWORD *v4; // esi
  int v5; // eax
  _DWORD *v6; // ecx
  int v7; // ebx
  _DWORD *v8; // eax
  _DWORD *v9; // [esp+4h] [ebp-8h]
  int v10; // [esp+8h] [ebp-4h]
  int v11; // [esp+14h] [ebp+8h]

  if ( a1 )
  {
    if ( a2 )
    {
      if ( *a1 )
      {
        v10 = 0;
        if ( (int)a1[1] > 0 )
        {
          v11 = 0;
          do
          {
            v4 = (_DWORD *)(*a1 + v11);
            if ( v4[5] )
            {
              while ( v4 )
              {
                v5 = v4[4];
                v6 = (_DWORD *)*v4;
                v7 = a1[2];
                v9 = (_DWORD *)*v4;
                if ( v5 )
                {
                  a2(v5, a3, v4[1], v4[2], v4[3]);
                  v6 = v9;
                }
                if ( v7 == a1[2] || (v8 = (_DWORD *)(v11 + *a1), v4 != v8) )
                {
                  v4 = v6;
                }
                else
                {
                  if ( !v8[5] )
                    v4 = 0;
                  if ( (_DWORD *)*v8 != v6 )
                    v4 = (_DWORD *)(v11 + *a1);
                }
              }
            }
            ++v10;
            v11 += 24;
          }
          while ( v10 < a1[1] );
        }
      }
    }
  }
}

//----- (00435BD3) --------------------------------------------------------
int __cdecl xmlHashScan3(_DWORD *a1, char *a2, char *a3, char *a4, void (__cdecl *a5)(int, int, int, int, int), int a6)
{
  return xmlHashScanFull3(a1, a2, a3, a4, a5, a6);
}

//----- (00435BDC) --------------------------------------------------------
int __cdecl xmlHashScanFull3(
        _DWORD *a1,
        char *a2,
        char *a3,
        char *a4,
        void (__cdecl *a5)(int, int, int, int, int),
        int a6)
{
  int result; // eax
  int **v8; // esi
  int *v9; // ebx
  int *v10; // eax
  int v11; // [esp+4h] [ebp-4h]
  int v12; // [esp+10h] [ebp+8h]

  result = 0;
  if ( a1 )
  {
    if ( a5 )
    {
      if ( *a1 )
      {
        v11 = 0;
        if ( (int)a1[1] > 0 )
        {
          v12 = 0;
          do
          {
            v8 = (int **)(*a1 + v12);
            if ( v8[5] && v8 )
            {
              do
              {
                v9 = *v8;
                if ( (!a2 || xmlStrEqual(a2, (char *)v8[1]))
                  && (!a3 || xmlStrEqual(a3, (char *)v8[2]))
                  && (!a4 || xmlStrEqual(a4, (char *)v8[3])) )
                {
                  v10 = v8[4];
                  if ( v10 )
                    a5((int)v10, a6, (int)v8[1], (int)v8[2], (int)v8[3]);
                }
                result = 0;
                v8 = (int **)v9;
              }
              while ( v9 );
            }
            ++v11;
            v12 += 24;
          }
          while ( v11 < a1[1] );
        }
      }
    }
  }
  return result;
}

//----- (00435CA1) --------------------------------------------------------
void ***__cdecl xmlHashCopy(_DWORD *a1, int (__cdecl *a2)(int, int))
{
  int *v3; // ebx
  void ***result; // eax
  int *v5; // esi
  void *v6; // eax
  void ***v7; // [esp+8h] [ebp-8h]
  int v8; // [esp+Ch] [ebp-4h]
  int v9; // [esp+18h] [ebp+8h]

  v3 = 0;
  if ( !a1 || !a2 )
    return 0;
  v7 = (void ***)xmlHashCreate(a1[1]);
  if ( *a1 )
  {
    v8 = 0;
    if ( (int)a1[1] > 0 )
    {
      v9 = 0;
      do
      {
        v5 = (int *)(*a1 + v9);
        if ( (int *)v5[5] != v3 && v5 != v3 )
        {
          do
          {
            v3 = (int *)*v5;
            v6 = (void *)a2(v5[4], v5[1]);
            xmlHashAddEntry3(v7, (unsigned __int8 *)v5[1], (unsigned __int8 *)v5[2], (char *)v5[3], v6);
            v5 = v3;
          }
          while ( v3 );
        }
        ++v8;
        v9 += 24;
      }
      while ( v8 < a1[1] );
    }
  }
  result = v7;
  v7[2] = (void **)a1[2];
  return result;
}

//----- (00435D2A) --------------------------------------------------------
int __cdecl xmlHashSize(int a1)
{
  if ( a1 )
    return *(_DWORD *)(a1 + 8);
  else
    return -1;
}

//----- (00435D3A) --------------------------------------------------------
int __cdecl xmlHashRemoveEntry(_DWORD *a1, char *a2, void (__cdecl *a3)(int, _DWORD))
{
  return xmlHashRemoveEntry3(a1, a2, 0, 0, a3);
}

//----- (00435D53) --------------------------------------------------------
int __cdecl xmlHashRemoveEntry2(_DWORD *a1, char *a2, char *a3, void (__cdecl *a4)(int, _DWORD))
{
  return xmlHashRemoveEntry3(a1, a2, a3, 0, a4);
}

//----- (00435D6E) --------------------------------------------------------
int __cdecl xmlHashRemoveEntry3(_DWORD *a1, char *a2, char *a3, char *a4, void (__cdecl *a5)(int, _DWORD))
{
  _DWORD *v5; // edi
  int v6; // ebx
  int v7; // esi
  int v9; // eax
  int v10; // [esp-4h] [ebp-14h]
  _DWORD *v11; // [esp+Ch] [ebp-4h]

  v11 = 0;
  v5 = a1;
  if ( a1 )
  {
    if ( a2 )
    {
      v6 = 24 * sub_435057(a3, a2, (int)a1, a4);
      v7 = *a1 + v6;
      if ( *(_DWORD *)(v7 + 20) )
      {
        while ( v7 )
        {
          if ( xmlStrEqual(*(char **)(v7 + 4), a2)
            && xmlStrEqual(*(char **)(v7 + 8), a3)
            && xmlStrEqual(*(char **)(v7 + 12), a4) )
          {
            if ( a5 )
            {
              v9 = *(_DWORD *)(v7 + 16);
              if ( v9 )
                a5(v9, *(_DWORD *)(v7 + 4));
            }
            *(_DWORD *)(v7 + 16) = 0;
            if ( !a1[3] )
            {
              if ( *(_DWORD *)(v7 + 4) )
                ((void (__cdecl *)(_DWORD))xmlFree)(*(_DWORD *)(v7 + 4));
              if ( *(_DWORD *)(v7 + 8) )
                ((void (__cdecl *)(_DWORD))xmlFree)(*(_DWORD *)(v7 + 8));
              if ( *(_DWORD *)(v7 + 12) )
                ((void (__cdecl *)(_DWORD))xmlFree)(*(_DWORD *)(v7 + 12));
            }
            if ( v11 )
            {
              *v11 = *(_DWORD *)v7;
              ((void (__cdecl *)(int))xmlFree)(v7);
            }
            else if ( *(_DWORD *)v7 )
            {
              v10 = *(_DWORD *)v7;
              qmemcpy((void *)(v6 + *a1), *(const void **)v7, 0x18u);
              ((void (__cdecl *)(int))xmlFree)(v10);
              v5 = a1;
            }
            else
            {
              *(_DWORD *)(v7 + 20) = 0;
            }
            --v5[2];
            return 0;
          }
          v11 = (_DWORD *)v7;
          v7 = *(_DWORD *)v7;
        }
      }
    }
  }
  return -1;
}
// 496494: invalid function type has been ignored

//----- (00435E79) --------------------------------------------------------
int __usercall sub_435E79@<eax>(_DWORD *a1@<ebx>, void **a2@<edi>)
{
  char *v3; // esi
  char v4; // al
  char v5; // al

  if ( !a2 )
    return -1;
  v3 = (char *)*a2;
  v4 = *(_BYTE *)*a2;
  if ( (v4 < 97 || v4 > 122) && (v4 < 65 || v4 > 90) )
    return 2;
  do
  {
    do
      v5 = *++v3;
    while ( *v3 >= 97 && v5 <= 122 );
  }
  while ( v5 >= 65 && v5 <= 90 || v5 >= 48 && v5 <= 57 || v5 == 43 || v5 == 45 || v5 == 46 );
  if ( a1 )
  {
    if ( *a1 )
      ((void (__cdecl *)(_DWORD))xmlFree)(*a1);
    *a1 = xmlStrndup(*a2, v3 - (_BYTE *)*a2);
  }
  *a2 = v3;
  return 0;
}
// 496494: invalid function type has been ignored

//----- (00435EEB) --------------------------------------------------------
int __usercall sub_435EEB@<eax>(char **a1@<ebx>, int a2@<edi>)
{
  char *v3; // esi
  char v4; // cl
  char v5; // al
  char v6; // al
  char *v7; // eax
  _BYTE *v8; // eax

  if ( !a1 )
    return -1;
  v3 = *a1;
  while ( 1 )
  {
    v4 = *v3;
    if ( (*v3 < 97 || v4 > 122)
      && (v4 < 65 || v4 > 90)
      && (v4 < 48 || v4 > 57)
      && v4 != 45
      && v4 != 46
      && v4 != 95
      && v4 != 126 )
    {
      if ( v4 != 37
        || ((v5 = v3[1], v5 < 48) || v5 > 57) && (v5 < 97 || v5 > 102) && (v5 < 65 || v5 > 70)
        || ((v6 = v3[2], v6 < 48) || v6 > 57) && (v6 < 97 || v6 > 102) && (v6 < 65 || v6 > 70) )
      {
        if ( v4 != 33
          && v4 != 36
          && v4 != 38
          && v4 != 40
          && v4 != 41
          && v4 != 42
          && v4 != 43
          && v4 != 44
          && v4 != 59
          && v4 != 61
          && v4 != 39
          && v4 != 58
          && v4 != 64
          && v4 != 47
          && v4 != 63
          && v4 != 91
          && v4 != 93 )
        {
          if ( !a2 )
            goto LABEL_61;
          if ( (*(_BYTE *)(a2 + 36) & 1) == 0 || v4 != 123 && v4 != 125 && v4 != 124 && v4 != 92 && v4 != 94 && v4 != 96 )
            break;
        }
      }
    }
    if ( v4 == 37 )
      v3 += 3;
    else
      ++v3;
  }
  if ( *(_DWORD *)(a2 + 32) )
    ((void (__cdecl *)(_DWORD))xmlFree)(*(_DWORD *)(a2 + 32));
  v7 = *a1;
  if ( (*(_BYTE *)(a2 + 36) & 2) != 0 )
    v8 = xmlStrndup(v7, v3 - *a1);
  else
    v8 = (_BYTE *)xmlURIUnescapeString(v7, v3 - *a1, 0);
  *(_DWORD *)(a2 + 32) = v8;
LABEL_61:
  *a1 = v3;
  return 0;
}
// 496494: invalid function type has been ignored

//----- (00436054) --------------------------------------------------------
int __usercall sub_436054@<eax>(void **a1@<ebx>, int a2@<esi>)
{
  char *v3; // edi
  char v4; // cl
  char v5; // al
  char v6; // al
  void *v7; // eax
  _BYTE *v8; // eax

  if ( !a1 )
    return -1;
  v3 = (char *)*a1;
  while ( 1 )
  {
    v4 = *v3;
    if ( (*v3 < 97 || v4 > 122)
      && (v4 < 65 || v4 > 90)
      && (v4 < 48 || v4 > 57)
      && v4 != 45
      && v4 != 46
      && v4 != 95
      && v4 != 126 )
    {
      if ( v4 != 37
        || ((v5 = v3[1], v5 < 48) || v5 > 57) && (v5 < 97 || v5 > 102) && (v5 < 65 || v5 > 70)
        || ((v6 = v3[2], v6 < 48) || v6 > 57) && (v6 < 97 || v6 > 102) && (v6 < 65 || v6 > 70) )
      {
        if ( v4 != 33
          && v4 != 36
          && v4 != 38
          && v4 != 40
          && v4 != 41
          && v4 != 42
          && v4 != 43
          && v4 != 44
          && v4 != 59
          && v4 != 61
          && v4 != 39
          && v4 != 58
          && v4 != 64
          && v4 != 47
          && v4 != 63 )
        {
          if ( !a2 )
            goto LABEL_63;
          if ( (*(_BYTE *)(a2 + 36) & 1) == 0
            || v4 != 123 && v4 != 125 && v4 != 124 && v4 != 92 && v4 != 94 && v4 != 91 && v4 != 93 && v4 != 96 )
          {
            break;
          }
        }
      }
    }
    if ( v4 == 37 )
      v3 += 3;
    else
      ++v3;
  }
  if ( *(_DWORD *)(a2 + 28) )
    ((void (__cdecl *)(_DWORD))xmlFree)(*(_DWORD *)(a2 + 28));
  v7 = *a1;
  if ( (*(_BYTE *)(a2 + 36) & 2) != 0 )
    v8 = xmlStrndup(v7, v3 - (_BYTE *)*a1);
  else
    v8 = (_BYTE *)xmlURIUnescapeString((const char *)v7, v3 - (_BYTE *)*a1, 0);
  *(_DWORD *)(a2 + 28) = v8;
  if ( *(_DWORD *)(a2 + 40) )
    ((void (__cdecl *)(_DWORD))xmlFree)(*(_DWORD *)(a2 + 40));
  *(_DWORD *)(a2 + 40) = xmlStrndup(*a1, v3 - (_BYTE *)*a1);
LABEL_63:
  *a1 = v3;
  return 0;
}
// 496494: invalid function type has been ignored

//----- (004361E6) --------------------------------------------------------
int __usercall sub_4361E6@<eax>(int a1@<edx>, char **a2@<esi>)
{
  char *v2; // eax
  char v3; // cl
  char i; // cl

  v2 = *a2;
  v3 = **a2;
  if ( v3 < 48 || v3 > 57 )
    return 1;
  if ( a1 )
    *(_DWORD *)(a1 + 20) = 0;
  for ( i = *v2; *v2 >= 48; i = *++v2 )
  {
    if ( i > 57 )
      break;
    if ( a1 )
      *(_DWORD *)(a1 + 20) = 10 * *(_DWORD *)(a1 + 20) + i - 48;
  }
  *a2 = v2;
  return 0;
}

//----- (0043622F) --------------------------------------------------------
int __usercall sub_43622F@<eax>(char **a1@<ebx>, int a2@<edi>)
{
  char *v2; // esi
  char v3; // cl
  char v4; // al
  char v5; // al
  char *v6; // eax
  _BYTE *v7; // eax

  v2 = *a1;
  while ( 1 )
  {
    v3 = *v2;
    if ( (*v2 < 97 || v3 > 122)
      && (v3 < 65 || v3 > 90)
      && (v3 < 48 || v3 > 57)
      && v3 != 45
      && v3 != 46
      && v3 != 95
      && v3 != 126 )
    {
      if ( v3 != 37
        || ((v4 = v2[1], v4 < 48) || v4 > 57) && (v4 < 97 || v4 > 102) && (v4 < 65 || v4 > 70)
        || ((v5 = v2[2], v5 < 48) || v5 > 57) && (v5 < 97 || v5 > 102) && (v5 < 65 || v5 > 70) )
      {
        if ( v3 != 33
          && v3 != 36
          && v3 != 38
          && v3 != 40
          && v3 != 41
          && v3 != 42
          && v3 != 43
          && v3 != 44
          && v3 != 59
          && v3 != 61
          && v3 != 39
          && v3 != 58 )
        {
          break;
        }
      }
    }
    if ( v3 == 37 )
      v2 += 3;
    else
      ++v2;
  }
  if ( *v2 != 64 )
    return 1;
  if ( a2 )
  {
    if ( *(_DWORD *)(a2 + 16) )
      ((void (__cdecl *)(_DWORD))xmlFree)(*(_DWORD *)(a2 + 16));
    v6 = *a1;
    if ( (*(_BYTE *)(a2 + 36) & 2) != 0 )
      v7 = xmlStrndup(v6, v2 - *a1);
    else
      v7 = (_BYTE *)xmlURIUnescapeString(v6, v2 - *a1, 0);
    *(_DWORD *)(a2 + 16) = v7;
  }
  *a1 = v2;
  return 0;
}
// 496494: invalid function type has been ignored

//----- (0043634D) --------------------------------------------------------
int __usercall sub_43634D@<eax>(char **a1@<esi>)
{
  char *v1; // eax
  char v2; // bl
  char *v3; // ecx
  char v4; // dl
  char v5; // dl
  char v6; // cl
  char v7; // cl
  char *v8; // eax

  v1 = *a1;
  v2 = **a1;
  if ( v2 < 48 || v2 > 57 )
    return 1;
  v3 = v1 + 1;
  v4 = v1[1];
  if ( v4 < 48 || v4 > 57 )
    goto LABEL_19;
  if ( v2 == 48 )
    goto LABEL_9;
  v3 = v1 + 2;
  v5 = v1[2];
  if ( v5 < 48 || v5 > 57 )
  {
LABEL_19:
    v8 = v3;
    goto LABEL_20;
  }
  v4 = v1[1];
LABEL_9:
  if ( v2 == 49 && (v6 = v1[2], v6 >= 48) && v6 <= 57
    || v2 == 50 && (v4 <= 52 && (v7 = v1[2], v7 >= 48) && v7 <= 57 || v4 == 53 && v1[2] >= 48) )
  {
    v8 = v1 + 3;
LABEL_20:
    *a1 = v8;
    return 0;
  }
  return 1;
}

//----- (004363D0) --------------------------------------------------------
int __usercall sub_4363D0@<eax>(int a1@<ebx>, char **a2)
{
  char *v2; // edi
  char *v3; // esi
  char v4; // al
  char *v5; // esi
  char v6; // al
  char v8; // cl
  char v9; // al
  char v10; // al
  int v11; // eax
  _BYTE *v12; // eax
  char *Src; // [esp+8h] [ebp-8h]
  char *v14; // [esp+Ch] [ebp-4h] BYREF

  v2 = *a2;
  v3 = *a2;
  v4 = **a2;
  v14 = v3;
  Src = v3;
  if ( v4 != 91 )
  {
    if ( v4 >= 48 && v4 <= 57 )
    {
      if ( !sub_43634D(&v14) && *v14 == 46 )
      {
        ++v14;
        if ( !sub_43634D(&v14) && *v14 == 46 && !sub_43634D(&v14) && *v14 == 46 && !sub_43634D(&v14) )
        {
          v3 = v14;
          goto LABEL_56;
        }
      }
      v3 = v2;
    }
    while ( 1 )
    {
      v8 = *v3;
      if ( (*v3 < 97 || v8 > 122)
        && (v8 < 65 || v8 > 90)
        && (v8 < 48 || v8 > 57)
        && v8 != 45
        && v8 != 46
        && v8 != 95
        && v8 != 126 )
      {
        if ( v8 != 37
          || ((v9 = v3[1], v9 < 48) || v9 > 57) && (v9 < 97 || v9 > 102) && (v9 < 65 || v9 > 70)
          || ((v10 = v3[2], v10 < 48) || v10 > 57) && (v10 < 97 || v10 > 102) && (v10 < 65 || v10 > 70) )
        {
          if ( v8 != 33
            && v8 != 36
            && v8 != 38
            && v8 != 40
            && v8 != 41
            && v8 != 42
            && v8 != 43
            && v8 != 44
            && v8 != 59
            && v8 != 61
            && v8 != 39 )
          {
            break;
          }
        }
      }
      if ( v8 == 37 )
        v3 += 3;
      else
        ++v3;
    }
    goto LABEL_56;
  }
  v5 = v3 + 1;
  v6 = *v5;
  if ( *v5 != 93 )
  {
    do
    {
      if ( !v6 )
        break;
      v6 = *++v5;
    }
    while ( *v5 != 93 );
    if ( *v5 != 93 )
      return 1;
  }
  v3 = v5 + 1;
LABEL_56:
  if ( a1 )
  {
    if ( *(_DWORD *)(a1 + 8) )
      ((void (__cdecl *)(_DWORD))xmlFree)(*(_DWORD *)(a1 + 8));
    v11 = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 8) = 0;
    if ( v11 )
      ((void (__cdecl *)(int))xmlFree)(v11);
    if ( v3 == Src )
    {
      *(_DWORD *)(a1 + 12) = 0;
    }
    else
    {
      if ( (*(_BYTE *)(a1 + 36) & 2) != 0 )
        v12 = xmlStrndup(Src, v3 - Src);
      else
        v12 = (_BYTE *)xmlURIUnescapeString(Src, v3 - Src, 0);
      *(_DWORD *)(a1 + 12) = v12;
    }
  }
  *a2 = v3;
  return 0;
}
// 496494: invalid function type has been ignored

//----- (0043658C) --------------------------------------------------------
int __usercall sub_43658C@<eax>(int a1@<eax>, char **a2)
{
  char **v2; // esi
  int result; // eax
  char *v5; // [esp+Ch] [ebp-4h] BYREF

  v2 = a2;
  v5 = *a2;
  if ( sub_43622F(&v5, a1) || *v5 != 64 )
    v5 = *a2;
  else
    ++v5;
  result = sub_4363D0(a1, &v5);
  if ( !result )
  {
    if ( *v5 == 58 )
    {
      ++v5;
      result = sub_4361E6(a1, &v5);
      if ( result )
        return result;
      v2 = a2;
    }
    *v2 = v5;
    return 0;
  }
  return result;
}

//----- (004365F3) --------------------------------------------------------
BOOL __usercall sub_4365F3@<eax>(char **a1@<esi>, char a2, int a3)
{
  char *v3; // ecx
  char v4; // al
  char v5; // dl
  char v6; // dl
  char v8; // al
  char v9; // dl
  char v10; // dl

  v3 = *a1;
  v4 = **a1;
  if ( (v4 < 97 || v4 > 122)
    && (v4 < 65 || v4 > 90)
    && (v4 < 48 || v4 > 57)
    && v4 != 45
    && v4 != 46
    && v4 != 95
    && v4 != 126 )
  {
    if ( v4 != 37
      || ((v5 = v3[1], v5 < 48) || v5 > 57) && (v5 < 97 || v5 > 102) && (v5 < 65 || v5 > 70)
      || ((v6 = v3[2], v6 < 48) || v6 > 57) && (v6 < 97 || v6 > 102) && (v6 < 65 || v6 > 70) )
    {
      if ( v4 != 33
        && v4 != 36
        && v4 != 38
        && v4 != 40
        && v4 != 41
        && v4 != 42
        && v4 != 43
        && v4 != 44
        && v4 != 59
        && v4 != 61
        && v4 != 39
        && v4 != 58
        && v4 != 64 )
      {
        return a3 == 0;
      }
    }
  }
  while ( 1 )
  {
    v8 = *v3;
    if ( (*v3 < 97 || v8 > 122)
      && (v8 < 65 || v8 > 90)
      && (v8 < 48 || v8 > 57)
      && v8 != 45
      && v8 != 46
      && v8 != 95
      && v8 != 126 )
    {
      if ( v8 != 37
        || ((v9 = v3[1], v9 < 48) || v9 > 57) && (v9 < 97 || v9 > 102) && (v9 < 65 || v9 > 70)
        || ((v10 = v3[2], v10 < 48) || v10 > 57) && (v10 < 97 || v10 > 102) && (v10 < 65 || v10 > 70) )
      {
        if ( v8 != 33
          && v8 != 36
          && v8 != 38
          && v8 != 40
          && v8 != 41
          && v8 != 42
          && v8 != 43
          && v8 != 44
          && v8 != 59
          && v8 != 61
          && v8 != 39
          && v8 != 58
          && v8 != 64 )
        {
          break;
        }
      }
    }
    if ( v8 == a2 )
      break;
    if ( v8 == 37 )
      v3 += 3;
    else
      ++v3;
  }
  *a1 = v3;
  return 0;
}

//----- (00436795) --------------------------------------------------------
BOOL __usercall sub_436795@<eax>(char **a1@<ebx>, int a2@<edi>)
{
  char *i; // esi
  BOOL result; // eax
  char *v4; // eax
  _BYTE *v5; // eax
  char *v6; // [esp+4h] [ebp-4h] BYREF

  for ( i = *a1; *i == 47; i = v6 )
  {
    v6 = i + 1;
    result = sub_4365F3(&v6, 0, 1);
    if ( result )
      return result;
  }
  if ( a2 )
  {
    if ( *(_DWORD *)(a2 + 24) )
      ((void (__cdecl *)(_DWORD))xmlFree)(*(_DWORD *)(a2 + 24));
    v4 = *a1;
    if ( *a1 == i )
    {
      *(_DWORD *)(a2 + 24) = 0;
    }
    else
    {
      if ( (*(_BYTE *)(a2 + 36) & 2) != 0 )
        v5 = xmlStrndup(v4, i - v4);
      else
        v5 = (_BYTE *)xmlURIUnescapeString(v4, i - v4, 0);
      *(_DWORD *)(a2 + 24) = v5;
    }
  }
  *a1 = i;
  return 0;
}
// 496494: invalid function type has been ignored

//----- (00436806) --------------------------------------------------------
BOOL __usercall sub_436806@<eax>(char *a1@<ecx>, int a2@<edi>, int a3)
{
  BOOL result; // eax
  BOOL v4; // eax
  char *v5; // esi
  void *v6; // eax
  _BYTE *v7; // eax
  char *v8; // [esp+0h] [ebp-4h] BYREF

  v8 = a1;
  if ( **(_BYTE **)a3 != 47 )
    return 1;
  v8 = (char *)(*(_DWORD *)a3 + 1);
  v4 = sub_4365F3(&v8, 0, 0);
  v5 = v8;
  if ( !v4 )
  {
    while ( *v5 == 47 )
    {
      v8 = v5 + 1;
      result = sub_4365F3(&v8, 0, 1);
      if ( result )
        return result;
      v5 = v8;
    }
  }
  if ( a2 )
  {
    if ( *(_DWORD *)(a2 + 24) )
      ((void (__cdecl *)(_DWORD))xmlFree)(*(_DWORD *)(a2 + 24));
    v6 = *(void **)a3;
    if ( v5 == *(char **)a3 )
    {
      *(_DWORD *)(a2 + 24) = 0;
    }
    else
    {
      if ( (*(_BYTE *)(a2 + 36) & 2) != 0 )
        v7 = xmlStrndup(v6, v5 - (_BYTE *)v6);
      else
        v7 = (_BYTE *)xmlURIUnescapeString((const char *)v6, v5 - (_BYTE *)v6, 0);
      *(_DWORD *)(a2 + 24) = v7;
    }
  }
  *(_DWORD *)a3 = v5;
  return 0;
}
// 496494: invalid function type has been ignored

//----- (004368A2) --------------------------------------------------------
BOOL __usercall sub_4368A2@<eax>(int a1@<edi>, char **a2)
{
  BOOL result; // eax
  char *v3; // esi
  char *v4; // eax
  _BYTE *v5; // eax
  char *v6; // [esp+8h] [ebp-4h] BYREF

  v6 = *a2;
  for ( result = sub_4365F3(&v6, 0, 0); !result; result = sub_4365F3(&v6, 0, 1) )
  {
    v3 = v6;
    if ( *v6 != 47 )
    {
      if ( a1 )
      {
        if ( *(_DWORD *)(a1 + 24) )
          ((void (__cdecl *)(_DWORD))xmlFree)(*(_DWORD *)(a1 + 24));
        v4 = *a2;
        if ( v3 == *a2 )
        {
          *(_DWORD *)(a1 + 24) = 0;
        }
        else
        {
          if ( (*(_BYTE *)(a1 + 36) & 2) != 0 )
            v5 = xmlStrndup(v4, v3 - v4);
          else
            v5 = (_BYTE *)xmlURIUnescapeString(v4, v3 - v4, 0);
          *(_DWORD *)(a1 + 24) = v5;
        }
      }
      *a2 = v3;
      return 0;
    }
    ++v6;
  }
  return result;
}
// 496494: invalid function type has been ignored

//----- (00436921) --------------------------------------------------------
BOOL __usercall sub_436921@<eax>(char **a1@<ebx>, int a2@<edi>)
{
  BOOL result; // eax
  char *v3; // esi
  char *v4; // eax
  _BYTE *v5; // eax
  char *v6; // [esp+4h] [ebp-4h] BYREF

  v6 = *a1;
  for ( result = sub_4365F3(&v6, 58, 0); !result; result = sub_4365F3(&v6, 0, 1) )
  {
    v3 = v6;
    if ( *v6 != 47 )
    {
      if ( a2 )
      {
        if ( *(_DWORD *)(a2 + 24) )
          ((void (__cdecl *)(_DWORD))xmlFree)(*(_DWORD *)(a2 + 24));
        v4 = *a1;
        if ( v3 == *a1 )
        {
          *(_DWORD *)(a2 + 24) = 0;
        }
        else
        {
          if ( (*(_BYTE *)(a2 + 36) & 2) != 0 )
            v5 = xmlStrndup(v4, v3 - v4);
          else
            v5 = (_BYTE *)xmlURIUnescapeString(v4, v3 - v4, 0);
          *(_DWORD *)(a2 + 24) = v5;
        }
      }
      *a1 = v3;
      return 0;
    }
    ++v6;
  }
  return result;
}
// 496494: invalid function type has been ignored

//----- (00436999) --------------------------------------------------------
int __usercall sub_436999@<eax>(int a1@<eax>, char *a2@<ecx>, char **a3@<esi>)
{
  char *v3; // ebx
  int result; // eax
  char v6; // al
  char v7; // al
  char *v8; // [esp+8h] [ebp-4h] BYREF

  v3 = *a3;
  LOBYTE(a2) = **a3;
  v8 = *a3;
  if ( (_BYTE)a2 != 47 )
  {
    if ( ((char)a2 < 97 || (char)a2 > 122)
      && ((char)a2 < 65 || (char)a2 > 90)
      && ((char)a2 < 48 || (char)a2 > 57)
      && (_BYTE)a2 != 45
      && (_BYTE)a2 != 46
      && (_BYTE)a2 != 95
      && (_BYTE)a2 != 126 )
    {
      if ( (_BYTE)a2 != 37
        || ((v6 = v3[1], v6 < 48) || v6 > 57) && (v6 < 97 || v6 > 102) && (v6 < 65 || v6 > 70)
        || ((v7 = v3[2], v7 < 48) || v7 > 57) && (v7 < 97 || v7 > 102) && (v7 < 65 || v7 > 70) )
      {
        if ( (_BYTE)a2 != 33
          && (_BYTE)a2 != 36
          && (_BYTE)a2 != 38
          && (_BYTE)a2 != 40
          && (_BYTE)a2 != 41
          && (_BYTE)a2 != 42
          && (_BYTE)a2 != 43
          && (_BYTE)a2 != 44
          && (_BYTE)a2 != 59
          && (_BYTE)a2 != 61
          && (_BYTE)a2 != 39
          && (_BYTE)a2 != 58
          && (_BYTE)a2 != 64 )
        {
          if ( a1 )
          {
            if ( *(_DWORD *)(a1 + 24) )
              ((void (__cdecl *)(_DWORD))xmlFree)(*(_DWORD *)(a1 + 24));
            *(_DWORD *)(a1 + 24) = 0;
          }
LABEL_9:
          *a3 = v3;
          return 0;
        }
      }
    }
    result = sub_4368A2(a1, &v8);
LABEL_7:
    if ( result )
      return result;
    v3 = v8;
    goto LABEL_9;
  }
  if ( v3[1] != 47 )
  {
    result = sub_436806(a2, a1, (int)&v8);
    goto LABEL_7;
  }
  v8 = v3 + 2;
  result = sub_43658C(a1, &v8);
  if ( !result )
  {
    result = sub_436795(&v8, a1);
    if ( !result )
    {
      *a3 = v8;
      return 0;
    }
  }
  return result;
}
// 496494: invalid function type has been ignored

//----- (00436AE7) --------------------------------------------------------
int __usercall sub_436AE7@<eax>(_DWORD *a1@<eax>, char *a2@<ecx>, _BYTE *a3)
{
  _BYTE *v3; // ebx
  int result; // eax
  char v6; // al
  char v7; // al

  v3 = a3;
  LOBYTE(a2) = *a3;
  if ( *a3 == 47 )
  {
    if ( a3[1] == 47 )
    {
      a3 += 2;
      result = sub_43658C((int)a1, &a3);
      if ( result )
        return result;
      result = sub_436795(&a3, (int)a1);
    }
    else
    {
      result = sub_436806(a2, (int)a1, (int)&a3);
    }
  }
  else
  {
    if ( ((char)a2 < 97 || (char)a2 > 122)
      && ((char)a2 < 65 || (char)a2 > 90)
      && ((char)a2 < 48 || (char)a2 > 57)
      && (_BYTE)a2 != 45
      && (_BYTE)a2 != 46
      && (_BYTE)a2 != 95
      && (_BYTE)a2 != 126 )
    {
      if ( (_BYTE)a2 != 37
        || ((v6 = a3[1], v6 < 48) || v6 > 57) && (v6 < 97 || v6 > 102) && (v6 < 65 || v6 > 70)
        || ((v7 = a3[2], v7 < 48) || v7 > 57) && (v7 < 97 || v7 > 102) && (v7 < 65 || v7 > 70) )
      {
        if ( (_BYTE)a2 != 33
          && (_BYTE)a2 != 36
          && (_BYTE)a2 != 38
          && (_BYTE)a2 != 40
          && (_BYTE)a2 != 41
          && (_BYTE)a2 != 42
          && (_BYTE)a2 != 43
          && (_BYTE)a2 != 44
          && (_BYTE)a2 != 59
          && (_BYTE)a2 != 61
          && (_BYTE)a2 != 39
          && (_BYTE)a2 != 58
          && (_BYTE)a2 != 64 )
        {
          if ( a1 )
          {
            if ( a1[6] )
              ((void (__cdecl *)(_DWORD))xmlFree)(a1[6]);
            a1[6] = 0;
          }
          goto LABEL_7;
        }
      }
    }
    result = sub_436921(&a3, (int)a1);
  }
  if ( result )
    return result;
  v3 = a3;
LABEL_7:
  if ( *v3 == 63 )
  {
    a3 = v3 + 1;
    result = sub_436054((void **)&a3, (int)a1);
    if ( result )
      return result;
    v3 = a3;
  }
  if ( *v3 == 35 )
  {
    a3 = v3 + 1;
    result = sub_435EEB(&a3, (int)a1);
    if ( result )
      return result;
    v3 = a3;
  }
  if ( !*v3 )
    return 0;
  sub_4378D5(a1);
  return 1;
}
// 496494: invalid function type has been ignored

//----- (00436C86) --------------------------------------------------------
int __cdecl sub_436C86(_DWORD *a1, _BYTE *a2)
{
  int result; // eax
  char *v3; // ecx

  result = sub_435E79(a1, (void **)&a2);
  if ( !result )
  {
    if ( *a2 == 58 )
    {
      ++a2;
      result = sub_436999((int)a1, v3, &a2);
      if ( !result )
      {
        if ( *a2 != 63 || (++a2, (result = sub_436054((void **)&a2, (int)a1)) == 0) )
        {
          if ( *a2 != 35 || (++a2, (result = sub_435EEB(&a2, (int)a1)) == 0) )
          {
            if ( *a2 )
            {
              sub_4378D5(a1);
              return 1;
            }
            else
            {
              return 0;
            }
          }
        }
      }
    }
    else
    {
      return 1;
    }
  }
  return result;
}
// 436CB2: variable 'v3' is possibly undefined

//----- (00436D05) --------------------------------------------------------
int __usercall sub_436D05@<eax>(_DWORD *a1@<eax>, _BYTE *a2)
{
  char *v4; // ecx
  int v5; // edi

  if ( !a2 )
    return -1;
  sub_4378D5(a1);
  if ( !sub_436C86(a1, a2) )
    return 0;
  sub_4378D5(a1);
  v5 = sub_436AE7(a1, v4, a2);
  if ( !v5 )
    return 0;
  sub_4378D5(a1);
  return v5;
}
// 436D35: variable 'v4' is possibly undefined

//----- (00436D4F) --------------------------------------------------------
_DWORD *__cdecl xmlParseURI(_BYTE *a1)
{
  _DWORD *URI; // eax
  _DWORD *v3; // esi

  if ( !a1 )
    return 0;
  URI = xmlCreateURI();
  v3 = URI;
  if ( !URI || !sub_436D05(URI, a1) )
    return v3;
  xmlFreeURI(v3);
  return 0;
}

//----- (00436D82) --------------------------------------------------------
int __cdecl xmlParseURIReference(_DWORD *a1, _BYTE *a2)
{
  return sub_436D05(a1, a2);
}

//----- (00436D91) --------------------------------------------------------
_DWORD *__cdecl xmlParseURIRaw(_BYTE *a1, int a2)
{
  _DWORD *URI; // eax
  _DWORD *v4; // esi

  if ( !a1 )
    return 0;
  URI = xmlCreateURI();
  v4 = URI;
  if ( !URI )
    return v4;
  if ( a2 )
    URI[9] |= 2u;
  if ( !xmlParseURIReference(URI, a1) )
    return v4;
  xmlFreeURI(v4);
  return 0;
}

//----- (00436DD1) --------------------------------------------------------
void *xmlCreateURI()
{
  void *v0; // eax
  void *v1; // esi

  v0 = (void *)xmlMalloc(44);
  v1 = v0;
  if ( v0 )
  {
    memset(v0, 0, 0x2Cu);
    return v1;
  }
  else
  {
    xmlGenericError(xmlGenericErrorContext, "xmlCreateURI: out of memory\n");
    return 0;
  }
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);

//----- (00436E09) --------------------------------------------------------
void *__cdecl xmlSaveUri(_DWORD *a1)
{
  _DWORD *v1; // ebx
  int v3; // ebp
  void *v4; // edi
  int v5; // esi
  char *v6; // ebx
  int v7; // eax
  int v8; // eax
  _BYTE *v9; // eax
  int v10; // ebx
  int v11; // eax
  char v12; // al
  int v13; // esi
  int v14; // eax
  int v15; // esi
  char *v16; // ebx
  int v17; // ebx
  int v18; // eax
  char v19; // al
  int v20; // esi
  int v21; // eax
  _BYTE *i; // ebx
  int v23; // eax
  int v24; // eax
  int v25; // eax
  int v26; // esi
  char *v27; // ebx
  int v28; // eax
  char v29; // al
  int v30; // esi
  int v31; // eax
  int v32; // esi
  char *v33; // ebx
  char v34; // al
  int v35; // esi
  int v36; // eax
  char v37; // al
  int v38; // esi
  int v39; // eax
  _BYTE *v40; // ebx
  int v41; // eax
  int v42; // eax
  char *v43; // ebx
  int v44; // eax
  char v45; // al
  int v46; // esi
  int v47; // eax
  int v48; // ebx
  int v49; // eax
  char v50; // al
  int v51; // esi
  int v52; // eax
  char *v53; // [esp+4h] [ebp-4h]
  char *v54; // [esp+4h] [ebp-4h]
  int v55; // [esp+4h] [ebp-4h]
  int v56; // [esp+4h] [ebp-4h]
  int v57; // [esp+4h] [ebp-4h]
  int v58; // [esp+4h] [ebp-4h]
  char *v59; // [esp+4h] [ebp-4h]

  v1 = a1;
  if ( !a1 )
    return 0;
  v3 = 80;
  v4 = (void *)xmlMallocAtomic(0x51u);
  if ( !v4 )
  {
    xmlGenericError(xmlGenericErrorContext, "xmlSaveUri: out of memory\n");
    return 0;
  }
  v5 = 0;
  if ( *a1 )
  {
    v6 = (char *)*a1;
    if ( *(_BYTE *)*a1 )
    {
      do
      {
        if ( v5 >= v3 )
        {
          v3 *= 2;
          v7 = xmlRealloc(v4, v3 + 1);
          if ( !v7 )
            goto LABEL_278;
          v4 = (void *)v7;
        }
        *((_BYTE *)v4 + v5++) = *v6++;
      }
      while ( *v6 );
      if ( v5 >= v3 )
      {
        v3 *= 2;
        v8 = xmlRealloc(v4, v3 + 1);
        if ( !v8 )
          goto LABEL_278;
        v4 = (void *)v8;
      }
    }
    v1 = a1;
    *((_BYTE *)v4 + v5++) = 58;
  }
  v9 = (_BYTE *)v1[1];
  if ( v9 )
  {
    v53 = (char *)v1[1];
    if ( *v9 )
    {
      v10 = v5 + 3;
      do
      {
        if ( v10 >= v3 )
        {
          v3 *= 2;
          v11 = xmlRealloc(v4, v3 + 1);
          if ( !v11 )
            goto LABEL_278;
          v4 = (void *)v11;
        }
        v12 = *v53;
        if ( *v53 == 59
          || v12 == 47
          || v12 == 63
          || v12 == 58
          || v12 == 64
          || v12 == 38
          || v12 == 61
          || v12 == 43
          || v12 == 36
          || v12 == 44
          || v12 == 91
          || v12 == 93
          || v12 >= 97 && v12 <= 122
          || v12 >= 65 && v12 <= 90
          || v12 >= 48 && v12 <= 57
          || v12 == 45
          || v12 == 95
          || v12 == 46
          || v12 == 33
          || v12 == 126
          || v12 == 42
          || v12 == 39
          || v12 == 40
          || v12 == 41 )
        {
          *((_BYTE *)v4 + v5++) = v12;
          ++v10;
          ++v53;
        }
        else
        {
          ++v53;
          *((_BYTE *)v4 + v5) = 37;
          v13 = v5 + 1;
          *((_BYTE *)v4 + v13) = (unsigned __int8)v12 / 16 + ((unsigned __int8)v12 / 16 <= 9 ? 48 : 55);
          *((_BYTE *)v4 + ++v13) = (v12 & 0xF) + ((v12 & 0xFu) <= 9 ? 48 : 55);
          v5 = v13 + 1;
          v10 += 3;
        }
      }
      while ( *v53 );
    }
  }
  else
  {
    if ( v1[3] )
    {
      if ( v5 + 3 >= v3 )
      {
        v3 *= 2;
        v14 = xmlRealloc(v4, v3 + 1);
        if ( !v14 )
          goto LABEL_278;
        v4 = (void *)v14;
      }
      *((_BYTE *)v4 + v5) = 47;
      v15 = v5 + 1;
      *((_BYTE *)v4 + v15) = 47;
      v16 = (char *)v1[4];
      v5 = v15 + 1;
      if ( v16 )
      {
        v54 = v16;
        if ( *v16 )
        {
          v17 = v5 + 3;
          do
          {
            if ( v17 >= v3 )
            {
              v3 *= 2;
              v18 = xmlRealloc(v4, v3 + 1);
              if ( !v18 )
                goto LABEL_278;
              v4 = (void *)v18;
            }
            v19 = *v54;
            if ( *v54 >= 97 && v19 <= 122
              || v19 >= 65 && v19 <= 90
              || v19 >= 48 && v19 <= 57
              || v19 == 45
              || v19 == 95
              || v19 == 46
              || v19 == 33
              || v19 == 126
              || v19 == 42
              || v19 == 39
              || v19 == 40
              || v19 == 41
              || v19 == 59
              || v19 == 58
              || v19 == 38
              || v19 == 61
              || v19 == 43
              || v19 == 36
              || v19 == 44 )
            {
              *((_BYTE *)v4 + v5++) = v19;
              ++v17;
              ++v54;
            }
            else
            {
              ++v54;
              *((_BYTE *)v4 + v5) = 37;
              v20 = v5 + 1;
              *((_BYTE *)v4 + v20) = (unsigned __int8)v19 / 16 + ((unsigned __int8)v19 / 16 <= 9 ? 48 : 55);
              *((_BYTE *)v4 + ++v20) = (v19 & 0xF) + ((v19 & 0xFu) <= 9 ? 48 : 55);
              v5 = v20 + 1;
              v17 += 3;
            }
          }
          while ( *v54 );
        }
        if ( v5 + 3 >= v3 )
        {
          v3 *= 2;
          v21 = xmlRealloc(v4, v3 + 1);
          if ( !v21 )
            goto LABEL_278;
          v4 = (void *)v21;
        }
        *((_BYTE *)v4 + v5++) = 64;
      }
      for ( i = (_BYTE *)a1[3]; *i; ++i )
      {
        if ( v5 >= v3 )
        {
          v3 *= 2;
          v23 = xmlRealloc(v4, v3 + 1);
          if ( !v23 )
            goto LABEL_278;
          v4 = (void *)v23;
        }
        *((_BYTE *)v4 + v5++) = *i;
      }
      if ( (int)a1[5] > 0 )
      {
        if ( v5 + 10 >= v3 )
        {
          v3 *= 2;
          v24 = xmlRealloc(v4, v3 + 1);
          if ( !v24 )
            goto LABEL_278;
          v4 = (void *)v24;
        }
        v5 += _snprintf((char *const)v4 + v5, v3 - v5, ":%d", a1[5]);
      }
    }
    else if ( v1[2] )
    {
      if ( v5 + 3 >= v3 )
      {
        v3 *= 2;
        v25 = xmlRealloc(v4, v3 + 1);
        if ( !v25 )
          goto LABEL_278;
        v4 = (void *)v25;
      }
      *((_BYTE *)v4 + v5) = 47;
      v26 = v5 + 1;
      *((_BYTE *)v4 + v26) = 47;
      v27 = (char *)a1[2];
      v5 = v26 + 1;
      if ( *v27 )
      {
        v55 = v5 + 3;
        do
        {
          if ( v55 >= v3 )
          {
            v3 *= 2;
            v28 = xmlRealloc(v4, v3 + 1);
            if ( !v28 )
              goto LABEL_278;
            v4 = (void *)v28;
          }
          v29 = *v27;
          if ( *v27 >= 97 && v29 <= 122
            || v29 >= 65 && v29 <= 90
            || v29 >= 48 && v29 <= 57
            || v29 == 45
            || v29 == 95
            || v29 == 46
            || v29 == 33
            || v29 == 126
            || v29 == 42
            || v29 == 39
            || v29 == 40
            || v29 == 41
            || v29 == 36
            || v29 == 44
            || v29 == 59
            || v29 == 58
            || v29 == 64
            || v29 == 38
            || v29 == 61
            || v29 == 43 )
          {
            *((_BYTE *)v4 + v5++) = v29;
            ++v55;
            ++v27;
          }
          else
          {
            ++v27;
            *((_BYTE *)v4 + v5) = 37;
            v30 = v5 + 1;
            *((_BYTE *)v4 + v30) = (unsigned __int8)v29 / 16 + ((unsigned __int8)v29 / 16 <= 9 ? 48 : 55);
            *((_BYTE *)v4 + ++v30) = (v29 & 0xF) + ((v29 & 0xFu) <= 9 ? 48 : 55);
            v5 = v30 + 1;
            v55 += 3;
          }
        }
        while ( *v27 );
      }
    }
    else if ( *v1 )
    {
      if ( v5 + 3 >= v3 )
      {
        v3 *= 2;
        v31 = xmlRealloc(v4, v3 + 1);
        if ( !v31 )
          goto LABEL_278;
        v4 = (void *)v31;
      }
      *((_BYTE *)v4 + v5) = 47;
      v32 = v5 + 1;
      *((_BYTE *)v4 + v32) = 47;
      v5 = v32 + 1;
    }
    v33 = (char *)a1[6];
    if ( v33 )
    {
      if ( *a1 && *v33 == 47 )
      {
        if ( (v34 = v33[1], v34 >= 97) && v34 <= 122 || v34 >= 65 && v34 <= 90 )
        {
          if ( v33[2] == 58 && xmlStrEqual((char *)*a1, "file") )
          {
            if ( v5 + 3 >= v3 )
            {
              v3 *= 2;
              v4 = (void *)xmlRealloc(v4, v3 + 1);
              if ( !v4 )
              {
                xmlGenericError(xmlGenericErrorContext, "xmlSaveUri: out of memory\n");
                return 0;
              }
            }
            *((_BYTE *)v4 + v5) = *v33;
            v35 = v5 + 1;
            *((_BYTE *)v4 + v35) = v33[1];
            *((_BYTE *)v4 + ++v35) = v33[2];
            v5 = v35 + 1;
            v33 += 3;
          }
        }
      }
      if ( *v33 )
      {
        v56 = v5 + 3;
        do
        {
          if ( v56 >= v3 )
          {
            v3 *= 2;
            v36 = xmlRealloc(v4, v3 + 1);
            if ( !v36 )
              goto LABEL_278;
            v4 = (void *)v36;
          }
          v37 = *v33;
          if ( *v33 >= 97 && v37 <= 122
            || v37 >= 65 && v37 <= 90
            || v37 >= 48 && v37 <= 57
            || v37 == 45
            || v37 == 95
            || v37 == 46
            || v37 == 33
            || v37 == 126
            || v37 == 42
            || v37 == 39
            || v37 == 40
            || v37 == 41
            || v37 == 47
            || v37 == 59
            || v37 == 64
            || v37 == 38
            || v37 == 61
            || v37 == 43
            || v37 == 36
            || v37 == 44 )
          {
            *((_BYTE *)v4 + v5++) = v37;
            ++v56;
            ++v33;
          }
          else
          {
            ++v33;
            *((_BYTE *)v4 + v5) = 37;
            v38 = v5 + 1;
            *((_BYTE *)v4 + v38) = (unsigned __int8)v37 / 16 + ((unsigned __int8)v37 / 16 <= 9 ? 48 : 55);
            *((_BYTE *)v4 + ++v38) = (v37 & 0xF) + ((v37 & 0xFu) <= 9 ? 48 : 55);
            v5 = v38 + 1;
            v56 += 3;
          }
        }
        while ( *v33 );
      }
    }
    if ( a1[10] )
    {
      if ( v5 + 1 >= v3 )
      {
        v3 *= 2;
        v39 = xmlRealloc(v4, v3 + 1);
        if ( !v39 )
          goto LABEL_278;
        v4 = (void *)v39;
      }
      *((_BYTE *)v4 + v5++) = 63;
      v40 = (_BYTE *)a1[10];
      if ( *v40 )
      {
        v57 = v5 + 1;
        do
        {
          if ( v57 >= v3 )
          {
            v3 *= 2;
            v41 = xmlRealloc(v4, v3 + 1);
            if ( !v41 )
              goto LABEL_278;
            v4 = (void *)v41;
          }
          *((_BYTE *)v4 + v5++) = *v40;
          ++v57;
          ++v40;
        }
        while ( *v40 );
      }
    }
    else if ( a1[7] )
    {
      if ( v5 + 3 >= v3 )
      {
        v3 *= 2;
        v42 = xmlRealloc(v4, v3 + 1);
        if ( !v42 )
          goto LABEL_278;
        v4 = (void *)v42;
      }
      *((_BYTE *)v4 + v5) = 63;
      v43 = (char *)a1[7];
      ++v5;
      if ( *v43 )
      {
        v58 = v5 + 3;
        do
        {
          if ( v58 >= v3 )
          {
            v3 *= 2;
            v44 = xmlRealloc(v4, v3 + 1);
            if ( !v44 )
              goto LABEL_278;
            v4 = (void *)v44;
          }
          v45 = *v43;
          if ( *v43 >= 97 && v45 <= 122
            || v45 >= 65 && v45 <= 90
            || v45 >= 48 && v45 <= 57
            || v45 == 45
            || v45 == 95
            || v45 == 46
            || v45 == 33
            || v45 == 126
            || v45 == 42
            || v45 == 39
            || v45 == 40
            || v45 == 41
            || v45 == 59
            || v45 == 47
            || v45 == 63
            || v45 == 58
            || v45 == 64
            || v45 == 38
            || v45 == 61
            || v45 == 43
            || v45 == 36
            || v45 == 44
            || v45 == 91
            || v45 == 93 )
          {
            *((_BYTE *)v4 + v5++) = v45;
            ++v58;
            ++v43;
          }
          else
          {
            ++v43;
            *((_BYTE *)v4 + v5) = 37;
            v46 = v5 + 1;
            *((_BYTE *)v4 + v46) = (unsigned __int8)v45 / 16 + ((unsigned __int8)v45 / 16 <= 9 ? 48 : 55);
            *((_BYTE *)v4 + ++v46) = (v45 & 0xF) + ((v45 & 0xFu) <= 9 ? 48 : 55);
            v5 = v46 + 1;
            v58 += 3;
          }
        }
        while ( *v43 );
      }
    }
  }
  if ( !a1[8] )
    goto LABEL_276;
  if ( v5 + 3 >= v3 )
  {
    v3 *= 2;
    v47 = xmlRealloc(v4, v3 + 1);
    if ( v47 )
    {
      v4 = (void *)v47;
      goto LABEL_241;
    }
LABEL_278:
    xmlGenericError(xmlGenericErrorContext, "xmlSaveUri: out of memory\n");
    ((void (__cdecl *)(void *))xmlFree)(v4);
    return 0;
  }
LABEL_241:
  *((_BYTE *)v4 + v5++) = 35;
  v59 = (char *)a1[8];
  if ( *v59 )
  {
    v48 = v5 + 3;
    do
    {
      if ( v48 >= v3 )
      {
        v3 *= 2;
        v49 = xmlRealloc(v4, v3 + 1);
        if ( !v49 )
          goto LABEL_278;
        v4 = (void *)v49;
      }
      v50 = *v59;
      if ( *v59 >= 97 && v50 <= 122
        || v50 >= 65 && v50 <= 90
        || v50 >= 48 && v50 <= 57
        || v50 == 45
        || v50 == 95
        || v50 == 46
        || v50 == 33
        || v50 == 126
        || v50 == 42
        || v50 == 39
        || v50 == 40
        || v50 == 41
        || v50 == 59
        || v50 == 47
        || v50 == 63
        || v50 == 58
        || v50 == 64
        || v50 == 38
        || v50 == 61
        || v50 == 43
        || v50 == 36
        || v50 == 44
        || v50 == 91
        || v50 == 93 )
      {
        *((_BYTE *)v4 + v5++) = v50;
        ++v48;
        ++v59;
      }
      else
      {
        ++v59;
        *((_BYTE *)v4 + v5) = 37;
        v51 = v5 + 1;
        *((_BYTE *)v4 + v51) = (unsigned __int8)v50 / 16 + ((unsigned __int8)v50 / 16 <= 9 ? 48 : 55);
        *((_BYTE *)v4 + ++v51) = (v50 & 0xF) + ((v50 & 0xFu) <= 9 ? 48 : 55);
        v5 = v51 + 1;
        v48 += 3;
      }
    }
    while ( *v59 );
  }
LABEL_276:
  if ( v5 >= v3 )
  {
    v52 = xmlRealloc(v4, 2 * v3 + 1);
    if ( !v52 )
      goto LABEL_278;
    v4 = (void *)v52;
  }
  *((_BYTE *)v4 + v5) = 0;
  return v4;
}
// 496494: invalid function type has been ignored
// 49B2BC: using guessed type int (__cdecl *xmlMallocAtomic)(size_t Size);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);

//----- (004378A9) --------------------------------------------------------
const char *__cdecl xmlPrintURI(FILE *Stream, _DWORD *a2)
{
  const char *result; // eax
  const char *v3; // esi

  result = (const char *)xmlSaveUri(a2);
  v3 = result;
  if ( result )
  {
    fprintf(Stream, "%s", result);
    return (const char *)((int (__cdecl *)(const char *))xmlFree)(v3);
  }
  return result;
}
// 496494: invalid function type has been ignored

//----- (004378D5) --------------------------------------------------------
void __usercall sub_4378D5(_DWORD *a1@<esi>)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax

  if ( a1 )
  {
    if ( *a1 )
      ((void (__cdecl *)(_DWORD))xmlFree)(*a1);
    v1 = a1[3];
    *a1 = 0;
    if ( v1 )
      ((void (__cdecl *)(int))xmlFree)(v1);
    v2 = a1[4];
    a1[3] = 0;
    if ( v2 )
      ((void (__cdecl *)(int))xmlFree)(v2);
    v3 = a1[6];
    a1[4] = 0;
    if ( v3 )
      ((void (__cdecl *)(int))xmlFree)(v3);
    v4 = a1[8];
    a1[6] = 0;
    if ( v4 )
      ((void (__cdecl *)(int))xmlFree)(v4);
    v5 = a1[1];
    a1[8] = 0;
    if ( v5 )
      ((void (__cdecl *)(int))xmlFree)(v5);
    v6 = a1[2];
    a1[1] = 0;
    if ( v6 )
      ((void (__cdecl *)(int))xmlFree)(v6);
    v7 = a1[7];
    a1[2] = 0;
    if ( v7 )
      ((void (__cdecl *)(int))xmlFree)(v7);
    v8 = a1[10];
    a1[7] = 0;
    if ( v8 )
      ((void (__cdecl *)(int))xmlFree)(v8);
    a1[10] = 0;
  }
}
// 496494: invalid function type has been ignored

//----- (00437982) --------------------------------------------------------
int __cdecl xmlFreeURI(_DWORD *Block)
{
  int result; // eax

  if ( Block )
  {
    if ( *Block )
      ((void (__cdecl *)(_DWORD))xmlFree)(*Block);
    if ( Block[3] )
      ((void (__cdecl *)(_DWORD))xmlFree)(Block[3]);
    if ( Block[4] )
      ((void (__cdecl *)(_DWORD))xmlFree)(Block[4]);
    if ( Block[6] )
      ((void (__cdecl *)(_DWORD))xmlFree)(Block[6]);
    if ( Block[8] )
      ((void (__cdecl *)(_DWORD))xmlFree)(Block[8]);
    if ( Block[1] )
      ((void (__cdecl *)(_DWORD))xmlFree)(Block[1]);
    if ( Block[2] )
      ((void (__cdecl *)(_DWORD))xmlFree)(Block[2]);
    if ( Block[7] )
      ((void (__cdecl *)(_DWORD))xmlFree)(Block[7]);
    if ( Block[10] )
      ((void (__cdecl *)(_DWORD))xmlFree)(Block[10]);
    return ((int (__cdecl *)(_DWORD *))xmlFree)(Block);
  }
  return result;
}
// 496494: invalid function type has been ignored

//----- (00437A1F) --------------------------------------------------------
int __cdecl xmlNormalizeURIPath(_BYTE *a1)
{
  _BYTE *v1; // esi
  _BYTE *i; // eax
  char v4; // cl
  _BYTE *v5; // edi
  char v6; // dl
  _BYTE *j; // ecx
  char v8; // dl
  _BYTE *v9; // eax
  _BYTE *v10; // eax
  char v11; // dl
  _BYTE *v12; // esi
  char *v13; // eax
  char v14; // dl
  _BYTE *v15; // eax
  bool v16; // zf
  _BYTE *v17; // eax
  _BYTE *v18; // eax
  _BYTE *v19; // ecx
  char v20; // dl
  _BYTE *v21; // edx

  v1 = a1;
  if ( !a1 )
    return -1;
  for ( i = a1; *i == 47; ++i )
    ;
  v4 = *i;
  if ( !*i )
    return 0;
  v5 = i;
  while ( v4 == 46 )
  {
    v6 = i[1];
    if ( v6 != 47 )
    {
      if ( !v6 )
        goto LABEL_23;
      break;
    }
    for ( i += 2; *i == 47; ++i )
      ;
LABEL_22:
    v4 = *i;
    if ( !*i )
      goto LABEL_23;
  }
  if ( v4 == 47 )
  {
    do
    {
      if ( i[1] != 47 )
        break;
      ++i;
LABEL_20:
      ;
    }
    while ( *i == 47 );
    *v5++ = *i++;
    goto LABEL_22;
  }
  while ( v4 )
  {
    *v5++ = v4;
    v4 = *++i;
    if ( *i == 47 )
      goto LABEL_20;
  }
LABEL_23:
  *v5 = 0;
  for ( j = a1; *j == 47; ++j )
    ;
  if ( *j )
  {
    while ( 1 )
    {
      v8 = *j;
      v9 = j;
      if ( *j != 47 )
        break;
LABEL_31:
      if ( !*v9 )
        goto LABEL_53;
      v10 = v9 + 1;
      if ( *j == 46 && j[1] == 46 && v10 == j + 3 || *v10 != 46 || v10[1] != 46 || (v11 = v10[2], v11 != 47) && v11 )
      {
        j = v10;
      }
      else
      {
        if ( !v11 )
        {
          *j = 0;
          goto LABEL_53;
        }
        v12 = j;
        v13 = v10 + 3;
        do
        {
          v14 = *v13;
          *v12++ = *v13++;
        }
        while ( v14 );
        v15 = j;
        while ( 1 )
        {
          v16 = v15 == a1;
          if ( v15 <= a1 )
            break;
          if ( *--v15 != 47 )
          {
            v16 = v15 == a1;
            break;
          }
        }
        if ( !v16 )
        {
          j = v15;
          if ( v15 > a1 )
          {
            do
            {
              v17 = j - 1;
              if ( *(j - 1) == 47 )
                break;
              --j;
            }
            while ( v17 > a1 );
          }
        }
        v1 = a1;
      }
    }
    while ( v8 )
    {
      v8 = *++v9;
      if ( *v9 == 47 )
        goto LABEL_31;
    }
LABEL_53:
    *v5 = 0;
    if ( *v1 == 47 )
    {
      v18 = v1;
      do
      {
        if ( v18[1] != 46 )
          break;
        if ( v18[2] != 46 )
          break;
        v19 = v18 + 3;
        v20 = v18[3];
        if ( v20 != 47 )
        {
          if ( v20 )
            break;
        }
        v18 += 3;
      }
      while ( *v19 == 47 );
      if ( v18 != v1 )
      {
        v21 = v1;
        while ( *v18 )
          *v21++ = *v18++;
        *v21 = 0;
      }
    }
  }
  return 0;
}

//----- (00437B7E) --------------------------------------------------------
BOOL __usercall sub_437B7E@<eax>(char a1@<al>)
{
  return a1 >= 48 && a1 <= 57 || a1 >= 97 && a1 <= 102 || (unsigned __int8)(a1 - 65) <= 5u;
}

//----- (00437B9B) --------------------------------------------------------
int __cdecl xmlURIUnescapeString(const char *a1, int a2, int a3)
{
  const char *v3; // esi
  int v5; // edi
  int v6; // ebx
  _BYTE *v7; // ecx
  char *v8; // edx
  char v9; // al
  char v10; // al
  _BYTE *v11; // esi
  char v12; // al
  char v13; // dl

  v3 = a1;
  if ( !a1 )
    return 0;
  v5 = a2;
  if ( a2 <= 0 )
  {
    v5 = strlen(a1);
    if ( v5 < 0 )
      return 0;
  }
  v6 = a3;
  if ( !a3 )
  {
    v6 = xmlMallocAtomic(v5 + 1);
    if ( !v6 )
    {
      xmlGenericError(xmlGenericErrorContext, "xmlURIUnescapeString: out of memory\n");
      return 0;
    }
  }
  v7 = (_BYTE *)v6;
  while ( v5 > 0 )
  {
    if ( v5 > 2 && *v3 == 37 && sub_437B7E(v3[1]) && sub_437B7E(v3[2]) )
    {
      v9 = *v8;
      if ( *v8 >= 48 && v9 <= 57 )
      {
        v10 = v9 - 48;
LABEL_23:
        *v7 = v10;
        goto LABEL_24;
      }
      if ( v9 >= 97 && v9 <= 102 )
      {
        v10 = v9 - 87;
        goto LABEL_23;
      }
      if ( v9 >= 65 && v9 <= 70 )
      {
        v10 = v9 - 55;
        goto LABEL_23;
      }
LABEL_24:
      v11 = v8 + 1;
      v12 = v8[1];
      if ( v12 >= 48 && v12 <= 57 )
      {
        v13 = v12 + 16 * (*v7 - 3);
LABEL_33:
        *v7 = v13;
        goto LABEL_34;
      }
      if ( v12 >= 97 && v12 <= 102 )
      {
        v13 = v12 + 16 * *v7 - 87;
        goto LABEL_33;
      }
      if ( v12 >= 65 && v12 <= 70 )
      {
        v13 = v12 + 16 * *v7 - 55;
        goto LABEL_33;
      }
LABEL_34:
      v3 = v11 + 1;
      v5 -= 3;
      ++v7;
    }
    else
    {
      *v7++ = *v3++;
      --v5;
    }
  }
  *v7 = 0;
  return v6;
}
// 437C35: variable 'v8' is possibly undefined
// 437C59: variable 'v7' is possibly undefined
// 49B2BC: using guessed type int (__cdecl *xmlMallocAtomic)(size_t Size);
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);

//----- (00437CB9) --------------------------------------------------------
_BYTE *__cdecl xmlURIEscapeStr(char *Src, _BYTE *a2)
{
  int v3; // eax
  void *v4; // edi
  int i; // esi
  int v6; // eax
  unsigned __int8 v7; // dl
  char v8; // al
  int v9; // esi
  char v10; // al
  unsigned __int8 v11; // dl
  char v12; // al
  SIZE_T Size; // [esp+8h] [ebp-4h]

  if ( !Src )
    return 0;
  if ( !*Src )
    return xmlStrdup(Src);
  v3 = xmlStrlen(Src);
  if ( !v3 )
    return 0;
  Size = v3 + 20;
  v4 = (void *)xmlMallocAtomic(v3 + 20);
  if ( !v4 )
  {
    xmlGenericError(xmlGenericErrorContext, "xmlURIEscapeStr: out of memory\n");
    return 0;
  }
  for ( i = 0; *Src; ++Src )
  {
    if ( Size - i <= 3 )
    {
      Size += 20;
      v6 = xmlRealloc(v4, Size);
      if ( !v6 )
      {
        xmlGenericError(xmlGenericErrorContext, "xmlURIEscapeStr: out of memory\n");
        ((void (__cdecl *)(void *))xmlFree)(v4);
        return 0;
      }
      v4 = (void *)v6;
    }
    v7 = *Src;
    if ( *Src == 64
      || v7 >= 0x61u && v7 <= 0x7Au
      || v7 >= 0x41u && v7 <= 0x5Au
      || v7 >= 0x30u && v7 <= 0x39u
      || v7 == 45
      || v7 == 95
      || v7 == 46
      || v7 == 33
      || v7 == 126
      || v7 == 42
      || v7 == 39
      || v7 == 40
      || v7 == 41
      || xmlStrchr(a2, *Src) )
    {
      *((_BYTE *)v4 + i) = v7;
    }
    else
    {
      *((_BYTE *)v4 + i) = 37;
      v8 = v7 >> 4;
      v9 = i + 1;
      if ( (unsigned __int8)(v7 >> 4) > 9u )
        v10 = v8 + 55;
      else
        v10 = v8 + 48;
      v11 = v7 & 0xF;
      *((_BYTE *)v4 + v9) = v10;
      i = v9 + 1;
      if ( v11 > 9u )
        v12 = v11 + 55;
      else
        v12 = v11 + 48;
      *((_BYTE *)v4 + i) = v12;
    }
    ++i;
  }
  *((_BYTE *)v4 + i) = 0;
  return v4;
}
// 496494: invalid function type has been ignored
// 437DBD: variable 'v7' is possibly undefined
// 49B2BC: using guessed type int (__cdecl *xmlMallocAtomic)(size_t Size);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);

//----- (00437E20) --------------------------------------------------------
_BYTE *__cdecl xmlURIEscape(_BYTE *a1)
{
  _BYTE *v1; // ebx
  char **URI; // eax
  char **v4; // esi
  _BYTE *v5; // eax
  _BYTE *v6; // edi
  _BYTE *v7; // eax
  char *v8; // eax
  _BYTE *v9; // eax
  char *v10; // eax
  _BYTE *v11; // eax
  _BYTE *v12; // eax
  char *v13; // eax
  _BYTE *v14; // eax
  char *v15; // eax
  _BYTE *v16; // eax
  _BYTE *v17; // edi
  _BYTE *v18; // eax
  char *v19; // eax
  _BYTE *v20; // edi
  _BYTE *v21; // eax
  char *v22; // eax
  _BYTE *v23; // eax
  _BYTE *v24; // edi
  char *v25; // eax
  _BYTE *v26; // eax
  _BYTE *Block; // [esp+8h] [ebp-14h]
  _BYTE *Blocka; // [esp+8h] [ebp-14h]
  _BYTE *Blockb; // [esp+8h] [ebp-14h]
  _BYTE *Blockc; // [esp+8h] [ebp-14h]
  char Buffer[12]; // [esp+Ch] [ebp-10h] BYREF

  v1 = 0;
  if ( !a1 )
    return 0;
  URI = (char **)xmlCreateURI();
  v4 = URI;
  if ( !URI )
    return 0;
  URI[9] = (char *)1;
  if ( xmlParseURIReference(URI, a1) )
  {
    xmlFreeURI(v4);
    return 0;
  }
  if ( *v4 )
  {
    v5 = xmlURIEscapeStr(*v4, "+-.");
    v6 = v5;
    if ( !v5 )
      goto LABEL_32;
    v7 = xmlStrcat(0, v5);
    v1 = xmlStrcat(v7, ":");
    ((void (__cdecl *)(_BYTE *))xmlFree)(v6);
  }
  v8 = v4[2];
  if ( v8 )
  {
    Block = xmlURIEscapeStr(v8, "/?;:@");
    if ( !Block )
      goto LABEL_32;
    v9 = xmlStrcat(v1, "//");
    v1 = xmlStrcat(v9, Block);
    ((void (__cdecl *)(_BYTE *))xmlFree)(Block);
  }
  v10 = v4[4];
  if ( v10 )
  {
    Blocka = xmlURIEscapeStr(v10, ";:&=+$,");
    if ( !Blocka )
      goto LABEL_32;
    v11 = xmlStrcat(v1, "//");
    v12 = xmlStrcat(v11, Blocka);
    v1 = xmlStrcat(v12, "@");
    ((void (__cdecl *)(_BYTE *))xmlFree)(Blocka);
  }
  v13 = v4[3];
  if ( v13 )
  {
    Blockb = xmlURIEscapeStr(v13, "/?;:@");
    if ( !Blockb )
      goto LABEL_32;
    if ( !v4[4] )
      v1 = xmlStrcat(v1, "//");
    v1 = xmlStrcat(v1, Blockb);
    ((void (__cdecl *)(_BYTE *))xmlFree)(Blockb);
  }
  if ( v4[5] )
  {
    _snprintf(Buffer, 0xAu, "%d", v4[5]);
    v14 = xmlStrcat(v1, ":");
    v1 = xmlStrcat(v14, Buffer);
  }
  v15 = v4[6];
  if ( v15 )
  {
    v16 = xmlURIEscapeStr(v15, ":@&=+$,/?;");
    v17 = v16;
    if ( !v16 )
      goto LABEL_32;
    v1 = xmlStrcat(v1, v16);
    ((void (__cdecl *)(_BYTE *))xmlFree)(v17);
  }
  if ( v4[10] )
  {
    v18 = xmlStrcat(v1, "?");
    v1 = xmlStrcat(v18, v4[10]);
    goto LABEL_30;
  }
  v19 = v4[7];
  if ( v19 )
  {
    v20 = xmlURIEscapeStr(v19, ";/?:@&=+,$");
    if ( v20 )
    {
      v21 = xmlStrcat(v1, "?");
      v1 = xmlStrcat(v21, v20);
      ((void (__cdecl *)(_BYTE *))xmlFree)(v20);
      goto LABEL_30;
    }
LABEL_32:
    xmlGenericError(xmlGenericErrorContext, "xmlURIEscape: out of memory\n");
    xmlFreeURI(v4);
    return 0;
  }
LABEL_30:
  v22 = v4[1];
  if ( v22 )
  {
    v23 = xmlURIEscapeStr(v22, byte_47627C);
    v24 = v23;
    if ( !v23 )
      goto LABEL_32;
    v1 = xmlStrcat(v1, v23);
    ((void (__cdecl *)(_BYTE *))xmlFree)(v24);
  }
  v25 = v4[8];
  if ( v25 )
  {
    Blockc = xmlURIEscapeStr(v25, "#");
    if ( Blockc )
    {
      v26 = xmlStrcat(v1, "#");
      v1 = xmlStrcat(v26, Blockc);
      ((void (__cdecl *)(_BYTE *))xmlFree)(Blockc);
    }
    else
    {
      xmlGenericError(xmlGenericErrorContext, "xmlURIEscape: out of memory\n");
      v1 = 0;
    }
  }
  xmlFreeURI(v4);
  return v1;
}
// 496494: invalid function type has been ignored
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);

//----- (004380EE) --------------------------------------------------------
void *__cdecl xmlBuildURI(_BYTE *Src, _BYTE *a2)
{
  _DWORD *v2; // esi
  _DWORD *v3; // ebx
  void **v4; // edi
  _DWORD *URI; // eax
  int v6; // eax
  void *v7; // eax
  void **v8; // eax
  void *v9; // eax
  void *v10; // eax
  char *v11; // eax
  size_t v12; // ecx
  const char *v13; // eax
  _BYTE *v14; // eax
  _BYTE *v15; // edx
  int v16; // ecx
  int v17; // eax
  _BYTE *v18; // edx
  _BYTE *v19; // ecx
  char i; // cl
  _DWORD *v22; // [esp+Ch] [ebp-8h]
  void *v23; // [esp+10h] [ebp-4h]
  char *Srca; // [esp+1Ch] [ebp+8h]

  v2 = 0;
  v3 = 0;
  v4 = 0;
  v23 = 0;
  v22 = 0;
  if ( !Src )
    return v23;
  if ( *Src )
  {
    URI = xmlCreateURI();
    v3 = URI;
    v22 = URI;
    if ( !URI )
      return v23;
    v6 = xmlParseURIReference(URI, Src);
  }
  else
  {
    v6 = 0;
  }
  if ( v6 )
    goto LABEL_94;
  if ( v3 && *v3 )
  {
    v7 = xmlStrdup(Src);
LABEL_93:
    v23 = v7;
LABEL_94:
    if ( v3 )
      xmlFreeURI(v3);
    goto LABEL_96;
  }
  if ( a2 )
  {
    v8 = (void **)xmlCreateURI();
    v4 = v8;
    if ( !v8 )
      goto LABEL_94;
    if ( !xmlParseURIReference(v8, a2) )
    {
      if ( !v3 )
      {
        if ( v4[8] )
        {
          ((void (__cdecl *)(void *))xmlFree)(v4[8]);
          v4[8] = 0;
        }
        v23 = xmlSaveUri(v4);
        goto LABEL_96;
      }
      v2 = xmlCreateURI();
      if ( !v2 )
        goto LABEL_94;
      if ( *v3 )
        goto LABEL_14;
      if ( !v3[6] && !v3[2] && !v3[3] )
      {
        if ( *v4 )
          *v2 = xmlMemStrdup(*v4);
        if ( v4[2] )
        {
          v2[2] = xmlMemStrdup(v4[2]);
        }
        else if ( v4[3] )
        {
          v2[3] = xmlMemStrdup(v4[3]);
          if ( v4[4] )
            v2[4] = xmlMemStrdup(v4[4]);
          v2[5] = v4[5];
        }
        if ( v4[6] )
          v2[6] = xmlMemStrdup(v4[6]);
        v9 = (void *)v3[10];
        if ( v9 )
          goto LABEL_35;
        v10 = (void *)v3[7];
        if ( v10 )
          goto LABEL_39;
        v9 = v4[10];
        if ( v9 )
        {
LABEL_35:
          v2[10] = xmlMemStrdup(v9);
          goto LABEL_40;
        }
        v10 = v4[7];
        if ( v10 )
LABEL_39:
          v2[7] = xmlMemStrdup(v10);
LABEL_40:
        if ( v3[8] )
          v2[8] = xmlMemStrdup((void *)v3[8]);
        goto LABEL_92;
      }
      if ( *v4 )
        *v2 = xmlMemStrdup(*v4);
      if ( v3[10] )
      {
        v2[10] = xmlMemStrdup((void *)v3[10]);
      }
      else if ( v3[7] )
      {
        v2[7] = xmlMemStrdup((void *)v3[7]);
      }
      if ( v3[8] )
        v2[8] = xmlMemStrdup((void *)v3[8]);
      if ( v3[2] )
      {
        v2[2] = xmlMemStrdup((void *)v3[2]);
      }
      else
      {
        if ( !v3[3] )
        {
          if ( v4[2] )
          {
            v2[2] = xmlMemStrdup(v4[2]);
          }
          else if ( v4[3] )
          {
            v2[3] = xmlMemStrdup(v4[3]);
            if ( v4[4] )
              v2[4] = xmlMemStrdup(v4[4]);
            v2[5] = v4[5];
          }
          v11 = (char *)v3[6];
          if ( !v11 || *v11 != 47 )
          {
            v12 = 2;
            if ( v11 )
              v12 = strlen(v11) + 2;
            v13 = (const char *)v4[6];
            if ( v13 )
              v12 += strlen(v13);
            v14 = (_BYTE *)xmlMallocAtomic(v12);
            v2[6] = v14;
            if ( !v14 )
            {
              xmlGenericError(xmlGenericErrorContext, "xmlBuildURI: out of memory\n");
              goto LABEL_94;
            }
            *v14 = 0;
            v15 = v4[6];
            v16 = 0;
            v17 = 0;
            if ( v15 && *v15 )
            {
              do
              {
                if ( *((_BYTE *)v4[6] + v16) )
                {
                  do
                  {
                    v18 = v4[6];
                    if ( v18[v16] == 47 )
                      break;
                    ++v16;
                  }
                  while ( v18[v16] );
                }
                if ( !*((_BYTE *)v4[6] + v16) )
                  break;
                if ( v17 < ++v16 )
                {
                  do
                  {
                    *(_BYTE *)(v17 + v2[6]) = *((_BYTE *)v4[6] + v17);
                    ++v17;
                  }
                  while ( v17 < v16 );
                  v3 = v22;
                }
              }
              while ( *((_BYTE *)v4[6] + v16) );
            }
            *(_BYTE *)(v17 + v2[6]) = 0;
            v19 = (_BYTE *)v3[6];
            if ( v19 && *v19 )
            {
              Srca = 0;
              if ( !v17 && v4[3] )
              {
                *(_BYTE *)v2[6] = 47;
                v17 = 1;
              }
              for ( i = *(_BYTE *)v3[6]; i; i = Srca[v3[6]] )
              {
                *(_BYTE *)(v17 + v2[6]) = i;
                ++v17;
                ++Srca;
              }
            }
            *(_BYTE *)(v17 + v2[6]) = 0;
            xmlNormalizeURIPath((_BYTE *)v2[6]);
            goto LABEL_92;
          }
          goto LABEL_91;
        }
        v2[3] = xmlMemStrdup((void *)v3[3]);
        if ( v3[4] )
          v2[4] = xmlMemStrdup((void *)v3[4]);
        v2[5] = v3[5];
      }
      v11 = (char *)v3[6];
      if ( !v11 )
      {
LABEL_92:
        v7 = xmlSaveUri(v2);
        goto LABEL_93;
      }
LABEL_91:
      v2[6] = xmlMemStrdup(v11);
      goto LABEL_92;
    }
  }
  if ( v3 )
  {
LABEL_14:
    v7 = xmlSaveUri(v3);
    goto LABEL_93;
  }
LABEL_96:
  if ( v4 )
    xmlFreeURI(v4);
  if ( v2 )
    xmlFreeURI(v2);
  return v23;
}
// 496494: invalid function type has been ignored
// 43842F: conditional instruction was optimized away because eax.4==0
// 49B2BC: using guessed type int (__cdecl *xmlMallocAtomic)(size_t Size);
// 4A4B74: using guessed type int (__cdecl *xmlMemStrdup)(void *Src);
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);

//----- (004384A8) --------------------------------------------------------
char *__cdecl xmlBuildRelativeURI(_BYTE *Src, _BYTE *a2)
{
  int v2; // edi
  char **URI; // eax
  unsigned __int8 **v4; // eax
  unsigned __int8 **v5; // esi
  char *v6; // eax
  char *v7; // esi
  char *v8; // ebx
  unsigned __int8 *v9; // esi
  char *v10; // eax
  char *v11; // eax
  signed int v12; // edi
  int i; // edx
  unsigned __int8 v14; // cl
  char v15; // dl
  int v16; // ecx
  unsigned __int8 *j; // ecx
  int v18; // ebx
  unsigned int v19; // eax
  _BYTE *v20; // esi
  _BYTE *v21; // esi
  char *v22; // esi
  int v24; // [esp+Ch] [ebp-14h]
  int v25; // [esp+10h] [ebp-10h]
  char **v26; // [esp+14h] [ebp-Ch]
  unsigned __int8 **v27; // [esp+18h] [ebp-8h]
  char *Block; // [esp+1Ch] [ebp-4h]
  char *Srca; // [esp+28h] [ebp+8h]

  v2 = 0;
  Block = 0;
  v25 = 0;
  v27 = 0;
  v24 = 0;
  if ( !Src )
    return 0;
  if ( !*Src )
    return 0;
  URI = (char **)xmlCreateURI();
  v26 = URI;
  if ( !URI )
    return 0;
  if ( *Src == 46 )
  {
    URI[6] = xmlStrdup(Src);
  }
  else if ( xmlParseURIReference(URI, Src) )
  {
    goto LABEL_92;
  }
  if ( !a2 || !*a2 )
  {
    v11 = xmlStrdup(Src);
    goto LABEL_89;
  }
  v4 = (unsigned __int8 **)xmlCreateURI();
  v27 = v4;
  if ( v4 )
  {
    if ( *a2 == 46 )
    {
      v5 = v4;
      v4[6] = xmlStrdup(a2);
      goto LABEL_15;
    }
    if ( !xmlParseURIReference(v4, a2) )
    {
      v5 = v27;
LABEL_15:
      if ( *v26 && (!*v5 || xmlStrcmp(*v5, *v26) || xmlStrcmp(v5[3], v26[3])) )
      {
        v6 = xmlStrdup(Src);
LABEL_20:
        Block = v6;
        goto LABEL_92;
      }
      v7 = v26[6];
      v8 = (char *)v27[6];
      if ( xmlStrEqual(v8, v7) )
      {
        v6 = xmlStrdup(byte_47627C);
        goto LABEL_20;
      }
      if ( !v8 )
      {
        v6 = xmlStrdup(v7);
        goto LABEL_20;
      }
      if ( !v7 )
      {
        v26[6] = "/";
        v24 = 1;
      }
      v9 = v27[6];
      v10 = v26[6];
      if ( !v9 )
      {
        if ( !v10 )
          goto LABEL_90;
        if ( *v10 == 47 )
          ++v10;
        v11 = xmlURIEscapeStr(v10, "/;&=+$,");
        goto LABEL_89;
      }
      if ( v10 )
      {
        if ( *v10 == 46 && v10[1] == 47 )
          v2 = 2;
        if ( *v9 == 46 && v9[1] == 47 )
        {
          v9 += 2;
        }
        else if ( *v9 == 47 && v10[v2] != 47 )
        {
          ++v9;
        }
        for ( i = v10[v2]; ; i = v26[6][v2] )
        {
          v14 = v9[v2];
          if ( v14 != i || !v14 )
            break;
          ++v2;
        }
        v15 = v10[v2];
        if ( v9[v2] == v15 )
        {
          v11 = xmlStrdup(byte_47627C);
LABEL_89:
          Block = v11;
LABEL_90:
          if ( v24 )
            v26[6] = 0;
          goto LABEL_92;
        }
        v16 = v2;
        if ( v15 == 47 && v2 > 0 )
        {
          v16 = v2 - 1;
        }
        else if ( !v15 && v2 > 1 && v10[v2 - 1] == 47 )
        {
          v16 = v2 - 2;
        }
        while ( v16 > 0 && v10[v16] != 47 )
          --v16;
        if ( v16 )
          v10 += ++v16;
        Srca = v10;
        for ( j = &v9[v16]; *j; ++j )
        {
          if ( *j == 47 )
            ++v25;
        }
        v12 = xmlStrlen(v10) + 1;
      }
      else
      {
        while ( *v9 )
        {
          if ( *v9 == 47 )
            ++v25;
          ++v9;
        }
        Srca = 0;
        v12 = 1;
      }
      if ( !v25 )
      {
        if ( !Srca )
          goto LABEL_90;
        v11 = xmlURIEscapeStr(Srca, "/;&=+$,");
        goto LABEL_89;
      }
      v18 = v25;
      v19 = xmlMalloc(v12 + 3 * v25);
      Block = (char *)v19;
      if ( !v19 )
      {
        xmlGenericError(xmlGenericErrorContext, "xmlBuildRelativeURI: out of memory\n");
        goto LABEL_90;
      }
      v20 = (_BYTE *)v19;
      while ( v18 > 0 )
      {
        *v20 = 46;
        v21 = v20 + 1;
        *v21++ = 46;
        *v21 = 47;
        v20 = v21 + 1;
        --v18;
      }
      if ( Srca )
      {
        if ( (unsigned int)v20 > v19 && v12 > 0 && *Srca == 47 && *(v20 - 1) == 47 )
        {
          memcpy(v20, Srca + 1, v12 - 1);
          v20[v12 - 2] = 0;
LABEL_87:
          v22 = Block;
          Block = xmlURIEscapeStr(Block, "/;&=+$,");
          ((void (__cdecl *)(char *))xmlFree)(v22);
          goto LABEL_90;
        }
        memcpy(v20, Srca, v12);
      }
      v20[v12 - 1] = 0;
      goto LABEL_87;
    }
  }
LABEL_92:
  xmlFreeURI(v26);
  if ( v27 )
    xmlFreeURI(v27);
  return Block;
}
// 496494: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);

//----- (004387CA) --------------------------------------------------------
_BYTE *__cdecl xmlCanonicPath(char *Source)
{
  char *v1; // edi
  _BYTE *result; // eax
  _DWORD *v3; // eax
  unsigned __int8 *v4; // eax
  int v5; // eax
  int v6; // edx
  char v7; // cl
  _BYTE *v8; // eax
  _BYTE *v9; // esi
  _DWORD *v10; // ebx
  int v11; // esi
  char v12; // al
  char v13; // al
  _BYTE *v14; // eax
  char *v15; // esi
  char *v16; // eax
  _BYTE *v17; // eax
  char *Sourcea; // [esp+Ch] [ebp+8h]

  v1 = Source;
  if ( !Source )
    return 0;
  if ( *Source == 47 && Source[1] == 47 && Source[2] != 47 )
    v1 = Source + 1;
  v3 = xmlParseURI(v1);
  if ( v3 )
  {
    xmlFreeURI(v3);
    return xmlStrdup(v1);
  }
  v4 = xmlStrstr((unsigned __int8 *)v1, "://");
  if ( v4 )
  {
    v5 = v4 - (unsigned __int8 *)v1;
    if ( (unsigned int)(v5 - 1) <= 0x13 )
    {
      v6 = 0;
      if ( v5 <= 0 )
      {
LABEL_16:
        v8 = xmlURIEscapeStr(v1, ":/?_.#&;=");
        v9 = v8;
        if ( v8 )
        {
          v10 = xmlParseURI(v8);
          if ( v10 )
            goto LABEL_18;
        }
      }
      else
      {
        while ( 1 )
        {
          v7 = v1[v6];
          if ( ((unsigned __int8)v7 < 0x61u || (unsigned __int8)v7 > 0x7Au) && (unsigned __int8)(v7 - 65) > 0x19u )
            break;
          if ( ++v6 >= v5 )
            goto LABEL_16;
        }
      }
    }
  }
  result = xmlCreateURI();
  v10 = result;
  if ( result )
  {
    v11 = xmlStrlen(v1);
    Sourcea = (char *)v11;
    if ( v11 > 2
      && v1
      && ((v12 = *v1, (unsigned __int8)*v1 >= 0x61u) && (unsigned __int8)v12 <= 0x7Au
       || (unsigned __int8)v12 >= 0x41u && (unsigned __int8)v12 <= 0x5Au)
      && v1[1] == 58
      && ((v13 = v1[2], v13 == 47) || v13 == 92) )
    {
      *v10 = xmlStrdup("file");
      v14 = (_BYTE *)xmlMallocAtomic(v11 + 2);
      v10[6] = v14;
      if ( !v14 )
      {
LABEL_31:
        v9 = 0;
LABEL_18:
        xmlFreeURI(v10);
        return v9;
      }
      *v14 = 47;
      v15 = (char *)(v10[6] + 1);
      strncpy(v15, v1, (size_t)(Sourcea + 1));
    }
    else
    {
      v16 = xmlStrdup(v1);
      v10[6] = v16;
      if ( !v16 )
        goto LABEL_31;
      v15 = v16;
    }
    while ( *v15 )
    {
      if ( *v15 == 92 )
        *v15 = 47;
      ++v15;
    }
    if ( *v10 )
      v17 = xmlSaveUri(v10);
    else
      v17 = xmlStrdup((_BYTE *)v10[6]);
    v9 = v17;
    goto LABEL_18;
  }
  return result;
}
// 49B2BC: using guessed type int (__cdecl *xmlMallocAtomic)(size_t Size);

//----- (00438932) --------------------------------------------------------
_BYTE *__cdecl xmlPathToURI(char *Src)
{
  _DWORD *v2; // eax
  _BYTE *v3; // eax
  int v4; // esi
  _DWORD *v5; // eax
  _BYTE *i; // eax
  void *v7; // edi
  int v8[11]; // [esp+4h] [ebp-2Ch] BYREF

  if ( !Src )
    return 0;
  v2 = xmlParseURI(Src);
  if ( v2 )
  {
    xmlFreeURI(v2);
    return xmlStrdup(Src);
  }
  else
  {
    v3 = xmlCanonicPath(Src);
    v4 = (int)v3;
    if ( !v3 )
      return 0;
    v5 = xmlParseURI(v3);
    if ( v5 )
    {
      xmlFreeURI(v5);
      return (_BYTE *)v4;
    }
    else
    {
      for ( i = (_BYTE *)v4; *i; ++i )
      {
        if ( *i == 92 )
          *i = 47;
      }
      memset(v8, 0, sizeof(v8));
      v8[6] = v4;
      v7 = xmlSaveUri(v8);
      ((void (__cdecl *)(int))xmlFree)(v4);
      return v7;
    }
  }
}
// 496494: invalid function type has been ignored

//----- (004389C3) --------------------------------------------------------
int xmlInitializeDict()
{
  int result; // eax

  if ( dword_4A9C1C )
    return 1;
  result = (int)malloc(4u);
  dword_4A9C18 = result;
  if ( result )
  {
    result = 1;
    dword_4A9C1C = 1;
  }
  return result;
}
// 4A9C18: using guessed type int dword_4A9C18;
// 4A9C1C: using guessed type int dword_4A9C1C;

//----- (004389EB) --------------------------------------------------------
void xmlDictCleanup()
{
  if ( dword_4A9C1C )
  {
    xmlFreeRMutex((void *)dword_4A9C18);
    dword_4A9C1C = 0;
  }
}
// 4A9C18: using guessed type int dword_4A9C18;
// 4A9C1C: using guessed type int dword_4A9C1C;

//----- (00438A08) --------------------------------------------------------
_DWORD *__usercall sub_438A08@<eax>(int a1@<eax>, void *Src, int Size)
{
  _DWORD *v4; // esi
  int v5; // eax
  int v6; // edi
  _DWORD *result; // eax
  void *v8; // ebx

  v4 = *(_DWORD **)(a1 + 16);
  v5 = 0;
  if ( v4 )
  {
    while ( v4[2] - v4[1] <= Size )
    {
      if ( v4[3] > v5 )
        v5 = v4[3];
      v4 = (_DWORD *)*v4;
      if ( !v4 )
      {
        if ( !v5 )
          goto LABEL_7;
        v6 = v5;
        goto LABEL_9;
      }
    }
    goto LABEL_13;
  }
LABEL_7:
  v6 = 250;
LABEL_9:
  if ( v6 < Size )
    v6 = Size;
  result = (_DWORD *)xmlMalloc(v6 * 4 + 24);
  v4 = result;
  if ( result )
  {
    result[4] = 0;
    result[1] = result + 5;
    result[3] = v6 * 4;
    result[2] = &result[v6 + 5];
    *result = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 16) = result;
LABEL_13:
    v8 = (void *)v4[1];
    memcpy(v8, Src, Size);
    v4[1] += Size;
    *(_BYTE *)v4[1]++ = 0;
    ++v4[4];
    return v8;
  }
  return result;
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (00438AA6) --------------------------------------------------------
_DWORD *__usercall sub_438AA6@<eax>(size_t a1@<ebx>, int a2, void *Src, size_t Size, void *a5)
{
  int v5; // ecx
  _DWORD *result; // eax
  _DWORD *v7; // esi
  int v8; // edi
  void *v9; // edi

  v5 = 0;
  if ( !Src )
    return sub_438A08(a2, a5, a1);
  v7 = *(_DWORD **)(a2 + 16);
  if ( v7 )
  {
    while ( v7[2] - v7[1] <= (int)(Size + a1 + 1) )
    {
      if ( v7[3] > v5 )
        v5 = v7[3];
      v7 = (_DWORD *)*v7;
      if ( !v7 )
      {
        if ( !v5 )
          goto LABEL_9;
        v8 = 4 * v5;
        goto LABEL_11;
      }
    }
    goto LABEL_15;
  }
LABEL_9:
  v8 = 1000;
LABEL_11:
  if ( v8 < (int)(4 * (a1 + Size) + 4) )
    v8 = 4 * (a1 + Size) + 4;
  result = (_DWORD *)xmlMalloc(v8 + 24);
  v7 = result;
  if ( result )
  {
    result[4] = 0;
    result[1] = result + 5;
    result[2] = (char *)result + v8 + 20;
    result[3] = v8;
    *result = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(a2 + 16) = result;
LABEL_15:
    v9 = (void *)v7[1];
    memcpy(v9, Src, Size);
    v7[1] += Size;
    *(_BYTE *)v7[1]++ = 58;
    memcpy((void *)v7[1], a5, a1);
    v7[1] += a1;
    *(_BYTE *)v7[1]++ = 0;
    ++v7[4];
    return v9;
  }
  return result;
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (00438B7E) --------------------------------------------------------
unsigned int __usercall sub_438B7E@<eax>(int a1@<edx>, int a2@<ecx>, int a3)
{
  int v3; // eax
  unsigned int v4; // ecx

  v3 = 0;
  if ( a3 <= 0 || !a1 )
    return 0;
  do
  {
    v4 = 1025 * (a2 + *(unsigned __int8 *)(v3 + a1));
    a2 = (v4 >> 6) ^ v4;
    ++v3;
  }
  while ( v3 < a3 );
  return 32769 * ((9 * a2) ^ ((unsigned int)(9 * a2) >> 11));
}
// 438B8E: conditional instruction was optimized away because %arg_0.4>=1

//----- (00438BC0) --------------------------------------------------------
unsigned int __usercall sub_438BC0@<eax>(int a1@<eax>, int a2, int a3, int a4, int a5)
{
  int i; // ecx
  unsigned int v6; // eax
  unsigned int v7; // ecx
  int j; // eax
  unsigned int v9; // ecx

  for ( i = 0; i < a3; ++i )
  {
    v6 = 1025 * (a1 + *(unsigned __int8 *)(i + a2));
    a1 = (v6 >> 6) ^ v6;
  }
  v7 = ((unsigned int)(1025 * (a1 + 58)) >> 6) ^ (1025 * (a1 + 58));
  for ( j = 0; j < a5; ++j )
  {
    v9 = 1025 * (v7 + *(unsigned __int8 *)(j + a4));
    v7 = (v9 >> 6) ^ v9;
  }
  return 32769 * ((9 * v7) ^ ((9 * v7) >> 11));
}

//----- (00438C2B) --------------------------------------------------------
int __fastcall sub_438C2B(unsigned __int8 *a1, int a2)
{
  int result; // eax

  if ( !a1 )
    return 0;
  result = 32 * *a1;
  if ( a2 > 10 )
  {
    result += a1[a2 - 1];
    a2 = 10;
  }
  switch ( a2 )
  {
    case 2:
      goto LABEL_14;
    case 3:
      goto LABEL_13;
    case 4:
      goto LABEL_12;
    case 5:
      goto LABEL_11;
    case 6:
      goto LABEL_10;
    case 7:
      goto LABEL_9;
    case 8:
      goto LABEL_8;
    case 9:
      goto LABEL_7;
    case 10:
      result += a1[9];
LABEL_7:
      result += a1[8];
LABEL_8:
      result += a1[7];
LABEL_9:
      result += a1[6];
LABEL_10:
      result += a1[5];
LABEL_11:
      result += a1[4];
LABEL_12:
      result += a1[3];
LABEL_13:
      result += a1[2];
LABEL_14:
      result += a1[1];
      break;
    default:
      return result;
  }
  return result;
}

//----- (00438CB3) --------------------------------------------------------
int __usercall sub_438CB3@<eax>(int a1@<eax>, unsigned __int8 *a2@<edx>, unsigned __int8 *a3@<ecx>, int a4, int a5)
{
  int v5; // ebx
  int v6; // edi
  int result; // eax
  int v8; // ebx

  v5 = a5;
  v6 = a4;
  if ( a4 )
    result = a1 + 30 * *a3;
  else
    result = a1 + 1740;
  if ( a5 > 10 )
  {
    result += a2[a5 - a4 - 2];
    v6 = a4;
    v5 = 10;
    if ( a4 > 10 )
      v6 = 10;
  }
  switch ( v6 )
  {
    case 1:
      goto LABEL_17;
    case 2:
      goto LABEL_16;
    case 3:
      goto LABEL_15;
    case 4:
      goto LABEL_14;
    case 5:
      goto LABEL_13;
    case 6:
      goto LABEL_12;
    case 7:
      goto LABEL_11;
    case 8:
      goto LABEL_10;
    case 9:
      goto LABEL_9;
    case 10:
      result += a3[9];
LABEL_9:
      result += a3[8];
LABEL_10:
      result += a3[7];
LABEL_11:
      result += a3[6];
LABEL_12:
      result += a3[5];
LABEL_13:
      result += a3[4];
LABEL_14:
      result += a3[3];
LABEL_15:
      result += a3[2];
LABEL_16:
      result += a3[1];
LABEL_17:
      result += *a3;
      break;
    default:
      break;
  }
  v8 = v5 - v6;
  if ( v8 > 0 )
  {
    result += 58;
    --v8;
  }
  switch ( v8 )
  {
    case 1:
      goto LABEL_30;
    case 2:
      goto LABEL_29;
    case 3:
      goto LABEL_28;
    case 4:
      goto LABEL_27;
    case 5:
      goto LABEL_26;
    case 6:
      goto LABEL_25;
    case 7:
      goto LABEL_24;
    case 8:
      goto LABEL_23;
    case 9:
      goto LABEL_22;
    case 10:
      result += a2[9];
LABEL_22:
      result += a2[8];
LABEL_23:
      result += a2[7];
LABEL_24:
      result += a2[6];
LABEL_25:
      result += a2[5];
LABEL_26:
      result += a2[4];
LABEL_27:
      result += a2[3];
LABEL_28:
      result += a2[2];
LABEL_29:
      result += a2[1];
LABEL_30:
      result += *a2;
      break;
    default:
      return result;
  }
  return result;
}

//----- (00438DEB) --------------------------------------------------------
int xmlDictCreate()
{
  int result; // eax
  _DWORD *v1; // eax
  _DWORD *v2; // esi
  void *v3; // eax

  if ( dword_4A9C1C || (result = xmlInitializeDict()) != 0 )
  {
    v1 = (_DWORD *)xmlMalloc(28);
    v2 = v1;
    if ( v1 )
    {
      *v1 = 1;
      v1[2] = 128;
      v1[3] = 0;
      v3 = (void *)xmlMalloc(2560);
      v2[1] = v3;
      v2[4] = 0;
      v2[5] = 0;
      if ( v3 )
      {
        memset(v3, 0, 0xA00u);
        v2[6] = 0;
        return (int)v2;
      }
      ((void (__cdecl *)(_DWORD *))xmlFree)(v2);
    }
    return 0;
  }
  return result;
}
// 496494: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A9C1C: using guessed type int dword_4A9C1C;

//----- (00438E5C) --------------------------------------------------------
int __cdecl xmlDictCreateSub(_DWORD *a1)
{
  int v1; // esi

  v1 = xmlDictCreate();
  if ( v1 && a1 )
  {
    *(_DWORD *)(v1 + 24) = a1[6];
    *(_DWORD *)(v1 + 20) = a1;
    xmlDictReference(a1);
  }
  return v1;
}

//----- (00438E84) --------------------------------------------------------
int __cdecl xmlDictReference(_DWORD *a1)
{
  if ( !dword_4A9C1C && !xmlInitializeDict() || !a1 )
    return -1;
  ++*a1;
  return 0;
}
// 4A9C1C: using guessed type int dword_4A9C1C;

//----- (00438EA7) --------------------------------------------------------
int __usercall sub_438EA7@<eax>(int a1@<eax>, _DWORD *a2@<ebx>)
{
  void *v4; // eax
  char *v5; // esi
  unsigned int v6; // eax
  unsigned int v7; // edi
  int v8; // edx
  _DWORD *v9; // eax
  _DWORD *v10; // eax
  bool v11; // zf
  void *v12; // esi
  void *v13; // edi
  unsigned int v14; // eax
  unsigned int v15; // ecx
  int v16; // edx
  _DWORD *v17; // eax
  int v18; // [esp+4h] [ebp-20h]
  void *v19; // [esp+4h] [ebp-20h]
  int v20; // [esp+8h] [ebp-1Ch]
  int v21; // [esp+Ch] [ebp-18h]
  char *v22; // [esp+10h] [ebp-14h]
  void **v23; // [esp+10h] [ebp-14h]
  char *Block; // [esp+14h] [ebp-10h]
  void *Blocka; // [esp+14h] [ebp-10h]
  int v26; // [esp+18h] [ebp-Ch]
  void **v27; // [esp+1Ch] [ebp-8h]
  unsigned int v28; // [esp+20h] [ebp-4h]
  unsigned int v29; // [esp+20h] [ebp-4h]

  v20 = 0;
  v26 = 1;
  if ( !a2 )
    return -1;
  if ( a1 < 8 )
    return -1;
  if ( a1 > 0x4000 )
    return -1;
  v21 = a2[2];
  v27 = (void **)a2[1];
  if ( !v27 )
    return -1;
  if ( a2[2] == 128 )
    v26 = 0;
  v4 = (void *)xmlMalloc(20 * a1);
  a2[1] = v4;
  if ( v4 )
  {
    memset(v4, 0, 20 * a1);
    a2[2] = a1;
    if ( v21 > 0 )
    {
      v5 = (char *)(v27 + 1);
      v22 = (char *)(v27 + 1);
      Block = (char *)v21;
      do
      {
        if ( *((_DWORD *)v5 + 2) )
        {
          if ( v26 )
          {
            v6 = *((_DWORD *)v5 + 3);
          }
          else if ( a2[2] == 128 )
          {
            v6 = sub_438C2B(*(unsigned __int8 **)v5, *((_DWORD *)v5 + 1));
          }
          else
          {
            v6 = sub_438B7E(*(_DWORD *)v5, a2[6], *((_DWORD *)v5 + 1));
          }
          v28 = v6;
          v7 = v6;
          v8 = 20 * (v6 % a2[2]);
          v9 = (_DWORD *)(v8 + a2[1]);
          v18 = v8;
          if ( v9[3] )
          {
            v10 = (_DWORD *)xmlMalloc(20);
            if ( v10 )
            {
              v10[1] = *(_DWORD *)v5;
              v10[2] = *((_DWORD *)v5 + 1);
              v10[4] = v7;
              *v10 = *(_DWORD *)(v18 + a2[1]);
              v10[3] = 1;
              *(_DWORD *)(v18 + a2[1]) = v10;
            }
            else
            {
              v20 = -1;
            }
          }
          else
          {
            qmemcpy(v9, v5 - 4, 0x14u);
            *(_DWORD *)(v8 + a2[1]) = 0;
            v5 = v22;
            *(_DWORD *)(a2[1] + v8 + 16) = v28;
          }
        }
        v5 += 20;
        v11 = Block-- == (char *)1;
        v22 = v5;
      }
      while ( !v11 );
    }
    if ( v21 > 0 )
    {
      v23 = v27;
      do
      {
        v12 = *v23;
        Blocka = *v23;
        if ( *v23 )
        {
          while ( 1 )
          {
            v13 = *(void **)v12;
            v19 = *(void **)v12;
            if ( v26 )
              v14 = *((_DWORD *)v12 + 4);
            else
              v14 = a2[2] == 128
                  ? sub_438C2B(*((unsigned __int8 **)v12 + 1), *((_DWORD *)v12 + 2))
                  : sub_438B7E(*((_DWORD *)v12 + 1), a2[6], *((_DWORD *)v12 + 2));
            v29 = v14;
            v15 = v14;
            v16 = 20 * (v14 % a2[2]);
            v17 = (_DWORD *)(v16 + a2[1]);
            if ( v17[3] )
            {
              *(_DWORD *)v12 = *v17;
              *((_DWORD *)v12 + 4) = v15;
              *(_DWORD *)(v16 + a2[1]) = v12;
            }
            else
            {
              qmemcpy(v17, v12, 0x14u);
              *(_DWORD *)(v16 + a2[1]) = 0;
              *(_DWORD *)(a2[1] + v16 + 12) = 1;
              *(_DWORD *)(a2[1] + v16 + 16) = v29;
              ((void (__cdecl *)(void *))xmlFree)(Blocka);
              v13 = v19;
            }
            Blocka = v13;
            if ( !v13 )
              break;
            v12 = v13;
          }
        }
        v23 += 5;
        --v21;
      }
      while ( v21 );
    }
    ((void (__cdecl *)(void **))xmlFree)(v27);
    return v20;
  }
  else
  {
    a2[1] = v27;
    return -1;
  }
}
// 496494: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (004390D2) --------------------------------------------------------
void __cdecl xmlDictFree(void **Block)
{
  _DWORD *v2; // eax
  int v3; // ecx
  _DWORD *v4; // edi
  _DWORD *v5; // eax
  _DWORD *v6; // edi
  int v7; // [esp+8h] [ebp-4h]
  char *Blocka; // [esp+14h] [ebp+8h]

  if ( Block && (dword_4A9C1C || xmlInitializeDict()) )
  {
    *Block = (char *)*Block - 1;
    if ( (int)*Block <= 0 )
    {
      if ( Block[5] )
        xmlDictFree(Block[5]);
      if ( Block[1] )
      {
        v7 = 0;
        if ( (int)Block[2] > 0 )
        {
          Blocka = 0;
          do
          {
            if ( (int)Block[3] <= 0 )
              break;
            v2 = (char *)Block[1] + (_DWORD)Blocka;
            if ( v2[3] )
            {
              v3 = 1;
              do
              {
                v4 = (_DWORD *)*v2;
                if ( !v3 )
                  ((void (__cdecl *)(_DWORD *))xmlFree)(v2);
                Block[3] = (char *)Block[3] - 1;
                v3 = 0;
                v2 = v4;
              }
              while ( v4 );
            }
            ++v7;
            Blocka += 20;
          }
          while ( v7 < (int)Block[2] );
        }
        ((void (__cdecl *)(void *))xmlFree)(Block[1]);
      }
      v5 = Block[4];
      if ( v5 )
      {
        do
        {
          v6 = (_DWORD *)*v5;
          ((void (__cdecl *)(_DWORD *))xmlFree)(v5);
          v5 = v6;
        }
        while ( v6 );
      }
      ((void (__cdecl *)(void **))xmlFree)(Block);
    }
  }
}
// 496494: invalid function type has been ignored
// 4A9C1C: using guessed type int dword_4A9C1C;

//----- (0043918C) --------------------------------------------------------
unsigned __int8 *__cdecl xmlDictLookup(_DWORD *a1, char *Src, int Size)
{
  _DWORD *v3; // esi
  unsigned int v4; // edi
  unsigned int v5; // eax
  int v6; // edx
  int v7; // ecx
  int **i; // edi
  int v9; // ebx
  int *v10; // esi
  unsigned __int8 *v11; // esi
  _DWORD *v13; // esi
  unsigned int v14; // eax
  int v15; // esi
  int v16; // ebx
  int *v18; // eax
  int v19; // eax
  int v20; // [esp+Ch] [ebp-10h]
  unsigned int v21; // [esp+10h] [ebp-Ch]
  unsigned int v22; // [esp+14h] [ebp-8h]
  unsigned int v23; // [esp+18h] [ebp-4h]
  _DWORD *v24; // [esp+24h] [ebp+8h]

  v21 = 0;
  v3 = a1;
  if ( !a1 || !Src )
    return 0;
  if ( Size < 0 )
    Size = strlen(Src);
  v4 = a1[2];
  if ( v4 == 128 )
    v5 = sub_438C2B((unsigned __int8 *)Src, Size);
  else
    v5 = sub_438B7E((int)Src, a1[6], Size);
  v23 = v5;
  v6 = v5 % v4;
  v7 = a1[1];
  i = 0;
  v9 = v6;
  v20 = v6;
  if ( *(_DWORD *)(v7 + 20 * v6 + 12) )
  {
    for ( i = (int **)(v7 + 20 * v6); ; i = (int **)v10 )
    {
      v10 = *i;
      if ( !*i )
        break;
      if ( i[4] == (int *)v23 && i[2] == (int *)Size && !xmlStrncmp((unsigned __int8 *)i[1], Src, Size) )
        return (unsigned __int8 *)i[1];
      ++v21;
    }
    if ( i[4] == (int *)v23 && i[2] == (int *)Size )
    {
      v11 = (unsigned __int8 *)i[1];
      if ( !xmlStrncmp(v11, Src, Size) )
        return v11;
    }
    v3 = a1;
  }
  v13 = (_DWORD *)v3[5];
  if ( v13 )
  {
    if ( a1[2] == 128 )
    {
      if ( v13[2] != 128 )
      {
        v14 = sub_438B7E((int)Src, v13[6], Size);
        goto LABEL_29;
      }
    }
    else if ( v13[2] == 128 )
    {
      v14 = sub_438C2B((unsigned __int8 *)Src, Size);
      goto LABEL_29;
    }
    v14 = v23;
LABEL_29:
    v22 = v14;
    v15 = v13[1] + 20 * (v14 % v13[2]);
    if ( *(_DWORD *)(v15 + 12) )
    {
      while ( 1 )
      {
        v16 = *(_DWORD *)v15;
        if ( !*(_DWORD *)v15 )
          break;
        if ( *(_DWORD *)(v15 + 16) == v22
          && *(_DWORD *)(v15 + 8) == Size
          && !xmlStrncmp(*(unsigned __int8 **)(v15 + 4), Src, Size) )
        {
          return *(unsigned __int8 **)(v15 + 4);
        }
        ++v21;
        v15 = v16;
      }
      if ( *(_DWORD *)(v15 + 16) == v22 && *(_DWORD *)(v15 + 8) == Size )
      {
        v11 = *(unsigned __int8 **)(v15 + 4);
        if ( !xmlStrncmp(v11, Src, Size) )
          return v11;
      }
    }
    v9 = v20;
  }
  v24 = sub_438A08((int)a1, Src, Size);
  if ( v24 )
  {
    if ( i )
    {
      v18 = (int *)xmlMalloc(20);
      if ( !v18 )
        return 0;
    }
    else
    {
      v18 = (int *)(a1[1] + 20 * v9);
    }
    *v18 = 0;
    v18[1] = (int)v24;
    v18[2] = Size;
    v18[3] = 1;
    v18[4] = v23;
    if ( i )
      *i = v18;
    ++a1[3];
    if ( v21 <= 3 )
      return (unsigned __int8 *)v24;
    v19 = a1[2];
    if ( v19 > 2730 || !sub_438EA7(6 * v19, a1) )
      return (unsigned __int8 *)v24;
  }
  return 0;
}
// 439293: conditional instruction was optimized away because edx.4==80
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (004393B7) --------------------------------------------------------
unsigned __int8 *__cdecl xmlDictExists(_DWORD *a1, char *a2, int a3)
{
  _DWORD *v3; // edi
  unsigned int v4; // esi
  unsigned int v5; // eax
  int i; // esi
  int v7; // edi
  unsigned __int8 *v8; // esi
  _DWORD *v10; // esi
  unsigned int v11; // eax
  unsigned int v12; // ebx
  int v13; // edx
  int v14; // edi
  unsigned int v15; // [esp+Ch] [ebp-4h]

  v3 = a1;
  if ( a1 && a2 )
  {
    if ( a3 < 0 )
      a3 = strlen(a2);
    v4 = a1[2];
    if ( v4 == 128 )
      v5 = sub_438C2B((unsigned __int8 *)a2, a3);
    else
      v5 = sub_438B7E((int)a2, a1[6], a3);
    v15 = v5;
    i = 20 * (v5 % v4) + a1[1];
    if ( *(_DWORD *)(i + 12) )
    {
      while ( 1 )
      {
        v7 = *(_DWORD *)i;
        if ( !*(_DWORD *)i )
          break;
        if ( *(_DWORD *)(i + 16) == v15 && *(_DWORD *)(i + 8) == a3 && !xmlStrncmp(*(unsigned __int8 **)(i + 4), a2, a3) )
          return *(unsigned __int8 **)(i + 4);
        i = v7;
      }
      if ( *(_DWORD *)(i + 16) == v15 && *(_DWORD *)(i + 8) == a3 )
      {
        v8 = *(unsigned __int8 **)(i + 4);
        if ( !xmlStrncmp(v8, a2, a3) )
          return v8;
      }
      v3 = a1;
    }
    v10 = (_DWORD *)v3[5];
    if ( v10 )
    {
      if ( v3[2] == 128 )
      {
        if ( v10[2] == 128 )
          goto LABEL_29;
        v11 = sub_438B7E((int)a2, v10[6], a3);
      }
      else
      {
        if ( v10[2] != 128 )
        {
LABEL_29:
          v12 = v15;
          goto LABEL_30;
        }
        v11 = sub_438C2B((unsigned __int8 *)a2, a3);
      }
      v12 = v11;
LABEL_30:
      v13 = 20 * (v12 % v10[2]);
      if ( *(_DWORD *)(v10[1] + v13 + 12) )
      {
        for ( i = v13 + v10[1]; ; i = v14 )
        {
          v14 = *(_DWORD *)i;
          if ( !*(_DWORD *)i )
            break;
          if ( *(_DWORD *)(i + 16) == v12
            && *(_DWORD *)(i + 8) == a3
            && !xmlStrncmp(*(unsigned __int8 **)(i + 4), a2, a3) )
          {
            return *(unsigned __int8 **)(i + 4);
          }
        }
        if ( *(_DWORD *)(i + 16) == v12 && *(_DWORD *)(i + 8) == a3 )
        {
          v8 = *(unsigned __int8 **)(i + 4);
          if ( !xmlStrncmp(v8, a2, a3) )
            return v8;
        }
      }
    }
  }
  return 0;
}
// 4394A5: conditional instruction was optimized away because ecx.4==80

//----- (00439546) --------------------------------------------------------
unsigned __int8 *__cdecl xmlDictQLookup(_DWORD *a1, char *a2, char *Src)
{
  int v4; // ecx
  int v5; // eax
  unsigned int v6; // esi
  unsigned int v7; // eax
  int i; // edi
  int v9; // eax
  int v10; // esi
  char *v11; // esi
  int v12; // eax
  _DWORD *v13; // esi
  unsigned int v14; // eax
  int v15; // esi
  int v16; // ebx
  _DWORD *v17; // ebx
  _DWORD *v18; // eax
  int v19; // eax
  int v20; // [esp+Ch] [ebp-1Ch]
  size_t v21; // [esp+10h] [ebp-18h]
  unsigned int v22; // [esp+14h] [ebp-14h]
  int v23; // [esp+18h] [ebp-10h]
  size_t v24; // [esp+1Ch] [ebp-Ch]
  int v25; // [esp+20h] [ebp-8h]
  unsigned int v26; // [esp+20h] [ebp-8h]
  unsigned int v27; // [esp+24h] [ebp-4h]

  v22 = 0;
  if ( !a1 || !Src )
    return 0;
  if ( !a2 )
    return xmlDictLookup(a1, Src, -1);
  v4 = strlen(Src);
  v24 = v4;
  v5 = strlen(a2);
  v6 = a1[2];
  v21 = v5;
  v23 = v4 + v5 + 1;
  if ( v6 == 128 )
    v7 = sub_438CB3(a1[6], (unsigned __int8 *)Src, (unsigned __int8 *)a2, v5, v4);
  else
    v7 = sub_438BC0(a1[6], (int)a2, v5, (int)Src, v4);
  v27 = v7;
  i = 0;
  v20 = v7 % v6;
  v25 = v7 % v6;
  v9 = 20 * (v7 % v6) + a1[1];
  if ( *(_DWORD *)(v9 + 12) )
  {
    for ( i = v9; ; i = v10 )
    {
      v10 = *(_DWORD *)i;
      if ( !*(_DWORD *)i )
        break;
      if ( *(_DWORD *)(i + 16) == v27 && *(_DWORD *)(i + 8) == v23 && xmlStrQEqual(a2, Src, *(char **)(i + 4)) )
        return *(unsigned __int8 **)(i + 4);
      ++v22;
    }
    if ( *(_DWORD *)(i + 16) == v27 && *(_DWORD *)(i + 8) == v23 )
    {
      v11 = *(char **)(i + 4);
      if ( xmlStrQEqual(a2, Src, v11) )
        return (unsigned __int8 *)v11;
    }
  }
  v12 = (int)a1;
  v13 = (_DWORD *)a1[5];
  if ( v13 )
  {
    if ( a1[2] == 128 )
    {
      if ( v13[2] != 128 )
      {
        v14 = sub_438BC0(v13[6], (int)a2, v21, (int)Src, v24);
        goto LABEL_28;
      }
    }
    else if ( v13[2] == 128 )
    {
      v14 = sub_438CB3(v13[6], (unsigned __int8 *)Src, (unsigned __int8 *)a2, v21, v24);
      goto LABEL_28;
    }
    v14 = v27;
LABEL_28:
    v26 = v14;
    v15 = v13[1] + 20 * (v14 % v13[2]);
    if ( *(_DWORD *)(v15 + 12) )
    {
      while ( 1 )
      {
        v16 = *(_DWORD *)v15;
        if ( !*(_DWORD *)v15 )
          break;
        if ( *(_DWORD *)(v15 + 16) == v26 && *(_DWORD *)(v15 + 8) == v23 && xmlStrQEqual(a2, Src, *(char **)(v15 + 4)) )
          return *(unsigned __int8 **)(v15 + 4);
        ++v22;
        v15 = v16;
      }
      if ( *(_DWORD *)(v15 + 16) == v26 && *(_DWORD *)(v15 + 8) == v23 )
      {
        v11 = *(char **)(v15 + 4);
        if ( xmlStrQEqual(a2, Src, v11) )
          return (unsigned __int8 *)v11;
      }
    }
    v25 = v20;
    v12 = (int)a1;
  }
  v11 = (char *)sub_438AA6(v24, v12, a2, v21, Src);
  if ( v11 )
  {
    if ( !i )
    {
      v17 = a1;
      v18 = (_DWORD *)(a1[1] + 20 * v25);
LABEL_45:
      *v18 = 0;
      v18[2] = v23;
      v18[1] = v11;
      v18[3] = 1;
      v18[4] = v27;
      if ( i )
        *(_DWORD *)i = v18;
      ++v17[3];
      if ( v22 > 3 )
      {
        v19 = v17[2];
        if ( v19 <= 2730 )
          sub_438EA7(6 * v19, v17);
      }
      return (unsigned __int8 *)v11;
    }
    v18 = (_DWORD *)xmlMalloc(20);
    if ( v18 )
    {
      v17 = a1;
      goto LABEL_45;
    }
  }
  return 0;
}
// 43967E: conditional instruction was optimized away because ecx.4==80
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (004397C7) --------------------------------------------------------
int __cdecl xmlDictOwns(int a1, unsigned int a2)
{
  int v2; // ecx
  int result; // eax

  v2 = a1;
  if ( !a1 )
    return -1;
  while ( 2 )
  {
    if ( !a2 )
      return -1;
    for ( result = *(_DWORD *)(v2 + 16); result; result = *(_DWORD *)result )
    {
      if ( a2 >= result + 20 && a2 <= *(_DWORD *)(result + 4) )
        return 1;
    }
    v2 = *(_DWORD *)(v2 + 20);
    if ( v2 )
      continue;
    break;
  }
  return result;
}

//----- (00439802) --------------------------------------------------------
int __cdecl xmlDictSize(int a1)
{
  int v2; // eax

  if ( !a1 )
    return -1;
  v2 = *(_DWORD *)(a1 + 20);
  if ( v2 )
    return *(_DWORD *)(a1 + 12) + *(_DWORD *)(v2 + 12);
  else
    return *(_DWORD *)(a1 + 12);
}

//----- (00439820) --------------------------------------------------------
int __cdecl xmlCharInRange(unsigned int a1, _DWORD *a2)
{
  int result; // eax
  int v3; // edi
  int v4; // esi
  int v5; // ecx
  int v6; // eax
  int v7; // ecx
  int v8; // edi
  int v9; // esi
  int v10; // ecx
  int v11; // eax

  result = (int)a2;
  if ( a2 )
  {
    if ( a1 >= 0x10000 )
    {
      v7 = a2[1];
      if ( v7 )
      {
        v8 = a2[3];
        v9 = 0;
        v10 = v7 - 1;
        if ( v10 >= 0 )
        {
          do
          {
            v11 = (v10 + v9) / 2;
            if ( a1 >= *(_DWORD *)(v8 + 8 * v11) )
            {
              if ( a1 <= *(_DWORD *)(v8 + 8 * v11 + 4) )
                return 1;
              v9 = v11 + 1;
            }
            else
            {
              v10 = v11 - 1;
            }
          }
          while ( v9 <= v10 );
        }
      }
    }
    else if ( *a2 )
    {
      v3 = a2[2];
      v4 = 0;
      v5 = *a2 - 1;
      if ( v5 >= 0 )
      {
        do
        {
          v6 = (v5 + v4) / 2;
          if ( (unsigned __int16)a1 >= *(_WORD *)(v3 + 4 * v6) )
          {
            if ( (unsigned __int16)a1 <= *(_WORD *)(v3 + 4 * v6 + 2) )
              return 1;
            v4 = v6 + 1;
          }
          else
          {
            v5 = v6 - 1;
          }
        }
        while ( v4 <= v5 );
      }
    }
    return 0;
  }
  return result;
}

//----- (004398A2) --------------------------------------------------------
int __cdecl xmlIsBaseChar(unsigned int a1)
{
  if ( a1 >= 0x100 )
    return xmlCharInRange(a1, xmlIsBaseCharGroup);
  return a1 >= 0x41 && a1 <= 0x5A
      || a1 >= 0x61 && a1 <= 0x7A
      || a1 >= 0xC0 && a1 <= 0xD6
      || a1 >= 0xD8 && a1 <= 0xF6
      || a1 >= 0xF8;
}
// 47C2A4: using guessed type _DWORD xmlIsBaseCharGroup[2];

//----- (004398F9) --------------------------------------------------------
BOOL __cdecl xmlIsBlank(unsigned int a1)
{
  return a1 < 0x100 && (a1 == 32 || a1 >= 9 && a1 <= 0xA || a1 == 13);
}

//----- (0043991F) --------------------------------------------------------
int __cdecl xmlIsChar(unsigned int a1)
{
  if ( a1 >= 0x100 )
  {
    if ( a1 > 0xD7FF && (a1 < 0xE000 || a1 > 0xFFFD) && a1 - 0x10000 > 0xFFFFF )
      return 0;
  }
  else if ( (a1 < 9 || a1 > 0xA) && a1 != 13 && a1 < 0x20 )
  {
    return 0;
  }
  return 1;
}

//----- (00439966) --------------------------------------------------------
int __cdecl xmlIsCombining(unsigned int a1)
{
  if ( a1 >= 0x100 )
    return xmlCharInRange(a1, xmlIsCombiningGroup);
  else
    return 0;
}
// 47C454: using guessed type _DWORD xmlIsCombiningGroup[2];

//----- (00439984) --------------------------------------------------------
int __cdecl xmlIsDigit(unsigned int a1)
{
  if ( a1 >= 0x100 )
    return xmlCharInRange(a1, xmlIsDigitGroup);
  else
    return a1 - 48 <= 9;
}
// 47C49C: using guessed type _DWORD xmlIsDigitGroup[2];

//----- (004399A9) --------------------------------------------------------
int __cdecl xmlIsExtender(unsigned int a1)
{
  if ( a1 >= 0x100 )
    return xmlCharInRange(a1, xmlIsExtenderGroup);
  else
    return a1 == 183;
}
// 47C4D4: using guessed type _DWORD xmlIsExtenderGroup[2];

//----- (004399CF) --------------------------------------------------------
BOOL __cdecl xmlIsIdeographic(unsigned int a1)
{
  return a1 >= 0x100 && (a1 >= 0x4E00 && a1 <= 0x9FA5 || a1 == 12295 || a1 >= 0x3021 && a1 <= 0x3029);
}

//----- (00439A04) --------------------------------------------------------
int __cdecl xmlIsPubidChar(unsigned int a1)
{
  if ( a1 >= 0x100 )
    return 0;
  else
    return (unsigned __int8)xmlIsPubidChar_tab[a1];
}

//----- (00439A1A) --------------------------------------------------------
int (__cdecl *__cdecl sub_439A1A(_BYTE *a1))(int, char *Format, char ArgList)
{
  return _xmlSimpleError(27, 2, 0, 0, a1);
}

//----- (00439A2F) --------------------------------------------------------
int (__cdecl *__cdecl sub_439A2F(int a1, char *Format, _BYTE *Src))(int, char *Format, char ArgList)
{
  return _xmlRaiseError(0, 0, 0, 0, 0, 27, a1, 3, 0, 0, Src, 0, 0, 0, 0, Format, Src);
}

//----- (00439A59) --------------------------------------------------------
int __cdecl sub_439A59(_BYTE *a1, int a2, unsigned __int8 *a3, _DWORD *a4)
{
  unsigned __int8 *v4; // ecx
  _BYTE *v5; // eax
  unsigned __int8 *v6; // esi
  unsigned int v7; // edx
  unsigned int v8; // ebx
  unsigned __int8 *v10; // [esp+Ch] [ebp-8h]
  int v12; // [esp+1Ch] [ebp+8h]

  v4 = a3;
  v5 = a1;
  v6 = &a3[*a4];
  v7 = (unsigned int)&a1[*(_DWORD *)a2];
  v10 = a3;
  if ( a3 < v6 )
  {
    v12 = 5;
    do
    {
      if ( v12 >= *(_DWORD *)a2 )
        break;
      v8 = *a3++;
      if ( (unsigned int)v5 >= v7 )
        break;
      if ( v8 >= 0x80 )
      {
        *(_DWORD *)a2 = v5 - a1;
        *a4 = v4 - v10;
        return -1;
      }
      *v5 = v8;
      v4 = a3;
      ++v5;
      ++v12;
    }
    while ( a3 < v6 );
  }
  *(_DWORD *)a2 = v5 - a1;
  *a4 = v4 - v10;
  return *(_DWORD *)a2;
}

//----- (00439ADA) --------------------------------------------------------
int __cdecl sub_439ADA(_BYTE *a1, int a2, char *a3, _DWORD *a4)
{
  _BYTE *v4; // eax
  char *v5; // ecx
  unsigned int v7; // esi
  char v8; // si
  bool v9; // zf
  unsigned int v10; // [esp+Ch] [ebp-18h]
  char *v11; // [esp+14h] [ebp-10h]
  char *v12; // [esp+18h] [ebp-Ch]
  unsigned int v14; // [esp+20h] [ebp-4h]
  int v15; // [esp+2Ch] [ebp+8h]

  v4 = a1;
  v5 = a3;
  v12 = a3;
  if ( !a1 || !a2 || !a4 )
    return -1;
  if ( a3 )
  {
    v11 = &a3[*a4];
    v10 = (unsigned int)&a1[*(_DWORD *)a2];
    if ( a3 >= v11 )
    {
LABEL_24:
      *(_DWORD *)a2 = v4 - a1;
      *a4 = v5 - v12;
      return *(_DWORD *)a2;
    }
    else
    {
      while ( 1 )
      {
        v7 = (unsigned __int8)*a3++;
        if ( v7 >= 0x80 )
        {
          if ( v7 < 0xC0 )
            break;
          if ( v7 >= 0xE0 )
          {
            if ( v7 >= 0xF0 )
            {
              if ( v7 >= 0xF8 )
                break;
              v7 &= 7u;
              v15 = 3;
            }
            else
            {
              v7 &= 0xFu;
              v15 = 2;
            }
          }
          else
          {
            v7 &= 0x1Fu;
            v15 = 1;
          }
        }
        else
        {
          v15 = 0;
        }
        v14 = v7;
        if ( v11 - a3 < v15 )
          goto LABEL_24;
        if ( v15 )
        {
          do
          {
            if ( a3 >= v11 )
              break;
            v8 = *a3++;
            if ( (v8 & 0xC0) != 0x80 )
              break;
            v9 = v15-- == 1;
            v14 = (v14 << 6) | v8 & 0x3F;
          }
          while ( !v9 );
        }
        if ( v14 >= 0x80 )
          break;
        if ( (unsigned int)v4 < v10 )
        {
          *v4 = v14;
          v5 = a3;
          ++v4;
          if ( a3 < v11 )
            continue;
        }
        goto LABEL_24;
      }
      *(_DWORD *)a2 = v4 - a1;
      *a4 = v5 - v12;
      return -2;
    }
  }
  else
  {
    *(_DWORD *)a2 = 0;
    *a4 = 0;
    return 0;
  }
}

//----- (00439C16) --------------------------------------------------------
int __cdecl isolat1ToUTF8(_BYTE *a1, _DWORD *a2, _BYTE *a3, _DWORD *a4)
{
  _BYTE *v4; // ecx
  _BYTE *v5; // eax
  _DWORD *v6; // edx
  unsigned int v7; // esi
  unsigned int v8; // edi
  _BYTE *v9; // ecx
  _BYTE *v12; // [esp+10h] [ebp+8h]

  v4 = a1;
  v5 = a3;
  if ( !a1 )
    return -1;
  if ( !a3 )
    return -1;
  v6 = a2;
  if ( !a2 || !a4 )
    return -1;
  v7 = (unsigned int)&a3[*a4];
  v8 = (unsigned int)&a1[*a2];
  v12 = (_BYTE *)v7;
  if ( (unsigned int)a3 < v7 )
  {
    do
    {
      if ( (unsigned int)v4 >= v8 - 1 )
        break;
      if ( *v5 >= 0x80u )
      {
        *v4 = (*v5 >> 6) | 0xC0;
        v9 = v4 + 1;
        *v9 = *v5 & 0x3F | 0x80;
        v4 = v9 + 1;
        ++v5;
      }
      if ( v12 - v5 > (int)(v8 - (_DWORD)v4) )
        v12 = &v5[v8 - (_DWORD)v4];
      while ( v5 < v12 && *v5 < 0x80u )
        *v4++ = *v5++;
      v6 = a2;
    }
    while ( (unsigned int)v5 < v7 );
    if ( (unsigned int)v5 < v7 && (unsigned int)v4 < v8 && *v5 < 0x80u )
      *v4++ = *v5++;
  }
  *v6 = v4 - a1;
  *a4 = v5 - a3;
  return *v6;
}

//----- (00439CD8) --------------------------------------------------------
int __cdecl sub_439CD8(void *a1, signed int *a2, void *Src, signed int *a4)
{
  signed int v4; // esi

  if ( !a1 || !Src || !a2 || !a4 )
    return -1;
  v4 = *a4;
  if ( *a2 <= *a4 )
    v4 = *a2;
  if ( v4 < 0 )
    return -1;
  memcpy(a1, Src, v4);
  *a2 = v4;
  *a4 = v4;
  return *a2;
}

//----- (00439D25) --------------------------------------------------------
int __cdecl UTF8Toisolat1(_BYTE *a1, int a2, char *a3, _DWORD *a4)
{
  _BYTE *v4; // eax
  char *v5; // ecx
  unsigned int v7; // edi
  char v8; // di
  bool v9; // zf
  unsigned int v10; // [esp+Ch] [ebp-18h]
  char *v11; // [esp+14h] [ebp-10h]
  char *v12; // [esp+18h] [ebp-Ch]
  unsigned int v14; // [esp+20h] [ebp-4h]
  int v15; // [esp+2Ch] [ebp+8h]

  v4 = a1;
  v5 = a3;
  v12 = a3;
  if ( !a1 || !a2 || !a4 )
    return -1;
  if ( a3 )
  {
    v11 = &a3[*a4];
    v10 = (unsigned int)&a1[*(_DWORD *)a2];
    if ( a3 >= v11 )
    {
LABEL_24:
      *(_DWORD *)a2 = v4 - a1;
      *a4 = v5 - v12;
      return *(_DWORD *)a2;
    }
    else
    {
      while ( 1 )
      {
        v7 = (unsigned __int8)*a3++;
        if ( v7 >= 0x80 )
        {
          if ( v7 < 0xC0 )
            break;
          if ( v7 >= 0xE0 )
          {
            if ( v7 >= 0xF0 )
            {
              if ( v7 >= 0xF8 )
                break;
              v7 &= 7u;
              v15 = 3;
            }
            else
            {
              v7 &= 0xFu;
              v15 = 2;
            }
          }
          else
          {
            v7 &= 0x1Fu;
            v15 = 1;
          }
        }
        else
        {
          v15 = 0;
        }
        v14 = v7;
        if ( v11 - a3 < v15 )
          goto LABEL_24;
        if ( v15 )
        {
          do
          {
            if ( a3 >= v11 )
              break;
            v8 = *a3++;
            if ( (v8 & 0xC0) != 0x80 )
              goto LABEL_25;
            v9 = v15-- == 1;
            v14 = (v14 << 6) | v8 & 0x3F;
          }
          while ( !v9 );
        }
        if ( v14 > 0xFF )
          break;
        if ( (unsigned int)v4 < v10 )
        {
          *v4 = v14;
          v5 = a3;
          ++v4;
          if ( a3 < v11 )
            continue;
        }
        goto LABEL_24;
      }
LABEL_25:
      *(_DWORD *)a2 = v4 - a1;
      *a4 = v5 - v12;
      return -2;
    }
  }
  else
  {
    *(_DWORD *)a2 = 0;
    *a4 = 0;
    return 0;
  }
}

//----- (00439E61) --------------------------------------------------------
int __cdecl sub_439E61(_BYTE *a1, int a2, char *a3, _DWORD *a4)
{
  _BYTE *v4; // esi
  char *v5; // edi
  unsigned int v6; // ebx
  char *v7; // ecx
  unsigned int v8; // edx
  __int16 v9; // ax
  char v10; // al
  unsigned int v12; // [esp+Ch] [ebp-Ch]
  unsigned int v13; // [esp+10h] [ebp-8h]
  int v15; // [esp+20h] [ebp+8h]

  v4 = a1;
  v5 = a3;
  v6 = (unsigned int)&a1[*(_DWORD *)a2];
  v7 = a3;
  v12 = v6;
  if ( *a4 % 2 == 1 )
    --*a4;
  v13 = (unsigned int)&a3[2 * (*a4 / 2)];
  if ( (unsigned int)a3 < v13 )
  {
    while ( v4 - a1 + 5 < *(_DWORD *)a2 )
    {
      v8 = *(unsigned __int16 *)v5;
      v5 += 2;
      if ( (v8 & 0xFC00) == 55296 )
      {
        if ( (unsigned int)v5 >= v13 )
          break;
        v9 = *(_WORD *)v5;
        v5 += 2;
        if ( (v9 & 0xFC00) != 56320 )
        {
          *(_DWORD *)a2 = v4 - a1;
          *a4 = v7 - a3;
          return -2;
        }
        v8 = (v9 & 0x3FF | ((v8 & 0x3FF) << 10)) + 0x10000;
        v6 = v12;
      }
      if ( (unsigned int)v4 < v6 )
      {
        if ( v8 >= 0x80 )
        {
          if ( v8 >= 0x800 )
          {
            if ( v8 >= 0x10000 )
            {
              v10 = (v8 >> 18) & 7 | 0xF0;
              v15 = 12;
            }
            else
            {
              v10 = (v8 >> 12) & 0xF | 0xE0;
              v15 = 6;
            }
            *v4++ = v10;
          }
          else
          {
            *v4++ = (v8 >> 6) & 0x1F | 0xC0;
            v15 = 0;
          }
          do
          {
            if ( (unsigned int)v4 >= v6 )
              break;
            *v4++ = (v8 >> v15) & 0x3F | 0x80;
            v15 -= 6;
          }
          while ( v15 >= 0 );
        }
        else
        {
          *v4++ = v8;
        }
        v7 = v5;
        if ( (unsigned int)v5 < v13 )
          continue;
      }
      break;
    }
  }
  *(_DWORD *)a2 = v4 - a1;
  *a4 = v7 - a3;
  return *(_DWORD *)a2;
}

//----- (00439FEC) --------------------------------------------------------
int __cdecl sub_439FEC(unsigned int a1, _DWORD *a2, unsigned __int8 *a3, _DWORD *a4)
{
  unsigned int v4; // ecx
  unsigned __int8 *v5; // esi
  _DWORD *v6; // ebx
  unsigned int v8; // eax
  unsigned __int8 *v9; // edx
  unsigned __int8 v10; // di
  char v11; // bl
  bool v12; // zf
  unsigned int v13; // eax
  unsigned int v14; // eax
  int v15; // edx
  unsigned int v16; // [esp+Ch] [ebp-14h]
  unsigned __int8 *v17; // [esp+10h] [ebp-10h]
  unsigned __int8 *v18; // [esp+14h] [ebp-Ch]
  int v19; // [esp+18h] [ebp-8h]
  unsigned int v20; // [esp+1Ch] [ebp-4h]

  v4 = a1;
  v5 = a3;
  v17 = a3;
  if ( !a1 )
    return -1;
  v6 = a2;
  if ( !a2 || !a4 )
    return -1;
  if ( !a3 )
  {
    *a2 = 0;
    *a4 = 0;
    return 0;
  }
  v18 = &a3[*a4];
  v16 = a1 + 2 * (*a2 / 2);
  if ( a3 >= v18 )
    goto LABEL_37;
  v20 = a1 + 2;
  while ( 1 )
  {
    v8 = *a3;
    v9 = ++a3;
    if ( v8 >= 0x80 )
    {
      if ( v8 < 0xC0 )
        goto LABEL_35;
      if ( v8 >= 0xE0 )
      {
        if ( v8 >= 0xF0 )
        {
          if ( v8 >= 0xF8 )
          {
LABEL_35:
            *v6 = 2 * ((int)(v4 - a1) >> 1);
            *a4 = v5 - v17;
            return -2;
          }
          v8 &= 7u;
          v19 = 3;
        }
        else
        {
          v8 &= 0xFu;
          v19 = 2;
        }
      }
      else
      {
        v8 &= 0x1Fu;
        v19 = 1;
      }
    }
    else
    {
      v19 = 0;
    }
    if ( v18 - v9 < v19 )
      break;
    if ( v19 )
    {
      do
      {
        if ( v9 >= v18 )
          break;
        v10 = *v9;
        v11 = *v9++ & 0xC0;
        a3 = v9;
        if ( v11 != (char)0x80 )
          break;
        v12 = v19-- == 1;
        v8 = (v8 << 6) | v10 & 0x3F;
      }
      while ( !v12 );
    }
    v6 = a2;
    if ( v8 >= 0x10000 )
    {
      if ( v8 >= 0x110000 || v20 >= v16 )
        goto LABEL_37;
      v20 += 2;
      v14 = v8 - 0x10000;
      v15 = (v14 >> 10) | 0xD800;
      v8 = v14 & 0x3FF | 0xDC00;
      if ( !dword_4A4D28 )
      {
        *(_WORD *)v4 = v15;
        v4 += 2;
        *(_BYTE *)v4 = v8;
        v13 = v8 >> 8;
        goto LABEL_32;
      }
      *(_WORD *)v4 = v15;
      v4 += 2;
    }
    else
    {
      if ( v4 >= v16 )
        goto LABEL_37;
      if ( !dword_4A4D28 )
      {
        *(_BYTE *)v4 = v8;
        v13 = v8 >> 8;
LABEL_32:
        *(_BYTE *)(v4 + 1) = v13;
        goto LABEL_33;
      }
    }
    *(_WORD *)v4 = v8;
LABEL_33:
    v5 = a3;
    v20 += 2;
    v4 += 2;
    if ( a3 >= v18 )
      goto LABEL_37;
  }
  v6 = a2;
LABEL_37:
  *v6 = 2 * ((int)(v4 - a1) >> 1);
  *a4 = v5 - v17;
  return *v6;
}
// 4A4D28: using guessed type int dword_4A4D28;

//----- (0043A1B0) --------------------------------------------------------
int __cdecl sub_43A1B0(unsigned int a1, _DWORD *a2, unsigned __int8 *a3, _DWORD *a4)
{
  int result; // eax

  if ( a3 )
    return sub_439FEC(a1, a2, a3, a4);
  if ( (int)*a2 < 2 )
  {
    *a2 = 0;
    result = 0;
  }
  else
  {
    *(_BYTE *)a1 = -1;
    *(_BYTE *)(a1 + 1) = -2;
    *a2 = 2;
    result = 2;
  }
  *a4 = 0;
  return result;
}

//----- (0043A1E6) --------------------------------------------------------
int __cdecl sub_43A1E6(_BYTE *a1, int a2, unsigned __int8 *a3, _DWORD *a4)
{
  unsigned __int8 *v4; // ecx
  _BYTE *v5; // esi
  unsigned int v7; // ebx
  unsigned int v8; // edx
  unsigned __int16 v9; // ax
  char v10; // al
  unsigned int v12; // [esp+Ch] [ebp-Ch]
  unsigned int v13; // [esp+10h] [ebp-8h]
  unsigned __int8 *v15; // [esp+20h] [ebp+8h]
  int v16; // [esp+2Ch] [ebp+14h]

  v4 = a3;
  v5 = a1;
  v7 = (unsigned int)&a1[*(_DWORD *)a2];
  v12 = v7;
  v15 = a3;
  if ( *a4 % 2 == 1 )
    --*a4;
  v13 = (unsigned int)&a3[2 * (*a4 / 2)];
  if ( (unsigned int)a3 >= v13 )
  {
LABEL_26:
    *(_DWORD *)a2 = v5 - a1;
    *a4 = v4 - a3;
    return *(_DWORD *)a2;
  }
  while ( 1 )
  {
    v8 = dword_4A4D28 ? (*v15 << 8) | v15[1] : *(unsigned __int16 *)v15;
    v15 += 2;
    if ( (v8 & 0xFC00) == 55296 )
      break;
LABEL_14:
    if ( (unsigned int)v5 < v7 )
    {
      if ( v8 >= 0x80 )
      {
        if ( v8 >= 0x800 )
        {
          if ( v8 >= 0x10000 )
          {
            v10 = (v8 >> 18) & 7 | 0xF0;
            v16 = 12;
          }
          else
          {
            v10 = (v8 >> 12) & 0xF | 0xE0;
            v16 = 6;
          }
          *v5++ = v10;
        }
        else
        {
          *v5++ = (v8 >> 6) & 0x1F | 0xC0;
          v16 = 0;
        }
        do
        {
          if ( (unsigned int)v5 >= v7 )
            break;
          *v5++ = (v8 >> v16) & 0x3F | 0x80;
          v16 -= 6;
        }
        while ( v16 >= 0 );
      }
      else
      {
        *v5++ = v8;
      }
      v4 = v15;
      if ( (unsigned int)v15 < v13 )
        continue;
    }
    goto LABEL_26;
  }
  if ( (unsigned int)v15 < v13 )
  {
    v9 = dword_4A4D28 ? _byteswap_ushort(*(_WORD *)v15) : *(_WORD *)v15;
    v15 += 2;
    if ( (v9 & 0xFC00) == 56320 )
    {
      v8 = (v9 & 0x3FF | ((v8 & 0x3FF) << 10)) + 0x10000;
      v7 = v12;
      goto LABEL_14;
    }
  }
  *(_DWORD *)a2 = v5 - a1;
  *a4 = v4 - a3;
  return -2;
}
// 4A4D28: using guessed type int dword_4A4D28;

//----- (0043A363) --------------------------------------------------------
int __cdecl sub_43A363(_BYTE *a1, int *a2, _BYTE *a3, _DWORD *a4)
{
  _BYTE *v4; // ecx
  _BYTE *v5; // esi
  int *v6; // edi
  _DWORD *v7; // ebx
  _BYTE *v9; // edx
  unsigned int v10; // eax
  char v11; // di
  char v12; // bl
  bool v13; // zf
  unsigned int v14; // eax
  __int16 v15; // bx
  __int16 v16; // ax
  _BYTE *v17; // ecx
  unsigned int v18; // [esp+Ch] [ebp-14h]
  unsigned int v20; // [esp+14h] [ebp-Ch]
  int v21; // [esp+18h] [ebp-8h]
  _BYTE *v22; // [esp+1Ch] [ebp-4h]
  _BYTE *v23; // [esp+30h] [ebp+10h]

  v4 = a1;
  v5 = a3;
  if ( !a1 )
    return -1;
  v6 = a2;
  if ( !a2 )
    return -1;
  v7 = a4;
  if ( !a4 )
    return -1;
  if ( a3 )
  {
    v20 = (unsigned int)&a3[*a4];
    v9 = a3;
    v18 = (unsigned int)&a1[2 * (*a2 / 2)];
    if ( (unsigned int)a3 < v20 )
    {
      v22 = a1 + 2;
      while ( 1 )
      {
        v10 = (unsigned __int8)*v9++;
        v23 = v9;
        if ( v10 >= 0x80 )
        {
          if ( v10 < 0xC0 )
            goto LABEL_39;
          if ( v10 >= 0xE0 )
          {
            if ( v10 >= 0xF0 )
            {
              if ( v10 >= 0xF8 )
              {
LABEL_39:
                *v6 = (v4 - a1) >> 1;
                *v7 = v5 - a3;
                return -2;
              }
              v10 &= 7u;
              v21 = 3;
            }
            else
            {
              v10 &= 0xFu;
              v21 = 2;
            }
          }
          else
          {
            v10 &= 0x1Fu;
            v21 = 1;
          }
        }
        else
        {
          v21 = 0;
        }
        if ( (int)(v20 - (_DWORD)v9) < v21 )
          break;
        if ( v21 )
        {
          while ( (unsigned int)v9 < v20 )
          {
            v11 = *v9;
            v12 = *v9++ & 0xC0;
            v23 = v9;
            if ( v12 != (char)0x80 || (v13 = v21 == 1, --v21, v10 = (v10 << 6) | v11 & 0x3F, v13) )
            {
              v6 = a2;
              break;
            }
            v6 = a2;
          }
        }
        if ( v10 >= 0x10000 )
        {
          if ( v10 >= 0x110000 || (unsigned int)v22 >= v18 )
            break;
          v14 = v10 - 0x10000;
          if ( dword_4A4D28 )
          {
            v15 = (v14 >> 10) | 0xD800;
            v4[1] = v14 >> 10;
            v16 = v14 & 0x3FF | 0xDC00;
            *v4 = HIBYTE(v15);
            v17 = v4 + 2;
            *v17 = HIBYTE(v16);
            v9 = v23;
            v17[1] = v16;
          }
          else
          {
            *(_WORD *)v4 = (v14 >> 10) | 0xD800;
            v17 = v4 + 2;
            *(_WORD *)v17 = v14 & 0x3FF | 0xDC00;
          }
          v4 = v17 + 2;
          v22 += 4;
        }
        else
        {
          if ( (unsigned int)v4 >= v18 )
            break;
          if ( dword_4A4D28 )
          {
            *v4 = BYTE1(v10);
            v4[1] = v10;
          }
          else
          {
            *(_WORD *)v4 = v10;
          }
          v4 += 2;
          v22 += 2;
        }
        v7 = a4;
        v5 = v9;
        if ( (unsigned int)v9 >= v20 )
          goto LABEL_41;
      }
      v7 = a4;
    }
LABEL_41:
    *v6 = 2 * ((v4 - a1) >> 1);
    *v7 = v5 - a3;
    return *v6;
  }
  else
  {
    *a2 = 0;
    *a4 = 0;
    return 0;
  }
}
// 4A4D28: using guessed type int dword_4A4D28;

//----- (0043A558) --------------------------------------------------------
int __cdecl xmlDetectCharEncoding(char *a1, int a2)
{
  char v3; // bl
  char v4; // cl
  char v5; // cl

  if ( !a1 )
    return 0;
  if ( a2 >= 4 )
  {
    v3 = *a1;
    if ( !*a1 && !a1[1] && !a1[2] && a1[3] == 60 )
      return 5;
    if ( v3 == 60 && !a1[1] && !a1[2] && !a1[3] )
      return 4;
    if ( !v3 )
    {
      v4 = a1[1];
      if ( !v4 && a1[2] == 60 && !a1[3] )
        return 7;
      if ( v4 == 60 && !a1[2] && !a1[3] )
        return 8;
    }
    if ( v3 == 76 && a1[1] == 111 && a1[2] == -89 && a1[3] == -108 )
      return 6;
    if ( v3 == 60 )
    {
      v5 = a1[1];
      if ( v5 == 63 && a1[2] == 120 && a1[3] == 109 )
        return 1;
      if ( !v5 && a1[2] == 63 && !a1[3] )
        return 2;
    }
    if ( !v3 && a1[1] == 60 && !a1[2] && a1[3] == 63 )
      return 3;
  }
  if ( a2 >= 3 && *a1 == -17 && a1[1] == -69 && a1[2] == -65 )
    return 1;
  if ( a2 >= 2 )
  {
    if ( *a1 == -2 && a1[1] == -1 )
      return 3;
    if ( *a1 == -1 && a1[1] == -2 )
      return 2;
  }
  return 0;
}

//----- (0043A67D) --------------------------------------------------------
_DWORD *xmlCleanupEncodingAliases()
{
  _DWORD *result; // eax
  int i; // esi

  result = dword_4A9C28;
  if ( dword_4A9C28 )
  {
    for ( i = 0; i < dword_4A9C2C; ++i )
    {
      if ( result[2 * i] )
      {
        ((void (__cdecl *)(_DWORD))xmlFree)(result[2 * i]);
        result = dword_4A9C28;
      }
      if ( result[2 * i + 1] )
      {
        ((void (__cdecl *)(_DWORD))xmlFree)(result[2 * i + 1]);
        result = dword_4A9C28;
      }
    }
    dword_4A9C2C = 0;
    dword_4A9C30 = 0;
    result = (_DWORD *)((int (__cdecl *)(_DWORD *))xmlFree)(result);
    dword_4A9C28 = 0;
  }
  return result;
}
// 496494: invalid function type has been ignored
// 4A9C2C: using guessed type int dword_4A9C2C;
// 4A9C30: using guessed type int dword_4A9C30;

//----- (0043A6E2) --------------------------------------------------------
int __cdecl xmlGetEncodingAlias(int a1)
{
  int i; // esi
  char v3; // al
  const char **j; // edi
  int v5; // [esp+4h] [ebp-6Ch]
  char v6[100]; // [esp+8h] [ebp-68h] BYREF

  if ( !a1 || !dword_4A9C28 )
    return 0;
  for ( i = 0; i < 99; ++i )
  {
    v3 = toupper(v6[a1 - (_DWORD)v6 + i]);
    v6[i] = v3;
    if ( !v3 )
      break;
  }
  v5 = 0;
  v6[i] = 0;
  if ( dword_4A9C2C <= 0 )
    return 0;
  for ( j = (const char **)((char *)dword_4A9C28 + 4); strcmp(*j, v6); j += 2 )
  {
    if ( ++v5 >= dword_4A9C2C )
      return 0;
  }
  return *((_DWORD *)dword_4A9C28 + 2 * v5);
}
// 4A9C2C: using guessed type int dword_4A9C2C;
// 43A6E2: using guessed type char var_68[100];

//----- (0043A79C) --------------------------------------------------------
int __cdecl xmlAddEncodingAlias(void *a1, int a2)
{
  int v2; // ebx
  int i; // esi
  char v4; // al
  const char **v5; // eax
  int v7; // ecx
  const char **v8; // edi
  int v9; // eax
  int v10; // edx
  char v11[100]; // [esp+10h] [ebp-68h] BYREF

  v2 = 0;
  if ( !a1 || !a2 )
    return -1;
  for ( i = 0; i < 99; ++i )
  {
    v4 = toupper(v11[a2 - (_DWORD)v11 + i]);
    v11[i] = v4;
    if ( !v4 )
      break;
  }
  v5 = (const char **)dword_4A9C28;
  v11[i] = 0;
  if ( v5 )
  {
    v7 = dword_4A9C30;
    if ( dword_4A9C2C >= dword_4A9C30 )
    {
      dword_4A9C30 *= 2;
      v5 = (const char **)xmlRealloc(v5, 16 * v7);
      dword_4A9C28 = v5;
    }
  }
  else
  {
    dword_4A9C2C = 0;
    dword_4A9C30 = 20;
    v5 = (const char **)xmlMalloc(160);
    dword_4A9C28 = v5;
    if ( !v5 )
      return -1;
  }
  if ( dword_4A9C2C <= 0 )
  {
LABEL_15:
    *((_DWORD *)dword_4A9C28 + 2 * dword_4A9C2C) = xmlMemStrdup(a1);
    v9 = xmlMemStrdup(v11);
    v10 = dword_4A9C2C++;
    *((_DWORD *)dword_4A9C28 + 2 * v10 + 1) = v9;
  }
  else
  {
    v8 = v5 + 1;
    while ( strcmp(*v8, v11) )
    {
      ++v2;
      v8 += 2;
      if ( v2 >= dword_4A9C2C )
        goto LABEL_15;
    }
    ((void (__cdecl *)(const char *))xmlFree)(v5[2 * v2]);
    *((_DWORD *)dword_4A9C28 + 2 * v2) = xmlMemStrdup(a1);
  }
  return 0;
}
// 496494: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);
// 4A4B74: using guessed type int (__cdecl *xmlMemStrdup)(void *Src);
// 4A9C2C: using guessed type int dword_4A9C2C;
// 4A9C30: using guessed type int dword_4A9C30;
// 43A79C: using guessed type char var_68[100];

//----- (0043A8FA) --------------------------------------------------------
int __cdecl xmlDelEncodingAlias(_BYTE *a1)
{
  int v1; // edi
  _BYTE *v3; // ecx
  _BYTE *v4; // eax
  bool v5; // cf
  unsigned __int8 v6; // dl
  int v7; // eax
  _BYTE **i; // [esp+4h] [ebp-4h]

  v1 = 0;
  if ( !a1 )
    return -1;
  if ( !dword_4A9C28 )
    return -1;
  if ( dword_4A9C2C <= 0 )
    return -1;
  for ( i = (_BYTE **)((char *)dword_4A9C28 + 4); ; i += 2 )
  {
    v3 = a1;
    v4 = *i;
    while ( 1 )
    {
      v5 = *v4 < *v3;
      if ( *v4 != *v3 )
        break;
      if ( !*v4 )
        goto LABEL_12;
      v6 = v4[1];
      v5 = v6 < v3[1];
      if ( v6 != v3[1] )
        break;
      v4 += 2;
      v3 += 2;
      if ( !v6 )
      {
LABEL_12:
        v7 = 0;
        goto LABEL_14;
      }
    }
    v7 = -v5 - (v5 - 1);
LABEL_14:
    if ( !v7 )
      break;
    if ( ++v1 >= dword_4A9C2C )
      return -1;
  }
  ((void (__thiscall *)(_BYTE *, _DWORD))xmlFree)(v3, *((_DWORD *)dword_4A9C28 + 2 * v1));
  ((void (__cdecl *)(_DWORD))xmlFree)(*((_DWORD *)dword_4A9C28 + 2 * v1 + 1));
  memcpy_0((char *)dword_4A9C28 + 8 * v1, (char *)dword_4A9C28 + 8 * v1 + 8, 8 * (--dword_4A9C2C - v1));
  return 0;
}
// 496494: invalid function type has been ignored
// 4A9C2C: using guessed type int dword_4A9C2C;

//----- (0043A9AF) --------------------------------------------------------
int __cdecl xmlParseCharEncoding(int a1)
{
  int v1; // edi
  int result; // eax
  int EncodingAlias; // eax
  int v4; // esi
  int v5; // edi
  char v6; // al
  char v8[500]; // [esp+4h] [ebp-80h] BYREF

  v1 = a1;
  if ( !a1 )
    return 0;
  EncodingAlias = xmlGetEncodingAlias(a1);
  if ( EncodingAlias )
    v1 = EncodingAlias;
  v4 = 0;
  v5 = v1 - (_DWORD)v8;
  do
  {
    v6 = toupper(v8[v5 + v4]);
    v8[v4] = v6;
    if ( !v6 )
      break;
    ++v4;
  }
  while ( v4 < 499 );
  result = 1;
  v8[v4] = 0;
  if ( !strcmp(v8, byte_47627C) )
    return 0;
  if ( strcmp(v8, "UTF-8") && strcmp(v8, "UTF8") )
  {
    if ( !strcmp(v8, "UTF-16") || !strcmp(v8, "UTF16") )
      return 2;
    if ( !strcmp(v8, "ISO-10646-UCS-2") || !strcmp(v8, "UCS-2") || !strcmp(v8, "UCS2") )
      return 9;
    if ( !strcmp(v8, "ISO-10646-UCS-4") || !strcmp(v8, "UCS-4") || !strcmp(v8, "UCS4") )
      return 4;
    result = 11;
    if ( !strcmp(v8, "ISO-8859-1") || !strcmp(v8, "ISO-LATIN-1") || !strcmp(v8, "ISO LATIN 1") )
      return 10;
    if ( strcmp(v8, "ISO-8859-2") && strcmp(v8, "ISO-LATIN-2") && strcmp(v8, "ISO LATIN 2") )
    {
      if ( !strcmp(v8, "ISO-8859-3") )
        return 12;
      if ( !strcmp(v8, "ISO-8859-4") )
        return 13;
      if ( !strcmp(v8, "ISO-8859-5") )
        return 14;
      if ( !strcmp(v8, "ISO-8859-6") )
        return 15;
      if ( !strcmp(v8, "ISO-8859-7") )
        return 16;
      if ( !strcmp(v8, "ISO-8859-8") )
        return 17;
      if ( !strcmp(v8, "ISO-8859-9") )
        return 18;
      if ( !strcmp(v8, "ISO-2022-JP") )
        return 19;
      if ( !strcmp(v8, "SHIFT_JIS") )
        return 20;
      return strcmp(v8, "EUC-JP") != 0 ? -1 : 21;
    }
  }
  return result;
}
// 43A9AF: using guessed type char var_1F8[500];

//----- (0043AC5B) --------------------------------------------------------
const char *__cdecl xmlGetCharEncodingName(int a1)
{
  const char *result; // eax

  switch ( a1 )
  {
    case 1:
      result = "UTF-8";
      break;
    case 2:
    case 3:
      result = "UTF-16";
      break;
    case 4:
    case 5:
    case 7:
    case 8:
      result = "ISO-10646-UCS-4";
      break;
    case 6:
      result = "EBCDIC";
      break;
    case 9:
      result = "ISO-10646-UCS-2";
      break;
    case 10:
      result = "ISO-8859-1";
      break;
    case 11:
      result = "ISO-8859-2";
      break;
    case 12:
      result = "ISO-8859-3";
      break;
    case 13:
      result = "ISO-8859-4";
      break;
    case 14:
      result = "ISO-8859-5";
      break;
    case 15:
      result = "ISO-8859-6";
      break;
    case 16:
      result = "ISO-8859-7";
      break;
    case 17:
      result = "ISO-8859-8";
      break;
    case 18:
      result = "ISO-8859-9";
      break;
    case 19:
      result = "ISO-2022-JP";
      break;
    case 20:
      result = "Shift-JIS";
      break;
    case 21:
      result = "EUC-JP";
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (0043AD37) --------------------------------------------------------
int *__cdecl xmlNewCharEncodingHandler(int a1, int a2, int a3)
{
  int v3; // edi
  int EncodingAlias; // eax
  int v5; // esi
  int v7; // edi
  char v8; // al
  int v9; // ebx
  int *v10; // eax
  int *v11; // esi
  char Src[500]; // [esp+10h] [ebp-1F8h] BYREF

  v3 = a1;
  EncodingAlias = xmlGetEncodingAlias(a1);
  v5 = 0;
  if ( EncodingAlias )
    v3 = EncodingAlias;
  if ( !v3 )
  {
    sub_439A2F(6000, "xmlNewCharEncodingHandler : no name !\n", 0);
    return 0;
  }
  v7 = v3 - (_DWORD)Src;
  do
  {
    v8 = toupper(Src[v7 + v5]);
    Src[v5] = v8;
    if ( !v8 )
      break;
    ++v5;
  }
  while ( v5 < 499 );
  Src[v5] = 0;
  v9 = xmlMemStrdup(Src);
  if ( !v9 )
  {
    sub_439A1A("xmlNewCharEncodingHandler : out of memory !\n");
    return 0;
  }
  v10 = (int *)xmlMalloc(12);
  v11 = v10;
  if ( !v10 )
  {
    ((void (__cdecl *)(int))xmlFree)(v9);
    sub_439A1A("xmlNewCharEncodingHandler : out of memory !\n");
    return 0;
  }
  *v10 = 0;
  v10[1] = 0;
  v10[2] = 0;
  v10[1] = a2;
  v10[2] = a3;
  *v10 = v9;
  xmlRegisterCharEncodingHandler((int)v10);
  return v11;
}
// 496494: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A4B74: using guessed type int (__cdecl *xmlMemStrdup)(void *Src);
// 43AD37: using guessed type char Src[500];

//----- (0043AE21) --------------------------------------------------------
void xmlInitCharEncodingHandlers()
{
  if ( !dword_4A9C34 )
  {
    dword_4A9C34 = (void *)xmlMalloc(200);
    dword_4A4D28 = 1;
    if ( dword_4A9C34 )
    {
      xmlNewCharEncodingHandler((int)"UTF-8", (int)sub_439CD8, (int)sub_439CD8);
      dword_4A9C20 = (int)xmlNewCharEncodingHandler((int)"UTF-16LE", (int)sub_439E61, (int)sub_439FEC);
      dword_4A9C24 = (int)xmlNewCharEncodingHandler((int)"UTF-16BE", (int)sub_43A1E6, (int)sub_43A363);
      xmlNewCharEncodingHandler((int)"UTF-16", (int)sub_439E61, (int)sub_43A1B0);
      xmlNewCharEncodingHandler((int)"ISO-8859-1", (int)isolat1ToUTF8, (int)UTF8Toisolat1);
      xmlNewCharEncodingHandler((int)"ASCII", (int)sub_439A59, (int)sub_439ADA);
      xmlNewCharEncodingHandler((int)"US-ASCII", (int)sub_439A59, (int)sub_439ADA);
    }
    else
    {
      sub_439A1A("xmlInitCharEncodingHandlers : out of memory !\n");
    }
  }
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A4D28: using guessed type int dword_4A4D28;
// 4A9C20: using guessed type int dword_4A9C20;
// 4A9C24: using guessed type int dword_4A9C24;

//----- (0043AEEE) --------------------------------------------------------
_DWORD *xmlCleanupCharEncodingHandlers()
{
  _DWORD *result; // eax
  _DWORD *v1; // ecx
  _DWORD *v2; // ecx

  xmlCleanupEncodingAliases();
  result = dword_4A9C34;
  if ( dword_4A9C34 )
  {
    while ( dword_4A9C38 > 0 )
    {
      v1 = &result[--dword_4A9C38];
      if ( *v1 )
      {
        v2 = (_DWORD *)*v1;
        if ( *v2 )
        {
          ((void (__cdecl *)(_DWORD))xmlFree)(*v2);
          result = dword_4A9C34;
        }
        ((void (__cdecl *)(_DWORD))xmlFree)(result[dword_4A9C38]);
        result = dword_4A9C34;
      }
    }
    result = (_DWORD *)((int (__cdecl *)(_DWORD *))xmlFree)(result);
    dword_4A9C34 = 0;
    dword_4A9C38 = 0;
    dword_4A9C3C = 0;
  }
  return result;
}
// 496494: invalid function type has been ignored
// 4A9C38: using guessed type int dword_4A9C38;
// 4A9C3C: using guessed type int dword_4A9C3C;

//----- (0043AF61) --------------------------------------------------------
int (__cdecl *__cdecl xmlRegisterCharEncodingHandler(int a1))(int, char *Format, char ArgList)
{
  _DWORD *v1; // ecx
  int v2; // eax
  int (__cdecl *result)(int, char *, char); // eax

  v1 = dword_4A9C34;
  if ( !dword_4A9C34 )
  {
    xmlInitCharEncodingHandlers();
    v1 = dword_4A9C34;
  }
  if ( !a1 || !v1 )
    return sub_439A2F(6001, "xmlRegisterCharEncodingHandler: NULL handler !\n", 0);
  v2 = dword_4A9C38;
  if ( dword_4A9C38 >= 50 )
    return sub_439A2F(
             6002,
             "xmlRegisterCharEncodingHandler: Too many handler registered, see %s\n",
             "MAX_ENCODING_HANDLERS");
  v1[dword_4A9C38] = a1;
  result = (int (__cdecl *)(int, char *, char))(v2 + 1);
  dword_4A9C38 = (int)result;
  return result;
}
// 43AE21: using guessed type int xmlInitCharEncodingHandlers(void);
// 4A9C38: using guessed type int dword_4A9C38;

//----- (0043AFBC) --------------------------------------------------------
int __cdecl xmlGetCharEncodingHandler(int a1)
{
  int result; // eax

  if ( !dword_4A9C34 )
    xmlInitCharEncodingHandlers();
  switch ( a1 )
  {
    case 2:
      return dword_4A9C20;
    case 3:
      return dword_4A9C24;
    case 4:
    case 5:
      result = xmlFindCharEncodingHandler("ISO-10646-UCS-4");
      if ( !result )
      {
        result = xmlFindCharEncodingHandler("UCS-4");
        if ( !result )
        {
          result = xmlFindCharEncodingHandler("UCS4");
          goto LABEL_9;
        }
      }
      return result;
    case 6:
      result = xmlFindCharEncodingHandler("EBCDIC");
      if ( !result )
      {
        result = xmlFindCharEncodingHandler("ebcdic");
        if ( !result )
        {
          result = xmlFindCharEncodingHandler("EBCDIC-US");
          goto LABEL_9;
        }
      }
      return result;
    case 9:
      result = xmlFindCharEncodingHandler("ISO-10646-UCS-2");
      if ( !result )
      {
        result = xmlFindCharEncodingHandler("UCS-2");
        if ( !result )
        {
          result = xmlFindCharEncodingHandler("UCS2");
          goto LABEL_9;
        }
      }
      return result;
    case 10:
      result = xmlFindCharEncodingHandler("ISO-8859-1");
      goto LABEL_9;
    case 11:
      result = xmlFindCharEncodingHandler("ISO-8859-2");
      goto LABEL_9;
    case 12:
      result = xmlFindCharEncodingHandler("ISO-8859-3");
      goto LABEL_9;
    case 13:
      result = xmlFindCharEncodingHandler("ISO-8859-4");
      goto LABEL_9;
    case 14:
      result = xmlFindCharEncodingHandler("ISO-8859-5");
      goto LABEL_9;
    case 15:
      result = xmlFindCharEncodingHandler("ISO-8859-6");
      goto LABEL_9;
    case 16:
      result = xmlFindCharEncodingHandler("ISO-8859-7");
      goto LABEL_9;
    case 17:
      result = xmlFindCharEncodingHandler("ISO-8859-8");
      goto LABEL_9;
    case 18:
      result = xmlFindCharEncodingHandler("ISO-8859-9");
      goto LABEL_9;
    case 19:
      result = xmlFindCharEncodingHandler("ISO-2022-JP");
      goto LABEL_9;
    case 20:
      result = xmlFindCharEncodingHandler("SHIFT-JIS");
      if ( result )
        return result;
      result = xmlFindCharEncodingHandler("SHIFT_JIS");
      if ( result )
        return result;
      result = xmlFindCharEncodingHandler("Shift_JIS");
LABEL_9:
      if ( !result )
        return 0;
      return result;
    case 21:
      result = xmlFindCharEncodingHandler("EUC-JP");
      goto LABEL_9;
    default:
      return 0;
  }
}
// 4A9C20: using guessed type int dword_4A9C20;
// 4A9C24: using guessed type int dword_4A9C24;

//----- (0043B14C) --------------------------------------------------------
int __cdecl xmlFindCharEncodingHandler(const char *a1)
{
  int EncodingAlias; // eax
  int i; // esi
  char v3; // al
  int v4; // edi
  int v5; // eax
  const char *CharEncodingName; // eax
  const char *v7; // esi
  const char *v9; // [esp+10h] [ebp-6Ch]
  char v10[100]; // [esp+14h] [ebp-68h] BYREF

  while ( 1 )
  {
    v9 = a1;
    if ( !dword_4A9C34 )
      xmlInitCharEncodingHandlers();
    if ( !a1 || !*a1 )
      return dword_4A9C3C;
    EncodingAlias = xmlGetEncodingAlias((int)a1);
    if ( EncodingAlias )
      v9 = (const char *)EncodingAlias;
    for ( i = 0; i < 99; ++i )
    {
      v3 = toupper(v10[v9 - v10 + i]);
      v10[i] = v3;
      if ( !v3 )
        break;
    }
    v10[i] = 0;
    if ( dword_4A9C34 )
    {
      v4 = 0;
      if ( dword_4A9C38 > 0 )
        break;
    }
LABEL_14:
    v5 = xmlParseCharEncoding((int)a1);
    if ( v5 == -1 )
      return 0;
    CharEncodingName = xmlGetCharEncodingName(v5);
    v7 = CharEncodingName;
    if ( !CharEncodingName || !strcmp(v9, CharEncodingName) )
      return 0;
    a1 = v7;
  }
  while ( strcmp(v10, **((const char ***)dword_4A9C34 + v4)) )
  {
    if ( ++v4 >= dword_4A9C38 )
      goto LABEL_14;
  }
  return *((_DWORD *)dword_4A9C34 + v4);
}
// 4A9C38: using guessed type int dword_4A9C38;
// 4A9C3C: using guessed type int dword_4A9C3C;
// 43B14C: using guessed type char var_68[100];

//----- (0043B279) --------------------------------------------------------
int __usercall sub_43B279@<eax>(_DWORD *a1@<edi>, _DWORD *a2@<esi>, int a3, int a4)
{
  int v4; // ebx
  signed int v6; // ecx
  int v7; // eax
  int (__cdecl *v8)(int, int *, _DWORD, signed int *); // eax
  int v9; // [esp+4h] [ebp-8h] BYREF
  signed int v10; // [esp+8h] [ebp-4h] BYREF

  v4 = -2;
  if ( !a3 || !a2 || !a1 )
    return -1;
  v6 = a1[1];
  v7 = a2[2] - a2[1] - 1;
  v9 = v7;
  v10 = v6;
  if ( a4 < 0 )
  {
    if ( v6 > 180 )
    {
      v6 = 180;
      goto LABEL_10;
    }
  }
  else if ( v6 > a4 )
  {
    v6 = a4;
LABEL_10:
    v10 = v6;
  }
  if ( 2 * v6 >= v7 )
  {
    xmlBufferGrow((int)a2, v6);
    v9 = a2[2] - a2[1] - 1;
  }
  v8 = *(int (__cdecl **)(int, int *, _DWORD, signed int *))(a3 + 4);
  if ( v8 )
  {
    v4 = v8(a2[1] + *a2, &v9, *a1, &v10);
    xmlBufferShrink((int)a1, v10);
    a2[1] += v9;
    *(_BYTE *)(a2[1] + *a2) = 0;
    if ( v4 == -3 )
      v4 = 0;
    if ( v4 == -1 )
      return 0;
  }
  return v4;
}

//----- (0043B32C) --------------------------------------------------------
int __cdecl xmlCharEncFirstLine(int a1, _DWORD *a2, _DWORD *a3)
{
  return sub_43B279(a3, a2, a1, -1);
}

//----- (0043B346) --------------------------------------------------------
int __cdecl xmlCharEncInFunc(int a1, _DWORD *a2, unsigned __int8 **a3)
{
  int result; // eax
  unsigned int v4; // edx
  int v5; // ecx
  int v6; // edx
  int (__cdecl *v7)(int, int *, unsigned __int8 *, unsigned int *); // eax
  bool v8; // zf
  unsigned int v9; // [esp+Ch] [ebp-44h] BYREF
  int v10; // [esp+10h] [ebp-40h] BYREF
  int v11; // [esp+14h] [ebp-3Ch]
  char Buffer[52]; // [esp+18h] [ebp-38h] BYREF

  v11 = -2;
  if ( !a1 || !a2 || !a3 )
    return -1;
  v4 = (unsigned int)a3[1];
  v9 = v4;
  if ( !v4 )
    return 0;
  v5 = a2[2];
  v6 = 2 * v4;
  v10 = v5 - a2[1] - 1;
  if ( v6 >= v10 )
  {
    xmlBufferGrow((int)a2, v5 + v6);
    v10 = a2[2] - a2[1] - 1;
  }
  v7 = *(int (__cdecl **)(int, int *, unsigned __int8 *, unsigned int *))(a1 + 4);
  if ( !v7
    || (v11 = v7(a2[1] + *a2, &v10, *a3, &v9),
        xmlBufferShrink((int)a3, v9),
        a2[1] += v10,
        v8 = v11 == -2,
        *(_BYTE *)(a2[1] + *a2) = 0,
        v8) )
  {
    _snprintf(Buffer, 0x31u, "0x%02X 0x%02X 0x%02X 0x%02X", **a3, (*a3)[1], (*a3)[2], (*a3)[3]);
    Buffer[49] = 0;
    sub_439A2F(6003, "input conversion failed due to input error, bytes %s\n", Buffer);
  }
  if ( v11 == -3 )
    v11 = 0;
  result = v10;
  if ( !v10 )
    return v11;
  return result;
}

//----- (0043B454) --------------------------------------------------------
int __cdecl xmlCharEncOutFunc(int a1, _DWORD *a2, unsigned __int8 **a3)
{
  int v3; // ecx
  int v4; // ebx
  int v5; // eax
  unsigned int v6; // edx
  signed int v7; // edx
  int (__cdecl *v8)(int, int *, unsigned __int8 *, unsigned int *); // ecx
  bool v9; // zf
  int UTF8Char; // eax
  int v11; // ecx
  int (__cdecl *v12)(int, int *, _DWORD, unsigned int *); // ecx
  unsigned int v14; // [esp+10h] [ebp-5Ch] BYREF
  int v15; // [esp+14h] [ebp-58h]
  unsigned int v16; // [esp+18h] [ebp-54h] BYREF
  int v17; // [esp+1Ch] [ebp-50h] BYREF
  char Src[52]; // [esp+20h] [ebp-4Ch] BYREF
  char Buffer[20]; // [esp+54h] [ebp-18h] BYREF

  v3 = a1;
  v4 = 0;
  if ( a1 && a2 )
  {
    while ( 1 )
    {
      v5 = a2[2] - a2[1];
      v17 = v5;
      if ( v5 > 0 )
        v17 = --v5;
      if ( !a3 )
      {
        v12 = *(int (__cdecl **)(int, int *, _DWORD, unsigned int *))(v3 + 8);
        v16 = 0;
        if ( v12 && v12(*a2 + a2[1], &v17, 0, &v16) >= 0 )
        {
          a2[1] += v17;
          *(_BYTE *)(a2[1] + *a2) = 0;
        }
        return 0;
      }
      v6 = (unsigned int)a3[1];
      v16 = v6;
      if ( !v6 )
        return 0;
      v7 = 4 * v6;
      if ( v7 >= v5 )
      {
        xmlBufferGrow((int)a2, v7);
        v3 = a1;
        v17 = a2[2] - a2[1] - 1;
      }
      v8 = *(int (__cdecl **)(int, int *, unsigned __int8 *, unsigned int *))(v3 + 8);
      if ( !v8 )
        break;
      v15 = v8(*a2 + a2[1], &v17, *a3, &v16);
      if ( v17 > 0 )
      {
        xmlBufferShrink((int)a3, v16);
        a2[1] += v17;
      }
      v9 = v15 == -2;
      *(_BYTE *)(a2[1] + *a2) = 0;
      if ( !v9 )
        return v15;
      v14 = (unsigned int)a3[1];
      UTF8Char = xmlGetUTF8Char(*a3, (int *)&v14);
      if ( v4 )
      {
        v11 = v17;
        if ( v17 < v4 )
        {
          a2[1] -= v17;
          xmlBufferShrink((int)a3, v4 - v11);
          return -1;
        }
      }
      if ( UTF8Char <= 0 )
      {
        _snprintf(Src, 0x31u, "0x%02X 0x%02X 0x%02X 0x%02X", **a3, (*a3)[1], (*a3)[2], (*a3)[3]);
        Src[49] = 0;
        sub_439A2F(6003, "output conversion failed due to conv error, bytes %s\n", Src);
        if ( a3[3] != (unsigned __int8 *)2 )
          **a3 = 32;
        return v15;
      }
      v4 = _snprintf(Buffer, 0x14u, "&#%d;", UTF8Char);
      xmlBufferShrink((int)a3, v14);
      xmlBufferAddHead((const void **)a3, Buffer, -1);
      v3 = a1;
    }
    sub_439A2F(6004, "xmlCharEncOutFunc: no output function !\n", 0);
  }
  return -1;
}

//----- (0043B62B) --------------------------------------------------------
int __cdecl xmlCharEncCloseFunc(_DWORD *a1)
{
  if ( a1 )
    return (*a1 != 0) - 1;
  else
    return -1;
}

//----- (0043B642) --------------------------------------------------------
int __cdecl xmlByteConsumed(int a1)
{
  _DWORD *v2; // esi
  int v3; // ebx
  int v4; // eax
  int v5; // edi
  int v6; // eax
  unsigned int v7; // eax
  int v8; // [esp+4h] [ebp-80h] BYREF
  int v9; // [esp+8h] [ebp-7Ch] BYREF
  unsigned int v10; // [esp+Ch] [ebp-78h]
  char v11[32000]; // [esp+10h] [ebp-74h] BYREF

  if ( !a1 )
    return -1;
  v2 = *(_DWORD **)(a1 + 36);
  if ( !v2 )
    return -1;
  if ( !*v2 )
    return v2[4] + v2[9] - v2[3];
  v3 = *(_DWORD *)(*v2 + 12);
  if ( !v3 )
    return v2[4] + v2[9] - v2[3];
  v4 = v2[5] - v2[4];
  v10 = 0;
  if ( v4 > 0 )
  {
    v5 = v2[4];
    if ( *(_DWORD *)(v3 + 8) )
    {
      while ( 1 )
      {
        v8 = v2[5] - v5;
        v9 = 32000;
        v6 = (*(int (__cdecl **)(char *, int *, int, int *))(v3 + 8))(v11, &v9, v5, &v8);
        if ( v6 == -1 )
          break;
        v10 += v9;
        v5 += v8;
        if ( v6 != -2 )
          goto LABEL_11;
      }
    }
    return -1;
  }
LABEL_11:
  v7 = *(_DWORD *)(*v2 + 32);
  if ( v7 < v10 )
    return -1;
  return v7 - v10;
}
// 43B642: using guessed type char var_7D04[32000];

//----- (0043B710) --------------------------------------------------------
WCHAR *__cdecl sub_43B710(LPCCH lpMultiByteStr)
{
  WCHAR *v1; // ebp
  int v2; // esi
  WCHAR *v3; // eax

  v1 = 0;
  if ( lpMultiByteStr )
  {
    v2 = MultiByteToWideChar(0xFDE9u, 8u, lpMultiByteStr, -1, 0, 0);
    if ( v2 )
    {
      v3 = (WCHAR *)xmlMalloc(2 * v2);
      v1 = v3;
      if ( v3 )
      {
        if ( !MultiByteToWideChar(0xFDE9u, 0, lpMultiByteStr, -1, v3, v2) )
        {
          ((void (__cdecl *)(WCHAR *))xmlFree)(v1);
          return 0;
        }
      }
    }
  }
  return v1;
}
// 496494: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (0043B76D) --------------------------------------------------------
int (__cdecl *__cdecl sub_43B76D(_BYTE *a1))(int, char *Format, char ArgList)
{
  return _xmlSimpleError(8, 2, 0, 0, a1);
}

//----- (0043B782) --------------------------------------------------------
int (__cdecl *__usercall sub_43B782@<eax>(int a1@<eax>, _BYTE *a2))(int, char *Format, char ArgList)
{
  int v2; // ecx

  if ( !a1 )
  {
    if ( *_errno() )
    {
      if ( *_errno() == 13 )
      {
        a1 = 1501;
      }
      else if ( *_errno() == 11 )
      {
        a1 = 1502;
      }
      else if ( *_errno() == 9 )
      {
        a1 = 1503;
      }
      else if ( *_errno() == 16 )
      {
        a1 = 1505;
      }
      else if ( *_errno() == 10 )
      {
        a1 = 1507;
      }
      else if ( *_errno() == 36 )
      {
        a1 = 1508;
      }
      else if ( *_errno() == 33 )
      {
        a1 = 1509;
      }
      else if ( *_errno() == 17 )
      {
        a1 = 1510;
      }
      else if ( *_errno() == 14 )
      {
        a1 = 1511;
      }
      else if ( *_errno() == 27 )
      {
        a1 = 1512;
      }
      else if ( *_errno() == 112 )
      {
        a1 = 1513;
      }
      else if ( *_errno() == 4 )
      {
        a1 = 1514;
      }
      else if ( *_errno() == 22 )
      {
        a1 = 1515;
      }
      else if ( *_errno() == 5 )
      {
        a1 = 1516;
      }
      else if ( *_errno() == 21 )
      {
        a1 = 1517;
      }
      else if ( *_errno() == 24 )
      {
        a1 = 1518;
      }
      else if ( *_errno() == 31 )
      {
        a1 = 1519;
      }
      else if ( *_errno() == 38 )
      {
        a1 = 1521;
      }
      else if ( *_errno() == 23 )
      {
        a1 = 1522;
      }
      else if ( *_errno() == 19 )
      {
        a1 = 1523;
      }
      else if ( *_errno() == 2 )
      {
        a1 = 1524;
      }
      else if ( *_errno() == 8 )
      {
        a1 = 1525;
      }
      else if ( *_errno() == 39 )
      {
        a1 = 1526;
      }
      else if ( *_errno() == 12 )
      {
        a1 = 1527;
      }
      else if ( *_errno() == 28 )
      {
        a1 = 1528;
      }
      else if ( *_errno() == 40 )
      {
        a1 = 1529;
      }
      else if ( *_errno() == 20 )
      {
        a1 = 1530;
      }
      else if ( *_errno() == 41 )
      {
        a1 = 1531;
      }
      else if ( *_errno() == 25 )
      {
        a1 = 1533;
      }
      else if ( *_errno() == 6 )
      {
        a1 = 1534;
      }
      else if ( *_errno() == 1 )
      {
        a1 = 1535;
      }
      else if ( *_errno() == 32 )
      {
        a1 = 1536;
      }
      else if ( *_errno() == 34 )
      {
        a1 = 1537;
      }
      else if ( *_errno() == 30 )
      {
        a1 = 1538;
      }
      else if ( *_errno() == 29 )
      {
        a1 = 1539;
      }
      else if ( *_errno() == 3 )
      {
        a1 = 1540;
      }
      else if ( *_errno() == 18 )
      {
        a1 = 1542;
      }
      else
      {
        a1 = *_errno() != 112 ? 1500 : 1513;
      }
    }
    else
    {
      a1 = 0;
    }
  }
  v2 = 0;
  if ( a1 >= 1500 )
  {
    v2 = a1 - 1500;
    if ( (unsigned int)(a1 - 1500) >= 0x39 )
      v2 = 0;
  }
  return _xmlSimpleError(8, a1, 0, off_4A4C38[v2], a2);
}
// 4A4C38: using guessed type char *off_4A4C38[57];

//----- (0043BAB2) --------------------------------------------------------
int (__cdecl *__usercall sub_43BAB2@<eax>(int *a1@<edx>, char *Format, _BYTE *Src))(int, char *Format, char ArgList)
{
  int (__cdecl *result)(int, char *, char); // eax
  int (__cdecl *v4)(int, char *, char); // esi
  FILE *v5; // edi
  int v6; // ebx
  _DWORD *v7; // ecx
  int (__cdecl *v8)(FILE *, int *); // [esp+Ch] [ebp-4h]

  result = 0;
  v4 = 0;
  v5 = 0;
  v8 = 0;
  v6 = 2;
  if ( !a1 )
    return _xmlRaiseError(v8, v4, v5, a1, 0, 8, 1549, v6, 0, 0, Src, 0, 0, 0, 0, Format, Src);
  if ( !a1[53] || a1[43] != -1 )
  {
    v7 = (_DWORD *)*a1;
    if ( *a1 )
    {
      if ( a1[26] )
      {
        v4 = (int (__cdecl *)(int, char *, char))v7[22];
        v6 = 2;
      }
      else
      {
        v4 = (int (__cdecl *)(int, char *, char))v7[21];
        v6 = 1;
      }
      if ( v7[27] == -554844497 )
        v8 = (int (__cdecl *)(FILE *, int *))v7[31];
      v5 = (FILE *)a1[1];
    }
    return _xmlRaiseError(v8, v4, v5, a1, 0, 8, 1549, v6, 0, 0, Src, 0, 0, 0, 0, Format, Src);
  }
  return result;
}

//----- (0043BB35) --------------------------------------------------------
void xmlCleanupInputCallbacks()
{
  int v0; // ecx
  int *v1; // eax

  if ( dword_4A9C44 )
  {
    v0 = dword_4A9C40 - 1;
    if ( dword_4A9C40 - 1 >= 0 )
    {
      v1 = &dword_4A79D4[4 * v0];
      do
      {
        *(v1 - 1) = 0;
        *v1 = 0;
        v1[1] = 0;
        v1[2] = 0;
        --v0;
        v1 -= 4;
      }
      while ( v0 >= 0 );
    }
    dword_4A9C40 = 0;
    dword_4A9C44 = 0;
  }
}
// 4A79D4: using guessed type int dword_4A79D4[];
// 4A9C40: using guessed type int dword_4A9C40;
// 4A9C44: using guessed type int dword_4A9C44;

//----- (0043BB74) --------------------------------------------------------
int xmlPopInputCallbacks()
{
  int result; // eax
  int v1; // ecx

  if ( !dword_4A9C44 || dword_4A9C40 <= 0 )
    return -1;
  result = dword_4A9C40 - 1;
  v1 = 4 * (dword_4A9C40 - 1);
  dword_4A79D0[v1] = 0;
  dword_4A79D4[v1] = 0;
  dword_4A79D8[v1] = 0;
  dword_4A9C40 = result;
  dword_4A79DC[v1] = 0;
  return result;
}
// 4A79D0: using guessed type int dword_4A79D0[];
// 4A79D4: using guessed type int dword_4A79D4[];
// 4A79D8: using guessed type int dword_4A79D8[];
// 4A79DC: using guessed type int dword_4A79DC[];
// 4A9C40: using guessed type int dword_4A9C40;
// 4A9C44: using guessed type int dword_4A9C44;

//----- (0043BBAF) --------------------------------------------------------
void xmlCleanupOutputCallbacks()
{
  int v0; // ecx
  int *v1; // eax

  if ( dword_4A9C4C )
  {
    v0 = dword_4A9C48 - 1;
    if ( dword_4A9C48 - 1 >= 0 )
    {
      v1 = &dword_4A7AC4[4 * v0];
      do
      {
        *(v1 - 1) = 0;
        *v1 = 0;
        v1[1] = 0;
        v1[2] = 0;
        --v0;
        v1 -= 4;
      }
      while ( v0 >= 0 );
    }
    dword_4A9C48 = 0;
    dword_4A9C4C = 0;
  }
}
// 4A7AC4: using guessed type int dword_4A7AC4[];
// 4A9C48: using guessed type int dword_4A9C48;
// 4A9C4C: using guessed type int dword_4A9C4C;

//----- (0043BBEE) --------------------------------------------------------
FILE *__cdecl sub_43BBEE(char *FileName, int a2)
{
  WCHAR *v2; // edi
  const wchar_t *v3; // eax
  FILE *v4; // esi
  const char *v5; // eax

  v2 = sub_43B710(FileName);
  if ( !v2 )
    goto LABEL_5;
  v3 = L"wb";
  if ( !a2 )
    v3 = L"rb";
  v4 = _wfopen(v2, v3);
  ((void (__cdecl *)(WCHAR *))xmlFree)(v2);
  if ( !v4 )
  {
LABEL_5:
    v5 = "wb";
    if ( !a2 )
      v5 = "rb";
    return fopen(FileName, v5);
  }
  return v4;
}
// 496494: invalid function type has been ignored
// 486A7C: using guessed type wchar_t aRb[3];

//----- (0043BC4C) --------------------------------------------------------
int __cdecl sub_43BC4C(char *FileName, struct _stat32 *Stat)
{
  WCHAR *v2; // eax
  WCHAR *v3; // esi
  int v4; // edi

  v2 = sub_43B710(FileName);
  v3 = v2;
  if ( !v2 )
    return _stat32(FileName, Stat);
  v4 = _wstat32(v2, Stat);
  ((void (__cdecl *)(WCHAR *))xmlFree)(v3);
  if ( v4 < 0 )
    return _stat32(FileName, Stat);
  return v4;
}
// 496494: invalid function type has been ignored

//----- (0043BC8E) --------------------------------------------------------
FILE *__cdecl sub_43BC8E(char *FileName, int a2)
{
  const char *v2; // eax

  v2 = "wb";
  if ( !a2 )
    v2 = "rb";
  return fopen(FileName, v2);
}

//----- (0043BCB1) --------------------------------------------------------
void sub_43BCB1()
{
  struct _OSVERSIONINFOA VersionInformation; // [esp+0h] [ebp-98h] BYREF

  if ( !dword_4A9C50 )
  {
    VersionInformation.dwOSVersionInfoSize = 148;
    if ( GetVersionExA(&VersionInformation) && VersionInformation.dwPlatformId == 2 )
    {
      off_4A4D1C = (int (__cdecl *)(_DWORD, _DWORD))sub_43BC4C;
      off_4A4D20 = (int (__cdecl *)(char *, int))sub_43BBEE;
    }
    else
    {
      off_4A4D1C = (int (__cdecl *)(_DWORD, _DWORD))j___stat32;
      off_4A4D20 = (int (__cdecl *)(char *, int))sub_43BC8E;
    }
    dword_4A9C50 = 1;
  }
}
// 4A4D1C: using guessed type int (__cdecl *off_4A4D1C)(_DWORD, _DWORD);
// 4A4D20: using guessed type int (__cdecl *off_4A4D20)(char *FileName, int);
// 4A9C50: using guessed type int dword_4A9C50;

//----- (0043BD31) --------------------------------------------------------
int __cdecl xmlCheckFilename(char *FileName)
{
  struct _stat32 Stat; // [esp+0h] [ebp-24h] BYREF

  if ( !FileName || off_4A4D1C(FileName, &Stat) == -1 )
    return 0;
  else
    return ((Stat.st_mode & 0xF000) == 0x4000) + 1;
}
// 4A4D1C: using guessed type int (__cdecl *off_4A4D1C)(_DWORD, _DWORD);

//----- (0043BD70) --------------------------------------------------------
int __cdecl sub_43BD70(int FileHandle, void *DstBuf, unsigned int MaxCharCount)
{
  int v3; // esi

  v3 = _read(FileHandle, DstBuf, MaxCharCount);
  if ( v3 < 0 )
    sub_43B782(0, "read()");
  return v3;
}

//----- (0043BD9C) --------------------------------------------------------
int __cdecl sub_43BD9C(int FileHandle, void *Buf, int MaxCharCount)
{
  int v3; // esi

  v3 = 0;
  if ( MaxCharCount > 0 )
  {
    v3 = _write(FileHandle, Buf, MaxCharCount);
    if ( v3 < 0 )
      sub_43B782(0, "write()");
  }
  return v3;
}

//----- (0043BDF2) --------------------------------------------------------
int xmlIsMainThread()
{
  return 1;
}

//----- (0043BDF6) --------------------------------------------------------
void **__usercall sub_43BDF6@<eax>(char *a1@<ebx>)
{
  char *v2; // esi
  int v3; // edi

  if ( !a1 )
    return 0;
  if ( !strcmp(a1, "-") )
    return sub_44F01A();
  if ( xmlStrncasecmp((unsigned __int8 *)a1, "file://localhost/", 17) )
  {
    if ( xmlStrncasecmp((unsigned __int8 *)a1, "file:///", 8) )
    {
      v2 = a1 + 6;
      if ( xmlStrncasecmp((unsigned __int8 *)a1, "file:/", 6) )
        v2 = a1;
    }
    else
    {
      v2 = a1 + 8;
    }
  }
  else
  {
    v2 = a1 + 17;
  }
  if ( !v2 || !xmlCheckFilename(v2) )
    return 0;
  v3 = off_4A4D20(v2, 0);
  if ( !v3 )
    sub_43B782(0, v2);
  return (void **)v3;
}
// 4A4D20: using guessed type int (__cdecl *off_4A4D20)(char *FileName, int);

//----- (0043BE91) --------------------------------------------------------
void **__cdecl xmlFileOpen(char *a1)
{
  void **v1; // esi
  char *v2; // ebx

  v1 = sub_43BDF6(a1);
  if ( !v1 )
  {
    v2 = (char *)xmlURIUnescapeString(a1, 0, 0);
    if ( v2 )
    {
      v1 = sub_43BDF6(v2);
      ((void (__cdecl *)(char *))xmlFree)(v2);
    }
  }
  return v1;
}
// 496494: invalid function type has been ignored

//----- (0043BEC7) --------------------------------------------------------
void **__cdecl sub_43BEC7(char *a1)
{
  char *v2; // esi
  int v3; // edi

  if ( !strcmp(a1, "-") )
    return sub_44F01A() + 8;
  if ( xmlStrncasecmp((unsigned __int8 *)a1, "file://localhost/", 17) )
  {
    v2 = a1 + 8;
    if ( xmlStrncasecmp((unsigned __int8 *)a1, "file:///", 8) )
      v2 = a1;
  }
  else
  {
    v2 = a1 + 17;
  }
  if ( !v2 )
    return 0;
  v3 = off_4A4D20(v2, 1);
  if ( !v3 )
    sub_43B782(0, v2);
  return (void **)v3;
}
// 4A4D20: using guessed type int (__cdecl *off_4A4D20)(char *FileName, int);

//----- (0043BF40) --------------------------------------------------------
int __cdecl xmlFileRead(FILE *Stream, void *Buffer, size_t ElementCount)
{
  signed int v3; // esi

  if ( !Stream || !Buffer )
    return -1;
  v3 = fread(Buffer, 1u, ElementCount, Stream);
  if ( v3 < 0 )
    sub_43B782(0, "fread()");
  return v3;
}

//----- (0043BF80) --------------------------------------------------------
size_t __cdecl sub_43BF80(FILE *Stream, void *Buffer, size_t ElementSize)
{
  size_t v3; // esi

  if ( !Stream || !Buffer )
    return -1;
  v3 = fwrite(Buffer, ElementSize, 1u, Stream);
  if ( !v3 && ferror(Stream) )
  {
    sub_43B782(0, "fwrite()");
    return -1;
  }
  return ElementSize * v3;
}

//----- (0043BFD1) --------------------------------------------------------
int __cdecl xmlFileClose(FILE *Stream)
{
  int v2; // esi

  if ( !Stream )
    return -1;
  if ( Stream == (FILE *)(sub_44F01A() + 8) || Stream == (FILE *)(sub_44F01A() + 16) )
  {
    if ( fflush(Stream) < 0 )
      sub_43B782(0, "fflush()");
    return 0;
  }
  if ( Stream == (FILE *)sub_44F01A() )
    return 0;
  v2 = (fclose(Stream) != -1) - 1;
  if ( v2 < 0 )
    sub_43B782(0, "fclose()");
  return v2;
}

//----- (0043C041) --------------------------------------------------------
int __cdecl sub_43C041(FILE *Stream)
{
  int v2; // esi

  if ( !Stream )
    return -1;
  v2 = (fflush(Stream) != -1) - 1;
  if ( v2 < 0 )
    sub_43B782(0, "fflush()");
  return v2;
}

//----- (0043C075) --------------------------------------------------------
int __cdecl sub_43C075(int *a1, _BYTE *Src, int a3)
{
  if ( xmlBufferAdd(a1, Src, a3) )
    return -1;
  else
    return a3;
}

//----- (0043C096) --------------------------------------------------------
int __cdecl xmlRegisterInputCallbacks(int a1, int a2, int a3, int a4)
{
  int v4; // ecx
  int result; // eax
  int v6; // eax

  v4 = dword_4A9C40;
  if ( dword_4A9C40 >= 15 )
    return -1;
  v6 = 4 * dword_4A9C40;
  dword_4A79D0[v6] = a1;
  dword_4A79D4[v6] = a2;
  dword_4A79D8[v6] = a3;
  dword_4A79DC[v6] = a4;
  result = v4;
  dword_4A9C44 = 1;
  dword_4A9C40 = v4 + 1;
  return result;
}
// 4A79D0: using guessed type int dword_4A79D0[];
// 4A79D4: using guessed type int dword_4A79D4[];
// 4A79D8: using guessed type int dword_4A79D8[];
// 4A79DC: using guessed type int dword_4A79DC[];
// 4A9C40: using guessed type int dword_4A9C40;
// 4A9C44: using guessed type int dword_4A9C44;

//----- (0043C0E6) --------------------------------------------------------
int __cdecl xmlRegisterOutputCallbacks(int a1, int a2, int a3, int a4)
{
  int v4; // ecx
  int result; // eax
  int v6; // eax

  v4 = dword_4A9C48;
  if ( dword_4A9C48 >= 15 )
    return -1;
  v6 = 4 * dword_4A9C48;
  dword_4A7AC0[v6] = a1;
  dword_4A7AC4[v6] = a2;
  dword_4A7AC8[v6] = a3;
  dword_4A7ACC[v6] = a4;
  result = v4;
  dword_4A9C4C = 1;
  dword_4A9C48 = v4 + 1;
  return result;
}
// 4A7AC0: using guessed type int dword_4A7AC0[];
// 4A7AC4: using guessed type int dword_4A7AC4[];
// 4A7AC8: using guessed type int dword_4A7AC8[];
// 4A7ACC: using guessed type int dword_4A7ACC[];
// 4A9C48: using guessed type int dword_4A9C48;
// 4A9C4C: using guessed type int dword_4A9C4C;

//----- (0043C136) --------------------------------------------------------
int xmlRegisterDefaultInputCallbacks()
{
  int result; // eax

  if ( !dword_4A9C44 )
  {
    sub_43BCB1();
    result = xmlRegisterInputCallbacks((int)xmlIsMainThread, (int)xmlFileOpen, (int)xmlFileRead, (int)xmlFileClose);
    dword_4A9C44 = 1;
  }
  return result;
}
// 4A9C44: using guessed type int dword_4A9C44;

//----- (0043C16B) --------------------------------------------------------
int xmlRegisterDefaultOutputCallbacks()
{
  int result; // eax

  if ( !dword_4A9C4C )
  {
    sub_43BCB1();
    result = xmlRegisterOutputCallbacks((int)xmlIsMainThread, (int)sub_43BEC7, (int)sub_43BF80, (int)xmlFileClose);
    dword_4A9C4C = 1;
  }
  return result;
}
// 4A9C4C: using guessed type int dword_4A9C4C;

//----- (0043C1A0) --------------------------------------------------------
_DWORD *__cdecl xmlAllocParserInputBuffer(int a1)
{
  _DWORD *v1; // esi
  _DWORD *Size; // eax
  int CharEncodingHandler; // eax

  v1 = (_DWORD *)xmlMalloc(36);
  if ( !v1 )
  {
    sub_43B76D("creating input buffer");
    return 0;
  }
  memset(v1, 0, 0x24u);
  Size = xmlBufferCreateSize(2 * xmlDefaultBufferSize);
  v1[4] = Size;
  if ( !Size )
  {
    ((void (__cdecl *)(_DWORD *))xmlFree)(v1);
    return 0;
  }
  Size[3] = 0;
  CharEncodingHandler = xmlGetCharEncodingHandler(a1);
  v1[3] = CharEncodingHandler;
  if ( CharEncodingHandler )
    v1[5] = xmlBufferCreateSize(2 * xmlDefaultBufferSize);
  else
    v1[5] = 0;
  v1[6] = -1;
  v1[1] = 0;
  v1[2] = 0;
  *v1 = 0;
  v1[8] = 0;
  return v1;
}
// 496494: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A4B84: using guessed type int xmlDefaultBufferSize;

//----- (0043C229) --------------------------------------------------------
_DWORD *__cdecl xmlAllocOutputBuffer(int a1)
{
  _DWORD *v1; // esi
  _DWORD *v3; // eax
  _DWORD *Size; // eax

  v1 = (_DWORD *)xmlMalloc(32);
  if ( !v1 )
  {
    sub_43B76D("creating output buffer");
    return 0;
  }
  memset(v1, 0, 0x20u);
  v3 = xmlBufferCreate();
  v1[4] = v3;
  if ( !v3 )
    goto LABEL_8;
  if ( v3[3] == 1 )
    v3[3] = 0;
  v1[3] = a1;
  if ( a1 )
  {
    Size = xmlBufferCreateSize(4000);
    v1[5] = Size;
    if ( !Size )
    {
LABEL_8:
      ((void (__cdecl *)(_DWORD *))xmlFree)(v1);
      return 0;
    }
    xmlCharEncOutFunc(a1, Size, 0);
  }
  else
  {
    v1[5] = 0;
  }
  v1[1] = 0;
  v1[2] = 0;
  *v1 = 0;
  v1[6] = 0;
  return v1;
}
// 496494: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (0043C2B4) --------------------------------------------------------
_DWORD *__usercall sub_43C2B4@<eax>(int a1@<ebx>)
{
  _DWORD *v1; // esi
  _DWORD *v3; // eax
  _DWORD *Size; // eax

  v1 = (_DWORD *)xmlMalloc(32);
  if ( !v1 )
  {
    sub_43B76D("creating output buffer");
    return 0;
  }
  memset(v1, 0, 0x20u);
  v3 = xmlBufferCreate();
  v1[4] = v3;
  if ( !v3 )
  {
LABEL_5:
    ((void (__cdecl *)(_DWORD *))xmlFree)(v1);
    return 0;
  }
  v3[3] = 3;
  *(_DWORD *)(v1[4] + 16) = *(_DWORD *)v1[4];
  v1[3] = a1;
  if ( a1 )
  {
    Size = xmlBufferCreateSize(4000);
    v1[5] = Size;
    if ( !Size )
      goto LABEL_5;
    xmlCharEncOutFunc(a1, Size, 0);
  }
  else
  {
    v1[5] = 0;
  }
  v1[1] = 0;
  v1[2] = 0;
  *v1 = 0;
  v1[6] = 0;
  return v1;
}
// 496494: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (0043C33E) --------------------------------------------------------
void __cdecl xmlFreeParserInputBuffer(int **Block)
{
  int *v1; // eax

  if ( Block )
  {
    if ( Block[5] )
    {
      xmlBufferFree(Block[5]);
      Block[5] = 0;
    }
    if ( Block[3] )
      xmlCharEncCloseFunc(Block[3]);
    v1 = Block[2];
    if ( v1 )
      ((void (__cdecl *)(int *))v1)(*Block);
    if ( Block[4] )
    {
      xmlBufferFree(Block[4]);
      Block[4] = 0;
    }
    ((void (__cdecl *)(int **))xmlFree)(Block);
  }
}
// 496494: invalid function type has been ignored

//----- (0043C38F) --------------------------------------------------------
int __cdecl xmlOutputBufferClose(_DWORD *Block)
{
  int v1; // edi
  int result; // eax
  int (__cdecl *v3)(_DWORD); // eax
  int *v4; // eax
  int v5; // ebx

  v1 = 0;
  if ( !Block )
    return -1;
  if ( Block[1] )
    xmlOutputBufferFlush(Block);
  v3 = (int (__cdecl *)(_DWORD))Block[2];
  if ( v3 )
    v1 = v3(*Block);
  v4 = (int *)Block[5];
  v5 = Block[6];
  if ( v4 )
  {
    xmlBufferFree(v4);
    Block[5] = 0;
  }
  if ( Block[3] )
    xmlCharEncCloseFunc((_DWORD *)Block[3]);
  if ( Block[4] )
  {
    xmlBufferFree((int *)Block[4]);
    Block[4] = 0;
  }
  if ( Block[7] )
    v1 = -1;
  ((void (__cdecl *)(_DWORD *))xmlFree)(Block);
  result = v5;
  if ( v1 )
    return v1;
  return result;
}
// 496494: invalid function type has been ignored

//----- (0043C40D) --------------------------------------------------------
_DWORD *__cdecl sub_43C40D(int a1, int a2)
{
  int v3; // edi
  int *i; // esi
  int v5; // ebx
  _DWORD *v6; // eax
  _DWORD *v7; // esi

  if ( !dword_4A9C44 )
    xmlRegisterDefaultInputCallbacks();
  if ( !a1 )
    return 0;
  v3 = dword_4A9C40 - 1;
  if ( dword_4A9C40 - 1 < 0 )
    return 0;
  for ( i = &dword_4A79D0[4 * v3]; ; i -= 4 )
  {
    if ( *i )
    {
      if ( ((int (__cdecl *)(int))*i)(a1) )
      {
        v5 = ((int (__cdecl *)(int))i[1])(a1);
        if ( v5 )
          break;
      }
    }
    if ( --v3 < 0 )
      return 0;
  }
  v6 = xmlAllocParserInputBuffer(a2);
  v7 = v6;
  if ( v6 )
  {
    *v6 = v5;
    v6[1] = dword_4A79D8[4 * v3];
    v6[2] = dword_4A79DC[4 * v3];
  }
  else
  {
    ((void (__cdecl *)(int))dword_4A79DC[4 * v3])(v5);
  }
  return v7;
}
// 43C468: conditional instruction was optimized away because ebx.4==0
// 4A79D0: using guessed type int dword_4A79D0[];
// 4A79D8: using guessed type int dword_4A79D8[];
// 4A79DC: using guessed type int dword_4A79DC[57];
// 4A9C40: using guessed type int dword_4A9C40;
// 4A9C44: using guessed type int dword_4A9C44;

//----- (0043C4AA) --------------------------------------------------------
_DWORD *__cdecl xmlParserInputBufferCreateFilename(int a1, int a2)
{
  if ( xmlParserInputBufferCreateFilenameValue )
    return (_DWORD *)xmlParserInputBufferCreateFilenameValue(a1, a2);
  else
    return sub_43C40D(a1, a2);
}
// 4A9CBC: using guessed type int (__cdecl *xmlParserInputBufferCreateFilenameValue)(_DWORD, _DWORD);

//----- (0043C4BA) --------------------------------------------------------
_DWORD *__cdecl sub_43C4BA(char *a1, int a2)
{
  _DWORD *result; // eax
  char **v3; // eax
  char **v4; // esi
  char *v5; // eax
  int v6; // edi
  int *v7; // esi
  int *i; // esi
  int v9; // [esp+4h] [ebp-8h]
  void *Block; // [esp+8h] [ebp-4h]

  v9 = 0;
  Block = 0;
  if ( !dword_4A9C4C )
    xmlRegisterDefaultOutputCallbacks();
  if ( !a1 )
    return 0;
  v3 = (char **)xmlParseURI(a1);
  v4 = v3;
  if ( !v3 )
    goto LABEL_17;
  v5 = *v3;
  if ( !*v4 || xmlStrEqual(v5, "file") )
    Block = (void *)xmlURIUnescapeString(a1, 0, 0);
  xmlFreeURI(v4);
  if ( !Block )
    goto LABEL_17;
  v6 = dword_4A9C48 - 1;
  if ( dword_4A9C48 - 1 >= 0 )
  {
    v7 = &dword_4A7AC0[4 * v6];
    do
    {
      if ( *v7 )
      {
        if ( ((int (__cdecl *)(void *))*v7)(Block) )
        {
          v9 = ((int (__cdecl *)(void *))v7[1])(Block);
          if ( v9 )
            break;
        }
      }
      --v6;
      v7 -= 4;
    }
    while ( v6 >= 0 );
  }
  ((void (__cdecl *)(void *))xmlFree)(Block);
  if ( !v9 )
  {
LABEL_17:
    v6 = dword_4A9C48 - 1;
    if ( dword_4A9C48 - 1 < 0 )
      return 0;
    for ( i = &dword_4A7AC0[4 * v6]; ; i -= 4 )
    {
      if ( *i )
      {
        if ( ((int (__cdecl *)(char *))*i)(a1) )
        {
          v9 = ((int (__cdecl *)(char *))i[1])(a1);
          if ( v9 )
            break;
        }
      }
      if ( --v6 < 0 )
        return 0;
    }
  }
  result = sub_43C2B4(a2);
  if ( result )
  {
    *result = v9;
    result[1] = dword_4A7AC8[4 * v6];
    result[2] = dword_4A7ACC[4 * v6];
  }
  return result;
}
// 496494: invalid function type has been ignored
// 43C5AF: conditional instruction was optimized away because %var_8.4==0
// 4A7AC0: using guessed type int dword_4A7AC0[];
// 4A7AC8: using guessed type int dword_4A7AC8[];
// 4A7ACC: using guessed type int dword_4A7ACC[57];
// 4A9C48: using guessed type int dword_4A9C48;
// 4A9C4C: using guessed type int dword_4A9C4C;

//----- (0043C5E2) --------------------------------------------------------
_DWORD *__cdecl xmlOutputBufferCreateFilename(char *a1, int a2)
{
  if ( xmlOutputBufferCreateFilenameValue )
    return (_DWORD *)xmlOutputBufferCreateFilenameValue();
  else
    return sub_43C4BA(a1, a2);
}
// 4A9CC4: invalid function type has been ignored
// 4A9CC4: using guessed type int (*xmlOutputBufferCreateFilenameValue)(void);

//----- (0043C5F7) --------------------------------------------------------
_DWORD *__cdecl xmlParserInputBufferCreateFile(int a1, int a2)
{
  _DWORD *result; // eax

  if ( !dword_4A9C44 )
    xmlRegisterDefaultInputCallbacks();
  if ( !a1 )
    return 0;
  result = xmlAllocParserInputBuffer(a2);
  if ( result )
  {
    *result = a1;
    result[1] = xmlFileRead;
    result[2] = sub_43C041;
  }
  return result;
}
// 4A9C44: using guessed type int dword_4A9C44;

//----- (0043C632) --------------------------------------------------------
_DWORD *__cdecl xmlOutputBufferCreateFile(int a1, int a2)
{
  _DWORD *result; // eax

  if ( !dword_4A9C4C )
    xmlRegisterDefaultOutputCallbacks();
  if ( !a1 )
    return 0;
  result = sub_43C2B4(a2);
  if ( result )
  {
    *result = a1;
    result[1] = sub_43BF80;
    result[2] = sub_43C041;
  }
  return result;
}
// 4A9C4C: using guessed type int dword_4A9C4C;

//----- (0043C66E) --------------------------------------------------------
_DWORD *__cdecl xmlOutputBufferCreateBuffer(int a1, int a2)
{
  if ( a1 )
    return xmlOutputBufferCreateIO((int)sub_43C075, 0, a1, a2);
  else
    return 0;
}

//----- (0043C690) --------------------------------------------------------
_DWORD *__cdecl xmlParserInputBufferCreateFd(int a1, int a2)
{
  _DWORD *result; // eax

  if ( a1 < 0 )
    return 0;
  result = xmlAllocParserInputBuffer(a2);
  if ( result )
  {
    *result = a1;
    result[1] = sub_43BD70;
    result[2] = sub_43BDD0;
  }
  return result;
}
// 43BDD0: using guessed type int sub_43BDD0();

//----- (0043C6BD) --------------------------------------------------------
_DWORD *__cdecl xmlParserInputBufferCreateMem(_BYTE *Src, int a2, int a3)
{
  _DWORD *v4; // eax
  _DWORD *v5; // esi
  int *v6; // [esp-14h] [ebp-14h]

  if ( a2 <= 0 )
    return 0;
  if ( !Src )
    return 0;
  v4 = xmlAllocParserInputBuffer(a3);
  v5 = v4;
  if ( !v4 )
    return v5;
  v4[2] = 0;
  v6 = (int *)v4[4];
  *v4 = Src;
  v4[1] = xmlSAX2GetPublicId;
  if ( !xmlBufferAdd(v6, Src, a2) )
    return v5;
  ((void (__cdecl *)(_DWORD *))xmlFree)(v5);
  return 0;
}
// 496494: invalid function type has been ignored

//----- (0043C717) --------------------------------------------------------
int *__cdecl xmlParserInputBufferCreateStatic(int a1, int a2, int a3)
{
  int *v4; // esi
  _DWORD *Static; // eax
  int CharEncodingHandler; // eax

  if ( a2 <= 0 )
    return 0;
  if ( !a1 )
    return 0;
  v4 = (int *)xmlMalloc(36);
  if ( v4 )
  {
    memset(v4, 0, 0x24u);
    Static = xmlBufferCreateStatic(a1, a2);
    v4[4] = (int)Static;
    if ( Static )
    {
      CharEncodingHandler = xmlGetCharEncodingHandler(a3);
      v4[3] = CharEncodingHandler;
      if ( CharEncodingHandler )
        v4[5] = (int)xmlBufferCreateSize(2 * xmlDefaultBufferSize);
      else
        v4[5] = 0;
      v4[6] = -1;
      *v4 = a1;
      v4[1] = 0;
      v4[2] = 0;
      return v4;
    }
    else
    {
      ((void (__cdecl *)(int *))xmlFree)(v4);
      return 0;
    }
  }
  else
  {
    sub_43B76D("creating input buffer");
    return 0;
  }
}
// 496494: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A4B84: using guessed type int xmlDefaultBufferSize;

//----- (0043C7B1) --------------------------------------------------------
_DWORD *__cdecl xmlOutputBufferCreateFd(int a1, int a2)
{
  _DWORD *result; // eax

  if ( a1 < 0 )
    return 0;
  result = sub_43C2B4(a2);
  if ( result )
  {
    result[2] = 0;
    *result = a1;
    result[1] = sub_43BD9C;
  }
  return result;
}

//----- (0043C7DC) --------------------------------------------------------
_DWORD *__cdecl xmlParserInputBufferCreateIO(int a1, int a2, int a3, int a4)
{
  _DWORD *result; // eax

  if ( !a1 )
    return 0;
  result = xmlAllocParserInputBuffer(a4);
  if ( result )
  {
    *result = a3;
    result[1] = a1;
    result[2] = a2;
  }
  return result;
}

//----- (0043C809) --------------------------------------------------------
_DWORD *__cdecl xmlOutputBufferCreateIO(int a1, int a2, int a3, int a4)
{
  _DWORD *result; // eax

  if ( !a1 )
    return 0;
  result = sub_43C2B4(a4);
  if ( result )
  {
    *result = a3;
    result[1] = a1;
    result[2] = a2;
  }
  return result;
}

//----- (0043C837) --------------------------------------------------------
_DWORD *(__cdecl *__cdecl xmlParserInputBufferCreateFilenameDefault(int (__cdecl *a1)(_DWORD, _DWORD)))(int a1, int a2)
{
  _DWORD *(__cdecl *result)(int, int); // eax

  result = (_DWORD *(__cdecl *)(int, int))xmlParserInputBufferCreateFilenameValue;
  if ( !xmlParserInputBufferCreateFilenameValue )
    result = sub_43C40D;
  xmlParserInputBufferCreateFilenameValue = a1;
  return result;
}
// 4A9CBC: using guessed type int (__cdecl *xmlParserInputBufferCreateFilenameValue)(_DWORD, _DWORD);

//----- (0043C850) --------------------------------------------------------
int (*__cdecl xmlOutputBufferCreateFilenameDefault(int (*a1)(void)))(void)
{
  int (*result)(void); // eax

  result = xmlOutputBufferCreateFilenameValue;
  if ( !xmlOutputBufferCreateFilenameValue )
    result = (int (*)(void))sub_43C4BA;
  xmlOutputBufferCreateFilenameValue = a1;
  return result;
}
// 4A9CC4: using guessed type int (*xmlOutputBufferCreateFilenameValue)(void);

//----- (0043C869) --------------------------------------------------------
int __cdecl xmlParserInputBufferPush(int a1, int a2, _BYTE *Src)
{
  int v3; // ebx
  int result; // eax
  int v5; // edi

  v3 = a2;
  result = 0;
  if ( a2 >= 0 )
  {
    if ( !a1 || *(_DWORD *)(a1 + 28) )
      return -1;
    if ( *(_DWORD *)(a1 + 12) )
    {
      if ( !*(_DWORD *)(a1 + 20) )
        *(_DWORD *)(a1 + 20) = xmlBufferCreate();
      if ( xmlBufferAdd(*(int **)(a1 + 20), Src, a2) )
        return -1;
      v5 = *(_DWORD *)(*(_DWORD *)(a1 + 20) + 4);
      v3 = xmlCharEncInFunc(*(_DWORD *)(a1 + 12), *(_DWORD **)(a1 + 16), *(unsigned __int8 ***)(a1 + 20));
      if ( v3 < 0 )
      {
        _xmlSimpleError(8, 1544, 0, off_4A4CE8[0], 0);
        *(_DWORD *)(a1 + 28) = 1544;
        return -1;
      }
      *(_DWORD *)(a1 + 32) += v5 - *(_DWORD *)(*(_DWORD *)(a1 + 20) + 4);
    }
    else if ( xmlBufferAdd(*(int **)(a1 + 16), Src, a2) )
    {
      return -1;
    }
    return v3;
  }
  return result;
}
// 4A4CE8: using guessed type char *off_4A4CE8[13];

//----- (0043C90B) --------------------------------------------------------
int __cdecl xmlParserInputBufferGrow(int a1, int a2)
{
  int v2; // ebx
  _DWORD *v3; // eax
  int v4; // ecx
  int v5; // edi
  size_t v6; // ecx
  _BYTE *v7; // edi
  int (__cdecl *v8)(_DWORD, _BYTE *, int); // eax
  int result; // eax
  int v10; // ebx
  int v11; // edi

  if ( !a1 || *(_DWORD *)(a1 + 28) )
    return -1;
  v2 = a2;
  if ( a2 <= 4000 && a2 != 4 )
    v2 = 4000;
  v3 = *(_DWORD **)(a1 + 16);
  v4 = v3[1];
  if ( v3[2] - v4 <= 0 )
  {
    v5 = 1548;
    _xmlSimpleError(8, 1548, 0, off_4A4CF8[0], 0);
LABEL_23:
    *(_DWORD *)(a1 + 28) = v5;
    return -1;
  }
  v6 = v4 + v2 + 1;
  if ( v6 <= v3[2] || xmlBufferResize(v3, v6) )
  {
    v7 = (_BYTE *)(**(_DWORD **)(a1 + 16) + *(_DWORD *)(*(_DWORD *)(a1 + 16) + 4));
    v8 = *(int (__cdecl **)(_DWORD, _BYTE *, int))(a1 + 4);
    if ( !v8 )
    {
      v5 = 1547;
      _xmlSimpleError(8, 1547, 0, off_4A4CF4[0], 0);
      goto LABEL_23;
    }
    result = v8(*(_DWORD *)a1, v7, v2);
    v10 = result;
    if ( result > 0 || (*(_DWORD *)(a1 + 4) = xmlSAX2GetPublicId, result >= 0) )
    {
      if ( !*(_DWORD *)(a1 + 12) )
      {
        *(_DWORD *)(*(_DWORD *)(a1 + 16) + 4) += result;
        v7[result] = 0;
        return result;
      }
      if ( !*(_DWORD *)(a1 + 20) )
        *(_DWORD *)(a1 + 20) = xmlBufferCreate();
      if ( !xmlBufferAdd(*(int **)(a1 + 20), v7, v10) )
      {
        v11 = *(_DWORD *)(*(_DWORD *)(a1 + 20) + 4);
        result = xmlCharEncInFunc(*(_DWORD *)(a1 + 12), *(_DWORD **)(a1 + 16), *(unsigned __int8 ***)(a1 + 20));
        if ( result >= 0 )
        {
          *(_DWORD *)(a1 + 32) += v11 - *(_DWORD *)(*(_DWORD *)(a1 + 20) + 4);
          return result;
        }
        v5 = 1544;
        _xmlSimpleError(8, 1544, 0, off_4A4CE8[0], 0);
        goto LABEL_23;
      }
    }
  }
  else
  {
    sub_43B76D("growing input buffer");
    *(_DWORD *)(a1 + 28) = 2;
  }
  return -1;
}
// 4A4CE8: using guessed type char *off_4A4CE8[13];
// 4A4CF4: using guessed type char *off_4A4CF4[10];
// 4A4CF8: using guessed type char *off_4A4CF8[9];

//----- (0043CA40) --------------------------------------------------------
int __cdecl xmlParserInputBufferRead(_DWORD *a1, int a2)
{
  int v3; // eax

  if ( !a1 || a1[7] )
    return -1;
  if ( a1[1] )
    return xmlParserInputBufferGrow((int)a1, a2);
  v3 = a1[4];
  if ( v3 && *(_DWORD *)(v3 + 12) == 2 )
    return 0;
  else
    return -1;
}

//----- (0043CA75) --------------------------------------------------------
int __cdecl xmlOutputBufferWrite(_DWORD *a1, int a2, char *Src)
{
  int v4; // edi
  int v5; // eax
  int v6; // eax
  int v7; // ebx
  int (__cdecl *v8)(_DWORD, _DWORD, int); // eax
  signed int v9; // eax
  signed int v10; // edi
  signed int v11; // eax
  int v12; // [esp+Ch] [ebp-4h]

  v12 = 0;
  if ( !a1 || a1[7] )
    return -1;
  if ( a2 < 0 )
    return 0;
  do
  {
    v4 = a2;
    if ( a2 > 16000 )
      v4 = 16000;
    if ( a1[3] )
    {
      if ( !a1[5] )
        a1[5] = xmlBufferCreate();
      if ( xmlBufferAdd((int *)a1[4], Src, v4) )
        return -1;
      if ( *(_DWORD *)(a1[4] + 4) < 0xFA0u && v4 == a2 )
        return v12;
      v5 = xmlCharEncOutFunc(a1[3], (_DWORD *)a1[5], (unsigned __int8 **)a1[4]);
      if ( v5 < 0 && v5 != -3 )
      {
        _xmlSimpleError(8, 1544, 0, off_4A4CE8[0], 0);
        a1[7] = 1544;
        return -1;
      }
      v6 = a1[5];
    }
    else
    {
      if ( xmlBufferAdd((int *)a1[4], Src, v4) )
        return -1;
      v6 = a1[4];
    }
    v7 = *(_DWORD *)(v6 + 4);
    Src += v4;
    a2 -= v4;
    if ( v7 < 4000 && a2 <= 0 )
      break;
    v8 = (int (__cdecl *)(_DWORD, _DWORD, int))a1[1];
    if ( v8 )
    {
      if ( a1[3] )
      {
        v9 = v8(*a1, *(_DWORD *)a1[5], v7);
        v10 = v9;
        if ( v9 < 0 )
          goto LABEL_31;
        xmlBufferShrink(a1[5], v9);
      }
      else
      {
        v11 = v8(*a1, *(_DWORD *)a1[4], v7);
        v10 = v11;
        if ( v11 < 0 )
        {
LABEL_31:
          _xmlSimpleError(8, 1546, 0, off_4A4CF0[0], 0);
          a1[7] = 1546;
          return v10;
        }
        xmlBufferShrink(a1[4], v11);
      }
      a1[6] += v10;
    }
    v12 += v7;
  }
  while ( a2 > 0 );
  return v12;
}
// 4A4CE8: using guessed type char *off_4A4CE8[13];
// 4A4CF0: using guessed type char *off_4A4CF0[11];

//----- (0043CBE2) --------------------------------------------------------
int __cdecl sub_43CBE2(_BYTE *a1, int *a2, char *a3, _DWORD *a4)
{
  _BYTE *v4; // eax
  char *v5; // esi
  unsigned int v6; // edi
  unsigned int v7; // edx
  int v8; // ecx
  char v9; // bl
  _BYTE *v10; // eax
  int v11; // ecx
  _BYTE *v12; // eax
  _BYTE *v13; // eax
  _BYTE *v14; // eax

  v4 = a1;
  v5 = a3;
  v6 = (unsigned int)&a3[*a4];
  v7 = (unsigned int)&a1[*a2];
  if ( (unsigned int)a3 < v6 )
  {
    v8 = *a2;
    while ( 1 )
    {
      if ( (unsigned int)v4 >= v7 )
        goto LABEL_20;
      v9 = *v5;
      if ( *v5 == 60 )
        break;
      switch ( v9 )
      {
        case 62:
          if ( v8 < 4 )
            goto LABEL_20;
          *v4 = 38;
          v10 = v4 + 1;
          *v10 = 103;
          goto LABEL_7;
        case 38:
          if ( v8 < 5 )
            goto LABEL_20;
          *v4 = 38;
          v13 = v4 + 1;
          *v13++ = 97;
          *v13 = 109;
          v11 = v8 - 2;
          v12 = v13 + 1;
          *v12 = 112;
          break;
        case 13:
          if ( v8 < 5 )
            goto LABEL_20;
          *v4 = 38;
          v14 = v4 + 1;
          *v14++ = 35;
          *v14 = 49;
          v11 = v8 - 2;
          v12 = v14 + 1;
          *v12 = 51;
          break;
        default:
          *v4 = v9;
          goto LABEL_19;
      }
LABEL_8:
      v4 = v12 + 1;
      v8 = v11 - 2;
      *v4 = 59;
LABEL_19:
      ++v4;
      --v8;
      if ( (unsigned int)++v5 >= v6 )
        goto LABEL_20;
    }
    if ( v8 < 4 )
      goto LABEL_20;
    *v4 = 38;
    v10 = v4 + 1;
    *v10 = 108;
LABEL_7:
    v11 = v8 - 1;
    v12 = v10 + 1;
    *v12 = 116;
    goto LABEL_8;
  }
LABEL_20:
  *a2 = v4 - a1;
  *a4 = v5 - a3;
  return 0;
}

//----- (0043CC9A) --------------------------------------------------------
int __cdecl xmlOutputBufferWriteEscape(
        int a1,
        const char *a2,
        int (__cdecl *a3)(_BYTE *a1, int *a2, char *a3, int *a4))
{
  _DWORD *v3; // esi
  int v4; // edi
  int v5; // eax
  int v6; // ebx
  _DWORD *v8; // ecx
  int v9; // eax
  int v10; // eax
  int v11; // ebx
  int (__cdecl *v12)(_DWORD, _DWORD, int); // eax
  signed int v13; // eax
  signed int v14; // edi
  signed int v15; // eax
  _DWORD *v16; // eax
  int v17; // [esp+Ch] [ebp-10h]
  int v18; // [esp+10h] [ebp-Ch]
  int v19; // [esp+14h] [ebp-8h]
  int v20; // [esp+18h] [ebp-4h] BYREF

  v3 = (_DWORD *)a1;
  v4 = 0;
  v18 = 0;
  if ( !a1 )
    return -1;
  if ( *(_DWORD *)(a1 + 28) )
    return -1;
  if ( !a2 )
    return -1;
  v5 = *(_DWORD *)(a1 + 16);
  if ( !v5 || *(_DWORD *)(v5 + 12) == 2 )
    return -1;
  v6 = strlen(a2);
  v19 = v6;
  if ( v6 < 0 )
    return 0;
  if ( !a3 )
    a3 = sub_43CBE2;
  while ( 1 )
  {
    v8 = (_DWORD *)v3[4];
    v20 = v6;
    v17 = v4;
    a1 = v8[2] - v8[1] - 1;
    if ( a1 < 40 )
    {
      if ( xmlBufferGrow((int)v8, v8[2] + 100) < 0 )
        return -1;
      v17 = -1;
      goto LABEL_38;
    }
    if ( v3[3] )
    {
      if ( !v3[5] )
        v3[5] = xmlBufferCreate();
      if ( a3((_BYTE *)(*(_DWORD *)v3[4] + *(_DWORD *)(v3[4] + 4)), &a1, (char *)a2, &v20) < 0 || !a1 )
        return -1;
      *(_DWORD *)(v3[4] + 4) += a1;
      *(_BYTE *)(*(_DWORD *)(v3[4] + 4) + *(_DWORD *)v3[4]) = 0;
      if ( *(_DWORD *)(v3[4] + 4) < 0xFA0u && v20 == v6 )
        return v18;
      v9 = xmlCharEncOutFunc(v3[3], (_DWORD *)v3[5], (unsigned __int8 **)v3[4]);
      if ( v9 < 0 && v9 != -3 )
      {
        _xmlSimpleError(8, 1544, 0, off_4A4CE8[0], 0);
        v3[7] = 1544;
        return -1;
      }
      v10 = v3[5];
    }
    else
    {
      if ( a3((_BYTE *)(*v8 + v8[1]), &a1, (char *)a2, &v20) < 0 || !a1 )
        return -1;
      *(_DWORD *)(v3[4] + 4) += a1;
      *(_BYTE *)(*(_DWORD *)(v3[4] + 4) + *(_DWORD *)v3[4]) = 0;
      v10 = v3[4];
    }
    v11 = *(_DWORD *)(v10 + 4);
    a2 += v20;
    v19 -= v20;
    if ( v11 < 4000 && v19 <= 0 )
      return v18;
    v12 = (int (__cdecl *)(_DWORD, _DWORD, int))v3[1];
    if ( !v12 )
    {
      v16 = (_DWORD *)v3[4];
      if ( (unsigned int)(v16[2] - v16[1]) < 0xFA0 )
        xmlBufferResize(v16, v16[2] + 4000);
      goto LABEL_37;
    }
    if ( v3[3] )
    {
      v13 = v12(*v3, *(_DWORD *)v3[5], v11);
      v14 = v13;
      if ( v13 < 0 )
        break;
      xmlBufferShrink(v3[5], v13);
      goto LABEL_34;
    }
    v15 = v12(*v3, *(_DWORD *)v3[4], v11);
    v14 = v15;
    if ( v15 < 0 )
      break;
    xmlBufferShrink(v3[4], v15);
LABEL_34:
    v3[6] += v14;
LABEL_37:
    v18 += v11;
    v6 = v19;
LABEL_38:
    if ( v6 > 0 )
    {
      v4 = v18;
      if ( v17 != v18 )
        continue;
    }
    return v18;
  }
  _xmlSimpleError(8, 1546, 0, off_4A4CF0[0], 0);
  v3[7] = 1546;
  return v14;
}
// 4A4CE8: using guessed type char *off_4A4CE8[13];
// 4A4CF0: using guessed type char *off_4A4CF0[11];

//----- (0043CEEC) --------------------------------------------------------
int __cdecl xmlOutputBufferWriteString(_DWORD *a1, char *Src)
{
  int result; // eax

  if ( !a1 || a1[7] || !Src )
    return -1;
  result = strlen(Src);
  if ( result > 0 )
    return xmlOutputBufferWrite(a1, result, Src);
  return result;
}

//----- (0043CF2B) --------------------------------------------------------
int __cdecl xmlOutputBufferFlush(_DWORD *a1)
{
  signed int v1; // edi
  _DWORD *v2; // ecx
  int v3; // eax
  _DWORD *v5; // eax
  int (__cdecl *v6)(_DWORD, _DWORD, _DWORD); // ecx
  signed int v7; // eax
  int (__cdecl *v8)(_DWORD, _DWORD, _DWORD); // ecx
  signed int v9; // eax

  v1 = 0;
  if ( !a1 || a1[7] )
    return -1;
  v2 = (_DWORD *)a1[5];
  if ( v2 )
  {
    v3 = a1[3];
    if ( v3 )
    {
      if ( xmlCharEncOutFunc(v3, v2, (unsigned __int8 **)a1[4]) < 0 )
      {
        _xmlSimpleError(8, 1544, 0, off_4A4CE8[0], 0);
        a1[7] = 1544;
        return -1;
      }
    }
  }
  v5 = (_DWORD *)a1[5];
  if ( !v5 || !a1[3] || (v6 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))a1[1]) == 0 )
  {
    v8 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))a1[1];
    if ( !v8 )
      goto LABEL_16;
    v9 = v8(*a1, *(_DWORD *)a1[4], *(_DWORD *)(a1[4] + 4));
    v1 = v9;
    if ( v9 >= 0 )
    {
      xmlBufferShrink(a1[4], v9);
      goto LABEL_16;
    }
LABEL_17:
    _xmlSimpleError(8, 1545, 0, off_4A4CEC[0], 0);
    a1[7] = 1545;
    return v1;
  }
  v7 = v6(*a1, *v5, v5[1]);
  v1 = v7;
  if ( v7 < 0 )
    goto LABEL_17;
  xmlBufferShrink(a1[5], v7);
LABEL_16:
  a1[6] += v1;
  return v1;
}
// 4A4CE8: using guessed type char *off_4A4CE8[13];
// 4A4CEC: using guessed type char *off_4A4CEC[12];

//----- (0043CFF6) --------------------------------------------------------
int __cdecl xmlParserGetDirectory(char *Source)
{
  int v1; // edi
  char *i; // eax
  char Destination[1023]; // [esp+Ch] [ebp-404h] BYREF
  char v5; // [esp+40Bh] [ebp-5h]

  v1 = 0;
  if ( !dword_4A9C44 )
    xmlRegisterDefaultInputCallbacks();
  if ( !Source )
    return 0;
  strncpy(Destination, Source, 0x3FFu);
  v5 = 0;
  for ( i = &Destination[strlen(Destination)]; i > Destination; --i )
  {
    if ( *i == 47 )
      goto LABEL_14;
    if ( *i == 92 )
      break;
  }
  if ( *i == 47 || *i == 92 )
  {
LABEL_14:
    if ( i == Destination )
      Destination[1] = 0;
    else
      *i = 0;
    return xmlMemStrdup(Destination);
  }
  if ( !_getcwd(Destination, 1024) )
    return v1;
  v5 = 0;
  return xmlMemStrdup(Destination);
}
// 4A4B74: using guessed type int (__cdecl *xmlMemStrdup)(void *Src);
// 4A9C44: using guessed type int dword_4A9C44;

//----- (0043D0D2) --------------------------------------------------------
int __cdecl xmlCheckHTTPInput(int a1, int a2)
{
  return a2;
}

//----- (0043D0D7) --------------------------------------------------------
unsigned __int8 *__usercall sub_43D0D7@<eax>(unsigned __int8 *result@<eax>)
{
  unsigned __int8 *v1; // esi

  v1 = result;
  if ( result )
  {
    if ( xmlStrncasecmp(result, "file://localhost/", 17) )
    {
      if ( !xmlStrncasecmp(v1, "file:///", 8) )
        v1 += 8;
    }
    else
    {
      v1 += 17;
    }
    return (unsigned __int8 *)xmlCheckFilename((char *)v1);
  }
  return result;
}

//----- (0043D119) --------------------------------------------------------
int *__cdecl sub_43D119(unsigned __int8 *ArgList, char *a2, int *a3)
{
  int v3; // edi
  int *result; // eax

  if ( a3 && (v3 = a3[90], (v3 & 0x800) != 0) )
  {
    a3[90] = v3 - 2048;
    result = (int *)xmlNoNetExternalEntityLoader(ArgList, (int)a2, (int)a3);
    a3[90] = v3;
  }
  else if ( ArgList )
  {
    return xmlNewInputFromFile(a3, (char *)ArgList);
  }
  else
  {
    if ( !a2 )
      a2 = "NULL";
    sub_43BAB2(a3, "failed to load external entity \"%s\"\n", a2);
    return 0;
  }
  return result;
}
// 43D119: using guessed type unsigned __int8 *ArgList;

//----- (0043D18B) --------------------------------------------------------
int (__cdecl *__cdecl xmlSetExternalEntityLoader(int (__cdecl *a1)(char ArgList, int, int)))(char ArgList, int, int)
{
  int (__cdecl *result)(char, int, int); // eax

  result = a1;
  off_4A4D24 = a1;
  return result;
}
// 4A4D24: using guessed type int (__cdecl *off_4A4D24)(char ArgList, int, int);

//----- (0043D195) --------------------------------------------------------
int (__cdecl *xmlGetExternalEntityLoader())(char ArgList, int, int)
{
  return off_4A4D24;
}
// 4A4D24: using guessed type int (__cdecl *off_4A4D24)(char ArgList, int, int);

//----- (0043D19B) --------------------------------------------------------
int __cdecl xmlLoadExternalEntity(char *Source, int a2, int a3)
{
  _BYTE *v3; // eax
  _BYTE *v4; // esi
  int v6; // edi

  if ( !Source || sub_43D0D7((unsigned __int8 *)Source) )
    return off_4A4D24((char)Source, a2, a3);
  v3 = xmlCanonicPath(Source);
  v4 = v3;
  if ( v3 )
  {
    v6 = off_4A4D24((char)v3, a2, a3);
    ((void (__cdecl *)(_BYTE *))xmlFree)(v4);
    return v6;
  }
  else
  {
    sub_43B76D("building canonical path\n");
    return 0;
  }
}
// 496494: invalid function type has been ignored
// 4A4D24: using guessed type int (__cdecl *off_4A4D24)(char ArgList, int, int);

//----- (0043D1FF) --------------------------------------------------------
int __cdecl xmlNoNetExternalEntityLoader(unsigned __int8 *ArgList, int a2, int a3)
{
  if ( !ArgList || xmlStrncasecmp(ArgList, "ftp://", 6) && xmlStrncasecmp(ArgList, "http://", 7) )
    return sub_43D119((char)ArgList, a2, a3);
  _xmlSimpleError(8, 1543, 0, off_4A4CE4[0], ArgList);
  return 0;
}
// 4A4CE4: using guessed type char *off_4A4CE4[14];
// 43D1FF: using guessed type unsigned __int8 *ArgList;

//----- (0043D25F) --------------------------------------------------------
void __usercall sub_43D25F(_DWORD *a1@<esi>, int a2)
{
  void (*v2)(_DWORD, const char *, ...); // eax

  if ( a1 )
  {
    if ( *a1 )
    {
      v2 = *(void (**)(_DWORD, const char *, ...))(*a1 + 88);
      if ( v2 )
        v2(a1[1], "%s: out of memory\n", a2);
    }
    a1[43] = -1;
    a1[21] = 2;
    a1[53] = 1;
  }
}

//----- (0043D29A) --------------------------------------------------------
void __usercall sub_43D29A(int a1@<ecx>, _BYTE *a2@<edx>, _BYTE *a3@<ebx>, int a4@<esi>, char *Format)
{
  int v5; // eax
  int (__cdecl *v6)(FILE *, int *); // eax

  if ( a4 )
  {
    if ( !*(_DWORD *)(a4 + 212) || *(_DWORD *)(a4 + 172) != -1 )
    {
      v5 = *(_DWORD *)a4;
      *(_DWORD *)(a4 + 84) = a1;
      if ( v5 && *(_DWORD *)(v5 + 108) == -554844497 )
        v6 = *(int (__cdecl **)(FILE *, int *))(v5 + 124);
      else
        v6 = 0;
      _xmlRaiseError(
        v6,
        *(int (__cdecl **)(int, char *, char))(a4 + 112),
        *(FILE **)(a4 + 108),
        (int *)a4,
        0,
        4,
        a1,
        2,
        0,
        0,
        a3,
        a2,
        0,
        0,
        0,
        Format,
        a3,
        a2);
      *(_DWORD *)(a4 + 100) = 0;
    }
  }
  else
  {
    _xmlRaiseError(0, 0, 0, 0, 0, 4, a1, 2, 0, 0, a3, a2, 0, 0, 0, Format, a3, a2);
  }
}

//----- (0043D314) --------------------------------------------------------
int (__cdecl *__usercall sub_43D314@<eax>(
        int (__cdecl *result)(int, char *Format, char ArgList)@<eax>,
        int *a2@<edi>,
        char *Format,
        _BYTE *Src))(int, char *Format, char ArgList)
{
  if ( a2 )
  {
    if ( a2[53] && a2[43] == -1 )
      return result;
    a2[21] = (int)result;
  }
  result = _xmlRaiseError(0, 0, 0, a2, 0, 1, (int)result, 3, 0, 0, Src, 0, 0, 0, 0, Format, Src, 0);
  if ( a2 )
  {
    a2[3] = 0;
    a2[25] = 0;
    if ( !a2[72] )
      a2[53] = 1;
  }
  return result;
}

//----- (0043D372) --------------------------------------------------------
int (__cdecl *__cdecl sub_43D372(char *Src))(int, char *Format, char ArgList)
{
  int *v1; // ecx
  int (__cdecl *result)(int, char *, char); // eax

  result = 0;
  if ( !v1 )
    return _xmlRaiseError(
             0,
             0,
             0,
             v1,
             0,
             1,
             107,
             1,
             0,
             0,
             Src,
             0,
             0,
             0,
             0,
             "Entity(%s) already defined in the internal subset\n",
             Src);
  if ( !v1[53] || v1[43] != -1 )
  {
    v1[21] = 107;
    return _xmlRaiseError(
             0,
             0,
             0,
             v1,
             0,
             1,
             107,
             1,
             0,
             0,
             Src,
             0,
             0,
             0,
             0,
             "Entity(%s) already defined in the internal subset\n",
             Src);
  }
  return result;
}
// 43D379: variable 'v1' is possibly undefined

//----- (0043D3B5) --------------------------------------------------------
int (__cdecl *__usercall sub_43D3B5@<eax>(
        int *a1@<ecx>,
        int a2@<edx>,
        char *Format,
        _BYTE *Src,
        _BYTE *a5))(int, char *Format, char ArgList)
{
  int (__cdecl *result)(int, char *, char); // eax

  result = 0;
  if ( !a1 )
    return _xmlRaiseError(0, 0, 0, a1, 0, 3, a2, 2, 0, 0, Src, a5, 0, 0, 0, Format, Src, a5);
  if ( !a1[53] || a1[43] != -1 )
  {
    a1[21] = a2;
    return _xmlRaiseError(0, 0, 0, a1, 0, 3, a2, 2, 0, 0, Src, a5, 0, 0, 0, Format, Src, a5);
  }
  return result;
}

//----- (0043D3FA) --------------------------------------------------------
int (__cdecl *__usercall sub_43D3FA@<eax>(
        int *a1@<ecx>,
        int a2@<edx>,
        char *Format,
        _BYTE *Src,
        _BYTE *a5))(int, char *Format, char ArgList)
{
  int (__cdecl *result)(int, char *, char); // eax

  result = 0;
  if ( !a1 )
    return _xmlRaiseError(0, 0, 0, a1, 0, 3, a2, 1, 0, 0, Src, a5, 0, 0, 0, Format, Src, a5);
  if ( !a1[53] || a1[43] != -1 )
  {
    a1[21] = a2;
    return _xmlRaiseError(0, 0, 0, a1, 0, 3, a2, 1, 0, 0, Src, a5, 0, 0, 0, Format, Src, a5);
  }
  return result;
}

//----- (0043D43F) --------------------------------------------------------
int xmlSAX2GetPublicId()
{
  return 0;
}

//----- (0043D442) --------------------------------------------------------
int __cdecl xmlSAX2GetSystemId(int a1)
{
  int v1; // eax

  if ( a1 && (v1 = *(_DWORD *)(a1 + 36)) != 0 )
    return *(_DWORD *)(v1 + 4);
  else
    return 0;
}

//----- (0043D458) --------------------------------------------------------
int __cdecl xmlSAX2GetLineNumber(int a1)
{
  int v1; // eax

  if ( a1 && (v1 = *(_DWORD *)(a1 + 36)) != 0 )
    return *(_DWORD *)(v1 + 28);
  else
    return 0;
}

//----- (0043D46E) --------------------------------------------------------
int __cdecl xmlSAX2GetColumnNumber(int a1)
{
  int v1; // eax

  if ( a1 && (v1 = *(_DWORD *)(a1 + 36)) != 0 )
    return *(_DWORD *)(v1 + 32);
  else
    return 0;
}

//----- (0043D484) --------------------------------------------------------
BOOL __cdecl xmlSAX2IsStandalone(int a1)
{
  int v1; // eax

  return a1 && (v1 = *(_DWORD *)(a1 + 8)) != 0 && *(_DWORD *)(v1 + 40) == 1;
}

//----- (0043D4A2) --------------------------------------------------------
BOOL __cdecl xmlSAX2HasInternalSubset(int a1)
{
  int v1; // eax

  return a1 && (v1 = *(_DWORD *)(a1 + 8)) != 0 && *(_DWORD *)(v1 + 44) != 0;
}

//----- (0043D4BF) --------------------------------------------------------
BOOL __cdecl xmlSAX2HasExternalSubset(int a1)
{
  int v1; // eax

  return a1 && (v1 = *(_DWORD *)(a1 + 8)) != 0 && *(_DWORD *)(v1 + 48) != 0;
}

//----- (0043D4DC) --------------------------------------------------------
void __cdecl xmlSAX2InternalSubset(_DWORD *a1, _BYTE *a2, _BYTE *a3, _BYTE *a4)
{
  int v4; // eax
  int IntSubset; // eax
  _DWORD *v6; // edi

  if ( a1 )
  {
    v4 = a1[2];
    if ( v4 )
    {
      IntSubset = xmlGetIntSubset(v4);
      v6 = (_DWORD *)IntSubset;
      if ( IntSubset )
      {
        if ( a1[8] )
          return;
        xmlUnlinkNode(IntSubset);
        xmlFreeDtd(v6);
        *(_DWORD *)(a1[2] + 44) = 0;
      }
      *(_DWORD *)(a1[2] + 44) = xmlCreateIntSubset((_DWORD *)a1[2], a2, a3, a4);
      if ( !*(_DWORD *)(a1[2] + 44) )
        sub_43D25F(a1, (int)"xmlSAX2InternalSubset");
    }
  }
}

//----- (0043D549) --------------------------------------------------------
void __cdecl xmlSAX2ExternalSubset(int *Block, _BYTE *a2, _BYTE *a3, char *Source)
{
  int (__cdecl *v5)(int, _BYTE *, char *); // eax
  int v6; // edi
  int v7; // ebx
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // [esp+8h] [ebp-Ch]
  int v13; // [esp+Ch] [ebp-8h]
  int v14; // [esp+10h] [ebp-4h]
  void *Blocka; // [esp+1Ch] [ebp+8h]

  if ( Block && (a3 || Source) && (Block[26] || Block[69]) )
  {
    if ( Block[3] )
    {
      if ( Block[2] )
      {
        if ( *Block )
        {
          v5 = *(int (__cdecl **)(int, _BYTE *, char *))(*Block + 16);
          if ( v5 )
          {
            v6 = v5(Block[1], a3, Source);
            if ( v6 )
            {
              xmlNewDtd(Block[2], a2, a3, Source);
              v7 = Block[9];
              Blocka = (void *)Block[10];
              v14 = Block[11];
              v13 = Block[12];
              v12 = Block[64];
              v8 = xmlMalloc(20);
              Block[12] = v8;
              if ( v8 )
              {
                Block[10] = 0;
                Block[9] = 0;
                Block[11] = 5;
                xmlPushInput(Block, (const char **)v6);
                v9 = Block[9];
                if ( *(int *)(v9 + 24) >= 4 )
                {
                  v10 = xmlDetectCharEncoding(*(char **)(v9 + 16), 4);
                  xmlSwitchEncoding(Block, v10);
                }
                if ( !*(_DWORD *)(v6 + 4) )
                  *(_DWORD *)(v6 + 4) = xmlCanonicPath(Source);
                *(_DWORD *)(v6 + 28) = 1;
                *(_DWORD *)(v6 + 32) = 1;
                *(_DWORD *)(v6 + 12) = *(_DWORD *)(Block[9] + 16);
                v11 = *(_DWORD *)(Block[9] + 16);
                *(_DWORD *)(v6 + 40) = 0;
                *(_DWORD *)(v6 + 16) = v11;
                xmlParseExternalSubset(Block, a3, Source);
                while ( Block[10] > 1 )
                  xmlPopInput(Block);
                xmlFreeInputStream((int ***)Block[9]);
                ((void (__cdecl *)(int))xmlFree)(Block[12]);
              }
              else
              {
                sub_43D25F(Block, (int)"xmlSAX2ExternalSubset");
              }
              Block[10] = (int)Blocka;
              Block[11] = v14;
              Block[12] = v13;
              Block[64] = v12;
              Block[9] = v7;
            }
          }
        }
      }
    }
  }
}
// 496494: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);

//----- (0043D6C7) --------------------------------------------------------
int __cdecl xmlSAX2ResolveEntity(int a1, int a2, _BYTE *a3)
{
  int v4; // eax
  _BYTE *v5; // eax
  char *v6; // edi
  int ExternalEntity; // esi

  if ( !a1 )
    return 0;
  v4 = *(_DWORD *)(a1 + 36);
  if ( !v4 || (v5 = *(_BYTE **)(v4 + 4)) == 0 )
    v5 = *(_BYTE **)(a1 + 180);
  v6 = (char *)xmlBuildURI(a3, v5);
  ExternalEntity = xmlLoadExternalEntity(v6, a2, a1);
  if ( v6 )
    ((void (__cdecl *)(char *))xmlFree)(v6);
  return ExternalEntity;
}
// 496494: invalid function type has been ignored

//----- (0043D716) --------------------------------------------------------
_DWORD *__cdecl xmlSAX2GetEntity(int *a1, char *a2)
{
  int *v2; // edi
  _DWORD *result; // eax
  int v4; // esi
  _DWORD *v5; // ebx
  _DWORD *v6; // ebx
  _DWORD *v7; // eax
  _DWORD *DocEntity; // esi
  bool v9; // zf
  char *v10; // [esp-Ch] [ebp-10h]
  char *v11; // [esp-Ch] [ebp-10h]

  v2 = a1;
  if ( !a1 )
    return 0;
  v4 = a1[54];
  if ( v4 || (result = xmlGetPredefinedEntity(a2)) == 0 )
  {
    v5 = (_DWORD *)v2[2];
    if ( v5 && v5[10] == 1 )
    {
      v10 = a2;
      if ( v4 != 2 )
      {
        DocEntity = xmlGetDocEntity(v5, a2);
        if ( DocEntity )
          goto LABEL_16;
        v11 = a2;
        v5[10] = 0;
        DocEntity = xmlGetDocEntity((_DWORD *)v2[2], v11);
        if ( DocEntity )
          sub_43D314(
            (int (__cdecl *)(int, char *, char))0x67,
            v2,
            "Entity(%s) document marked standalone but requires external subset\n",
            a2);
        *(_DWORD *)(v2[2] + 40) = 1;
LABEL_15:
        if ( !DocEntity )
          return DocEntity;
LABEL_16:
        if ( (v2[26] || v2[4]) && !DocEntity[3] && DocEntity[12] == 2 )
        {
          if ( xmlParseCtxtExternalEntity((int)v2, (char *)DocEntity[16], DocEntity[13], &a1) )
          {
            sub_43D314((int (__cdecl *)(int, char *, char))0x68, v2, "Failure to process entity %s\n", a2);
            v2[26] = 0;
            return 0;
          }
          xmlAddChildList(DocEntity, (_BYTE **)a1);
          v9 = DocEntity[18] == 0;
          DocEntity[17] = 1;
          if ( v9 )
            DocEntity[18] = 1;
        }
        return DocEntity;
      }
      v5[10] = 0;
      v6 = (_DWORD *)v2[2];
      v7 = xmlGetDocEntity(v6, v10);
      v6[10] = 1;
    }
    else
    {
      v7 = xmlGetDocEntity(v5, a2);
    }
    DocEntity = v7;
    goto LABEL_15;
  }
  return result;
}

//----- (0043D82C) --------------------------------------------------------
int __cdecl xmlSAX2GetParameterEntity(int a1, char *a2)
{
  int result; // eax

  result = a1;
  if ( a1 )
    return xmlGetParameterEntity(*(_DWORD *)(a1 + 8), a2);
  return result;
}

//----- (0043D844) --------------------------------------------------------
void __cdecl xmlSAX2EntityDecl(int *a1, char *Src, int a3, char *a4, char *a5, _BYTE *a6)
{
  int v6; // eax
  _DWORD *v7; // esi
  int v8; // eax
  _BYTE *v9; // eax
  void (*v10)(int, const char *, ...); // eax

  if ( !a1 )
    return;
  v6 = a1[54];
  if ( v6 == 1 )
  {
    v7 = xmlAddDocEntity(a1[2], Src, a3, a4, a5, a6);
    if ( !v7 )
    {
      if ( a1[67] )
        sub_43D372(Src);
      return;
    }
    goto LABEL_6;
  }
  if ( v6 != 2 )
  {
    sub_43D314(
      (int (__cdecl *)(int, char *, char))0x68,
      a1,
      "SAX.xmlSAX2EntityDecl(%s) called while not in subset\n",
      Src);
    return;
  }
  v7 = xmlAddDtdEntity(a1[2], Src, a3, a4, a5, a6);
  if ( v7 )
  {
LABEL_6:
    if ( !v7[16] && a5 )
    {
      v8 = a1[9];
      if ( !v8 || (v9 = *(_BYTE **)(v8 + 4)) == 0 )
        v9 = (_BYTE *)a1[45];
      v7[16] = xmlBuildURI(a5, v9);
    }
    return;
  }
  if ( a1[67] )
  {
    if ( *a1 )
    {
      v10 = *(void (**)(int, const char *, ...))(*a1 + 84);
      if ( v10 )
        v10(a1[1], "Entity(%s) already defined in the external subset\n", Src);
    }
  }
}

//----- (0043D934) --------------------------------------------------------
void __cdecl xmlSAX2AttributeDecl(int *a1, char *a2, char *a3, int a4, int a5, char *a6, void **a7)
{
  int v7; // edi
  char *v8; // eax
  int v9; // ecx
  char *v10; // edi
  void *Block; // [esp+4h] [ebp-4h] BYREF

  Block = 0;
  if ( a1 && a1[2] )
  {
    if ( xmlStrEqual(a3, "xml:id") && a4 != 2 )
    {
      v7 = a1[25];
      sub_43D29A(540, 0, 0, (int)a1, "xml:id : attribute type should be ID\n");
      a1[25] = v7;
    }
    v8 = xmlSplitQName(a1, a3, &Block);
    v9 = a1[54];
    v10 = v8;
    a1[36] = 1;
    if ( v9 == 1 )
    {
      xmlAddAttributeDecl((int)(a1 + 27), *(_DWORD **)(a1[2] + 44), a2, v8, (char *)Block, a4, a5, a6, a7);
    }
    else
    {
      if ( v9 != 2 )
      {
        sub_43D314(
          (int (__cdecl *)(int, char *, char))1,
          a1,
          "SAX.xmlSAX2AttributeDecl(%s) called while not in subset\n",
          v8);
        xmlFreeEnumeration(a7);
        return;
      }
      xmlAddAttributeDecl((int)(a1 + 27), *(_DWORD **)(a1[2] + 48), a2, v8, (char *)Block, a4, a5, a6, a7);
    }
    if ( Block )
      ((void (__cdecl *)(void *))xmlFree)(Block);
    if ( v10 )
      ((void (__cdecl *)(char *))xmlFree)(v10);
  }
}
// 496494: invalid function type has been ignored

//----- (0043DA2C) --------------------------------------------------------
void __cdecl xmlSAX2ElementDecl(int *a1, char *Src, int a3, _DWORD *a4)
{
  int v4; // eax
  int v5; // ecx

  if ( a1 )
  {
    v4 = a1[2];
    if ( v4 )
    {
      v5 = a1[54];
      if ( v5 == 1 )
      {
        xmlAddElementDecl((int)(a1 + 27), *(_DWORD **)(v4 + 44), Src, a3, a4);
      }
      else if ( v5 == 2 )
      {
        xmlAddElementDecl((int)(a1 + 27), *(_DWORD **)(v4 + 48), Src, a3, a4);
      }
      else
      {
        sub_43D314(
          (int (__cdecl *)(int, char *, char))1,
          a1,
          "SAX.xmlSAX2ElementDecl(%s) called while not in subset\n",
          Src);
      }
    }
  }
}

//----- (0043DA8B) --------------------------------------------------------
void __cdecl xmlSAX2NotationDecl(int *a1, unsigned __int8 *Src, _BYTE *a3, _BYTE *a4)
{
  int v4; // eax
  int v5; // ecx

  if ( a1 )
  {
    v4 = a1[2];
    if ( v4 )
    {
      if ( a3 || a4 )
      {
        v5 = a1[54];
        if ( v5 == 1 )
        {
          xmlAddNotationDecl((int)(a1 + 27), *(_DWORD *)(v4 + 44), Src, a3, a4);
        }
        else if ( v5 == 2 )
        {
          xmlAddNotationDecl((int)(a1 + 27), *(_DWORD *)(v4 + 48), Src, a3, a4);
        }
        else
        {
          sub_43D314(
            (int (__cdecl *)(int, char *, char))0x69,
            a1,
            "SAX.xmlSAX2NotationDecl(%s) called while not in subset\n",
            Src);
        }
      }
      else
      {
        sub_43D314(
          (int (__cdecl *)(int, char *, char))0x69,
          a1,
          "SAX.xmlSAX2NotationDecl(%s) externalID or PublicID missing\n",
          Src);
      }
    }
  }
}

//----- (0043DB00) --------------------------------------------------------
void __cdecl xmlSAX2UnparsedEntityDecl(int *a1, char *a2, char *a3, char *a4, _BYTE *a5)
{
  int v5; // eax
  _DWORD *v6; // esi
  void (__cdecl *v7)(int, const char *, char *); // eax
  int v8; // eax
  _BYTE *v9; // eax
  void (__cdecl *v10)(int, const char *, char *); // eax

  if ( !a1 )
    return;
  v5 = a1[54];
  if ( v5 == 1 )
  {
    v6 = xmlAddDocEntity(a1[2], a2, 3, a3, a4, a5);
    if ( !v6 )
    {
      if ( a1[67] && *a1 )
      {
        v7 = *(void (__cdecl **)(int, const char *, char *))(*a1 + 84);
        if ( v7 )
          v7(a1[1], "Entity(%s) already defined in the internal subset\n", a2);
      }
      return;
    }
    goto LABEL_8;
  }
  if ( v5 != 2 )
  {
    sub_43D314(
      (int (__cdecl *)(int, char *, char))1,
      a1,
      "SAX.xmlSAX2UnparsedEntityDecl(%s) called while not in subset\n",
      a2);
    return;
  }
  v6 = xmlAddDtdEntity(a1[2], a2, 3, a3, a4, a5);
  if ( v6 )
  {
LABEL_8:
    if ( !v6[16] && a4 )
    {
      v8 = a1[9];
      if ( !v8 || (v9 = *(_BYTE **)(v8 + 4)) == 0 )
        v9 = (_BYTE *)a1[45];
      v6[16] = xmlBuildURI(a4, v9);
    }
    return;
  }
  if ( a1[67] )
  {
    if ( *a1 )
    {
      v10 = *(void (__cdecl **)(int, const char *, char *))(*a1 + 84);
      if ( v10 )
        v10(a1[1], "Entity(%s) already defined in the external subset\n", a2);
    }
  }
}

//----- (0043DBFA) --------------------------------------------------------
void __cdecl xmlSAX2StartDocument(int a1)
{
  _DWORD *v1; // eax
  _DWORD *v2; // edi
  int v3; // eax
  int v4; // eax
  char *v5; // eax
  _DWORD *v6; // [esp-8h] [ebp-10h]

  if ( a1 )
  {
    if ( *(_DWORD *)(a1 + 32) )
    {
      xmlGenericError(xmlGenericErrorContext, "libxml2 built without HTML support\n");
      *(_DWORD *)(a1 + 172) = -1;
      *(_DWORD *)(a1 + 84) = 1;
      *(_DWORD *)(a1 + 212) = 1;
    }
    else
    {
      v1 = xmlNewDoc(*(char **)(a1 + 20));
      v2 = v1;
      *(_DWORD *)(a1 + 8) = v1;
      if ( !v1 )
        goto LABEL_17;
      v1[23] = 0;
      if ( (*(_DWORD *)(a1 + 360) & 0x20000) != 0 )
        v1[23] = 4;
      v1[22] = *(_DWORD *)(a1 + 360);
      v1[15] = *(_DWORD *)(a1 + 24) ? xmlStrdup(*(_BYTE **)(a1 + 24)) : 0;
      v2[10] = *(_DWORD *)(a1 + 28);
      if ( *(_DWORD *)(a1 + 364) )
      {
        v6 = *(_DWORD **)(a1 + 296);
        v2[20] = v6;
        xmlDictReference(v6);
      }
      v3 = *(_DWORD *)(a1 + 8);
      if ( v3 )
      {
        if ( !*(_DWORD *)(v3 + 72) )
        {
          v4 = *(_DWORD *)(a1 + 36);
          if ( v4 )
          {
            v5 = *(char **)(v4 + 4);
            if ( v5 )
            {
              *(_DWORD *)(*(_DWORD *)(a1 + 8) + 72) = xmlPathToURI(v5);
              if ( !*(_DWORD *)(*(_DWORD *)(a1 + 8) + 72) )
LABEL_17:
                sub_43D25F((_DWORD *)a1, (int)"xmlSAX2StartDocument");
            }
          }
        }
      }
    }
  }
}
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);

//----- (0043DCE0) --------------------------------------------------------
void __cdecl xmlSAX2EndDocument(_DWORD *a1)
{
  int v1; // ecx
  int v2; // eax
  int v3; // eax
  _BYTE *v4; // ecx
  int v5; // eax
  int v6; // eax
  int v7; // esi

  if ( a1 )
  {
    v1 = a1[6];
    if ( v1 )
    {
      v2 = a1[2];
      if ( v2 )
      {
        if ( !*(_DWORD *)(v2 + 60) )
        {
          *(_DWORD *)(v2 + 60) = v1;
          a1[6] = 0;
        }
      }
    }
    v3 = a1[12];
    if ( v3 )
    {
      if ( (int)a1[10] > 0 )
      {
        if ( *(_DWORD *)v3 )
        {
          v4 = *(_BYTE **)(*(_DWORD *)v3 + 44);
          if ( v4 )
          {
            v5 = a1[2];
            if ( v5 )
            {
              if ( !*(_DWORD *)(v5 + 60) )
                *(_DWORD *)(a1[2] + 60) = xmlStrdup(v4);
            }
          }
        }
      }
    }
    v6 = a1[64];
    if ( v6 )
    {
      v7 = a1[2];
      if ( v7 )
      {
        if ( !*(_DWORD *)(v7 + 76) )
          *(_DWORD *)(v7 + 76) = v6;
      }
    }
  }
}

//----- (0043DD53) --------------------------------------------------------
void __usercall sub_43DD53(int a1@<eax>, char *Src, unsigned __int8 *ArgList)
{
  char *v4; // ebx
  char *v5; // eax
  bool v6; // zf
  unsigned __int8 *v7; // eax
  unsigned __int8 *v8; // ebx
  void (*v9)(_DWORD, const char *, ...); // eax
  void (*v10)(_DWORD, const char *, ...); // eax
  unsigned __int8 *v11; // eax
  _DWORD *v12; // eax
  _DWORD *v13; // ebx
  int i; // edi
  _DWORD *v15; // edi
  char *NodeList; // eax
  _DWORD *v17; // eax
  _DWORD *v18; // [esp+Ch] [ebp-Ch]
  char *v19; // [esp+10h] [ebp-8h]
  void *Block; // [esp+14h] [ebp-4h] BYREF

  if ( *(_DWORD *)(a1 + 32) )
  {
    v4 = xmlStrdup(Src);
    v19 = v4;
    Block = 0;
  }
  else
  {
    v5 = xmlSplitQName((int *)a1, Src, &Block);
    v4 = v5;
    v19 = v5;
    if ( !v5 )
    {
LABEL_12:
      sub_43D25F((_DWORD *)a1, (int)"xmlSAX2StartElement");
      v6 = Block == 0;
      goto LABEL_98;
    }
    if ( !*v5 )
    {
      if ( xmlStrEqual((char *)Block, "xmlns") )
        sub_43D3B5((int *)a1, 35, "invalid namespace declaration '%s'\n", Src, 0);
      else
        sub_43D3FA((int *)a1, 106, "Avoid attribute ending with ':' like '%s'\n", Src, 0);
      if ( Block )
        ((void (__cdecl *)(void *))xmlFree)(Block);
      Block = 0;
      ((void (__cdecl *)(char *))xmlFree)(v4);
      v4 = xmlStrdup(Src);
      v19 = v4;
    }
  }
  if ( !v4 )
    goto LABEL_12;
  if ( *(_DWORD *)(a1 + 32) )
    goto LABEL_58;
  if ( Block || *v4 != 120 || v4[1] != 109 || v4[2] != 108 || v4[3] != 110 || v4[4] != 115 || v4[5] )
  {
    if ( !Block )
      goto LABEL_71;
    if ( *(_BYTE *)Block == 120
      && *((_BYTE *)Block + 1) == 109
      && *((_BYTE *)Block + 2) == 108
      && *((_BYTE *)Block + 3) == 110
      && *((_BYTE *)Block + 4) == 115
      && !*((_BYTE *)Block + 5) )
    {
      if ( *(_DWORD *)(a1 + 16) )
      {
        v8 = ArgList;
      }
      else
      {
        ++*(_DWORD *)(a1 + 248);
        v11 = xmlStringDecodeEntities((int *)a1, ArgList, 1, 0, 0, 0);
        --*(_DWORD *)(a1 + 248);
        v8 = v11;
        if ( !v11 )
        {
          sub_43D25F((_DWORD *)a1, (int)"xmlSAX2StartElement");
          ((void (__cdecl *)(void *))xmlFree)(Block);
          ((void (__cdecl *)(char *))xmlFree)(v19);
          return;
        }
      }
      if ( !*v8 )
        sub_43D3B5((int *)a1, 204, "Empty namespace name for prefix %s\n", v19, 0);
      if ( *(_DWORD *)(a1 + 268) && *v8 )
      {
        v12 = xmlParseURI(v8);
        v18 = v12;
        if ( v12 )
        {
          if ( !*v12 )
            sub_43D3FA((int *)a1, 100, "xmlns:%s: URI %s is not absolute\n", v19, ArgList);
          xmlFreeURI(v18);
        }
        else
        {
          sub_43D3FA((int *)a1, 99, "xmlns:%s: %s not a valid URI\n", v19, ArgList);
        }
      }
      xmlNewNs(*(_DWORD *)(a1 + 52), (char *)v8, v19);
      ((void (__cdecl *)(void *))xmlFree)(Block);
      ((void (__cdecl *)(char *))xmlFree)(v19);
      goto LABEL_35;
    }
LABEL_58:
    if ( Block )
    {
      v13 = xmlSearchNs(*(_DWORD *)(a1 + 8), *(_DWORD **)(a1 + 52), (char *)Block);
      if ( v13 )
      {
        for ( i = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 44); i; i = *(_DWORD *)(i + 24) )
        {
          if ( *(_DWORD *)(i + 36)
            && xmlStrEqual(v19, *(char **)(i + 8))
            && (v13 == *(_DWORD **)(i + 36) || xmlStrEqual((char *)v13[2], *(char **)(*(_DWORD *)(i + 36) + 8))) )
          {
            sub_43D3B5((int *)a1, 42, "Attribute %s in %s redefined\n", v19, (_BYTE *)v13[2]);
            *(_DWORD *)(a1 + 12) = 0;
            if ( !*(_DWORD *)(a1 + 288) )
              *(_DWORD *)(a1 + 212) = 1;
            goto LABEL_97;
          }
        }
      }
      else
      {
        sub_43D3B5((int *)a1, 201, "Namespace prefix %s of attribute %s is not defined\n", Block, v19);
      }
LABEL_72:
      v15 = xmlNewNsPropEatName(*(_DWORD **)(a1 + 52), (int)v13, v19, 0);
      if ( v15 )
      {
        if ( *(_DWORD *)(a1 + 16) || *(_DWORD *)(a1 + 32) )
        {
          if ( ArgList )
          {
            v17 = xmlNewDocText(*(_DWORD *)(a1 + 8), ArgList);
            v15[3] = v17;
            v15[4] = v17;
            if ( v17 )
              v17[5] = v15;
          }
        }
        else
        {
          NodeList = xmlStringGetNodeList(*(int (__cdecl **)(int, char *, char))(a1 + 8), ArgList);
          v15[3] = NodeList;
          while ( NodeList )
          {
            *((_DWORD *)NodeList + 5) = v15;
            if ( !*((_DWORD *)NodeList + 6) )
              v15[4] = NodeList;
            NodeList = (char *)*((_DWORD *)NodeList + 6);
          }
        }
      }
      if ( (*(_BYTE *)(a1 + 276) & 8) != 0 )
        goto LABEL_97;
      if ( *(_DWORD *)(a1 + 16) )
      {
        if ( *(_DWORD *)(a1 + 216) )
          goto LABEL_97;
      }
      else if ( *(_DWORD *)(a1 + 96) == 2 )
      {
        goto LABEL_97;
      }
      if ( xmlStrEqual(Src, "xml:id") )
      {
        if ( xmlValidateNCName(ArgList, 1) )
          sub_43D29A(539, 0, ArgList, a1, "xml:id : attribute value %s is not an NCName\n");
      }
      else if ( !xmlIsID(*(_DWORD **)(a1 + 8), *(_DWORD *)(a1 + 52), (int)v15) )
      {
        if ( xmlIsRef(*(_DWORD **)(a1 + 8), *(_DWORD *)(a1 + 52), (int)v15) )
          xmlAddRef(a1 + 108, *(_DWORD *)(a1 + 8), (char *)ArgList, (int)v15);
        goto LABEL_97;
      }
      xmlAddID(a1 + 108, *(_DWORD *)(a1 + 8), ArgList, (int)v15);
LABEL_97:
      v6 = Block == 0;
LABEL_98:
      if ( !v6 )
        ((void (__cdecl *)(void *))xmlFree)(Block);
      return;
    }
LABEL_71:
    v13 = 0;
    goto LABEL_72;
  }
  if ( *(_DWORD *)(a1 + 16) )
  {
    v8 = ArgList;
  }
  else
  {
    ++*(_DWORD *)(a1 + 248);
    v7 = xmlStringDecodeEntities((int *)a1, ArgList, 1, 0, 0, 0);
    --*(_DWORD *)(a1 + 248);
    v8 = v7;
  }
  if ( *v8 )
  {
    Block = xmlParseURI(v8);
    if ( Block )
    {
      if ( !*(_DWORD *)Block )
      {
        if ( *(_DWORD *)a1 )
        {
          v10 = *(void (**)(_DWORD, const char *, ...))(*(_DWORD *)a1 + 84);
          if ( v10 )
            v10(*(_DWORD *)(a1 + 4), "xmlns: URI %s is not absolute\n", v8);
        }
      }
      xmlFreeURI(Block);
    }
    else if ( *(_DWORD *)a1 )
    {
      v9 = *(void (**)(_DWORD, const char *, ...))(*(_DWORD *)a1 + 84);
      if ( v9 )
        v9(*(_DWORD *)(a1 + 4), "xmlns: %s not a valid URI\n", v8);
    }
  }
  xmlNewNs(*(_DWORD *)(a1 + 52), (char *)v8, 0);
  ((void (__cdecl *)(char *))xmlFree)(v19);
LABEL_35:
  if ( v8 != ArgList )
    ((void (__cdecl *)(unsigned __int8 *))xmlFree)(v8);
}
// 496494: invalid function type has been ignored
// 43DF08: conditional instruction was optimized away because eax.4==0
// 43E17A: conditional instruction was optimized away because eax.4==0

//----- (0043E22D) --------------------------------------------------------
void __usercall sub_43E22D(_DWORD *a1@<edx>, char **a2@<ecx>, char *a3, char *a4)
{
  int v4; // esi
  _DWORD *v5; // ebx
  int v6; // eax
  int v7; // edi
  char *Src; // esi
  int v9; // ebx
  _BYTE *v10; // eax
  _BYTE *v11; // eax
  char *v12; // eax
  char **v13; // ebx
  char *v14; // esi
  int i; // edi
  char *v16; // ebx
  char *v17; // ebx
  int DtdQAttrDesc; // eax
  char *v19; // ebx
  int v21; // [esp+1Ch] [ebp-48h]
  int DtdQElementDesc; // [esp+24h] [ebp-40h]
  char **v24; // [esp+24h] [ebp-40h]
  char *Block; // [esp+28h] [ebp-3Ch]
  char *Blocka; // [esp+28h] [ebp-3Ch]
  char v27[52]; // [esp+2Ch] [ebp-38h] BYREF

  v4 = (int)a1;
  v5 = (_DWORD *)a1[2];
  v21 = 1;
  DtdQElementDesc = xmlGetDtdQElementDesc(v5[11], a3, a4);
  if ( !DtdQElementDesc )
  {
    v6 = xmlGetDtdQElementDesc(v5[12], a3, a4);
    goto LABEL_50;
  }
  do
  {
    v7 = *(_DWORD *)(DtdQElementDesc + 44);
    if ( v5[10] == 1 && v5[12] && *(_DWORD *)(v4 + 104) )
    {
      while ( v7 )
      {
        if ( *(_DWORD *)(v7 + 48) )
        {
          Src = *(char **)(v7 + 56);
          v9 = a1[2];
          if ( xmlGetDtdQAttrDesc(*(_DWORD *)(v9 + 48), *(char **)(v7 + 60), *(char **)(v7 + 8), Src) == v7
            && !xmlGetDtdQAttrDesc(*(_DWORD *)(v9 + 44), *(char **)(v7 + 60), *(char **)(v7 + 8), Src) )
          {
            if ( Src )
            {
              v10 = xmlStrdup(Src);
              v11 = xmlStrcat(v10, ":");
              v12 = xmlStrcat(v11, *(_BYTE **)(v7 + 8));
            }
            else
            {
              v12 = xmlStrdup(*(_BYTE **)(v7 + 8));
            }
            Block = v12;
            if ( !v12 )
            {
              v4 = (int)a1;
              sub_43D25F(a1, (int)"xmlSAX2StartElement");
              break;
            }
            v13 = a2;
            if ( !a2 )
              goto LABEL_19;
            v14 = *a2;
            if ( !*a2 )
              goto LABEL_19;
            do
            {
              if ( xmlStrEqual(v14, Block) )
                break;
              v13 += 2;
              v14 = *v13;
            }
            while ( *v13 );
            if ( !v14 )
LABEL_19:
              sub_43D29A(
                538,
                *(_BYTE **)(v7 + 60),
                Block,
                (int)a1,
                "standalone: attribute %s on %s defaulted from external subset\n");
            ((void (__cdecl *)(char *))xmlFree)(Block);
          }
          v4 = (int)a1;
        }
        v7 = *(_DWORD *)(v7 + 36);
      }
    }
    for ( i = *(_DWORD *)(DtdQElementDesc + 44); i; i = *(_DWORD *)(i + 36) )
    {
      if ( !*(_DWORD *)(i + 48) )
        continue;
      v16 = *(char **)(i + 56);
      if ( v16 )
      {
        if ( !xmlStrEqual(v16, "xmlns") )
          goto LABEL_32;
      }
      else if ( !xmlStrEqual(*(char **)(i + 8), "xmlns") )
      {
LABEL_32:
        if ( (*(_BYTE *)(v4 + 276) & 4) == 0 )
          continue;
      }
      v17 = *(char **)(i + 8);
      DtdQAttrDesc = xmlGetDtdQAttrDesc(
                       *(_DWORD *)(*(_DWORD *)(v4 + 8) + 44),
                       *(char **)(i + 60),
                       v17,
                       *(char **)(i + 56));
      if ( DtdQAttrDesc == i || !DtdQAttrDesc )
      {
        Blocka = (char *)xmlBuildQName(v17, *(const char **)(i + 56), v27, 50);
        if ( !Blocka )
        {
          sub_43D25F((_DWORD *)v4, (int)"xmlSAX2StartElement");
          return;
        }
        if ( !a2 )
          goto LABEL_42;
        v19 = *a2;
        if ( !*a2 )
          goto LABEL_42;
        v24 = a2;
        do
        {
          if ( xmlStrEqual(v19, Blocka) )
            break;
          v24 += 2;
          v19 = *v24;
        }
        while ( *v24 );
        if ( !v19 )
LABEL_42:
          sub_43DD53(v4, Blocka, *(unsigned __int8 **)(i + 48));
        if ( Blocka != v27 && Blocka != *(char **)(i + 8) )
          ((void (__cdecl *)(char *))xmlFree)(Blocka);
      }
    }
    if ( v21 != 1 )
      return;
    v5 = *(_DWORD **)(v4 + 8);
    v6 = xmlGetDtdQElementDesc(v5[12], a3, a4);
LABEL_50:
    v21 = 0;
    DtdQElementDesc = v6;
  }
  while ( v6 );
}
// 496494: invalid function type has been ignored
// 43E3BB: conditional instruction was optimized away because ebx.4!=0

//----- (0043E4C0) --------------------------------------------------------
void __cdecl xmlSAX2StartElement(int *Block, char *a2, char **a3)
{
  int *v3; // esi
  int v4; // eax
  _DWORD *v5; // eax
  _DWORD *v6; // ebx
  int v7; // eax
  int v8; // eax
  char **v9; // ebx
  int v10; // eax
  char *v11; // eax
  unsigned __int8 *v12; // ecx
  char **v13; // edi
  unsigned __int8 **v14; // edi
  _DWORD *v15; // edi
  _BYTE *v16; // eax
  char *v17; // eax
  unsigned __int8 *v18; // ecx
  char **v19; // edi
  unsigned __int8 **v20; // edi
  char **v21; // edi
  unsigned __int8 **v22; // edi
  _BYTE *v23; // [esp+8h] [ebp-Ch]
  _DWORD *v24; // [esp+Ch] [ebp-8h]
  int v25; // [esp+10h] [ebp-4h]

  v3 = Block;
  if ( !Block )
    return;
  if ( !a2 )
    return;
  v4 = Block[2];
  if ( !v4 )
    return;
  v25 = Block[13];
  if ( Block[26] )
  {
    if ( !*(_DWORD *)(v4 + 48) )
    {
      v5 = *(_DWORD **)(v4 + 44);
      if ( !v5 || !v5[9] && !v5[10] && !v5[11] && !v5[12] )
      {
        sub_43D29A(94, 0, 0, (int)Block, "Validation failed: no DTD found !");
        v3[26] = 0;
      }
    }
  }
  v23 = xmlSplitQName(v3, a2, &Block);
  v6 = xmlNewDocNodeEatName(v3[2], 0, v23, 0);
  v24 = v6;
  if ( !v6 )
  {
    if ( Block )
      ((void (__cdecl *)(int *))xmlFree)(Block);
    sub_43D25F(v3, (int)"xmlSAX2StartElement");
    return;
  }
  v7 = v3[2];
  if ( *(_DWORD *)(v7 + 12) )
  {
    if ( !v25 )
      v25 = *(_DWORD *)(v7 + 12);
  }
  else
  {
    xmlAddChild((char *)v7, (char *)v6);
  }
  v3[66] = -1;
  if ( v3[70] )
  {
    v8 = v3[9];
    if ( v8 )
    {
      if ( *(int *)(v8 + 28) >= 0xFFFF )
        *((_WORD *)v6 + 28) = -1;
      else
        *((_WORD *)v6 + 28) = *(_WORD *)(v8 + 28);
    }
  }
  nodePush((int)v3, (int)v6);
  if ( v25 )
  {
    if ( *(_DWORD *)(v25 + 4) == 1 )
      xmlAddChild((char *)v25, (char *)v6);
    else
      xmlAddSibling((char *)v25, (char *)v6);
  }
  v9 = a3;
  if ( !v3[8] )
  {
    v10 = v3[2];
    if ( *(_DWORD *)(v10 + 44) || *(_DWORD *)(v10 + 48) )
      sub_43E22D(v3, a3, v23, (char *)Block);
  }
  if ( v9 )
  {
    v11 = *v9;
    v12 = (unsigned __int8 *)v9[1];
    if ( !v3[8] )
    {
      if ( v11 )
      {
        v13 = v9 + 2;
        do
        {
          if ( !v12 )
            break;
          if ( *v11 == 120 && v11[1] == 109 && v11[2] == 108 && v11[3] == 110 && v11[4] == 115 )
            sub_43DD53((int)v3, v11, v12);
          v11 = *v13;
          v14 = (unsigned __int8 **)(v13 + 1);
          v12 = *v14;
          v13 = (char **)(v14 + 1);
        }
        while ( v11 );
      }
    }
  }
  v15 = xmlSearchNs(v3[2], v24, (char *)Block);
  if ( !v15 && v25 )
    v15 = xmlSearchNs(v3[2], (_DWORD *)v25, (char *)Block);
  if ( Block )
  {
    if ( v15 )
    {
LABEL_52:
      v16 = (_BYTE *)v15[2];
      if ( v16 && (*v16 || v15[3]) )
        xmlSetNs((int)v24, (int)v15);
      goto LABEL_56;
    }
    v15 = xmlNewNs((int)v24, 0, (char *)Block);
    sub_43D3FA(v3, 201, "Namespace prefix %s is not defined\n", Block, 0);
  }
  if ( v15 )
    goto LABEL_52;
LABEL_56:
  if ( v9 )
  {
    v17 = *v9;
    v18 = (unsigned __int8 *)v9[1];
    if ( v3[8] )
    {
      if ( v17 )
      {
        v19 = v9 + 2;
        do
        {
          sub_43DD53((int)v3, v17, v18);
          v17 = *v19;
          v20 = (unsigned __int8 **)(v19 + 1);
          v18 = *v20;
          v19 = (char **)(v20 + 1);
        }
        while ( v17 );
      }
    }
    else if ( v17 )
    {
      v21 = v9 + 2;
      do
      {
        if ( !v18 )
          break;
        if ( *v17 != 120 || v17[1] != 109 || v17[2] != 108 || v17[3] != 110 || v17[4] != 115 )
          sub_43DD53((int)v3, v17, v18);
        v17 = *v21;
        v22 = (unsigned __int8 **)(v21 + 1);
        v18 = *v22;
        v21 = (char **)(v22 + 1);
      }
      while ( v17 );
    }
  }
  if ( Block )
    ((void (__cdecl *)(int *))xmlFree)(Block);
}
// 496494: invalid function type has been ignored

//----- (0043E75F) --------------------------------------------------------
int __cdecl xmlSAX2EndElement(int a1)
{
  int v1; // ecx
  int result; // eax

  if ( a1 )
  {
    v1 = *(_DWORD *)(a1 + 52);
    if ( v1 )
    {
      if ( *(_DWORD *)(a1 + 68) )
      {
        *(_DWORD *)(*(_DWORD *)(a1 + 448) + 12) = *(_DWORD *)(*(_DWORD *)(a1 + 36) + 16)
                                                - *(_DWORD *)(*(_DWORD *)(a1 + 36) + 12);
        *(_DWORD *)(*(_DWORD *)(a1 + 448) + 16) = *(_DWORD *)(*(_DWORD *)(a1 + 36) + 28);
        **(_DWORD **)(a1 + 448) = v1;
        xmlParserAddNodeInfo(a1, *(unsigned int **)(a1 + 448));
      }
    }
    *(_DWORD *)(a1 + 264) = -1;
    return nodePop((_DWORD *)a1);
  }
  return result;
}

//----- (0043E7BC) --------------------------------------------------------
int __usercall sub_43E7BC@<eax>(int a1@<eax>, _BYTE *Src, int Size)
{
  int *v4; // eax
  int v5; // ebx
  unsigned __int8 *v6; // edi
  int v7; // ecx
  _BYTE *v9; // ecx
  char v10; // dl
  unsigned __int8 v11; // al
  int v12; // ecx
  unsigned __int8 v13; // al
  _BYTE *v14; // eax
  int v15; // esi

  v4 = (int *)(a1 + 372);
  v5 = *v4;
  v6 = 0;
  if ( *v4 )
  {
    v7 = *(_DWORD *)(v5 + 24);
    --*(_DWORD *)(a1 + 368);
    *v4 = v7;
  }
  else
  {
    v5 = xmlMalloc(60);
  }
  if ( !v5 )
  {
    xmlErrMemory(a1, "xmlSAX2Characters");
    return 0;
  }
  memset((void *)v5, 0, 0x3Cu);
  if ( *(_DWORD *)(a1 + 364) )
  {
    v9 = &Src[Size];
    v10 = Src[Size];
    if ( Size < 8 && (*(_DWORD *)(a1 + 360) & 0x10000) != 0 )
    {
      v6 = (unsigned __int8 *)(v5 + 44);
      memcpy((void *)(v5 + 44), Src, Size);
      *(_BYTE *)(v5 + 44 + Size) = 0;
      goto LABEL_31;
    }
    if ( Size <= 3 && (v10 == 34 || v10 == 39 || v10 == 60 && v9[1] != 33) )
      goto LABEL_30;
    if ( (v11 = *Src, *Src == 32) || v11 >= 9u && v11 <= 0xAu || v11 == 13 )
    {
      if ( Size < 60 && v10 == 60 && v9[1] != 33 )
      {
        v12 = 1;
        if ( Size <= 1 )
        {
LABEL_30:
          v6 = xmlDictLookup(*(_DWORD **)(a1 + 296), Src, Size);
          goto LABEL_31;
        }
        while ( 1 )
        {
          v13 = Src[v12];
          if ( v13 != 32 && (v13 < 9u || v13 > 0xAu) && v13 != 13 )
            break;
          if ( ++v12 >= Size )
            goto LABEL_30;
        }
      }
    }
  }
LABEL_31:
  *(_DWORD *)(v5 + 4) = 3;
  *(_DWORD *)(v5 + 8) = "text";
  if ( v6 )
  {
    *(_DWORD *)(v5 + 40) = v6;
  }
  else
  {
    v14 = xmlStrndup(Src, Size);
    *(_DWORD *)(v5 + 40) = v14;
    if ( !v14 )
    {
      sub_43D25F((_DWORD *)a1, (int)"xmlSAX2TextNode");
      ((void (__cdecl *)(int))xmlFree)(v5);
      return 0;
    }
  }
  v15 = *(_DWORD *)(a1 + 36);
  if ( v15 )
    *(_WORD *)(v5 + 56) = *(_WORD *)(v15 + 28);
  if ( dword_4A9C08 )
  {
    if ( xmlRegisterNodeDefaultValue )
      xmlRegisterNodeDefaultValue(v5);
  }
  return v5;
}
// 496494: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A9C08: using guessed type int dword_4A9C08;
// 4A9CAC: using guessed type int (__cdecl *xmlRegisterNodeDefaultValue)(_DWORD);

//----- (0043E934) --------------------------------------------------------
_DWORD *__usercall sub_43E934@<eax>(int a1@<ecx>, _BYTE *a2@<eax>, char *Block, char *a4, char *Src)
{
  int v7; // ecx
  _DWORD *v8; // edi
  int v9; // ecx
  char *v10; // eax
  int v11; // ecx
  int v12; // eax
  _DWORD *result; // eax
  _DWORD *v14; // eax
  bool v15; // zf
  int v16; // ecx
  unsigned __int8 *v17; // ebx
  _DWORD *v18; // [esp-10h] [ebp-20h]
  char *v19; // [esp-8h] [ebp-18h]
  int v20; // [esp-4h] [ebp-14h]
  _DWORD *v21; // [esp+Ch] [ebp-4h]

  v21 = 0;
  if ( a4 )
    v21 = xmlSearchNs(*(_DWORD *)(a1 + 8), *(_DWORD **)(a1 + 52), a4);
  v7 = *(_DWORD *)(a1 + 380);
  if ( v7 )
  {
    v8 = *(_DWORD **)(a1 + 380);
    v9 = *(_DWORD *)(v7 + 24);
    --*(_DWORD *)(a1 + 376);
    *(_DWORD *)(a1 + 380) = v9;
    memset(v8, 0, 0x30u);
    v8[1] = 2;
    v8[5] = *(_DWORD *)(a1 + 52);
    v8[8] = *(_DWORD *)(a1 + 8);
    v8[9] = v21;
    if ( *(_DWORD *)(a1 + 364) )
      v10 = Block;
    else
      v10 = xmlStrdup(Block);
    v8[2] = v10;
    v11 = *(_DWORD *)(a1 + 52);
    v12 = *(_DWORD *)(v11 + 44);
    if ( v12 )
    {
      while ( *(_DWORD *)(v12 + 24) )
        v12 = *(_DWORD *)(v12 + 24);
      *(_DWORD *)(v12 + 24) = v8;
      v8[7] = v12;
    }
    else
    {
      *(_DWORD *)(v11 + 44) = v8;
    }
    if ( dword_4A9C08 && xmlRegisterNodeDefaultValue )
      xmlRegisterNodeDefaultValue(v8);
  }
  else
  {
    v18 = *(_DWORD **)(a1 + 52);
    if ( *(_DWORD *)(a1 + 364) )
      v14 = xmlNewNsPropEatName(v18, (int)v21, Block, 0);
    else
      v14 = xmlNewNsProp(v18, (int)v21, Block, 0);
    v8 = v14;
    if ( !v14 )
      return (_DWORD *)xmlErrMemory(a1, "xmlSAX2AttributeNs");
  }
  result = 0;
  if ( *(_DWORD *)(a1 + 16) || *(_DWORD *)(a1 + 32) )
  {
    if ( !Src )
      goto LABEL_33;
    v20 = a2 - Src;
    v19 = Src;
  }
  else
  {
    v20 = a2 - Src;
    v19 = Src;
    if ( !*a2 )
    {
      result = xmlStringLenGetNodeList(*(int (__cdecl **)(int, char *, char))(a1 + 8), Src, v20);
      v8[3] = result;
      while ( result )
      {
        v15 = result[6] == 0;
        result[8] = v8[8];
        result[5] = v8;
        if ( v15 )
          v8[4] = result;
        result = (_DWORD *)result[6];
      }
      goto LABEL_33;
    }
  }
  result = (_DWORD *)sub_43E7BC(a1, v19, v20);
  v8[4] = result;
  v8[3] = result;
  if ( result )
  {
    v16 = v8[8];
    result[5] = v8;
    result[8] = v16;
  }
LABEL_33:
  if ( (*(_BYTE *)(a1 + 276) & 8) != 0 )
    return result;
  result = *(_DWORD **)(a1 + 16);
  if ( result )
  {
    if ( *(_DWORD *)(a1 + 216) )
      return result;
  }
  else if ( *(_DWORD *)(a1 + 96) == 2 )
  {
    return result;
  }
  if ( a4 == *(char **)(a1 + 312) && *Block == 105 && Block[1] == 100 && !Block[2]
    || xmlIsID(*(_DWORD **)(a1 + 8), *(_DWORD *)(a1 + 52), (int)v8) )
  {
    v17 = xmlStrndup(Src, a2 - Src);
    result = xmlAddID(a1 + 108, *(_DWORD *)(a1 + 8), v17, (int)v8);
  }
  else
  {
    result = (_DWORD *)xmlIsRef(*(_DWORD **)(a1 + 8), *(_DWORD *)(a1 + 52), (int)v8);
    if ( !result )
      return result;
    v17 = xmlStrndup(Src, a2 - Src);
    result = xmlAddRef(a1 + 108, *(_DWORD *)(a1 + 8), (char *)v17, (int)v8);
  }
  if ( v17 )
    return (_DWORD *)((int (__cdecl *)(unsigned __int8 *))xmlFree)(v17);
  return result;
}
// 496494: invalid function type has been ignored
// 43EAB1: conditional instruction was optimized away because eax.4==0
// 4A9C08: using guessed type int dword_4A9C08;
// 4A9CAC: using guessed type int (__cdecl *xmlRegisterNodeDefaultValue)(_DWORD);

//----- (0043EB6C) --------------------------------------------------------
void __cdecl xmlSAX2StartElementNs(int a1, char *Src, char *a3, int a4, char *a5, char **a6, int a7, int a8, int a9)
{
  int v10; // eax
  _DWORD *v11; // eax
  unsigned __int8 *v12; // eax
  int v13; // ebx
  int v14; // ecx
  char *v15; // eax
  _DWORD *v16; // eax
  int v17; // eax
  char *v19; // ecx
  char **v20; // eax
  _DWORD *v21; // eax
  _DWORD *v22; // ecx
  _DWORD *v23; // eax
  _BYTE **v24; // ebx
  char *v25; // eax
  unsigned __int8 *v26; // eax
  char *v27; // eax
  char *v28; // [esp+8h] [ebp-10h]
  char **v29; // [esp+Ch] [ebp-Ch]
  _DWORD *v30; // [esp+10h] [ebp-8h]
  char *Block; // [esp+14h] [ebp-4h]
  char *Blocka; // [esp+14h] [ebp-4h]
  char *Blockb; // [esp+14h] [ebp-4h]
  int v34; // [esp+20h] [ebp+8h]
  int v35; // [esp+20h] [ebp+8h]

  v30 = 0;
  Block = 0;
  if ( a1 )
  {
    v34 = *(_DWORD *)(a1 + 52);
    if ( *(_DWORD *)(a1 + 104) )
    {
      v10 = *(_DWORD *)(a1 + 8);
      if ( !*(_DWORD *)(v10 + 48) )
      {
        v11 = *(_DWORD **)(v10 + 44);
        if ( !v11 || !v11[9] && !v11[10] && !v11[11] && !v11[12] )
        {
          sub_43D29A(94, 0, 0, a1, "Validation failed: no DTD found !");
          *(_DWORD *)(a1 + 104) = 0;
        }
      }
    }
    if ( a3 && !a4 )
    {
      if ( *(_DWORD *)(a1 + 364) )
      {
        v12 = xmlDictQLookup(*(_DWORD **)(a1 + 296), a3, Src);
        if ( v12 )
          Src = (char *)v12;
      }
      else
      {
        Block = (char *)xmlBuildQName(Src, a3, 0, 0);
      }
    }
    v13 = *(_DWORD *)(a1 + 372);
    if ( v13 )
    {
      v14 = *(_DWORD *)(v13 + 24);
      --*(_DWORD *)(a1 + 368);
      *(_DWORD *)(a1 + 372) = v14;
      memset((void *)v13, 0, 0x3Cu);
      *(_DWORD *)(v13 + 4) = 1;
      if ( *(_DWORD *)(a1 + 364) )
      {
        *(_DWORD *)(v13 + 8) = Src;
      }
      else
      {
        v15 = Block;
        if ( !Block )
          v15 = xmlStrdup(Src);
        *(_DWORD *)(v13 + 8) = v15;
        if ( !v15 )
          goto LABEL_63;
      }
      if ( dword_4A9C08 && xmlRegisterNodeDefaultValue )
        xmlRegisterNodeDefaultValue(v13);
    }
    else
    {
      if ( *(_DWORD *)(a1 + 364) )
      {
        v16 = xmlNewDocNodeEatName(*(_DWORD *)(a1 + 8), 0, Src, 0);
      }
      else if ( Block )
      {
        v16 = xmlNewDocNodeEatName(*(_DWORD *)(a1 + 8), 0, Block, 0);
      }
      else
      {
        v16 = xmlNewDocNode(*(_DWORD *)(a1 + 8), 0, Src, 0);
      }
      v13 = (int)v16;
      if ( !v16 )
        goto LABEL_63;
    }
    if ( *(_DWORD *)(a1 + 280) )
    {
      v17 = *(_DWORD *)(a1 + 36);
      if ( v17 )
      {
        if ( *(int *)(v17 + 28) >= 0xFFFF )
          *(_WORD *)(v13 + 56) = -1;
        else
          *(_WORD *)(v13 + 56) = *(_WORD *)(v17 + 28);
      }
    }
    if ( !v34 )
      xmlAddChild(*(char **)(a1 + 8), (char *)v13);
    if ( (int)a5 > 0 )
    {
      Blocka = a5;
      while ( 1 )
      {
        v19 = *a6;
        v20 = a6 + 1;
        v28 = v19;
        v29 = v20 + 1;
        v21 = xmlNewNs(0, *v20, v19);
        if ( v21 )
        {
          v22 = v30;
          v30 = v21;
          if ( v22 )
            *v22 = v21;
          else
            *(_DWORD *)(v13 + 48) = v21;
          if ( a4 && a3 == v28 )
            *(_DWORD *)(v13 + 36) = v21;
        }
        if ( !--Blocka )
          break;
        a6 = v29;
      }
    }
    *(_DWORD *)(a1 + 264) = -1;
    nodePush(a1, v13);
    if ( v34 )
    {
      if ( *(_DWORD *)(v34 + 4) == 1 )
        xmlAddChild((char *)v34, (char *)v13);
      else
        xmlAddSibling((char *)v34, (char *)v13);
    }
    if ( a8 && (*(_BYTE *)(a1 + 276) & 4) == 0 )
      a7 -= a8;
    if ( a4 && !*(_DWORD *)(v13 + 36) )
    {
      v23 = xmlSearchNs(*(_DWORD *)(a1 + 8), (_DWORD *)v34, a3);
      *(_DWORD *)(v13 + 36) = v23;
      if ( !v23 && xmlStrEqual(a3, "xml") )
        *(_DWORD *)(v13 + 36) = xmlSearchNs(*(_DWORD *)(a1 + 8), (_DWORD *)v13, a3);
      if ( !*(_DWORD *)(v13 + 36) )
      {
        if ( !xmlNewNs(v13, 0, a3) )
        {
LABEL_63:
          sub_43D25F((_DWORD *)a1, (int)"xmlSAX2StartElementNs");
          return;
        }
        if ( a3 )
          sub_43D3FA((int *)a1, 201, "Namespace prefix %s was not found\n", a3, 0);
        else
          sub_43D3FA((int *)a1, 201, "Namespace default prefix was not found\n", 0, 0);
      }
    }
    if ( a7 > 0 )
    {
      v24 = (_BYTE **)(a9 + 16);
      v35 = a7;
      while ( 1 )
      {
        v25 = *(v24 - 3);
        if ( !v25 || *(v24 - 2) )
          break;
        if ( *(_DWORD *)(a1 + 364) )
        {
          v26 = xmlDictQLookup(*(_DWORD **)(a1 + 296), v25, *(v24 - 4));
          if ( !v26 )
            break;
          sub_43E934(a1, *v24, (char *)v26, 0, *(v24 - 1));
        }
        else
        {
          v27 = (char *)xmlBuildQName(*(v24 - 4), v25, 0, 0);
          Blockb = v27;
          if ( !v27 )
            break;
          sub_43E934(a1, *v24, v27, 0, *(v24 - 1));
          ((void (__cdecl *)(char *))xmlFree)(Blockb);
        }
LABEL_77:
        v24 += 5;
        if ( !--v35 )
          return;
      }
      sub_43E934(a1, *v24, *(v24 - 4), *(v24 - 3), *(v24 - 1));
      goto LABEL_77;
    }
  }
}
// 496494: invalid function type has been ignored
// 4A9C08: using guessed type int dword_4A9C08;
// 4A9CAC: using guessed type int (__cdecl *xmlRegisterNodeDefaultValue)(_DWORD);

//----- (0043EEB3) --------------------------------------------------------
int __cdecl xmlSAX2EndElementNs(_DWORD *a1)
{
  unsigned int v1; // ecx
  _DWORD *v2; // eax
  int v3; // edx
  int result; // eax
  unsigned int v5[5]; // [esp+4h] [ebp-14h] BYREF

  if ( a1 )
  {
    v1 = a1[13];
    if ( a1[17] )
    {
      if ( v1 )
      {
        v2 = (_DWORD *)a1[9];
        v3 = v2[4] - v2[3];
        v5[4] = v2[7];
        v5[3] = v3;
        v5[0] = v1;
        xmlParserAddNodeInfo((int)a1, v5);
      }
    }
    a1[66] = -1;
    return nodePop(a1);
  }
  return result;
}

//----- (0043EF00) --------------------------------------------------------
void __cdecl xmlSAX2Reference(int a1, char *a2)
{
  char *v2; // eax
  char *v3; // edi
  _DWORD *v4; // [esp-Ch] [ebp-10h]

  if ( a1 )
  {
    v4 = *(_DWORD **)(a1 + 8);
    if ( *a2 == 35 )
      v2 = (char *)xmlNewCharRef((int)v4, a2);
    else
      v2 = (char *)xmlNewReference(v4, a2);
    v3 = v2;
    if ( !xmlAddChild(*(char **)(a1 + 52), v2) )
      xmlFreeNode(v3);
  }
}

//----- (0043EF40) --------------------------------------------------------
void __cdecl xmlSAX2Characters(int a1, _BYTE *Src, size_t Size)
{
  int v4; // eax
  int v5; // edi
  size_t v6; // edi
  int v7; // eax
  int v8; // ecx
  _BYTE *v9; // eax
  size_t v10; // eax
  int v11; // edx
  int v12; // ecx
  size_t v13; // eax
  int v14; // eax
  int v15; // eax
  char *v16; // eax
  int v17; // [esp+10h] [ebp+8h]

  if ( a1 )
  {
    v4 = *(_DWORD *)(a1 + 52);
    if ( v4 )
    {
      v5 = *(_DWORD *)(v4 + 16);
      if ( !v5 )
      {
        v6 = Size;
        v7 = sub_43E7BC(a1, Src, Size);
        if ( v7 )
        {
          *(_DWORD *)(*(_DWORD *)(a1 + 52) + 12) = v7;
          *(_DWORD *)(*(_DWORD *)(a1 + 52) + 16) = v7;
          *(_DWORD *)(v7 + 20) = *(_DWORD *)(a1 + 52);
          *(_DWORD *)(v7 + 32) = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 32);
LABEL_32:
          *(_DWORD *)(a1 + 260) = v6;
          *(_DWORD *)(a1 + 264) = v6 + 1;
          return;
        }
LABEL_22:
        sub_43D25F((_DWORD *)a1, (int)"xmlSAX2Characters");
        return;
      }
      if ( *(_DWORD *)(v5 + 4) == 3 && *(char **)(v5 + 8) == "text" )
      {
        v8 = *(_DWORD *)(a1 + 264);
        if ( v8 )
        {
          if ( *(_DWORD *)(v5 + 40) == v5 + 44 )
          {
            v9 = xmlStrdup(*(_BYTE **)(v5 + 40));
            *(_DWORD *)(v5 + 44) = 0;
          }
          else
          {
            if ( v8 != *(_DWORD *)(a1 + 260) + 1 || !xmlDictOwns(*(_DWORD *)(a1 + 296), *(_DWORD *)(v5 + 40)) )
            {
LABEL_15:
              v10 = *(_DWORD *)(a1 + 260);
              v11 = v10 + Size;
              if ( v10 + Size > 0x989680 && (*(_DWORD *)(a1 + 360) & 0x80000) == 0 )
              {
                sub_43D25F((_DWORD *)a1, (int)"xmlSAX2Characters: huge text node");
                return;
              }
              if ( v10 > -1 - Size || (v12 = *(_DWORD *)(a1 + 264), v13 = v12 + Size, v12 + Size > 0x7FFFFFFF) )
              {
                sub_43D25F((_DWORD *)a1, (int)"xmlSAX2Characters overflow prevented");
                return;
              }
              if ( v11 >= v12 )
              {
                v17 = 2 * v13;
                v14 = xmlRealloc(*(LPVOID *)(v5 + 40), 2 * v13);
                if ( !v14 )
                  goto LABEL_22;
                *(_DWORD *)(a1 + 264) = v17;
                *(_DWORD *)(v5 + 40) = v14;
              }
              memcpy((void *)(*(_DWORD *)(v5 + 40) + *(_DWORD *)(a1 + 260)), Src, Size);
              *(_DWORD *)(a1 + 260) += Size;
              *(_BYTE *)(*(_DWORD *)(a1 + 260) + *(_DWORD *)(v5 + 40)) = 0;
              return;
            }
            v9 = xmlStrdup(*(_BYTE **)(v5 + 40));
          }
          *(_DWORD *)(v5 + 40) = v9;
          goto LABEL_15;
        }
        if ( xmlTextConcat((_DWORD *)v5, Src, Size) )
          sub_43D25F((_DWORD *)a1, (int)"xmlSAX2Characters");
        if ( *(_DWORD *)(*(_DWORD *)(a1 + 52) + 12) )
        {
          v15 = xmlStrlen(*(_BYTE **)(v5 + 40));
          *(_DWORD *)(a1 + 260) = v15;
          *(_DWORD *)(a1 + 264) = v15 + 1;
        }
      }
      else
      {
        v6 = Size;
        v16 = (char *)sub_43E7BC(a1, Src, Size);
        if ( v16 )
        {
          xmlAddChild(*(char **)(a1 + 52), v16);
          if ( *(_DWORD *)(*(_DWORD *)(a1 + 52) + 12) )
            goto LABEL_32;
        }
      }
    }
  }
}
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);

//----- (0043F11E) --------------------------------------------------------
void __cdecl xmlSAX2ProcessingInstruction(int *a1, char *Src, _BYTE *a3)
{
  int v3; // edi
  _DWORD *v4; // eax
  int v5; // ecx
  int v6; // ecx
  char *v7; // [esp-Ch] [ebp-10h]

  if ( a1 )
  {
    v3 = a1[13];
    v4 = xmlNewDocPI(a1[2], Src, a3);
    if ( v4 )
    {
      if ( a1[70] )
      {
        v5 = a1[9];
        if ( v5 )
        {
          if ( *(int *)(v5 + 28) >= 0xFFFF )
            *((_WORD *)v4 + 28) = -1;
          else
            *((_WORD *)v4 + 28) = *(_WORD *)(v5 + 28);
        }
      }
      v6 = a1[54];
      if ( v6 == 1 )
      {
        v7 = *(char **)(a1[2] + 44);
LABEL_10:
        xmlAddChild(v7, (char *)v4);
        return;
      }
      if ( v6 == 2 )
      {
        xmlAddChild(*(char **)(a1[2] + 48), (char *)v4);
      }
      else if ( v3 )
      {
        v7 = (char *)v3;
        if ( *(_DWORD *)(v3 + 4) == 1 )
          goto LABEL_10;
        xmlAddSibling((char *)v3, (char *)v4);
      }
      else
      {
        xmlAddChild((char *)a1[2], (char *)v4);
      }
    }
  }
}

//----- (0043F1AE) --------------------------------------------------------
void __cdecl xmlSAX2Comment(int *a1, _BYTE *a2)
{
  int v2; // edi
  _DWORD *v3; // eax
  int v4; // ecx
  int v5; // ecx
  char *v6; // [esp-Ch] [ebp-10h]

  if ( a1 )
  {
    v2 = a1[13];
    v3 = xmlNewDocComment(a1[2], a2);
    if ( v3 )
    {
      if ( a1[70] )
      {
        v4 = a1[9];
        if ( v4 )
        {
          if ( *(int *)(v4 + 28) >= 0xFFFF )
            *((_WORD *)v3 + 28) = -1;
          else
            *((_WORD *)v3 + 28) = *(_WORD *)(v4 + 28);
        }
      }
      v5 = a1[54];
      if ( v5 == 1 )
      {
        v6 = *(char **)(a1[2] + 44);
LABEL_10:
        xmlAddChild(v6, (char *)v3);
        return;
      }
      if ( v5 == 2 )
      {
        xmlAddChild(*(char **)(a1[2] + 48), (char *)v3);
      }
      else if ( v2 )
      {
        v6 = (char *)v2;
        if ( *(_DWORD *)(v2 + 4) == 1 )
          goto LABEL_10;
        xmlAddSibling((char *)v2, (char *)v3);
      }
      else
      {
        xmlAddChild((char *)a1[2], (char *)v3);
      }
    }
  }
}

//----- (0043F235) --------------------------------------------------------
void __cdecl xmlSAX2CDataBlock(int a1, _BYTE *a2, signed int a3)
{
  _DWORD *LastChild; // eax
  char *v4; // eax

  if ( a1 )
  {
    LastChild = (_DWORD *)xmlGetLastChild(*(_DWORD *)(a1 + 52));
    if ( LastChild && LastChild[1] == 4 )
    {
      xmlTextConcat(LastChild, a2, a3);
    }
    else
    {
      v4 = (char *)xmlNewCDataBlock(*(_DWORD *)(a1 + 8), a2, a3);
      xmlAddChild(*(char **)(a1 + 52), v4);
    }
  }
}

//----- (0043F283) --------------------------------------------------------
int __cdecl xmlSAXDefaultVersion(int a1)
{
  int result; // eax

  result = dword_4A4BB4;
  if ( a1 != 1 && a1 != 2 )
    return -1;
  dword_4A4BB4 = a1;
  return result;
}
// 4A4BB4: using guessed type int dword_4A4BB4;

//----- (0043F2A1) --------------------------------------------------------
int __cdecl xmlSAXVersion(_DWORD *a1, int a2)
{
  if ( a1 )
  {
    if ( a2 == 2 )
    {
      a1[14] = 0;
      a1[15] = 0;
      a1[29] = xmlSAX2StartElementNs;
      a1[30] = xmlSAX2EndElementNs;
      a1[31] = 0;
      a1[27] = -554844497;
LABEL_6:
      a1[17] = xmlSAX2Characters;
      a1[18] = xmlSAX2Characters;
      *a1 = xmlSAX2InternalSubset;
      a1[26] = xmlSAX2ExternalSubset;
      a1[1] = xmlSAX2IsStandalone;
      a1[2] = xmlSAX2HasInternalSubset;
      a1[3] = xmlSAX2HasExternalSubset;
      a1[4] = xmlSAX2ResolveEntity;
      a1[5] = xmlSAX2GetEntity;
      a1[24] = xmlSAX2GetParameterEntity;
      a1[6] = xmlSAX2EntityDecl;
      a1[8] = xmlSAX2AttributeDecl;
      a1[9] = xmlSAX2ElementDecl;
      a1[7] = xmlSAX2NotationDecl;
      a1[10] = xmlSAX2UnparsedEntityDecl;
      a1[11] = xmlUnlockLibrary;
      a1[12] = xmlSAX2StartDocument;
      a1[13] = xmlSAX2EndDocument;
      a1[16] = xmlSAX2Reference;
      a1[25] = xmlSAX2CDataBlock;
      a1[19] = xmlSAX2ProcessingInstruction;
      a1[20] = xmlSAX2Comment;
      a1[21] = xmlParserWarning;
      a1[22] = xmlParserError;
      a1[23] = xmlParserError;
      return 0;
    }
    if ( a2 == 1 )
    {
      a1[14] = xmlSAX2StartElement;
      a1[15] = xmlSAX2EndElement;
      a1[27] = 1;
      goto LABEL_6;
    }
  }
  return -1;
}
// 43FED0: using guessed type int xmlUnlockLibrary();

//----- (0043F3A3) --------------------------------------------------------
int (*__cdecl xmlSAX2InitDefaultSAXHandler(_DWORD *a1, int a2))(_DWORD *a1, char *Format, ...)
{
  int (*result)(_DWORD *, char *, ...); // eax
  int v3; // edx

  if ( a1 )
  {
    if ( !a1[27] )
    {
      xmlSAXVersion(a1, dword_4A4BB4);
      result = a2 != 0 ? xmlParserWarning : 0;
      *(_DWORD *)(v3 + 84) = result;
    }
  }
  return result;
}
// 43F3CC: variable 'v3' is possibly undefined
// 4A4BB4: using guessed type int dword_4A4BB4;

//----- (0043F3D0) --------------------------------------------------------
int xmlDefaultSAXHandlerInit()
{
  return xmlSAXVersion(&xmlDefaultSAXHandler, 1);
}
// 4A4BB8: using guessed type int (__cdecl *xmlDefaultSAXHandler)(int, int, int, int);

//----- (0043F3DF) --------------------------------------------------------
int sub_43F3DF()
{
  return xmlGenericError(xmlGenericErrorContext, "xmlMallocBreakpoint reached on block %d\n", *(_DWORD *)dword_4A9C6C);
}
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);

//----- (0043F3FA) --------------------------------------------------------
_DWORD *__cdecl xmlMallocLoc(int a1, int a2, int a3)
{
  _DWORD *v3; // eax
  _DWORD *v4; // esi
  int v6; // ecx
  int v7; // ecx
  unsigned int v8; // eax
  _DWORD *v9; // esi

  if ( !dword_4A9C54 )
    xmlInitMemory();
  v3 = malloc(a1 + 24);
  v4 = v3;
  if ( v3 )
  {
    v6 = dword_4A9C68;
    v3[4] = a2;
    v3[5] = a3;
    v7 = v6 + 1;
    v8 = a1 + dword_4A9C58;
    ++dword_4A9C5C;
    *v4 = 23205;
    v4[3] = a1;
    v4[1] = 1;
    dword_4A9C68 = v7;
    v4[2] = v7;
    dword_4A9C58 = v8;
    if ( v8 > dword_4A9C60 )
      dword_4A9C60 = v8;
    if ( *(_DWORD *)dword_4A9C6C == v7 )
      sub_43F3DF();
    v9 = v4 + 6;
    if ( *(_DWORD **)dword_4A9C70 == v9 )
    {
      xmlGenericError(xmlGenericErrorContext, "%p : Malloc(%lu) Ok\n", *(const void **)dword_4A9C70, a1);
      sub_43F3DF();
    }
    return v9;
  }
  else
  {
    xmlGenericError(xmlGenericErrorContext, "xmlMallocLoc : Out of free space\n");
    return 0;
  }
}
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);
// 4A9C54: using guessed type int dword_4A9C54;
// 4A9C58: using guessed type int dword_4A9C58;
// 4A9C5C: using guessed type int dword_4A9C5C;
// 4A9C60: using guessed type int dword_4A9C60;
// 4A9C68: using guessed type int dword_4A9C68;

//----- (0043F4BE) --------------------------------------------------------
_DWORD *__cdecl xmlMallocAtomicLoc(int a1, int a2, int a3)
{
  _DWORD *v3; // eax
  _DWORD *v4; // esi
  int v6; // ecx
  int v7; // ecx
  unsigned int v8; // eax
  _DWORD *v9; // esi

  if ( !dword_4A9C54 )
    xmlInitMemory();
  v3 = malloc(a1 + 24);
  v4 = v3;
  if ( v3 )
  {
    v6 = dword_4A9C68;
    v3[4] = a2;
    v3[5] = a3;
    v7 = v6 + 1;
    v8 = a1 + dword_4A9C58;
    ++dword_4A9C5C;
    *v4 = 23205;
    v4[3] = a1;
    v4[1] = 4;
    dword_4A9C68 = v7;
    v4[2] = v7;
    dword_4A9C58 = v8;
    if ( v8 > dword_4A9C60 )
      dword_4A9C60 = v8;
    if ( *(_DWORD *)dword_4A9C6C == v7 )
      sub_43F3DF();
    v9 = v4 + 6;
    if ( *(_DWORD **)dword_4A9C70 == v9 )
    {
      xmlGenericError(xmlGenericErrorContext, "%p : Malloc(%lu) Ok\n", *(const void **)dword_4A9C70, a1);
      sub_43F3DF();
    }
    return v9;
  }
  else
  {
    xmlGenericError(xmlGenericErrorContext, "xmlMallocLoc : Out of free space\n");
    return 0;
  }
}
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);
// 4A9C54: using guessed type int dword_4A9C54;
// 4A9C58: using guessed type int dword_4A9C58;
// 4A9C5C: using guessed type int dword_4A9C5C;
// 4A9C60: using guessed type int dword_4A9C60;
// 4A9C68: using guessed type int dword_4A9C68;

//----- (0043F582) --------------------------------------------------------
_DWORD *__cdecl xmlMemMalloc(int a1)
{
  return xmlMallocLoc(a1, (int)"none", 0);
}

//----- (0043F596) --------------------------------------------------------
_DWORD *__cdecl xmlReallocLoc(int a1, int a2, int a3, int a4)
{
  _DWORD *v5; // edi
  int v6; // esi
  _DWORD *v7; // edi
  unsigned int v8; // esi
  int v9; // [esp+4h] [ebp-4h]

  if ( !a1 )
    return xmlMallocLoc(a2, a3, a4);
  if ( !dword_4A9C54 )
    xmlInitMemory();
  v5 = (_DWORD *)(a1 - 24);
  v9 = *(_DWORD *)(a1 - 16);
  if ( *(_DWORD *)dword_4A9C6C == v9 )
    sub_43F3DF();
  if ( *v5 != 23205 )
  {
    sub_43F8DA(v5);
    return 0;
  }
  v6 = dword_4A9C58 - v5[3];
  --dword_4A9C5C;
  *v5 = -23206;
  dword_4A9C58 = v6;
  v7 = realloc(v5, a2 + 24);
  if ( !v7 )
    return 0;
  if ( *(_DWORD *)dword_4A9C70 == a1 )
  {
    xmlGenericError(xmlGenericErrorContext, "%p : Realloced(%lu -> %lu) Ok\n", *(const void **)dword_4A9C70, v7[3], a2);
    sub_43F3DF();
    v6 = dword_4A9C58;
  }
  v7[2] = v9;
  v8 = a2 + v6;
  ++dword_4A9C5C;
  v7[4] = a3;
  *v7 = 23205;
  v7[1] = 2;
  v7[3] = a2;
  v7[5] = a4;
  dword_4A9C58 = v8;
  if ( v8 > dword_4A9C60 )
    dword_4A9C60 = v8;
  return v7 + 6;
}
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);
// 4A9C54: using guessed type int dword_4A9C54;
// 4A9C58: using guessed type int dword_4A9C58;
// 4A9C5C: using guessed type int dword_4A9C5C;
// 4A9C60: using guessed type int dword_4A9C60;

//----- (0043F697) --------------------------------------------------------
_DWORD *__cdecl xmlMemRealloc(int a1, int a2)
{
  return xmlReallocLoc(a1, a2, (int)"none", 0);
}

//----- (0043F6AF) --------------------------------------------------------
void __cdecl xmlMemFree(_DWORD *a1)
{
  _DWORD *v1; // esi
  size_t v2; // [esp-8h] [ebp-Ch]

  if ( a1 )
  {
    if ( a1 == (_DWORD *)-1 )
    {
      xmlGenericError(xmlGenericErrorContext, "trying to free pointer from freed area\n");
LABEL_8:
      xmlGenericError(xmlGenericErrorContext, "xmlMemFree(%lX) error\n", a1);
      sub_43F3DF();
      return;
    }
    if ( *(_DWORD **)dword_4A9C70 == a1 )
    {
      xmlGenericError(xmlGenericErrorContext, "%p : Freed()\n", *(const void **)dword_4A9C70);
      sub_43F3DF();
    }
    v1 = a1 - 6;
    if ( *(a1 - 6) != 23205 )
    {
      sub_43F8DA(a1 - 6);
      goto LABEL_8;
    }
    if ( *(_DWORD *)dword_4A9C6C == v1[2] )
      sub_43F3DF();
    v2 = v1[3];
    *v1 = -23206;
    memset(a1, -1, v2);
    dword_4A9C58 -= v1[3];
    --dword_4A9C5C;
    free(a1 - 6);
  }
}
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);
// 4A9C58: using guessed type int dword_4A9C58;
// 4A9C5C: using guessed type int dword_4A9C5C;

//----- (0043F762) --------------------------------------------------------
char *__cdecl xmlMemStrdupLoc(const char *a1, int a2, int a3)
{
  unsigned int v3; // kr00_4
  unsigned int v4; // esi
  _DWORD *v5; // eax
  int v6; // edx
  int v7; // ecx
  unsigned int v8; // edx
  char *v9; // esi

  v3 = strlen(a1);
  v4 = v3 + 1;
  if ( !dword_4A9C54 )
    xmlInitMemory();
  v5 = malloc(v3 + 25);
  if ( !v5 )
    return 0;
  v6 = dword_4A9C58;
  v5[4] = a2;
  v5[5] = a3;
  v7 = dword_4A9C68 + 1;
  v8 = v4 + v6;
  ++dword_4A9C5C;
  *v5 = 23205;
  v5[3] = v4;
  v5[1] = 3;
  dword_4A9C68 = v7;
  v5[2] = v7;
  dword_4A9C58 = v8;
  if ( v8 > dword_4A9C60 )
    dword_4A9C60 = v8;
  v9 = (char *)(v5 + 6);
  if ( *(_DWORD *)dword_4A9C6C == v7 )
    sub_43F3DF();
  if ( !v9 )
    return 0;
  strcpy(v9, a1);
  if ( *(char **)dword_4A9C70 == v9 )
  {
    xmlGenericError(xmlGenericErrorContext, "%p : Strdup() Ok\n", *(const void **)dword_4A9C70);
    sub_43F3DF();
  }
  return v9;
}
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);
// 4A9C54: using guessed type int dword_4A9C54;
// 4A9C58: using guessed type int dword_4A9C58;
// 4A9C5C: using guessed type int dword_4A9C5C;
// 4A9C60: using guessed type int dword_4A9C60;
// 4A9C68: using guessed type int dword_4A9C68;

//----- (0043F837) --------------------------------------------------------
char *__cdecl xmlMemoryStrdup(const char *a1)
{
  return xmlMemStrdupLoc(a1, (int)"none", 0);
}

//----- (0043F84B) --------------------------------------------------------
int xmlMemUsed()
{
  return dword_4A9C58;
}
// 4A9C58: using guessed type int dword_4A9C58;

//----- (0043F851) --------------------------------------------------------
int xmlMemBlocks()
{
  return dword_4A9C5C;
}
// 4A9C5C: using guessed type int dword_4A9C5C;

//----- (0043F857) --------------------------------------------------------
void __cdecl xmlMemDisplayLast(FILE *Stream, int a2)
{
  FILE *v2; // esi

  v2 = Stream;
  if ( a2 > 0 && (Stream || (v2 = fopen(".memorylist", "w")) != 0) )
  {
    fprintf(v2, "Memory list not compiled (MEM_LIST not defined !)\n");
    if ( !Stream )
      fclose(v2);
  }
}

//----- (0043F89C) --------------------------------------------------------
FILE *__cdecl xmlMemDisplay(FILE *Stream)
{
  FILE *v1; // esi
  FILE *result; // eax

  v1 = Stream;
  if ( Stream || (result = fopen(".memorylist", "w"), (v1 = result) != 0) )
  {
    result = (FILE *)fprintf(v1, "Memory list not compiled (MEM_LIST not defined !)\n");
    if ( !Stream )
      return (FILE *)fclose(v1);
  }
  return result;
}

//----- (0043F8DA) --------------------------------------------------------
int __cdecl sub_43F8DA(const void *ArgList)
{
  return xmlGenericError(xmlGenericErrorContext, "Memory tag error occurs :%p \n\t bye\n", ArgList);
}
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);

//----- (0043F8F3) --------------------------------------------------------
int __cdecl xmlMemShow(FILE *Stream)
{
  int result; // eax

  if ( Stream )
    return fprintf(Stream, "      MEMORY ALLOCATED : %lu, MAX was %lu\n", dword_4A9C58, dword_4A9C60);
  return result;
}
// 4A9C58: using guessed type int dword_4A9C58;
// 4A9C60: using guessed type int dword_4A9C60;

//----- (0043F918) --------------------------------------------------------
int xmlInitMemory()
{
  char *v1; // eax
  char *v2; // eax

  if ( dword_4A9C54 )
    return -1;
  dword_4A9C54 = 1;
  dword_4A9C64 = (int)malloc(4u);
  v1 = getenv("XML_MEM_BREAKPOINT");
  if ( v1 )
    sscanf(v1, "%ud", dword_4A9C6C);
  v2 = getenv("XML_MEM_TRACE");
  if ( v2 )
    sscanf(v2, "%p", dword_4A9C70);
  return 0;
}
// 4A9C54: using guessed type int dword_4A9C54;
// 4A9C64: using guessed type int dword_4A9C64;

//----- (0043F984) --------------------------------------------------------
void xmlCleanupMemory()
{
  if ( dword_4A9C54 )
  {
    xmlFreeRMutex((void *)dword_4A9C64);
    dword_4A9C64 = 0;
    dword_4A9C54 = 0;
  }
}
// 4A9C54: using guessed type int dword_4A9C54;
// 4A9C64: using guessed type int dword_4A9C64;

//----- (0043F9A8) --------------------------------------------------------
int __cdecl xmlMemSetup(
        int a1,
        int (__cdecl *a2)(_DWORD),
        int (__cdecl *a3)(LPVOID lpMem, SIZE_T dwBytes),
        int (__cdecl *a4)(void *Src))
{
  if ( !a1 || !a2 || !a3 || !a4 )
    return -1;
  xmlFree = a1;
  xmlMalloc = a2;
  xmlMallocAtomic = a2;
  xmlRealloc = a3;
  xmlMemStrdup = a4;
  return 0;
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 49B2BC: using guessed type int (__cdecl *xmlMallocAtomic)(size_t Size);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);
// 4A4B74: using guessed type int (__cdecl *xmlMemStrdup)(void *Src);

//----- (0043F9EE) --------------------------------------------------------
int __cdecl xmlMemGet(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  if ( a1 )
    *a1 = xmlFree;
  if ( a2 )
    *a2 = xmlMalloc;
  if ( a3 )
    *a3 = xmlRealloc;
  if ( a4 )
    *a4 = xmlMemStrdup;
  return 0;
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);
// 4A4B74: using guessed type int (__cdecl *xmlMemStrdup)(void *Src);

//----- (0043FA31) --------------------------------------------------------
int __cdecl xmlGcMemSetup(
        int a1,
        int (__cdecl *a2)(_DWORD),
        int (__cdecl *a3)(size_t Size),
        int (__cdecl *a4)(LPVOID lpMem, SIZE_T dwBytes),
        int (__cdecl *a5)(void *Src))
{
  if ( !a1 )
    return -1;
  if ( !a2 || !a3 || !a4 || !a5 )
    return -1;
  xmlMemStrdup = a5;
  xmlFree = a1;
  xmlMalloc = a2;
  xmlMallocAtomic = a3;
  xmlRealloc = a4;
  return 0;
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 49B2BC: using guessed type int (__cdecl *xmlMallocAtomic)(size_t Size);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);
// 4A4B74: using guessed type int (__cdecl *xmlMemStrdup)(void *Src);

//----- (0043FA86) --------------------------------------------------------
int __cdecl xmlGcMemGet(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  if ( a1 )
    *a1 = xmlFree;
  if ( a2 )
    *a2 = xmlMalloc;
  if ( a3 )
    *a3 = xmlMallocAtomic;
  if ( a4 )
    *a4 = xmlRealloc;
  if ( a5 )
    *a5 = xmlMemStrdup;
  return 0;
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 49B2BC: using guessed type int (__cdecl *xmlMallocAtomic)(size_t Size);
// 4A4B70: using guessed type int (__cdecl *xmlRealloc)(LPVOID lpMem, SIZE_T dwBytes);
// 4A4B74: using guessed type int (__cdecl *xmlMemStrdup)(void *Src);

//----- (0043FAD8) --------------------------------------------------------
void xmlInitGlobals()
{
  if ( !dword_4A9C74 )
    dword_4A9C74 = (int)malloc(4u);
}
// 4A9C74: using guessed type int dword_4A9C74;

//----- (0043FAEF) --------------------------------------------------------
void xmlCleanupGlobals()
{
  if ( dword_4A9C74 )
  {
    xmlFreeRMutex((void *)dword_4A9C74);
    dword_4A9C74 = 0;
  }
}
// 4A9C74: using guessed type int dword_4A9C74;

//----- (0043FB07) --------------------------------------------------------
void *__cdecl xmlInitializeGlobalState(_DWORD *a1)
{
  int v1; // ecx
  int v2; // ecx

  if ( !dword_4A9C74 )
    xmlInitGlobals();
  a1[97] = dword_4A4B80;
  a1[98] = dword_4A4B88;
  a1[100] = dword_4A9C88;
  a1[90] = malloc;
  a1[112] = malloc;
  a1[101] = dword_4A4B90;
  a1[108] = dword_4A4BA8;
  a1[109] = off_4A4BB0;
  a1[102] = dword_4A4B98;
  a1[103] = dword_4A9CA0;
  a1[104] = dword_4A9C90;
  a1[105] = dword_4A9C80;
  a1[106] = dword_4A9C98;
  a1[107] = dword_4A9CE8;
  v1 = dword_4A9CA8;
  a1[96] = 0;
  a1[99] = v1;
  a1[93] = off_4A4BA0;
  a1[94] = dword_4A9CD0;
  a1[95] = dword_4A9CD8;
  a1[128] = dword_4A9CE0;
  a1[110] = dword_4A9CB0;
  a1[111] = dword_4A9CB8;
  a1[126] = dword_4A9CC0;
  v2 = dword_4A9CC8;
  a1[1] = xmlSAX2GetPublicId;
  a1[2] = xmlSAX2GetSystemId;
  a1[3] = xmlSAX2GetLineNumber;
  a1[4] = xmlSAX2GetColumnNumber;
  a1[89] = free;
  a1[92] = realloc;
  a1[91] = xmlStrdup;
  *a1 = "20800";
  a1[127] = v2;
  return memset(a1 + 113, 0, 0x34u);
}
// 4A4B80: using guessed type int dword_4A4B80;
// 4A4B88: using guessed type int dword_4A4B88;
// 4A4B90: using guessed type int dword_4A4B90;
// 4A4B98: using guessed type int dword_4A4B98;
// 4A4BA0: using guessed type int (__cdecl *off_4A4BA0)(int, char *Format, char ArgList);
// 4A4BA8: using guessed type int dword_4A4BA8;
// 4A4BB0: using guessed type char *off_4A4BB0;
// 4A9C74: using guessed type int dword_4A9C74;
// 4A9C80: using guessed type int dword_4A9C80;
// 4A9C88: using guessed type int dword_4A9C88;
// 4A9C90: using guessed type int dword_4A9C90;
// 4A9C98: using guessed type int dword_4A9C98;
// 4A9CA0: using guessed type int dword_4A9CA0;
// 4A9CA8: using guessed type int dword_4A9CA8;
// 4A9CB0: using guessed type int dword_4A9CB0;
// 4A9CB8: using guessed type int dword_4A9CB8;
// 4A9CC0: using guessed type int dword_4A9CC0;
// 4A9CC8: using guessed type int dword_4A9CC8;
// 4A9CD0: using guessed type int dword_4A9CD0;
// 4A9CD8: using guessed type int dword_4A9CD8;
// 4A9CE0: using guessed type int dword_4A9CE0;
// 4A9CE8: using guessed type int dword_4A9CE8;

//----- (0043FC80) --------------------------------------------------------
int (__cdecl *__cdecl xmlThrDefSetGenericErrorFunc(
        int a1,
        int (__cdecl *a2)(int, char *Format, char ArgList)))(int, char *Format, char ArgList)
{
  int (__cdecl *result)(int, char *, char); // eax

  dword_4A9CD8 = a1;
  result = a2;
  off_4A4BA0 = a2;
  if ( !a2 )
    off_4A4BA0 = (int (__cdecl *)(int, char *, char))sub_431949;
  return result;
}
// 4A4BA0: using guessed type int (__cdecl *off_4A4BA0)(int, char *Format, char ArgList);
// 4A9CD8: using guessed type int dword_4A9CD8;

//----- (0043FCA1) --------------------------------------------------------
int __cdecl xmlThrDefSetStructuredErrorFunc(int a1, int a2)
{
  int result; // eax

  dword_4A9CE0 = a1;
  result = a2;
  dword_4A9CD0 = a2;
  return result;
}
// 4A9CD0: using guessed type int dword_4A9CD0;
// 4A9CE0: using guessed type int dword_4A9CE0;

//----- (0043FCB4) --------------------------------------------------------
int __cdecl xmlRegisterNodeDefault(int a1)
{
  int result; // eax

  result = xmlRegisterNodeDefaultValue;
  dword_4A9C08 = 1;
  xmlRegisterNodeDefaultValue = a1;
  return result;
}
// 4A9C08: using guessed type int dword_4A9C08;
// 4A9CAC: using guessed type int xmlRegisterNodeDefaultValue;

//----- (0043FCCE) --------------------------------------------------------
int __cdecl xmlThrDefRegisterNodeDefault(int a1)
{
  int result; // eax

  result = dword_4A9CB0;
  dword_4A9C08 = 1;
  dword_4A9CB0 = a1;
  return result;
}
// 4A9C08: using guessed type int dword_4A9C08;
// 4A9CB0: using guessed type int dword_4A9CB0;

//----- (0043FCE8) --------------------------------------------------------
int __cdecl xmlDeregisterNodeDefault(int a1)
{
  int result; // eax

  result = xmlDeregisterNodeDefaultValue;
  dword_4A9C08 = 1;
  xmlDeregisterNodeDefaultValue = a1;
  return result;
}
// 4A9C08: using guessed type int dword_4A9C08;
// 4A9CB4: using guessed type int xmlDeregisterNodeDefaultValue;

//----- (0043FD02) --------------------------------------------------------
int __cdecl xmlThrDefDeregisterNodeDefault(int a1)
{
  int result; // eax

  result = dword_4A9CB8;
  dword_4A9C08 = 1;
  dword_4A9CB8 = a1;
  return result;
}
// 4A9C08: using guessed type int dword_4A9C08;
// 4A9CB8: using guessed type int dword_4A9CB8;

//----- (0043FD1C) --------------------------------------------------------
_DWORD *(__cdecl *__cdecl xmlThrDefParserInputBufferCreateFilenameDefault(int a1))(int a1, int a2)
{
  _DWORD *(__cdecl *result)(int, int); // eax

  result = (_DWORD *(__cdecl *)(int, int))dword_4A9CC0;
  if ( !dword_4A9CC0 )
    result = sub_43C40D;
  dword_4A9CC0 = a1;
  return result;
}
// 4A9CC0: using guessed type int dword_4A9CC0;

//----- (0043FD35) --------------------------------------------------------
_DWORD *(__cdecl *__cdecl xmlThrDefOutputBufferCreateFilenameDefault(int a1))(char *a1, int a2)
{
  _DWORD *(__cdecl *result)(char *, int); // eax

  result = (_DWORD *(__cdecl *)(char *, int))dword_4A9CC8;
  if ( !dword_4A9CC8 )
    result = sub_43C4BA;
  dword_4A9CC8 = a1;
  return result;
}
// 4A9CC8: using guessed type int dword_4A9CC8;

//----- (0043FD4E) --------------------------------------------------------
void *_xmlLastError()
{
  return &xmlLastError;
}

//----- (0043FD54) --------------------------------------------------------
void *_oldXMLWDcompatibility()
{
  return &oldXMLWDcompatibility;
}

//----- (0043FD5A) --------------------------------------------------------
int *_xmlBufferAllocScheme()
{
  return &xmlBufferAllocScheme;
}
// 4A4B7C: using guessed type int xmlBufferAllocScheme;

//----- (0043FD60) --------------------------------------------------------
int __cdecl xmlThrDefBufferAllocScheme(int a1)
{
  int result; // eax

  result = dword_4A4B80;
  dword_4A4B80 = a1;
  return result;
}
// 4A4B80: using guessed type int dword_4A4B80;

//----- (0043FD70) --------------------------------------------------------
int *_xmlDefaultBufferSize()
{
  return &xmlDefaultBufferSize;
}
// 4A4B84: using guessed type int xmlDefaultBufferSize;

//----- (0043FD76) --------------------------------------------------------
int __cdecl xmlThrDefDefaultBufferSize(int a1)
{
  int result; // eax

  result = dword_4A4B88;
  dword_4A4B88 = a1;
  return result;
}
// 4A4B88: using guessed type int dword_4A4B88;

//----- (0043FD86) --------------------------------------------------------
int (__cdecl **_xmlDefaultSAXHandler())(int, int, int, int)
{
  return &xmlDefaultSAXHandler;
}
// 4A4BB8: using guessed type int (__cdecl *xmlDefaultSAXHandler)(int, int, int, int);

//----- (0043FD8C) --------------------------------------------------------
int (**_xmlDefaultSAXLocator())()
{
  return &xmlDefaultSAXLocator;
}
// 4A4C28: using guessed type int (*xmlDefaultSAXLocator)();

//----- (0043FD92) --------------------------------------------------------
int *_xmlDoValidityCheckingDefaultValue()
{
  return &xmlDoValidityCheckingDefaultValue;
}
// 4A9C84: using guessed type int xmlDoValidityCheckingDefaultValue;

//----- (0043FD98) --------------------------------------------------------
int __cdecl xmlThrDefDoValidityCheckingDefaultValue(int a1)
{
  int result; // eax

  result = dword_4A9C88;
  dword_4A9C88 = a1;
  return result;
}
// 4A9C88: using guessed type int dword_4A9C88;

//----- (0043FDA8) --------------------------------------------------------
int (__cdecl **_xmlGenericError())(int, char *Format, char ArgList)
{
  return xmlGenericError;
}
// 4A4B9C: using guessed type int (__cdecl *xmlGenericError[2])(int, char *Format, char ArgList);

//----- (0043FDAE) --------------------------------------------------------
int *_xmlStructuredError()
{
  return &xmlStructuredError;
}
// 4A9CCC: using guessed type int xmlStructuredError;

//----- (0043FDB4) --------------------------------------------------------
FILE **_xmlGenericErrorContext()
{
  return &xmlGenericErrorContext;
}

//----- (0043FDBA) --------------------------------------------------------
int *_xmlStructuredErrorContext()
{
  return &xmlStructuredErrorContext;
}
// 4A9CDC: using guessed type int xmlStructuredErrorContext;

//----- (0043FDC0) --------------------------------------------------------
int *_xmlGetWarningsDefaultValue()
{
  return &xmlGetWarningsDefaultValue;
}
// 4A4B8C: using guessed type int xmlGetWarningsDefaultValue;

//----- (0043FDC6) --------------------------------------------------------
int __cdecl xmlThrDefGetWarningsDefaultValue(int a1)
{
  int result; // eax

  result = dword_4A4B90;
  dword_4A4B90 = a1;
  return result;
}
// 4A4B90: using guessed type int dword_4A4B90;

//----- (0043FDD6) --------------------------------------------------------
int *_xmlIndentTreeOutput()
{
  return &xmlIndentTreeOutput;
}
// 4A4BA4: using guessed type int xmlIndentTreeOutput;

//----- (0043FDDC) --------------------------------------------------------
int __cdecl xmlThrDefIndentTreeOutput(int a1)
{
  int result; // eax

  result = dword_4A4BA8;
  dword_4A4BA8 = a1;
  return result;
}
// 4A4BA8: using guessed type int dword_4A4BA8;

//----- (0043FDEC) --------------------------------------------------------
void **_xmlTreeIndentString()
{
  return &xmlTreeIndentString;
}

//----- (0043FDF2) --------------------------------------------------------
char *__cdecl xmlThrDefTreeIndentString(char *a1)
{
  char *result; // eax

  result = off_4A4BB0;
  off_4A4BB0 = a1;
  return result;
}
// 4A4BB0: using guessed type char *off_4A4BB0;

//----- (0043FE02) --------------------------------------------------------
int *_xmlKeepBlanksDefaultValue()
{
  return &xmlKeepBlanksDefaultValue;
}
// 4A4B94: using guessed type int xmlKeepBlanksDefaultValue;

//----- (0043FE08) --------------------------------------------------------
int __cdecl xmlThrDefKeepBlanksDefaultValue(int a1)
{
  int result; // eax

  result = dword_4A4B98;
  dword_4A4B98 = a1;
  return result;
}
// 4A4B98: using guessed type int dword_4A4B98;

//----- (0043FE18) --------------------------------------------------------
int *_xmlLineNumbersDefaultValue()
{
  return &xmlLineNumbersDefaultValue;
}
// 4A9C9C: using guessed type int xmlLineNumbersDefaultValue;

//----- (0043FE1E) --------------------------------------------------------
int __cdecl xmlThrDefLineNumbersDefaultValue(int a1)
{
  int result; // eax

  result = dword_4A9CA0;
  dword_4A9CA0 = a1;
  return result;
}
// 4A9CA0: using guessed type int dword_4A9CA0;

//----- (0043FE2E) --------------------------------------------------------
int *_xmlLoadExtDtdDefaultValue()
{
  return &xmlLoadExtDtdDefaultValue;
}
// 4A9C8C: using guessed type int xmlLoadExtDtdDefaultValue;

//----- (0043FE34) --------------------------------------------------------
int __cdecl xmlThrDefLoadExtDtdDefaultValue(int a1)
{
  int result; // eax

  result = dword_4A9C90;
  dword_4A9C90 = a1;
  return result;
}
// 4A9C90: using guessed type int dword_4A9C90;

//----- (0043FE44) --------------------------------------------------------
int *_xmlParserDebugEntities()
{
  return &xmlParserDebugEntities;
}
// 4A9C7C: using guessed type int xmlParserDebugEntities;

//----- (0043FE4A) --------------------------------------------------------
int __cdecl xmlThrDefParserDebugEntities(int a1)
{
  int result; // eax

  result = dword_4A9C80;
  dword_4A9C80 = a1;
  return result;
}
// 4A9C80: using guessed type int dword_4A9C80;

//----- (0043FE5A) --------------------------------------------------------
char **_xmlParserVersion()
{
  return &xmlParserVersion;
}
// 4A4B78: using guessed type char *xmlParserVersion;

//----- (0043FE60) --------------------------------------------------------
int *_xmlPedanticParserDefaultValue()
{
  return &xmlPedanticParserDefaultValue;
}
// 4A9C94: using guessed type int xmlPedanticParserDefaultValue;

//----- (0043FE66) --------------------------------------------------------
int __cdecl xmlThrDefPedanticParserDefaultValue(int a1)
{
  int result; // eax

  result = dword_4A9C98;
  dword_4A9C98 = a1;
  return result;
}
// 4A9C98: using guessed type int dword_4A9C98;

//----- (0043FE76) --------------------------------------------------------
int *_xmlSaveNoEmptyTags()
{
  return &xmlSaveNoEmptyTags;
}
// 4A9CE4: using guessed type int xmlSaveNoEmptyTags;

//----- (0043FE7C) --------------------------------------------------------
int __cdecl xmlThrDefSaveNoEmptyTags(int a1)
{
  int result; // eax

  result = dword_4A9CE8;
  dword_4A9CE8 = a1;
  return result;
}
// 4A9CE8: using guessed type int dword_4A9CE8;

//----- (0043FE8C) --------------------------------------------------------
int *_xmlSubstituteEntitiesDefaultValue()
{
  return &xmlSubstituteEntitiesDefaultValue;
}
// 4A9CA4: using guessed type int xmlSubstituteEntitiesDefaultValue;

//----- (0043FE92) --------------------------------------------------------
int __cdecl xmlThrDefSubstituteEntitiesDefaultValue(int a1)
{
  int result; // eax

  result = dword_4A9CA8;
  dword_4A9CA8 = a1;
  return result;
}
// 4A9CA8: using guessed type int dword_4A9CA8;

//----- (0043FEA2) --------------------------------------------------------
int *_xmlRegisterNodeDefaultValue()
{
  return &xmlRegisterNodeDefaultValue;
}
// 4A9CAC: using guessed type int xmlRegisterNodeDefaultValue;

//----- (0043FEA8) --------------------------------------------------------
int *_xmlDeregisterNodeDefaultValue()
{
  return &xmlDeregisterNodeDefaultValue;
}
// 4A9CB4: using guessed type int xmlDeregisterNodeDefaultValue;

//----- (0043FEAE) --------------------------------------------------------
int *_xmlParserInputBufferCreateFilenameValue()
{
  return &xmlParserInputBufferCreateFilenameValue;
}
// 4A9CBC: using guessed type int xmlParserInputBufferCreateFilenameValue;

//----- (0043FEB4) --------------------------------------------------------
int *_xmlOutputBufferCreateFilenameValue()
{
  return &xmlOutputBufferCreateFilenameValue;
}
// 4A9CC4: using guessed type int xmlOutputBufferCreateFilenameValue;

//----- (0043FEBA) --------------------------------------------------------
void __cdecl xmlFreeRMutex(void *Block)
{
  if ( Block )
    free(Block);
}

//----- (0043FEC7) --------------------------------------------------------
void *xmlNewRMutex()
{
  return malloc(4u);
}

//----- (0043FED1) --------------------------------------------------------
int __usercall sub_43FED1@<eax>(_DWORD **a1@<esi>, int a2)
{
  void (__cdecl *v2)(_DWORD **); // eax

  *a1[1] = *a1;
  (*a1)[1] = a1[1];
  v2 = *(void (__cdecl **)(_DWORD **))(a2 + 4);
  if ( v2 )
    v2(a1);
  return ((int (__cdecl *)(_DWORD **))xmlFree)(a1);
}
// 496494: invalid function type has been ignored

//----- (0043FEF8) --------------------------------------------------------
int __cdecl sub_43FEF8(unsigned int a1, unsigned int a2)
{
  if ( a1 >= a2 )
    return a1 != a2;
  else
    return -1;
}

//----- (0043FF12) --------------------------------------------------------
_DWORD *__usercall sub_43FF12@<eax>(int a1@<edi>, int a2)
{
  _DWORD *i; // esi

  if ( !a1 )
    return 0;
  for ( i = **(_DWORD ***)a1; i != *(_DWORD **)a1; i = (_DWORD *)*i )
  {
    if ( (*(int (__cdecl **)(_DWORD, int))(a1 + 8))(i[2], a2) >= 0 )
      break;
  }
  return i;
}

//----- (0043FF3C) --------------------------------------------------------
_DWORD *__usercall sub_43FF3C@<eax>(_DWORD **a1@<edi>, int a2)
{
  _DWORD *i; // esi

  if ( !a1 )
    return 0;
  for ( i = (_DWORD *)(*a1)[1]; i != *a1; i = (_DWORD *)i[1] )
  {
    if ( ((int (__cdecl *)(_DWORD, int))a1[2])(i[2], a2) <= 0 )
      break;
  }
  return i;
}

//----- (0043FF68) --------------------------------------------------------
int __usercall sub_43FF68@<eax>(int result@<eax>, int a2)
{
  int v2; // edi
  _DWORD *v3; // eax

  v2 = result;
  if ( result )
  {
    v3 = sub_43FF12(result, a2);
    if ( v3 == *(_DWORD **)v2 )
      return 0;
    else
      return (*(int (__cdecl **)(_DWORD, int))(v2 + 8))(v3[2], a2) == 0 ? (unsigned int)v3 : 0;
  }
  return result;
}

//----- (0043FF9D) --------------------------------------------------------
_DWORD **__usercall sub_43FF9D@<eax>(_DWORD **result@<eax>, int a2)
{
  _DWORD **v2; // edi
  _DWORD *v3; // eax

  v2 = result;
  if ( result )
  {
    v3 = sub_43FF3C(result, a2);
    if ( v3 == *v2 )
      return 0;
    else
      return ((int (__cdecl *)(_DWORD, int))v2[2])(v3[2], a2) == 0 ? (_DWORD **)v3 : 0;
  }
  return result;
}

//----- (0043FFD2) --------------------------------------------------------
_DWORD *__cdecl xmlListCreate(int a1, int a2)
{
  _DWORD *v2; // esi
  _DWORD *v4; // eax

  v2 = (_DWORD *)xmlMalloc(12);
  if ( !v2 )
  {
    xmlGenericError(xmlGenericErrorContext, "Cannot initialize memory for list");
    return 0;
  }
  *v2 = 0;
  v2[1] = 0;
  v2[2] = 0;
  v4 = (_DWORD *)xmlMalloc(12);
  *v2 = v4;
  if ( !v4 )
  {
    xmlGenericError(xmlGenericErrorContext, "Cannot initialize memory for sentinel");
    ((void (__cdecl *)(_DWORD *))xmlFree)(v2);
    return 0;
  }
  *v4 = v4;
  *(_DWORD *)(*v2 + 4) = *v2;
  *(_DWORD *)(*v2 + 8) = 0;
  if ( a1 )
    v2[1] = a1;
  if ( a2 )
    v2[2] = a2;
  else
    v2[2] = sub_43FEF8;
  return v2;
}
// 496494: invalid function type has been ignored
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);

//----- (0044005E) --------------------------------------------------------
int __cdecl xmlListSearch(int a1, int a2)
{
  int v2; // eax

  if ( a1 && (v2 = sub_43FF68(a1, a2)) != 0 )
    return *(_DWORD *)(v2 + 8);
  else
    return 0;
}

//----- (0044007B) --------------------------------------------------------
_DWORD *__cdecl xmlListReverseSearch(_DWORD **a1, int a2)
{
  _DWORD **v2; // eax

  if ( a1 && (v2 = sub_43FF9D(a1, a2)) != 0 )
    return v2[2];
  else
    return 0;
}

//----- (00440098) --------------------------------------------------------
int __cdecl xmlListInsert(int a1, int a2)
{
  _DWORD *v3; // edi
  _DWORD *v4; // eax
  int v5; // ecx

  if ( !a1 )
    return 1;
  v3 = sub_43FF12(a1, a2);
  v4 = (_DWORD *)xmlMalloc(12);
  if ( v4 )
  {
    v4[2] = a2;
    v5 = v3[1];
    *v4 = *(_DWORD *)v5;
    *(_DWORD *)(*(_DWORD *)v5 + 4) = v4;
    *(_DWORD *)v5 = v4;
    v4[1] = v5;
    return 0;
  }
  else
  {
    xmlGenericError(xmlGenericErrorContext, "Cannot initialize memory for new link");
    return 1;
  }
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);

//----- (004400F2) --------------------------------------------------------
int __cdecl xmlListAppend(_DWORD **a1, int a2)
{
  _DWORD *v3; // esi
  _DWORD *v4; // eax

  if ( !a1 )
    return 1;
  v3 = sub_43FF3C(a1, a2);
  v4 = (_DWORD *)xmlMalloc(12);
  if ( v4 )
  {
    v4[2] = a2;
    *v4 = *v3;
    *(_DWORD *)(*v3 + 4) = v4;
    *v3 = v4;
    v4[1] = v3;
    return 0;
  }
  else
  {
    xmlGenericError(xmlGenericErrorContext, "Cannot initialize memory for new link");
    return 1;
  }
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);

//----- (0044014B) --------------------------------------------------------
int __cdecl xmlListDelete(_DWORD **Block)
{
  int result; // eax

  if ( Block )
  {
    xmlListClear(Block);
    ((void (__cdecl *)(_DWORD))xmlFree)(*Block);
    return ((int (__cdecl *)(_DWORD **))xmlFree)(Block);
  }
  return result;
}
// 496494: invalid function type has been ignored

//----- (0044016E) --------------------------------------------------------
int __cdecl xmlListRemoveFirst(int a1, int a2)
{
  _DWORD **v2; // eax

  if ( !a1 )
    return 0;
  v2 = (_DWORD **)sub_43FF68(a1, a2);
  if ( !v2 )
    return 0;
  sub_43FED1(v2, a1);
  return 1;
}

//----- (0044019C) --------------------------------------------------------
int __cdecl xmlListRemoveLast(_DWORD **a1, int a2)
{
  _DWORD **v2; // eax

  if ( !a1 )
    return 0;
  v2 = sub_43FF9D(a1, a2);
  if ( !v2 )
    return 0;
  sub_43FED1(v2, (int)a1);
  return 1;
}

//----- (004401CA) --------------------------------------------------------
int __cdecl xmlListRemoveAll(int a1, int a2)
{
  int v2; // esi

  v2 = 0;
  if ( !a1 )
    return 0;
  while ( xmlListRemoveFirst(a1, a2) )
    ++v2;
  return v2;
}

//----- (004401F0) --------------------------------------------------------
_DWORD *__cdecl xmlListClear(_DWORD **a1)
{
  _DWORD *result; // eax
  _DWORD **v2; // esi
  _DWORD *v3; // ebx

  if ( a1 )
  {
    result = *a1;
    v2 = (_DWORD **)**a1;
    if ( (_DWORD *)*result != result )
    {
      do
      {
        v3 = *v2;
        result = (_DWORD *)sub_43FED1(v2, (int)a1);
        v2 = (_DWORD **)v3;
      }
      while ( v3 != *a1 );
    }
  }
  return result;
}

//----- (00440216) --------------------------------------------------------
int __cdecl xmlListEmpty(_DWORD **a1)
{
  if ( a1 )
    return **a1 == (_DWORD)*a1;
  else
    return -1;
}

//----- (0044022E) --------------------------------------------------------
int __cdecl xmlListFront(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
    return **(_DWORD **)a1;
  return result;
}

//----- (0044023C) --------------------------------------------------------
int __cdecl xmlListEnd(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
    return *(_DWORD *)(*(_DWORD *)a1 + 4);
  return result;
}

//----- (0044024B) --------------------------------------------------------
int __cdecl xmlListSize(_DWORD **a1)
{
  int result; // eax
  _DWORD *v2; // ecx

  result = 0;
  if ( !a1 )
    return -1;
  v2 = (_DWORD *)**a1;
  while ( v2 != *a1 )
  {
    v2 = (_DWORD *)*v2;
    ++result;
  }
  return result;
}

//----- (00440267) --------------------------------------------------------
int __cdecl xmlListPopFront(_DWORD **a1)
{
  int result; // eax
  _DWORD ****v2; // edx

  result = xmlListEmpty(a1);
  if ( !result )
    return sub_43FED1(**v2, (int)v2);
  return result;
}
// 440276: variable 'v2' is possibly undefined

//----- (00440284) --------------------------------------------------------
int __cdecl xmlListPopBack(_DWORD **a1)
{
  int result; // eax
  int v2; // edx

  result = xmlListEmpty(a1);
  if ( !result )
    return sub_43FED1(*(_DWORD ***)(*(_DWORD *)v2 + 4), v2);
  return result;
}
// 440293: variable 'v2' is possibly undefined

//----- (004402A2) --------------------------------------------------------
int __cdecl xmlListPushFront(int *a1, int a2)
{
  int result; // eax
  int v3; // esi
  _DWORD *v4; // eax

  result = (int)a1;
  if ( a1 )
  {
    v3 = *a1;
    v4 = (_DWORD *)xmlMalloc(12);
    if ( v4 )
    {
      v4[2] = a2;
      *v4 = *(_DWORD *)v3;
      *(_DWORD *)(*(_DWORD *)v3 + 4) = v4;
      *(_DWORD *)v3 = v4;
      v4[1] = v3;
      return 1;
    }
    else
    {
      xmlGenericError(xmlGenericErrorContext, "Cannot initialize memory for new link");
      return 0;
    }
  }
  return result;
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);

//----- (004402EC) --------------------------------------------------------
int __cdecl xmlListPushBack(int a1, int a2)
{
  int result; // eax
  int v3; // esi
  _DWORD *v4; // eax

  result = a1;
  if ( a1 )
  {
    v3 = *(_DWORD *)(*(_DWORD *)a1 + 4);
    v4 = (_DWORD *)xmlMalloc(12);
    if ( v4 )
    {
      v4[2] = a2;
      *v4 = *(_DWORD *)v3;
      *(_DWORD *)(*(_DWORD *)v3 + 4) = v4;
      *(_DWORD *)v3 = v4;
      v4[1] = v3;
      return 1;
    }
    else
    {
      xmlGenericError(xmlGenericErrorContext, "Cannot initialize memory for new link");
      return 0;
    }
  }
  return result;
}
// 496ACC: using guessed type int (__cdecl *xmlMalloc)(_DWORD);
// 4A4B9C: using guessed type int (*xmlGenericError)(_DWORD, const char *, ...);

//----- (00440339) --------------------------------------------------------
int __cdecl xmlLinkGetData(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
    return *(_DWORD *)(a1 + 8);
  return result;
}

//----- (00440346) --------------------------------------------------------
_DWORD *__usercall xmlListReverse@<eax>(_DWORD *result@<eax>, _DWORD **a2)
{
  _DWORD *i; // ecx

  if ( a2 )
  {
    result = *a2;
    for ( i = (_DWORD *)**a2; i != *a2; i = (_DWORD *)*i )
    {
      *result = result[1];
      result[1] = i;
      result = i;
    }
    *result = result[1];
    result[1] = i;
  }
  return result;
}

//----- (00440371) --------------------------------------------------------
void __cdecl xmlListSort(_DWORD **Block)
{
  _DWORD *v1; // esi

  if ( Block && !xmlListEmpty(Block) )
  {
    v1 = xmlListDup((int)Block);
    if ( v1 )
    {
      xmlListClear(Block);
      xmlListMerge(Block, (_DWORD **)v1);
      xmlListDelete((_DWORD **)v1);
    }
  }
}

//----- (004403AC) --------------------------------------------------------
void __cdecl xmlListWalk(_DWORD **a1, int (__cdecl *a2)(_DWORD, int), int a3)
{
  _DWORD *i; // esi

  if ( a1 )
  {
    if ( a2 )
    {
      for ( i = (_DWORD *)**a1; i != *a1; i = (_DWORD *)*i )
      {
        if ( !a2(i[2], a3) )
          break;
      }
    }
  }
}

//----- (004403DF) --------------------------------------------------------
void __cdecl xmlListReverseWalk(int a1, int (__cdecl *a2)(_DWORD, int), int a3)
{
  int i; // esi

  if ( a1 )
  {
    if ( a2 )
    {
      for ( i = *(_DWORD *)(*(_DWORD *)a1 + 4); i != *(_DWORD *)a1; i = *(_DWORD *)(i + 4) )
      {
        if ( !a2(*(_DWORD *)(i + 8), a3) )
          break;
      }
    }
  }
}

//----- (00440414) --------------------------------------------------------
_DWORD *__cdecl xmlListMerge(_DWORD **Block, _DWORD **a2)
{
  xmlListCopy(Block, a2);
  return xmlListClear(a2);
}

//----- (0044042E) --------------------------------------------------------
_DWORD *__cdecl xmlListDup(int a1)
{
  _DWORD *result; // eax

  if ( !a1 )
    return 0;
  result = xmlListCreate(0, *(_DWORD *)(a1 + 8));
  if ( result )
    return xmlListCopy((_DWORD **)result, (_DWORD **)a1) == 0 ? result : 0;
  return result;
}

//----- (00440462) --------------------------------------------------------
int __cdecl xmlListCopy(_DWORD **Block, _DWORD **a2)
{
  _DWORD *v2; // esi

  if ( a2 && Block )
  {
    v2 = (_DWORD *)**a2;
    if ( v2 == *a2 )
      return 0;
    while ( !xmlListInsert((int)Block, v2[2]) )
    {
      v2 = (_DWORD *)*v2;
      if ( v2 == *a2 )
        return 0;
    }
    xmlListDelete(Block);
  }
  return 1;
}

//----- (004404B0) --------------------------------------------------------
int __cdecl sub_4404B0(int a1, _DWORD *a2, int a3)
{
  int v3; // edi
  unsigned int v4; // edi
  char v5; // al
  int v6; // ecx
  const char *v7; // eax
  const char *v8; // eax
  int v9; // edx
  char *v10; // eax
  char *j; // edi
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // ecx
  int result; // eax
  char *v18; // ebx
  int i; // edi
  int v20; // edi
  int v21; // edi
  char v22; // al
  char v23; // bl
  const char *v24; // eax
  int v25; // eax
  int v26; // eax
  int v27; // eax
  int v28; // eax
  int v29; // eax
  int v30; // edx
  _DWORD **v31; // edx
  int v32; // eax
  int v33; // eax
  char *v34; // eax
  int v35; // [esp-4h] [ebp-8Ch]
  double v36; // [esp+0h] [ebp-88h]
  char *v37; // [esp+4h] [ebp-84h]
  int Size; // [esp+1Ch] [ebp-6Ch]
  int v39; // [esp+20h] [ebp-68h] BYREF
  char v40; // [esp+27h] [ebp-61h]
  void *Src; // [esp+28h] [ebp-60h] BYREF
  _DWORD *v42; // [esp+2Ch] [ebp-5Ch] BYREF
  int v43; // [esp+30h] [ebp-58h]
  void *v44; // [esp+34h] [ebp-54h] BYREF
  int v45; // [esp+38h] [ebp-50h] BYREF
  _DWORD *v46; // [esp+3Ch] [ebp-4Ch] BYREF
  char *v47; // [esp+40h] [ebp-48h]
  char v48[32]; // [esp+44h] [ebp-44h] BYREF
  char Buffer[32]; // [esp+64h] [ebp-24h] BYREF

  v3 = *(unsigned __int8 *)(a1 + 8);
  v43 = a3;
  v4 = v3 & 0xFFFFFF7F;
  v5 = *(_BYTE *)(sub_473493((int)&unk_488930) + v4);
  v40 = v5;
  if ( v5 == 32 )
  {
    v34 = (char *)sub_473493((int)&unk_488990);
    return sub_4445A0(v34, v4);
  }
  else
  {
    Src = Buffer;
    v6 = a2[2];
    Size = 0;
    if ( a2[1] >= v6 )
    {
      a2[2] = v6 + 64;
      *a2 = (*(int (__cdecl **)(_DWORD, int))(*(_DWORD *)dword_4A80FC + 12))(*a2, v6 + 65);
      v5 = v40;
    }
    *(_BYTE *)(*a2 + a2[1]++) = v5;
    *(_BYTE *)(a2[1] + *a2) = 0;
    v48[0] = 0;
    if ( v4 == 9 || v4 == 4 )
    {
      v18 = *(char **)a1;
      v47 = v18;
      zend_hash_internal_pointer_reset_ex(v18, &v42);
      for ( i = zend_hash_get_current_key_ex((int)v18, &v44, &v39, &v45, 0, &v42);
            i != 3;
            i = zend_hash_get_current_key_ex((int)v18, &v44, &v39, &v45, 0, v31) )
      {
        zend_hash_get_current_data_ex((int)v18, &v46, (int *)&v42);
        v20 = i - 1;
        Src = v48;
        if ( v20 )
        {
          if ( v20 == 1 )
          {
            v21 = sprintf(v48, "%lu", v45);
            v39 = v21;
            Size = sprintf(Buffer, "%u:", v21);
          }
          else
          {
            v21 = v39;
          }
        }
        else
        {
          v22 = *(_BYTE *)(*v46 + 8) & 0x80;
          v21 = v39 - 1;
          v23 = *(char *)(*v46 + 8) < 0 ? 34 : 39;
          Src = v44;
          --v39;
          if ( v22 )
          {
            sub_444C80(v43, (const char **)&Src, &v39);
            v21 = v39;
          }
          v24 = (const char *)sub_473493((int)&unk_488948);
          v25 = sprintf(Buffer, v24, v21, v23);
          v18 = v47;
          Size = v25;
        }
        v26 = a2[1] + Size;
        if ( v26 > a2[2] )
        {
          v27 = v26 + 64;
          a2[2] = v27;
          *a2 = (*(int (__cdecl **)(_DWORD, int))(*(_DWORD *)dword_4A80FC + 12))(*a2, v27 + 1);
        }
        memcpy((void *)(a2[1] + *a2), Buffer, Size);
        a2[1] += Size;
        *(_BYTE *)(a2[1] + *a2) = 0;
        v28 = a2[1] + v21;
        if ( v28 > a2[2] )
        {
          v29 = v28 + 64;
          a2[2] = v29;
          *a2 = (*(int (__cdecl **)(_DWORD, int))(*(_DWORD *)dword_4A80FC + 12))(*a2, v29 + 1);
        }
        memcpy((void *)(a2[1] + *a2), Src, v21);
        a2[1] += v21;
        v30 = v43;
        *(_BYTE *)(a2[1] + *a2) = 0;
        sub_4404B0(*v46, a2, v30);
        zend_hash_move_forward_ex((int)v18, (int)&v42);
      }
      v32 = a2[2];
      if ( a2[1] >= v32 )
      {
        v33 = v32 + 64;
        a2[2] = v33;
        *a2 = (*(int (__cdecl **)(_DWORD, int))(*(_DWORD *)dword_4A80FC + 12))(*a2, v33 + 1);
      }
      *(_BYTE *)(*a2 + a2[1]++) = 125;
      result = a2[1];
      *(_BYTE *)(result + *a2) = 0;
    }
    else
    {
      switch ( v4 )
      {
        case 0u:
          break;
        case 1u:
        case 6u:
          v37 = *(char **)a1;
          v7 = (const char *)sub_473493((int)&unk_488950);
          Size = sprintf(Buffer, v7, v37);
          break;
        case 2u:
          v36 = *(double *)a1;
          v35 = dword_4AB148;
          v8 = (const char *)sub_473493((int)&unk_488958);
          Size = sprintf(Buffer, v8, v35, v36);
          break;
        case 3u:
          goto LABEL_10;
        case 8u:
          sub_444C80(v43, (const char **)a1, (_DWORD *)(a1 + 4));
LABEL_10:
          sprintf(v48, "%d'", *(_DWORD *)(a1 + 4));
          v9 = *(_DWORD *)(a1 + 4);
          Src = *(void **)a1;
          Size = v9;
          break;
        default:
          v10 = (char *)sub_473493((int)&unk_488964);
          sub_4445A0(v10, v4);
          break;
      }
      for ( j = v48; *j; *(_BYTE *)(*a2 + a2[1]++) = *j++ )
      {
        v12 = a2[2];
        if ( a2[1] == v12 )
        {
          v13 = v12 + 64;
          a2[2] = v13;
          *a2 = (*(int (__cdecl **)(_DWORD, int))(*(_DWORD *)dword_4A80FC + 12))(*a2, v13 + 1);
        }
      }
      *(_BYTE *)(*a2 + a2[1]) = 0;
      v14 = a2[1] + Size;
      if ( v14 > a2[2] )
      {
        v15 = v14 + 64;
        a2[2] = v15;
        *a2 = (*(int (__cdecl **)(_DWORD, int))(*(_DWORD *)dword_4A80FC + 12))(*a2, v15 + 1);
      }
      memcpy((void *)(a2[1] + *a2), Src, Size);
      v16 = *a2;
      a2[1] += Size;
      result = a2[1];
      *(_BYTE *)(result + v16) = 0;
    }
  }
  return result;
}
// 44089A: variable 'v31' is possibly undefined
// 4AB148: using guessed type int dword_4AB148;
// 4404B0: using guessed type int var_68;

//----- (00440950) --------------------------------------------------------
_BYTE *__usercall sub_440950@<eax>(_DWORD *a1@<esi>, int a2, int a3)
{
  _BYTE *v4; // [esp+0h] [ebp-Ch] BYREF
  int v5; // [esp+4h] [ebp-8h]
  int v6; // [esp+8h] [ebp-4h]

  v6 = 64;
  v5 = 0;
  v4 = (_BYTE *)(*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(65);
  *v4 = 0;
  sub_4404B0(a2, &v4, a3);
  if ( a1 )
    *a1 = v5;
  return v4;
}

//----- (004409A0) --------------------------------------------------------
int __usercall sub_4409A0@<eax>(int *a1@<edi>, FILE *Stream)
{
  const char *v2; // eax
  void *v3; // ebx
  char *v4; // esi
  const char *v5; // eax
  const char *v6; // eax
  int v8; // [esp-Ch] [ebp-10h]
  int v9; // [esp-8h] [ebp-Ch]
  int v10; // [esp-4h] [ebp-8h]

  switch ( *a1 )
  {
    case 1:
      v3 = &unk_4889C4;
      break;
    case 2:
      v3 = &unk_4889C8;
      break;
    case 3:
      v3 = (void *)sub_473493((int)&unk_4889CC);
      break;
    default:
      v10 = *a1;
      v2 = (const char *)sub_473493((int)&unk_4889D4);
      sub_4078E0(v2, v10);
  }
  if ( a1[1] == 1 )
  {
    v4 = (char *)malloc(strlen((const char *)a1[3]) + 3);
    v9 = a1[3];
    v5 = (const char *)sub_473493((int)&unk_4889F8);
    sprintf(v4, v5, v9);
  }
  else
  {
    v4 = (char *)a1[3];
  }
  v8 = a1[2];
  v6 = (const char *)sub_473493((int)&unk_488A00);
  return fprintf(Stream, v6, v3, v8, v4);
}

//----- (00440A50) --------------------------------------------------------
int *__usercall sub_440A50@<eax>(_DWORD *a1@<edi>, int a2)
{
  int *v2; // eax
  int v3; // edx
  int *v4; // ebp
  const char *v5; // eax
  unsigned int v6; // ebx
  char *v7; // eax
  unsigned int v8; // ecx
  int v9; // edx
  unsigned int v11; // [esp+4h] [ebp-18h]
  char Buffer[16]; // [esp+8h] [ebp-14h] BYREF

  v11 = sprintf(Buffer, "%u", a2);
  v2 = (int *)malloc(0x10u);
  v3 = *a1 ^ Buffer[0];
  v4 = v2;
  v2[1] = a1[1] ^ Buffer[1];
  v5 = (const char *)a1[2];
  *v4 = v3;
  if ( v5 )
  {
    v6 = strlen(v5);
    v7 = (char *)malloc(strlen(v5));
    v8 = 0;
    for ( v4[2] = (int)v7; v8 < v6; v7[v8 - 1] = *(_BYTE *)(v8 + a1[2] - 1) ^ Buffer[v9] )
    {
      v9 = v8 % v11;
      ++v8;
    }
    return v4;
  }
  else
  {
    v4[2] = 0;
    return v4;
  }
}

//----- (00440B20) --------------------------------------------------------
void __usercall sub_440B20(int a1@<eax>, int a2@<ecx>, int a3@<esi>)
{
  int *v4; // ebx
  unsigned int v5; // eax
  void (__cdecl *v6)(int, int *, int); // edx
  void (__cdecl *v7)(int, int *, int); // edx
  void (__cdecl *v8)(int, int *, int); // edx
  unsigned int v9; // eax
  void (__cdecl *v10)(int, int *, int); // ecx
  int v11; // [esp+4h] [ebp-4h] BYREF

  if ( a2 )
  {
    v4 = sub_440A50((_DWORD *)a2, a1);
    v5 = strlen(*(const char **)(a2 + 8));
    v6 = *(void (__cdecl **)(int, int *, int))(a3 + 108);
    v11 = v5;
    v6(a3, &v11, 4);
    v7 = *(void (__cdecl **)(int, int *, int))(a3 + 108);
    v11 = *v4;
    v7(a3, &v11, 4);
    v8 = *(void (__cdecl **)(int, int *, int))(a3 + 108);
    v11 = v4[1];
    v8(a3, &v11, 4);
    v9 = strlen(*(const char **)(a2 + 8));
    if ( v9 )
      (*(void (__cdecl **)(int, int, unsigned int))(a3 + 108))(a3, v4[2], v9);
    free((void *)v4[2]);
    free(v4);
  }
  else
  {
    v10 = *(void (__cdecl **)(int, int *, int))(a3 + 108);
    v11 = 0;
    v10(a3, &v11, 4);
  }
}

//----- (00440BE0) --------------------------------------------------------
char __usercall sub_440BE0@<al>(const char *a1@<ebx>, _DWORD *a2, size_t *a3)
{
  const char *v3; // eax
  _off_t st_size; // esi
  FILE *v5; // edi
  const char *v6; // eax
  void *v7; // eax
  const char *v8; // eax
  size_t v9; // eax
  const char *v10; // eax
  struct _stat32 Stat; // [esp+0h] [ebp-24h] BYREF

  if ( _stat32(a1, &Stat) < 0 )
  {
    v3 = (const char *)sub_473493((int)&unk_488A20);
    sub_4078E0(v3, a1);
  }
  st_size = Stat.st_size;
  v5 = fopen(a1, "rb");
  if ( !v5 )
  {
    v6 = (const char *)sub_473493((int)&unk_488A4C);
    sub_4078E0(v6, a1);
  }
  v7 = malloc(st_size);
  *a2 = v7;
  if ( !v7 )
  {
    fclose(v5);
    v8 = (const char *)sub_473493((int)&unk_488A70);
    sub_4078E0(v8, st_size, a1);
  }
  v9 = fread(v7, 1u, st_size, v5);
  if ( v9 != st_size )
  {
    fclose(v5);
    v10 = (const char *)sub_473493((int)&unk_488ABC);
    sub_4078E0(v10, a1);
  }
  *a3 = v9;
  fclose(v5);
  return 1;
}

//----- (00440CB0) --------------------------------------------------------
bool __usercall sub_440CB0@<al>(int a1@<eax>, int a2@<edi>, int *a3, _DWORD *a4)
{
  int v4; // esi
  int v5; // ecx
  int v6; // ebx
  void *v7; // eax
  const char *v8; // eax

  v4 = a1;
  if ( isspace(*(unsigned __int8 *)(a2 + a1 - 1)) )
  {
    do
      v5 = *(unsigned __int8 *)(a2 + v4-- - 2);
    while ( isspace(v5) );
  }
  sub_412CD0(&off_47BBA8);
  v6 = sub_413AD0(byte_488AE8);
  v7 = malloc(0x80u);
  *a3 = (int)v7;
  if ( !v7 )
  {
    v8 = (const char *)sub_473493((int)&unk_488AF0);
    sub_4078E0(v8);
  }
  *a4 = 128;
  return sub_413A10(v6, a2, v4, *a3, a4) == 0;
}
// 47BBA8: using guessed type void *off_47BBA8;

//----- (00440D50) --------------------------------------------------------
char __cdecl sub_440D50(const char *a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // edi
  int v4; // esi

  v3 = 0;
  if ( dword_4A7BBC <= 0 )
    return 0;
  while ( 1 )
  {
    v4 = *(_DWORD *)(dword_4A7BC8 + 4 * v3);
    if ( !strcmp(*(const char **)v4, a1) )
      break;
    if ( ++v3 >= dword_4A7BBC )
      return 0;
  }
  *a2 = *(_DWORD *)(v4 + 4);
  *a3 = *(_DWORD *)(v4 + 8);
  return 1;
}
// 4A7BBC: using guessed type int dword_4A7BBC;
// 4A7BC8: using guessed type int dword_4A7BC8;

//----- (00440DD0) --------------------------------------------------------
int __cdecl sub_440DD0(char *Source, int a2, int a3)
{
  _DWORD *v3; // esi
  int result; // eax
  int v5; // ecx
  int v6; // ecx
  int v7; // [esp-4h] [ebp-8h]

  v3 = malloc(0xCu);
  *v3 = _strdup(Source);
  result = dword_4A7BC0;
  v3[1] = a2;
  v5 = dword_4A7BBC;
  v3[2] = a3;
  if ( v5 == result )
  {
    dword_4A7BC0 = dword_4A7BC4 + result;
    v7 = 4 * (dword_4A7BC4 + result);
    if ( dword_4A7BC8 )
      result = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(dword_4A7BC8, v7);
    else
      result = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(v7);
    v6 = dword_4A7BBC;
    *(_DWORD *)(result + 4 * dword_4A7BBC) = v3;
    dword_4A7BC8 = result;
    dword_4A7BBC = v6 + 1;
  }
  else
  {
    *(_DWORD *)(dword_4A7BC8 + 4 * v5) = v3;
    dword_4A7BBC = v5 + 1;
  }
  return result;
}
// 4A7BBC: using guessed type int dword_4A7BBC;
// 4A7BC0: using guessed type int dword_4A7BC0;
// 4A7BC4: using guessed type int dword_4A7BC4;
// 4A7BC8: using guessed type int dword_4A7BC8;

//----- (00440E90) --------------------------------------------------------
char __usercall sub_440E90@<al>(int *a1@<esi>, int a2, int *a3)
{
  char result; // al
  const char *v4; // eax
  _DWORD *v5; // [esp+0h] [ebp-14h]
  int v6; // [esp+0h] [ebp-14h]
  int v7; // [esp+Ch] [ebp-8h] BYREF
  int v8; // [esp+10h] [ebp-4h] BYREF

  result = sub_440D50(*(const char **)(a2 + 12), a3, v5);
  if ( !result )
  {
    result = sub_440BE0(*(const char **)(a2 + 12), &v8, (size_t *)&v7);
    if ( result )
    {
      if ( !sub_440CB0(v7, v8, a3, a1) )
      {
        v6 = *(_DWORD *)(a2 + 12);
        v4 = (const char *)sub_473493((int)&unk_488B28);
        sub_4078E0(v4, v6);
      }
      return sub_440DD0(*(char **)(a2 + 12), *a3, *a1);
    }
  }
  return result;
}
// 440EA3: variable 'v5' is possibly undefined

//----- (00440F20) --------------------------------------------------------
int __usercall sub_440F20@<eax>(int *a1@<ebx>, _DWORD *a2@<edi>, int a3)
{
  int v3; // ebp
  void *v4; // eax
  const char *v5; // eax
  int result; // eax
  const char *v7; // eax
  int v8; // [esp-4h] [ebp-8h]

  sub_412CD0(&off_47BB40);
  v3 = sub_413AD0(aQ);
  v4 = malloc(0x80u);
  *a1 = (int)v4;
  if ( !v4 )
  {
    v5 = (const char *)sub_473493((int)&unk_488AF0);
    sub_4078E0(v5);
  }
  *a2 = 128;
  result = sub_413A10(v3, *(_DWORD *)(a3 + 12), strlen(*(const char **)(a3 + 12)), *a1, a2);
  if ( result )
  {
    v8 = *(_DWORD *)(a3 + 12);
    v7 = (const char *)sub_473493((int)&unk_488B58);
    sub_4078E0(v7, v8);
  }
  return result;
}
// 47BB40: using guessed type void *off_47BB40;

//----- (00440FB0) --------------------------------------------------------
char __usercall sub_440FB0@<al>(int *a1@<eax>, int *a2@<edx>, int a3@<ecx>)
{
  unsigned int v5; // eax

  if ( *(_DWORD *)(a3 + 4) == 1 )
  {
    if ( strlen(*(const char **)(a3 + 12)) >= 0x10 )
    {
      *a2 = *(_DWORD *)(a3 + 12);
      v5 = strlen(*(const char **)(a3 + 12));
      *a1 = v5;
    }
    else
    {
      LOBYTE(v5) = sub_440F20(a2, a1, a3);
    }
  }
  else
  {
    LOBYTE(v5) = sub_440E90(a1, a3, a2);
  }
  return v5;
}

//----- (00441010) --------------------------------------------------------
_BYTE *sub_441010()
{
  DWORD LastError; // esi
  _BYTE *result; // eax
  bool v2; // zf
  const char *v3; // ecx
  int v4; // esi
  char v5; // dl
  CHAR Buffer[4]; // [esp+4h] [ebp-4h] BYREF

  LastError = GetLastError();
  result = (_BYTE *)dword_4A9D04;
  if ( !dword_4A9D04 )
  {
    result = malloc(0x400u);
    dword_4A9D04 = (int)result;
  }
  *result = 0;
  if ( !LastError
    || (v2 = FormatMessageA(0x1300u, 0, LastError, 0x400u, Buffer, 0, 0) == 0,
        result = (_BYTE *)dword_4A9D04,
        v3 = byte_47627C,
        !v2) )
  {
    v3 = *(const char **)Buffer;
  }
  v4 = result - v3;
  do
  {
    v5 = *v3;
    v3[v4] = *v3;
    ++v3;
  }
  while ( v5 );
  return result;
}
// 4A9D04: using guessed type int dword_4A9D04;

//----- (00441080) --------------------------------------------------------
int sub_441080()
{
  int v0; // esi
  char *v1; // ecx
  int i; // eax
  _DWORD *v3; // eax
  _DWORD *v4; // esi
  _DWORD *v5; // eax
  _DWORD *v6; // eax
  _DWORD *v7; // esi
  int v8; // eax
  int (__cdecl *v9)(int); // ecx
  int (__cdecl *v10)(int); // ecx
  _DWORD *v11; // eax
  _DWORD *v13[2]; // [esp+8h] [ebp-8h] BYREF

  v0 = *(unsigned __int8 *)off_494724;
  v1 = (char *)off_494724 + 1;
  for ( i = 0; i <= v0; ++i )
    *v1++ ^= byte_4820BC[((_BYTE)i + (_BYTE)v0) & 0xF];
  if ( !dword_4A80FC )
  {
    v3 = (_DWORD *)off_4A4FE4(16);
    dword_4A80FC = v3;
    v4 = v3;
    *v3 = 0;
    v3[2] = 0;
    v3[3] = 0;
    v3[1] = 64;
    v5 = (_DWORD *)off_4A4FE4(256);
    v4[2] = v5;
    v4[3] = 0;
    *v5 = &unk_4A4FF0;
    *v4 = &unk_4A4FF0;
  }
  v6 = Block;
  if ( !Block )
  {
    v6 = sub_47315E();
    v6[6] = 0;
    v6[7] = 0;
    v6[8] = 0;
    Block = v6;
  }
  v7 = v6;
  ((void (__cdecl *)(_DWORD))v6[2])(*v6);
  if ( v7[6] )
  {
    v8 = v7[8];
    if ( v8 == v7[7] - 1 )
      v7[8] = 0;
    else
      v7[8] = v8 + 1;
  }
  _time32(&dword_4AAEA8);
  v9 = *(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8);
  dword_4A7BD0 = 0;
  dword_4A7BD4 = 64;
  dword_4A7BD8 = 64;
  dword_4A7BDC = v9(256);
  v10 = *(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8);
  dword_4A7BE0 = 0;
  dword_4A7BE4 = 16;
  dword_4A7BE8 = 16;
  dword_4A7BEC = v10(64);
  v11 = malloc(0x10u);
  *v11 = 0;
  v11[1] = 8;
  v11[2] = 8;
  dword_4A9D14 = (int)v11;
  v11[3] = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(32);
  v13[0] = &unk_4946E0;
  v13[1] = 0;
  sub_446010(v13);
  sub_446150();
  dword_4A9CFC = 1;
  return 0;
}
// 494724: using guessed type void *off_494724;
// 4A4FE4: using guessed type int (__cdecl *off_4A4FE4)(_DWORD);
// 4A7BD0: using guessed type int dword_4A7BD0;
// 4A7BD4: using guessed type int dword_4A7BD4;
// 4A7BD8: using guessed type int dword_4A7BD8;
// 4A7BDC: using guessed type int dword_4A7BDC;
// 4A7BE0: using guessed type int dword_4A7BE0;
// 4A7BE4: using guessed type int dword_4A7BE4;
// 4A7BE8: using guessed type int dword_4A7BE8;
// 4A7BEC: using guessed type int dword_4A7BEC;
// 4A9CFC: using guessed type int dword_4A9CFC;
// 4A9D14: using guessed type int dword_4A9D14;

//----- (00441210) --------------------------------------------------------
_DWORD *__cdecl sub_441210(char *Source)
{
  _DWORD *v1; // esi
  char *v2; // eax
  void *v3; // ecx
  int v4; // edx
  int (__thiscall *v5)(void *, int); // eax
  int v6; // eax
  int v7; // edx
  int (__cdecl *v8)(int); // eax
  int v9; // eax

  v1 = malloc(0x40u);
  v2 = _strdup(Source);
  v3 = dword_4A80FC;
  v4 = *(_DWORD *)dword_4A80FC;
  *v1 = v2;
  v1[6] = 50;
  v1[7] = 50;
  v5 = *(int (__thiscall **)(void *, int))(v4 + 8);
  v1[5] = 0;
  v6 = v5(v3, 200);
  v7 = *(_DWORD *)dword_4A80FC;
  v1[8] = v6;
  v1[2] = 25;
  v1[3] = 25;
  v8 = *(int (__cdecl **)(int))(v7 + 8);
  v1[1] = 0;
  v9 = v8(100);
  v1[10] = 0;
  v1[11] = 0;
  v1[13] = 0;
  v1[9] = 0;
  v1[14] = 0;
  v1[15] = 0;
  v1[4] = v9;
  v1[12] = 32;
  return v1;
}

//----- (00441290) --------------------------------------------------------
unsigned int __usercall sub_441290@<eax>(int *a1@<edi>)
{
  int i; // ebx
  int v2; // esi
  int v4; // [esp+0h] [ebp-4h]

  efree(a1[1]);
  for ( i = 0; i < a1[5]; ++i )
  {
    v2 = *(_DWORD *)(a1[8] + 4 * i);
    efree(*(_DWORD *)(v2 + 56));
    zend_hash_destroy(*(void **)(v2 + 24));
    efree(*(_DWORD *)(v2 + 24));
    efree(*(_DWORD *)(v2 + 8));
    if ( *(_DWORD *)(v2 + 28) )
      efree(*(_DWORD *)(v2 + 28));
    efree(v2);
  }
  if ( a1[8] )
  {
    (*(void (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 16))(a1[8]);
    a1[8] = 0;
  }
  v4 = a1[2];
  a1[6] = 0;
  a1[5] = 0;
  efree(v4);
  return efree((int)a1);
}

//----- (00441340) --------------------------------------------------------
void __usercall sub_441340(int a1@<esi>)
{
  int i; // ebx
  int v2; // edi
  int v3; // ebx
  bool v4; // cc
  int v5; // edi
  int j; // edi

  free(*(void **)a1);
  for ( i = 0; i < *(_DWORD *)(a1 + 20); ++i )
  {
    v2 = *(_DWORD *)(*(_DWORD *)(a1 + 32) + 4 * i);
    efree(*(_DWORD *)(v2 + 56));
    zend_hash_destroy(*(void **)(v2 + 24));
    efree(*(_DWORD *)(v2 + 24));
    efree(*(_DWORD *)(v2 + 8));
    if ( *(_DWORD *)(v2 + 28) )
      efree(*(_DWORD *)(v2 + 28));
    efree(v2);
  }
  if ( *(_DWORD *)(a1 + 32) )
  {
    (*(void (__cdecl **)(_DWORD))(*(_DWORD *)dword_4A80FC + 16))(*(_DWORD *)(a1 + 32));
    *(_DWORD *)(a1 + 32) = 0;
  }
  v3 = 0;
  v4 = *(_DWORD *)(a1 + 4) <= 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  if ( !v4 )
  {
    do
      sub_441290(*(int **)(*(_DWORD *)(a1 + 16) + 4 * v3++));
    while ( v3 < *(_DWORD *)(a1 + 4) );
  }
  if ( *(_DWORD *)(a1 + 16) )
  {
    (*(void (__cdecl **)(_DWORD))(*(_DWORD *)dword_4A80FC + 16))(*(_DWORD *)(a1 + 16));
    *(_DWORD *)(a1 + 16) = 0;
  }
  v5 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  if ( v5 )
  {
    efree(*(_DWORD *)(v5 + 56));
    zend_hash_destroy(*(void **)(v5 + 24));
    efree(*(_DWORD *)(v5 + 24));
    efree(*(_DWORD *)(v5 + 8));
    if ( *(_DWORD *)(v5 + 28) )
      efree(*(_DWORD *)(v5 + 28));
    efree(v5);
  }
  for ( j = 0; j < *(_DWORD *)(a1 + 40); ++j )
    free(*(void **)(*(_DWORD *)(a1 + 52) + 8 * j));
  if ( *(_DWORD *)(a1 + 52) )
  {
    (*(void (__cdecl **)(_DWORD))(*(_DWORD *)dword_4A80FC + 16))(*(_DWORD *)(a1 + 52));
    *(_DWORD *)(a1 + 52) = 0;
  }
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  free((void *)a1);
}

//----- (004414A0) --------------------------------------------------------
void __cdecl sub_4414A0(int a1, int a2)
{
  int v2; // ebp
  _DWORD *v3; // esi
  _DWORD *v4; // eax
  char v5; // al
  int v6; // edx
  int v7; // ecx
  char v8; // dl
  char v9; // cl
  int v10; // [esp+8h] [ebp-4h]

  v2 = 0;
  v10 = 0;
  if ( a2 > 0 )
  {
    while ( 1 )
    {
      v3 = Block;
      if ( !Block )
      {
        v3 = malloc(0x24u);
        v4 = malloc(0x1Cu);
        *v3 = v4;
        *v4 = 4096;
        *(_DWORD *)(*v3 + 4) = 4097;
        *(_DWORD *)(*v3 + 8) = 1236789;
        *(_DWORD *)(*v3 + 12) = 521288629;
        *(_DWORD *)(*v3 + 16) = 362;
        *(_DWORD *)(*v3 + 20) = 0;
        *(_DWORD *)(*v3 + 24) = 0;
        v3[1] = sub_472D69;
        v3[2] = sub_4730D6;
        v3[3] = sub_47314A;
        v3[4] = sub_472AAE;
        v3[5] = sub_472AB6;
        v3[6] = 0;
        v3[7] = 0;
        v3[8] = 0;
        Block = v3;
      }
      v5 = ((int (__cdecl *)(_DWORD))v3[2])(*v3);
      v6 = v3[6];
      if ( v6 )
      {
        v7 = v3[8];
        v8 = *(_BYTE *)(v7 + v6);
        v2 = v10;
        if ( v7 == v3[7] - 1 )
          v3[8] = 0;
        else
          v3[8] = v7 + 1;
        v9 = v5 ^ v8;
      }
      else
      {
        v9 = v5;
      }
      *(_BYTE *)(a1 + v2) = v9;
      if ( v9 != 60 )
      {
        v10 = ++v2;
        if ( v2 >= a2 )
          break;
      }
    }
  }
}
// 472AAE: using guessed type int sub_472AAE();
// 472AB6: using guessed type int sub_472AB6();
// 47314A: using guessed type int sub_47314A();

//----- (004415A0) --------------------------------------------------------
int __cdecl sub_4415A0(int a1, int a2, int a3)
{
  int v3; // ebp
  int v4; // esi
  int v5; // ebx
  int v6; // edi
  int result; // eax

  v3 = a2;
  v4 = a3;
  if ( a3 )
  {
    while ( 1 )
    {
      v5 = 0;
      if ( v4 >= 227 )
        v4 = 227;
      v6 = 0;
      if ( v4 > 0 )
      {
        do
        {
          if ( *(_BYTE *)(v5 + v3) == 60 )
            break;
          ++v5;
        }
        while ( v5 < v4 );
        if ( v5 == 60 )
          v5 = 59;
      }
      sub_4414A0((int)&a2, 2);
      if ( v5 == 227 )
      {
        LOBYTE(a2) = a2 & 0x7F;
        if ( (_BYTE)a2 == 60 )
          LOBYTE(a2) = 61;
      }
      else
      {
        if ( v5 < v4 && *(_BYTE *)(v5 + v3) == 60 )
        {
          LOBYTE(a2) = a2 | 0xC0;
          v6 = 1;
        }
        else
        {
          LOBYTE(a2) = a2 & 0x3F | 0x80;
        }
        BYTE1(a2) = v5;
      }
      result = (*(int (__cdecl **)(int, int *, int))(a1 + 108))(a1, &a2, 2);
      if ( v5 )
        result = (*(int (__cdecl **)(int, int, int))(a1 + 108))(a1, v3, v5);
      v3 += v5 + v6;
      a3 -= v5 + v6;
      if ( !a3 )
        break;
      v4 = a3;
    }
  }
  return result;
}

//----- (00441690) --------------------------------------------------------
int __cdecl sub_441690(int a1, int a2, int a3)
{
  int result; // eax
  char v4; // al
  void (__cdecl *v5)(int, char *, int); // eax
  _DWORD *v6; // esi
  char v7; // al
  int v8; // edx
  int v9; // ecx
  char v10; // dl
  char v11; // cl
  void (__cdecl *v12)(int, char *, int); // eax
  _DWORD *v13; // esi
  _DWORD *v14; // eax
  char v15; // al
  int v16; // edx
  int v17; // ecx
  char v18; // dl
  char v19[4]; // [esp+8h] [ebp-8h] BYREF
  int v20; // [esp+Ch] [ebp-4h]

  result = 0;
  v20 = 0;
  if ( a3 > 0 )
  {
    while ( 1 )
    {
      v4 = *(_BYTE *)(result + a2);
      if ( v4 == 60 )
        break;
      if ( v4 == -1 )
      {
        v5 = *(void (__cdecl **)(int, char *, int))(a1 + 108);
        v19[0] = -1;
        v5(a1, v19, 1);
        do
        {
          v6 = Block;
          if ( !Block )
          {
            v6 = sub_47315E();
            v6[6] = 0;
            v6[7] = 0;
            v6[8] = 0;
            Block = v6;
          }
          v7 = ((int (__cdecl *)(_DWORD))v6[2])(*v6);
          v8 = v6[6];
          if ( v8 )
          {
            v9 = v6[8];
            v10 = *(_BYTE *)(v9 + v8);
            if ( v9 == v6[7] - 1 )
              v6[8] = 0;
            else
              v6[8] = v9 + 1;
            v11 = v7 ^ v10;
          }
          else
          {
            v11 = v7;
          }
        }
        while ( v11 == 60 || v11 < 0 );
LABEL_27:
        v19[0] = v11;
        goto LABEL_28;
      }
      v19[0] = v4;
LABEL_28:
      (*(void (__cdecl **)(int, char *))(a1 + 108))(a1, v19);
      result = ++v20;
      if ( v20 >= a3 )
        return result;
    }
    v12 = *(void (__cdecl **)(int, char *, int))(a1 + 108);
    v19[0] = -1;
    v12(a1, v19, 1);
    do
    {
      v13 = Block;
      if ( !Block )
      {
        v13 = malloc(0x24u);
        v14 = malloc(0x1Cu);
        *v13 = v14;
        *v14 = 4096;
        *(_DWORD *)(*v13 + 4) = 4097;
        *(_DWORD *)(*v13 + 8) = 1236789;
        *(_DWORD *)(*v13 + 12) = 521288629;
        *(_DWORD *)(*v13 + 16) = 362;
        *(_DWORD *)(*v13 + 20) = 0;
        *(_DWORD *)(*v13 + 24) = 0;
        v13[1] = sub_472D69;
        v13[2] = sub_4730D6;
        v13[3] = sub_47314A;
        v13[4] = sub_472AAE;
        v13[5] = sub_472AB6;
        v13[6] = 0;
        v13[7] = 0;
        v13[8] = 0;
        Block = v13;
      }
      v15 = ((int (__cdecl *)(_DWORD))v13[2])(*v13);
      v16 = v13[6];
      if ( v16 )
      {
        v17 = v13[8];
        v18 = *(_BYTE *)(v17 + v16);
        if ( v17 == v13[7] - 1 )
          v13[8] = 0;
        else
          v13[8] = v17 + 1;
        v11 = v15 ^ v18;
      }
      else
      {
        v11 = v15;
      }
    }
    while ( v11 >= 0 );
    goto LABEL_27;
  }
  return result;
}
// 472AAE: using guessed type int sub_472AAE();
// 472AB6: using guessed type int sub_472AB6();
// 47314A: using guessed type int sub_47314A();
// 441690: using guessed type char var_8[4];

//----- (00441860) --------------------------------------------------------
int __usercall sub_441860@<eax>(int a1@<ebx>, int a2@<edi>, int a3, char a4)
{
  int i; // esi
  int (__cdecl *v5)(int, char *, int); // eax
  int result; // eax
  char v7[4]; // [esp+8h] [ebp-4h] BYREF

  for ( i = 0; i < a1; ++i )
  {
    v5 = *(int (__cdecl **)(int, char *, int))(a2 + 108);
    v7[0] = *(_BYTE *)(i + a3) ^ *(&a4 + (i & 3));
    result = v5(a2, v7, 1);
  }
  return result;
}
// 441860: using guessed type char var_4[4];

//----- (004418A0) --------------------------------------------------------
int __usercall sub_4418A0@<eax>(int a1@<esi>, int *a2)
{
  int (__cdecl *v2)(int, int *, int); // edx
  int v3; // edi
  int result; // eax
  _DWORD *v5; // eax
  void (__cdecl *v6)(int, char *, int); // edx
  const char *v7; // edi
  const char *v8; // ebp
  unsigned int v9; // ebx
  void (__cdecl *v10)(int, unsigned int *, int); // ecx
  unsigned int v11; // ebx
  unsigned int v12; // edi
  int (__cdecl *v13)(int, unsigned int *, int); // ecx
  unsigned int v14; // edi
  char v15[4]; // [esp+4h] [ebp-10h] BYREF
  int v16; // [esp+8h] [ebp-Ch]
  int v17; // [esp+Ch] [ebp-8h] BYREF
  unsigned int v18; // [esp+10h] [ebp-4h] BYREF

  v2 = *(int (__cdecl **)(int, int *, int))(a1 + 108);
  v17 = *a2;
  v3 = v17;
  result = v2(a1, &v17, 4);
  if ( v3 )
  {
    v16 = 0;
    v17 = v3;
    do
    {
      v5 = (_DWORD *)(v16 + a2[3]);
      v6 = *(void (__cdecl **)(int, char *, int))(a1 + 108);
      v7 = (const char *)v5[1];
      v8 = (const char *)v5[2];
      v15[0] = *v5;
      v6(a1, v15, 1);
      if ( v7 )
        v9 = strlen(v7);
      else
        v9 = 0;
      v10 = *(void (__cdecl **)(int, unsigned int *, int))(a1 + 108);
      v18 = v9;
      v10(a1, &v18, 4);
      v11 = v9 + 1;
      if ( v11 )
        (*(void (__cdecl **)(int, const char *, unsigned int))(a1 + 108))(a1, v7, v11);
      if ( v8 )
        v12 = strlen(v8);
      else
        v12 = 0;
      v13 = *(int (__cdecl **)(int, unsigned int *, int))(a1 + 108);
      v18 = v12;
      result = v13(a1, &v18, 4);
      v14 = v12 + 1;
      if ( v14 )
        result = (*(int (__cdecl **)(int, const char *, unsigned int))(a1 + 108))(a1, v8, v14);
      v16 += 12;
      --v17;
    }
    while ( v17 );
  }
  return result;
}
// 4418A0: using guessed type char var_10[4];

//----- (00441990) --------------------------------------------------------
int __cdecl sub_441990(int a1)
{
  int v1; // ecx
  int v2; // esi
  char *v3; // ecx
  int v4; // eax
  void *v5; // edx
  int v6; // ebx
  _DWORD *v7; // ebx
  const char *v8; // eax
  void *v9; // edi
  void *v10; // esi
  int v11; // ecx
  unsigned int v12; // eax
  void (__cdecl *v13)(_DWORD, _DWORD, _DWORD); // edx
  int v14; // eax
  const char *v15; // eax
  unsigned int v16; // edi
  char *v17; // eax
  char *v18; // esi
  const char *v19; // eax
  int v20; // eax
  _DWORD *v21; // edi
  _DWORD *v22; // esi
  int v23; // eax
  int v24; // edx
  int v25; // ecx
  unsigned __int8 v26; // dl
  int v27; // ecx
  _DWORD *v28; // esi
  void (__cdecl *v29)(_DWORD, _DWORD, _DWORD); // eax
  void (__cdecl *v30)(_DWORD, _DWORD, _DWORD); // eax
  void (__cdecl *v31)(_DWORD, _DWORD, _DWORD); // edx
  void (__cdecl *v32)(_DWORD, _DWORD, _DWORD); // edx
  int v33; // ebx
  void (__cdecl *v34)(_DWORD, _DWORD, _DWORD); // eax
  void (__cdecl *v35)(_DWORD, _DWORD, _DWORD); // edx
  _DWORD *v36; // eax
  int v37; // edx
  void (__cdecl *v38)(_DWORD, _DWORD, _DWORD); // ecx
  void (__cdecl *v39)(_DWORD, _DWORD, _DWORD); // eax
  int v40; // edi
  unsigned int v41; // ebx
  void (__cdecl *v42)(_DWORD, _DWORD, _DWORD); // edx
  void (__cdecl *v43)(_DWORD, _DWORD, _DWORD); // ecx
  void (__cdecl *v44)(_DWORD, _DWORD, _DWORD); // ecx
  void (__cdecl *v45)(_DWORD, _DWORD, _DWORD); // eax
  int v46; // edi
  unsigned int v47; // ebx
  void (__cdecl *v48)(_DWORD, _DWORD, _DWORD); // ecx
  void (__cdecl *v49)(_DWORD, _DWORD, _DWORD); // eax
  int v50; // edi
  unsigned int v51; // ebx
  void (__cdecl *v52)(_DWORD, _DWORD, _DWORD); // eax
  void (__cdecl *v53)(_DWORD, _DWORD, _DWORD); // edx
  unsigned int v54; // eax
  void (__cdecl *v55)(_DWORD, _DWORD, _DWORD); // edx
  int v56; // ebx
  void (__cdecl *v57)(_DWORD, _DWORD, _DWORD); // ecx
  void (__cdecl *v58)(_DWORD, _DWORD, _DWORD); // edx
  void (__cdecl *v59)(_DWORD, _DWORD, _DWORD); // ecx
  void (__cdecl *v60)(_DWORD, _DWORD, _DWORD); // eax
  char *v61; // eax
  void (__cdecl *v62)(_DWORD, _DWORD, _DWORD); // ecx
  _DWORD *v63; // eax
  bool v64; // cc
  int v65; // ebx
  void (__cdecl *v66)(_DWORD, _DWORD, _DWORD); // eax
  int v67; // edi
  unsigned int v68; // ebx
  void (__cdecl *v69)(_DWORD, _DWORD, _DWORD); // edx
  void (__cdecl *v70)(_DWORD, _DWORD, _DWORD); // edx
  _BYTE *v71; // edi
  char v72; // cl
  void (__cdecl *v73)(_DWORD, _DWORD, _DWORD); // eax
  int v74; // ebp
  unsigned int v75; // eax
  void (__cdecl *v76)(_DWORD, _DWORD, _DWORD); // ecx
  int v77; // ebx
  char v78; // di
  void (__cdecl *v79)(_DWORD, _DWORD, _DWORD); // edx
  int v80; // ebx
  char v81; // di
  void (__cdecl *v82)(_DWORD, _DWORD, _DWORD); // ecx
  void (__cdecl *v83)(_DWORD, _DWORD, _DWORD); // eax
  int v84; // edi
  char *v85; // eax
  char v86; // cl
  void (__cdecl *v87)(_DWORD, _DWORD, _DWORD); // eax
  _DWORD *v88; // eax
  const char *v89; // edi
  void (__cdecl *v90)(_DWORD, _DWORD, _DWORD); // eax
  char v91; // cl
  char *v92; // edi
  void (__cdecl *v93)(_DWORD, _DWORD, _DWORD); // ecx
  char v94; // dl
  int v95; // eax
  char v96; // dl
  int v97; // edi
  void (__cdecl *v98)(_DWORD, _DWORD, _DWORD); // ecx
  void (__cdecl *v99)(_DWORD, _DWORD, _DWORD); // edx
  int *v100; // eax
  int v101; // ebp
  int *v102; // eax
  int v103; // ebx
  char v104; // cl
  void (__cdecl *v105)(_DWORD, _DWORD, _DWORD); // eax
  void (__cdecl *v106)(_DWORD, _DWORD, _DWORD); // edx
  void (__cdecl *v107)(_DWORD, _DWORD, _DWORD); // eax
  int *v108; // eax
  int v109; // ebx
  int v110; // ebp
  void (__cdecl *v111)(_DWORD, _DWORD, _DWORD); // eax
  _DWORD *v112; // eax
  int i; // ebx
  const char *v114; // edx
  unsigned int v115; // kr08_4
  void (__cdecl *v116)(_DWORD, _DWORD, _DWORD); // eax
  _DWORD *v117; // edi
  int v118; // ebp
  signed int v119; // ebx
  int v120; // edi
  void (__cdecl *v121)(_DWORD, _DWORD, _DWORD); // ecx
  int v122; // eax
  signed int v123; // edi
  signed int v124; // ebx
  int v125; // edi
  void (__cdecl *v126)(_DWORD, _DWORD, _DWORD); // eax
  int v127; // ecx
  int v128; // ebp
  signed int v129; // edi
  void (__cdecl *v130)(_DWORD, _DWORD, _DWORD); // edx
  char *v131; // eax
  void (__cdecl *v132)(_DWORD, _DWORD, _DWORD); // ecx
  unsigned __int8 *v133; // ebx
  unsigned int v134; // edi
  unsigned int v135; // ebp
  unsigned int v136; // ecx
  int v137; // eax
  unsigned int v138; // edx
  unsigned int v139; // ecx
  int v140; // edi
  unsigned int v141; // ecx
  int v142; // edi
  unsigned int v143; // ecx
  int v144; // edi
  unsigned int v145; // ecx
  int v146; // edi
  unsigned int v147; // ecx
  int v148; // edi
  unsigned int v149; // ecx
  int v150; // edi
  unsigned int v151; // ecx
  int v152; // edi
  unsigned int v153; // ecx
  int v154; // edi
  unsigned int v155; // ecx
  int v156; // edi
  int v157; // ecx
  int v158; // edi
  int v159; // ecx
  int v160; // edi
  int v161; // ecx
  int v162; // edi
  int v163; // ecx
  int v164; // edi
  int v165; // ecx
  int v166; // edi
  int v167; // ecx
  int v168; // edi
  int v169; // edi
  void (__cdecl *v170)(_DWORD, _DWORD, _DWORD); // ecx
  int v171; // edx
  char v172; // cl
  char v173; // cl
  int v174; // edx
  int v175; // ecx
  int v176; // edx
  int v177; // ecx
  char v178; // al
  void *v179; // eax
  void (__cdecl *v180)(_DWORD, _DWORD, _DWORD); // edx
  unsigned int *v181; // eax
  unsigned int v182; // ecx
  int *v183; // edi
  int *v184; // ebp
  unsigned int m; // ebx
  int v186; // eax
  int *v187; // ecx
  unsigned int v188; // eax
  int v189; // ebx
  int (__cdecl **v190)(_DWORD); // ebp
  char v191; // al
  int (__cdecl *v192)(_DWORD); // ecx
  int (__cdecl *v193)(_DWORD); // edx
  char v194; // cl
  char v195; // cl
  int n; // eax
  int v197; // edi
  _DWORD *v198; // eax
  int v199; // ebp
  void (__cdecl *v200)(_DWORD, _DWORD, _DWORD); // ecx
  void (__cdecl *v201)(_DWORD, _DWORD, _DWORD); // eax
  int v202; // ebx
  int v203; // edi
  void *v204; // ecx
  void (__cdecl *v205)(_DWORD, _DWORD, _DWORD); // eax
  const char *v206; // eax
  unsigned __int8 *v207; // edi
  unsigned int v208; // ebx
  unsigned int ii; // ecx
  int v210; // eax
  unsigned int v211; // ecx
  int v212; // ebx
  unsigned int v213; // ecx
  int v214; // ebx
  unsigned int v215; // ecx
  int v216; // ebx
  unsigned int v217; // ecx
  int v218; // ebx
  unsigned int v219; // ecx
  int v220; // ebx
  unsigned int v221; // ecx
  int v222; // ebx
  unsigned int v223; // ecx
  int v224; // ebx
  unsigned int v225; // ecx
  int v226; // ebx
  unsigned int v227; // ecx
  int v228; // ebx
  int v229; // ecx
  int v230; // ebx
  int v231; // ecx
  int v232; // ebx
  int v233; // ecx
  int v234; // ebx
  int v235; // ecx
  int v236; // ebx
  int v237; // ecx
  int v238; // ebx
  int v239; // ecx
  int v240; // ebx
  void *v241; // ebx
  void (__cdecl *v242)(_DWORD, _DWORD, _DWORD); // ecx
  int v243; // eax
  void *v244; // ebx
  int v245; // edi
  _DWORD *v246; // eax
  _DWORD *v247; // edi
  _DWORD *v248; // edi
  void **v249; // esi
  int v250; // eax
  const char *v251; // esi
  _BYTE *v252; // eax
  const char *v254; // eax
  int v255; // esi
  FILE *v256; // eax
  int v257; // [esp-8h] [ebp-178h]
  int v258; // [esp-4h] [ebp-174h]
  int v259; // [esp-4h] [ebp-174h]
  int v260; // [esp-4h] [ebp-174h]
  int v261; // [esp-4h] [ebp-174h]
  char v262; // [esp+14h] [ebp-15Ch] BYREF
  int v263; // [esp+18h] [ebp-158h] BYREF
  char v264; // [esp+1Ch] [ebp-154h] BYREF
  int v265; // [esp+20h] [ebp-150h]
  const char *v266; // [esp+24h] [ebp-14Ch]
  int v267; // [esp+28h] [ebp-148h]
  int v268; // [esp+2Ch] [ebp-144h] BYREF
  char v269; // [esp+30h] [ebp-140h] BYREF
  char v270; // [esp+34h] [ebp-13Ch] BYREF
  int v271; // [esp+38h] [ebp-138h]
  char v272; // [esp+3Ch] [ebp-134h] BYREF
  void *v273; // [esp+40h] [ebp-130h] BYREF
  void *v274; // [esp+44h] [ebp-12Ch] BYREF
  _DWORD *v275; // [esp+48h] [ebp-128h]
  unsigned int v276; // [esp+4Ch] [ebp-124h] BYREF
  unsigned int v277; // [esp+50h] [ebp-120h]
  int k; // [esp+54h] [ebp-11Ch] BYREF
  int v279; // [esp+58h] [ebp-118h]
  _DWORD *v280; // [esp+5Ch] [ebp-114h]
  int v281; // [esp+60h] [ebp-110h]
  unsigned int v282; // [esp+64h] [ebp-10Ch]
  int v283; // [esp+68h] [ebp-108h]
  int v284; // [esp+6Ch] [ebp-104h]
  int j; // [esp+70h] [ebp-100h] BYREF
  int v286; // [esp+74h] [ebp-FCh]
  int v287; // [esp+78h] [ebp-F8h]
  char *v288; // [esp+7Ch] [ebp-F4h]
  __time32_t v289; // [esp+80h] [ebp-F0h]
  int v290; // [esp+84h] [ebp-ECh] BYREF
  int v291; // [esp+88h] [ebp-E8h] BYREF
  int v292[4]; // [esp+8Ch] [ebp-E4h] BYREF
  int v293[3]; // [esp+9Ch] [ebp-D4h] BYREF
  __int16 v294[2]; // [esp+A8h] [ebp-C8h] BYREF
  int v295; // [esp+ACh] [ebp-C4h]
  char v296; // [esp+B0h] [ebp-C0h]
  __int16 v297; // [esp+B1h] [ebp-BFh]
  char v298; // [esp+B3h] [ebp-BDh]
  int v299; // [esp+B4h] [ebp-BCh]
  int v300; // [esp+B8h] [ebp-B8h]
  int v301; // [esp+BCh] [ebp-B4h]
  int v302; // [esp+C0h] [ebp-B0h]
  __int16 v303; // [esp+C4h] [ebp-ACh]
  char v304; // [esp+C6h] [ebp-AAh]
  char v305; // [esp+C7h] [ebp-A9h]
  int v306; // [esp+C8h] [ebp-A8h]
  int v307; // [esp+CCh] [ebp-A4h]
  void *Block[6]; // [esp+D0h] [ebp-A0h] BYREF
  char Buffer[132]; // [esp+E8h] [ebp-88h] BYREF

  v2 = v1;
  v3 = *(char **)(a1 + 16);
  v258 = *(_DWORD *)(a1 + 20);
  v271 = a1;
  v287 = v2;
  v4 = sub_4460B0(v3, v258);
  v5 = *(void **)(a1 + 56);
  v6 = v4;
  v281 = v4;
  v283 = 1;
  Block[0] = v5;
  v277 = 0;
  sub_445500(a1, &v291, v2 + 40);
  if ( !v6 )
  {
    v261 = *(_DWORD *)(a1 + 20);
    v257 = *(_DWORD *)(a1 + 16);
    v254 = (const char *)sub_473493((int)&unk_488C24);
    v255 = sprintf(Buffer, v254, v257, v261);
    if ( v255 < 0 )
      v255 = 128;
    v256 = (FILE *)sub_44F01A();
    fwrite(Buffer, 1u, v255, v256 + 1);
    return v283;
  }
  v7 = sub_445CD0();
  v8 = *(const char **)(a1 + 52);
  v9 = 0;
  v10 = 0;
  v280 = v7;
  v273 = 0;
  v274 = 0;
  _chmod(v8, 511);
  v11 = *(_DWORD *)(a1 + 212);
  if ( v11 )
    sub_440FB0((int *)(v287 + 60), (int *)(v287 + 56), v11);
  if ( *(_DWORD *)(a1 + 188) )
  {
    sub_446800((int *)&v273, (int *)&v274, (int)v7, a1);
    v9 = v273;
    v10 = v274;
  }
  if ( ((int (__cdecl *)(_DWORD *, _DWORD, int))v7[24])(v7, *(_DWORD *)(a1 + 52), 1) )
  {
    v273 = 0;
    v279 = 0;
    v289 = dword_4AAEA8;
    if ( *(_DWORD *)(a1 + 188) )
    {
      if ( v10 )
        ((void (__cdecl *)(_DWORD *, void *, void *))v7[27])(v7, v9, v10);
      free(v9);
      v277 = (unsigned int)v10;
    }
    else if ( *(_DWORD *)(a1 + 124) )
    {
      v12 = strlen(*(const char **)(a1 + 128));
      if ( v12 )
        ((void (__cdecl *)(_DWORD *, _DWORD, unsigned int))v7[27])(v7, *(_DWORD *)(a1 + 128), v12);
      v13 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v7[27];
      v262 = 10;
      v13(v7, &v262, 1);
      v277 = strlen(*(const char **)(a1 + 128)) + 1;
    }
    if ( *(_DWORD *)(a1 + 184) )
    {
      v14 = sub_4464F0((int)v7, a1);
      v277 += v14;
    }
    v15 = *(const char **)(a1 + 48);
    if ( v15 )
    {
      v16 = strlen(v15);
      if ( v16 )
      {
        v17 = (char *)malloc(v16 + 64);
        v259 = *(_DWORD *)(a1 + 48);
        v18 = v17;
        v273 = v17;
        v19 = (const char *)sub_473493((int)&unk_488B84);
        v20 = sprintf(v18, v19, v16 + 14, v259);
        v279 = v20;
        if ( v18 )
        {
          if ( v20 )
            ((void (__cdecl *)(_DWORD *, char *, int))v7[27])(v7, v18, v20);
        }
      }
    }
    v266 = (const char *)sub_473493((int)&unk_488B9C);
    v21 = sub_47315E();
    v21[6] = 0;
    v21[7] = 0;
    v21[8] = 0;
    v274 = v21;
    v265 = *(_DWORD *)(a1 + 172) != 0;
    if ( *(_DWORD *)(a1 + 168) )
      v265 |= 2u;
    if ( *(_DWORD *)(a1 + 160) )
      v265 |= 4u;
    do
    {
      v22 = ::Block;
      if ( !::Block )
      {
        v22 = sub_47315E();
        v22[6] = 0;
        v22[7] = 0;
        v22[8] = 0;
        ::Block = v22;
      }
      v23 = ((int (__cdecl *)(_DWORD))v22[2])(*v22);
      v24 = v22[6];
      if ( v24 )
      {
        v25 = v22[8];
        v26 = *(_BYTE *)(v25 + v24);
        v21 = v274;
        if ( v25 == v22[7] - 1 )
        {
          v27 = v23 ^ v26;
          v22[8] = 0;
        }
        else
        {
          v22[8] = v25 + 1;
          v27 = v23 ^ v26;
        }
        v284 = v23 ^ v26;
      }
      else
      {
        v284 = v23;
        v27 = v23;
      }
    }
    while ( (v27 & 0xFF000000) == 1006632960
         || (v27 & 0xFF0000) == 3932160
         || (v27 & 0xFF00) == 15360
         || (_BYTE)v27 == 60 );
    ((void (__cdecl *)(int, _DWORD))v21[1])(v27, *v21);
    v28 = sub_445F90(1024);
    v29 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
    v263 = 5;
    v29(v28, &v263, 4);
    v30 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
    v263 = *(_DWORD *)(a1 + 96);
    v30(v28, &v263, 4);
    if ( *(_DWORD *)(a1 + 88) )
    {
      v31 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
      v263 = 1;
      v31(v28, &v263, 4);
    }
    v32 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
    v263 = v265;
    v32(v28, &v263, 4);
    v33 = *(_DWORD *)(a1 + 196);
    v263 = 0;
    ((void (__cdecl *)(_DWORD *, int *, int))v28[27])(v28, &v263, 4);
    if ( v33 )
    {
      v34 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
      v263 = 16;
      v34(v28, &v263, 4);
      ((void (__cdecl *)(_DWORD *, int, int))v28[27])(v28, v33, 16);
    }
    else
    {
      v35 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
      v263 = 0;
      v35(v28, &v263, 4);
    }
    if ( *(_DWORD *)(a1 + 104) )
    {
      if ( !*(_DWORD *)(a1 + 108) )
      {
        v263 = -1834523451;
LABEL_51:
        ((void (__cdecl *)(_DWORD *, int *, int))v28[27])(v28, &v263, 4);
        v38 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
        v263 = *(_DWORD *)(a1 + 32);
        v38(v28, &v263, 4);
        v39 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
        v263 = 6;
        v39(v28, &v263, 4);
        v40 = *(_DWORD *)(a1 + 104);
        if ( v40 )
          v41 = strlen(*(const char **)(a1 + 104));
        else
          v41 = 0;
        v42 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
        v263 = 1;
        v42(v28, &v263, 4);
        v43 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
        v263 = v41;
        v43(v28, &v263, 4);
        if ( v41 )
          ((void (__cdecl *)(_DWORD *, int, unsigned int))v28[27])(v28, v40, v41);
        v44 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
        v263 = 2;
        v44(v28, &v263, 4);
        v45 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
        v263 = 4;
        v45(v28, &v263, 4);
        ((void (__cdecl *)(_DWORD *, int, int))v28[27])(v28, a1 + 108, 4);
        v46 = *(_DWORD *)(a1 + 112);
        if ( v46 )
          v47 = strlen(*(const char **)(a1 + 112));
        else
          v47 = 0;
        v48 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
        v263 = 3;
        v48(v28, &v263, 4);
        v49 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
        v263 = v47;
        v49(v28, &v263, 4);
        if ( v47 )
          ((void (__cdecl *)(_DWORD *, int, unsigned int))v28[27])(v28, v46, v47);
        v50 = *(_DWORD *)(a1 + 116);
        if ( v50 )
          v51 = strlen(*(const char **)(a1 + 116));
        else
          v51 = 0;
        v52 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
        v263 = 4;
        v52(v28, &v263, 4);
        v53 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
        v263 = v51;
        v53(v28, &v263, 4);
        if ( v51 )
          ((void (__cdecl *)(_DWORD *, int, unsigned int))v28[27])(v28, v50, v51);
        v54 = strlen(v266);
        v55 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
        v56 = v54;
        v263 = 5;
        v55(v28, &v263, 4);
        v57 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
        v263 = v56;
        v57(v28, &v263, 4);
        if ( v56 )
          ((void (__cdecl *)(_DWORD *, const char *, int))v28[27])(v28, v266, v56);
        v58 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
        v263 = 5;
        v58(v28, &v263, 4);
        v59 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
        v263 = 4;
        v59(v28, &v263, 4);
        ((void (__cdecl *)(_DWORD *, int, int))v28[27])(v28, a1 + 132, 4);
        v60 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
        v263 = *(_DWORD *)(a1 + 156);
        v60(v28, &v263, 4);
        sub_4418A0((int)v28, *(int **)(a1 + 64));
        sub_440B20(v284, *(_DWORD *)(a1 + 212), (int)v28);
        v61 = *(char **)(a1 + 72);
        if ( v61 )
        {
          v62 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
          v262 = *v61;
          v62(v28, &v262, 1);
          v63 = *(_DWORD **)(a1 + 72);
          v64 = *v63 <= 0;
          v265 = 0;
          if ( !v64 )
          {
            do
            {
              v65 = v63[3] + 8 * v265;
              v66 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
              v262 = *(_BYTE *)v65;
              v66(v28, &v262, 1);
              v67 = *(_DWORD *)(v65 + 4);
              if ( v67 )
                v68 = strlen(*(const char **)(v65 + 4));
              else
                v68 = 0;
              v69 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
              v263 = v68;
              v69(v28, &v263, 4);
              if ( v68 != -1 )
                ((void (__cdecl *)(_DWORD *, int, unsigned int))v28[27])(v28, v67, v68 + 1);
              v63 = *(_DWORD **)(a1 + 72);
              v64 = ++v265 < *v63;
            }
            while ( v64 );
          }
        }
        else
        {
          v70 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
          v262 = 0;
          v70(v28, &v262, 1);
        }
        v71 = *(_BYTE **)(a1 + 60);
        v275 = v71;
        if ( v71 && *(_DWORD *)v71 )
        {
          v72 = *v71;
          v266 = *(const char **)(a1 + 32);
          v73 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
          v262 = v72;
          v73(v28, &v262, 1);
          v64 = *(_DWORD *)v71 <= 0;
          v265 = 0;
          if ( !v64 )
          {
            v267 = 0;
            do
            {
              v74 = v267 + v275[3];
              v282 = strlen(*(const char **)(v74 + 4));
              v75 = strlen(*(const char **)(v74 + 8));
              v76 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
              v77 = v75;
              v262 = *(_BYTE *)v74;
              v76(v28, &v262, 1);
              v78 = (char)v266;
              v79 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
              v263 = (unsigned __int16)((unsigned __int16)v266 ^ v77);
              v79(v28, &v263, 2);
              sub_441860(v77, (int)v28, *(_DWORD *)(v74 + 8), v78);
              v80 = v282;
              v81 = (char)v266;
              v82 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
              v263 = (unsigned __int16)((unsigned __int16)v266 ^ v282);
              v82(v28, &v263, 2);
              sub_441860(v80, (int)v28, *(_DWORD *)(v74 + 4), v81);
              v267 += 12;
              v64 = ++v265 < *v275;
            }
            while ( v64 );
          }
        }
        else
        {
          v83 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
          v262 = 0;
          v83(v28, &v262, 1);
        }
        v84 = v271;
        v85 = *(char **)(v271 + 68);
        if ( v85 )
        {
          v86 = *v85;
          v87 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
          v262 = v86;
          v87(v28, &v262, 1);
          v88 = *(_DWORD **)(v84 + 68);
          v64 = *v88 <= 0;
          v265 = 0;
          if ( !v64 )
          {
            v266 = 0;
            do
            {
              v89 = &v266[v88[3]];
              v90 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
              v91 = *v89;
              v263 = (int)v89;
              v262 = v91;
              v90(v28, &v262, 1);
              v64 = *(_DWORD *)v89 <= 0;
              v282 = 0;
              if ( !v64 )
              {
                v275 = 0;
                do
                {
                  v92 = (char *)v275 + *(_DWORD *)(v263 + 12);
                  v93 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
                  v94 = *v92;
                  v288 = v92;
                  v262 = v94;
                  v93(v28, &v262, 1);
                  v64 = *(_DWORD *)v92 <= 0;
                  v286 = 0;
                  if ( !v64 )
                  {
                    do
                    {
                      v95 = *((_DWORD *)v288 + 3);
                      v96 = *(_BYTE *)(v95 + 8 * v286);
                      v97 = v95 + 8 * v286;
                      v98 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
                      v276 = v97;
                      v262 = v96;
                      v98(v28, &v262, 1);
                      switch ( *(_DWORD *)v97 )
                      {
                        case 0:
                          v99 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
                          v272 = **(_BYTE **)(v97 + 4);
                          v99(v28, &v272, 1);
                          v100 = *(int **)(v97 + 4);
                          v101 = 0;
                          if ( *v100 > 0 )
                          {
                            v267 = 0;
                            do
                            {
                              v102 = (int *)(v267 + v100[3]);
                              v103 = v102[3];
                              v268 = *v102;
                              if ( v103 )
                              {
                                v104 = 0;
                              }
                              else
                              {
                                v103 = v102[2];
                                v104 = 1;
                              }
                              v105 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
                              v262 = v104;
                              v105(v28, &v262, 1);
                              ((void (__cdecl *)(_DWORD *, int *, int))v28[27])(v28, &v268, 4);
                              v106 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
                              v268 = v103;
                              v106(v28, &v268, 4);
                              v100 = *(int **)(v97 + 4);
                              v267 += 20;
                              ++v101;
                            }
                            while ( v101 < *v100 );
                          }
                          break;
                        case 1:
                          v107 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
                          v269 = **(_BYTE **)(v97 + 4);
                          v107(v28, &v269, 1);
                          v108 = *(int **)(v97 + 4);
                          v109 = 0;
                          if ( *v108 > 0 )
                          {
                            v110 = 0;
                            do
                            {
                              ((void (__cdecl *)(_DWORD *, int, int))v28[27])(v28, v110 + v108[3], 6);
                              v108 = *(int **)(v97 + 4);
                              ++v109;
                              v110 += 6;
                            }
                            while ( v109 < *v108 );
                          }
                          break;
                        case 2:
                        case 4:
                          v111 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
                          v270 = **(_BYTE **)(v97 + 4);
                          v111(v28, &v270, 1);
                          v112 = *(_DWORD **)(v97 + 4);
                          for ( i = 0; i < *v112; ++i )
                          {
                            v114 = *(const char **)(v112[3] + 4 * i);
                            v115 = strlen(v114);
                            if ( v115 != -1 )
                              ((void (__cdecl *)(_DWORD *, const char *, unsigned int))v28[27])(v28, v114, v115 + 1);
                            v112 = *(_DWORD **)(v97 + 4);
                          }
                          break;
                        case 3:
                          v116 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
                          v264 = **(_BYTE **)(v97 + 4);
                          v116(v28, &v264, 1);
                          v117 = *(_DWORD **)(v97 + 4);
                          v64 = *v117 <= 0;
                          v268 = 0;
                          if ( !v64 )
                          {
                            v267 = 0;
                            do
                            {
                              v118 = v267 + v117[3];
                              v119 = strlen(*(const char **)(v118 + 8));
                              v120 = v271;
                              v121 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
                              j = (unsigned __int16)(v119 ^ *(_WORD *)(v271 + 32));
                              v121(v28, &j, 2);
                              v122 = *(_DWORD *)(v120 + 32);
                              v123 = 0;
                              k = *(_DWORD *)(v118 + 8);
                              for ( j = v122; v123 < v119; ++v123 )
                              {
                                v262 = *(_BYTE *)(v123 + k) ^ *((_BYTE *)&j + (v123 & 3));
                                ((void (__cdecl *)(_DWORD *, char *, int))v28[27])(v28, &v262, 1);
                              }
                              v124 = strlen(*(const char **)(v118 + 4));
                              v125 = v271;
                              v126 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
                              k = (unsigned __int16)(v124 ^ *(_WORD *)(v271 + 32));
                              v126(v28, &k, 2);
                              v127 = *(_DWORD *)(v125 + 32);
                              v128 = *(_DWORD *)(v118 + 4);
                              v129 = 0;
                              for ( k = v127; v129 < v124; ++v129 )
                              {
                                v130 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
                                v262 = *(_BYTE *)(v129 + v128) ^ *((_BYTE *)&k + (v129 & 3));
                                v130(v28, &v262, 1);
                              }
                              v117 = *(_DWORD **)(v276 + 4);
                              v267 += 12;
                              v64 = ++v268 < *v117;
                            }
                            while ( v64 );
                          }
                          break;
                        case 5:
                          break;
                        default:
                          v260 = *(_DWORD *)v97;
                          v131 = (char *)sub_473493((int)&unk_488BB4);
                          sub_444570(v131, v260);
                          break;
                      }
                      v64 = ++v286 < *(_DWORD *)v288;
                    }
                    while ( v64 );
                  }
                  v275 += 4;
                  v64 = (int)++v282 < *(_DWORD *)v263;
                }
                while ( v64 );
              }
              v88 = *(_DWORD **)(v271 + 68);
              v266 += 16;
              v64 = ++v265 < *v88;
            }
            while ( v64 );
          }
        }
        else
        {
          v132 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
          v264 = 0;
          v132(v28, &v264, 1);
        }
        v133 = (unsigned __int8 *)v273;
        if ( !v273 )
          v133 = (unsigned __int8 *)byte_47627C;
        v134 = 0;
        v135 = v279;
        v136 = 17;
        if ( v279 )
        {
          do
          {
            v137 = v135;
            if ( v135 >= 0x15B0 )
              v137 = 5552;
            v135 -= v137;
            v276 = v135;
            if ( v137 >= 16 )
            {
              v138 = (unsigned int)v137 >> 4;
              v137 += -16 * ((unsigned int)v137 >> 4);
              do
              {
                v139 = *v133 + v136;
                v140 = v139 + v134;
                v141 = v133[1] + v139;
                v142 = v141 + v140;
                v143 = v133[2] + v141;
                v144 = v143 + v142;
                v145 = v133[3] + v143;
                v146 = v145 + v144;
                v147 = v133[4] + v145;
                v148 = v147 + v146;
                v149 = v133[5] + v147;
                v150 = v149 + v148;
                v151 = v133[6] + v149;
                v152 = v151 + v150;
                v153 = v133[7] + v151;
                v154 = v153 + v152;
                v155 = v133[8] + v153;
                v156 = v155 + v154;
                v157 = v133[9] + v155;
                v158 = v157 + v156;
                v159 = v133[10] + v157;
                v160 = v159 + v158;
                v161 = v133[11] + v159;
                v162 = v161 + v160;
                v163 = v133[12] + v161;
                v164 = v163 + v162;
                v165 = v133[13] + v163;
                v166 = v165 + v164;
                v167 = v133[14] + v165;
                v168 = v167 + v166;
                v136 = v133[15] + v167;
                v134 = v136 + v168;
                v133 += 16;
                --v138;
              }
              while ( v138 );
              v135 = v276;
            }
            for ( ; v137; --v137 )
            {
              v136 += *v133++;
              v134 += v136;
            }
            v136 %= 0xFFF1u;
            v134 %= 0xFFF1u;
          }
          while ( v135 );
        }
        v169 = v136 | (v134 << 16);
        v170 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
        v276 = v169;
        v170(v28, &v276, 4);
        v294[0] = *(_WORD *)v281;
        v171 = *(_DWORD *)(v271 + 24);
        v294[1] = *(_WORD *)(v271 + 20);
        v172 = *(_BYTE *)(v271 + 10);
        v295 = v171;
        LOWORD(v171) = *(_WORD *)(v271 + 11);
        v296 = v172;
        v173 = *(_BYTE *)(v271 + 13);
        v297 = v171;
        v174 = *(_DWORD *)(v271 + 28);
        v298 = v173;
        v175 = *(_DWORD *)(v271 + 32);
        v299 = v174;
        v176 = *(_DWORD *)v271;
        v300 = v175;
        v177 = *(_DWORD *)(v271 + 4);
        v301 = v176;
        LOWORD(v176) = *(_WORD *)(v271 + 8);
        v178 = (*(_BYTE *)(v271 + 76) & 1) != 0 ? 0xB7 : 0;
        v302 = v177;
        v304 = v178;
        v306 = v289 - 1023976199;
        dword_4AE2FC = v289 - 1023976199;
        v179 = Block[0];
        v303 = v176;
        v305 = 0;
        if ( !Block[0] )
          v179 = (void *)v289;
        v180 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v28[27];
        v307 = (int)v179 - 83941958;
        v180(v28, v294, 40);
        v181 = (unsigned int *)v28[1];
        v182 = *v181;
        v183 = (int *)v181[3];
        v265 = v182;
        v184 = v183;
        v292[0] = 1732584193;
        v292[1] = -271733879;
        v292[2] = -1732584194;
        v292[3] = 271733878;
        memset(v293, 0, sizeof(v293));
        if ( v182 )
        {
          for ( m = v182 >> 6; m; v184 += 16 )
          {
            --m;
            v186 = 512;
            v187 = v293;
            do
            {
              v188 = *(unsigned __int8 *)v187 + v186;
              *(_BYTE *)v187 = v188;
              v186 = v188 >> 8;
              v187 = (int *)((char *)v187 + 1);
            }
            while ( v186 );
            sub_405D00(v184, v292);
          }
        }
        sub_4446D0(8 * (v265 & 0x3F), v292, v184);
        v189 = 0;
        if ( v265 > 0 )
        {
          v190 = (int (__cdecl **)(_DWORD))v274;
          do
          {
            *((_BYTE *)v183 + v189) ^= *((_BYTE *)v292 + (v189 & 0xF));
            v191 = v190[2](*v190);
            v192 = v190[6];
            if ( v192 )
            {
              v193 = v190[8];
              v264 = *((_BYTE *)v192 + (_DWORD)v193);
              v194 = v264;
              if ( v193 == (int (__cdecl *)(_DWORD))((char *)v190[7] - 1) )
                v190[8] = 0;
              else
                v190[8] = (int (__cdecl *)(_DWORD))((char *)v193 + 1);
              v195 = v191 ^ v194;
            }
            else
            {
              v195 = v191;
            }
            *((_BYTE *)v183 + v189++) ^= v195;
          }
          while ( v189 < v265 );
        }
        for ( n = 0; n < 16; ++n )
          *((_BYTE *)v292 + n) = __ROR1__(*((_BYTE *)v292 + n), 3);
        ((void (__cdecl *)(_DWORD *, int *, int))v28[27])(v28, v292, 16);
        v197 = v271;
        v290 = *(_DWORD *)(v271 + 24);
        v198 = sub_445F90(0x8000);
        v199 = (int)v198;
        if ( *(_DWORD *)(v197 + 88) )
        {
          v200 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v198[27];
          Block[0] = (void *)413626302;
          v200(v198, Block, 4);
        }
        else
        {
          v201 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))v198[27];
          Block[0] = (void *)1738981189;
          v201(v199, Block, 4);
        }
        v202 = *(_DWORD *)(v199 + 16);
        sub_4414A0((int)Block, 24);
        (*(void (__cdecl **)(int, void **, int))(v199 + 108))(v199, Block, 24);
        v203 = *(_DWORD *)v28[1];
        dword_4AE2F0 = v203;
        sub_4415A0(v199, *(_DWORD *)(v28[1] + 12), v203);
        v279 = *(_DWORD *)(v199 + 16);
        sub_4414A0((int)Block, 8);
        (*(void (__cdecl **)(int, void **, int))(v199 + 108))(v199, Block, 8);
        if ( (*(int (__cdecl **)(int, int, int *, int))(v281 + 12))(v281, v199, &v290, v287) )
        {
          v204 = (void *)(v284 ^ (v280[4] - v277 + **(_DWORD **)(v199 + 4) + 12321) ^ 0x23958CDE);
          Block[2] = (void *)v284;
          v205 = *(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v199 + 116);
          Block[0] = v204;
          Block[1] = (void *)(((v203 ^ v284) + 203515694) ^ 0x184FF593);
          v205(v199, 0, v202);
          sub_441690(v199, (int)Block, 12);
          v206 = (const char *)(v279 - v202);
          v207 = (unsigned __int8 *)(v202 + *(_DWORD *)(*(_DWORD *)(v199 + 4) + 12));
          v208 = 0;
          v266 = v206;
          for ( ii = 17; v266; v208 %= 0xFFF1u )
          {
            v210 = (int)v266;
            if ( (unsigned int)v266 >= 0x15B0 )
              v210 = 5552;
            v266 -= v210;
            if ( v210 >= 16 )
            {
              v281 = (unsigned int)v210 >> 4;
              v210 += -16 * ((unsigned int)v210 >> 4);
              do
              {
                v211 = *v207 + ii;
                v212 = v211 + v208;
                v213 = v207[1] + v211;
                v214 = v213 + v212;
                v215 = v207[2] + v213;
                v216 = v215 + v214;
                v217 = v207[3] + v215;
                v218 = v217 + v216;
                v219 = v207[4] + v217;
                v220 = v219 + v218;
                v221 = v207[5] + v219;
                v222 = v221 + v220;
                v223 = v207[6] + v221;
                v224 = v223 + v222;
                v225 = v207[7] + v223;
                v226 = v225 + v224;
                v227 = v207[8] + v225;
                v228 = v227 + v226;
                v229 = v207[9] + v227;
                v230 = v229 + v228;
                v231 = v207[10] + v229;
                v232 = v231 + v230;
                v233 = v207[11] + v231;
                v234 = v233 + v232;
                v235 = v207[12] + v233;
                v236 = v235 + v234;
                v237 = v207[13] + v235;
                v238 = v237 + v236;
                v239 = v207[14] + v237;
                v240 = v239 + v238;
                ii = v207[15] + v239;
                v208 = ii + v240;
                v207 += 16;
                --v281;
              }
              while ( v281 );
            }
            for ( ; v210; --v210 )
            {
              ii += *v207++;
              v208 += ii;
            }
            ii %= 0xFFF1u;
          }
          v241 = (void *)(ii | (v208 << 16));
          v242 = *(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(v199 + 116);
          Block[0] = v241;
          v242(v199, 0, v279);
          sub_441690(v199, (int)Block, 4);
          if ( *(_DWORD *)(v271 + 100) )
          {
            v243 = sub_4649EF(**(_DWORD **)(v199 + 4), *(_BYTE **)(*(_DWORD *)(v199 + 4) + 12), Block);
            v244 = Block[0];
            v245 = (int)v280;
            if ( v243 )
              ((void (__cdecl *)(_DWORD *, void *, int))v280[27])(v280, Block[0], v243);
            free(v244);
          }
          else
          {
            v246 = *(_DWORD **)(v199 + 4);
            v245 = (int)v280;
            if ( *v246 )
              ((void (__cdecl *)(_DWORD *, _DWORD, _DWORD))v280[27])(v280, v246[3], *v246);
          }
          (*(void (__cdecl **)(int))(v245 + 112))(v245);
          if ( *(_DWORD *)(v245 + 40) )
            (*(void (__cdecl **)(_DWORD))(*(_DWORD *)dword_4A80FC + 16))(*(_DWORD *)(v245 + 40));
          (*(void (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 16))(v245);
        }
        else
        {
          v283 = 0;
        }
        v247 = *(_DWORD **)(v199 + 4);
        if ( v247[3] )
        {
          (*(void (__cdecl **)(_DWORD))(*(_DWORD *)dword_4A80FC + 16))(v247[3]);
          v247[3] = 0;
        }
        v247[1] = 0;
        *v247 = 0;
        (*(void (__cdecl **)(_DWORD *))(*(_DWORD *)dword_4A80FC + 16))(v247);
        (*(void (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 16))(v199);
        v248 = (_DWORD *)v28[1];
        if ( v248[3] )
        {
          (*(void (__cdecl **)(_DWORD))(*(_DWORD *)dword_4A80FC + 16))(v248[3]);
          v248[3] = 0;
        }
        v248[1] = 0;
        *v248 = 0;
        (*(void (__cdecl **)(_DWORD *))(*(_DWORD *)dword_4A80FC + 16))(v248);
        (*(void (__cdecl **)(_DWORD *))(*(_DWORD *)dword_4A80FC + 16))(v28);
        v249 = (void **)v274;
        (*((void (__cdecl **)(_DWORD))v274 + 5))(*(_DWORD *)v274);
        free(*v249);
        free(v249);
        if ( v273 )
          free(v273);
        return v283;
      }
    }
    else
    {
      v36 = *(_DWORD **)(a1 + 68);
      if ( v36 )
      {
        v37 = 7 * (dword_4A4F44 + 13 * *v36);
LABEL_50:
        v263 = v37;
        goto LABEL_51;
      }
    }
    v37 = dword_4A4F44;
    goto LABEL_50;
  }
  if ( dword_4AE2A4 )
    v250 = sub_473493((int)&unk_488BD0);
  else
    v250 = sub_473493((int)&unk_488BFC);
  v251 = (const char *)v250;
  v252 = sub_441010();
  sub_4079D0(v251, *(_DWORD *)(a1 + 52), v252);
  return 0;
}
// 441D82: conditional instruction was optimized away because eax.4!=0
// 441990: too many cbuild loops
// 4419B2: variable 'v1' is possibly undefined
// 4A4F44: using guessed type int dword_4A4F44;
// 4AE2A4: using guessed type int dword_4AE2A4;
// 4AE2F0: using guessed type int dword_4AE2F0;
// 4AE2FC: using guessed type int dword_4AE2FC;

//----- (00442DF0) --------------------------------------------------------
FILE *__usercall sub_442DF0@<eax>(const char *a1@<eax>, int a2, int a3, int a4)
{
  int *v4; // edi
  FILE *result; // eax
  FILE *v6; // ebp
  int v7; // edx
  int v8; // eax
  int v9; // ecx
  int v10; // ecx
  int v11; // eax
  int v12; // esi
  int v13; // ebx
  _DWORD **v14; // edx
  unsigned int v15; // eax
  int v16; // ebx
  int v17; // eax
  int v18; // edx
  int v19; // esi
  int v20; // ebp
  _DWORD **v21; // ecx
  unsigned int v22; // eax
  bool v23; // zf
  const char *v24; // eax
  int v25; // [esp-1Ch] [ebp-3Ch]
  int v26; // [esp-18h] [ebp-38h]
  int v27; // [esp-10h] [ebp-30h]
  int v28; // [esp+8h] [ebp-18h]
  int *v29; // [esp+Ch] [ebp-14h]
  int v30; // [esp+10h] [ebp-10h]
  int v31; // [esp+14h] [ebp-Ch]
  int v32; // [esp+18h] [ebp-8h]
  int v33; // [esp+18h] [ebp-8h]
  FILE *v34; // [esp+1Ch] [ebp-4h]

  v4 = (int *)a3;
  result = fopen(a1, "a");
  v6 = result;
  v7 = 0;
  v34 = result;
  if ( result )
  {
    v8 = 0;
    v9 = 0;
    v28 = 0;
    if ( a3 )
    {
      v10 = *(_DWORD *)(**(_DWORD **)(a3 + 36) + 20);
      v11 = *(_DWORD *)(a3 + 20);
      v12 = 0;
      v13 = 0;
      if ( v11 >= 2 )
      {
        v14 = *(_DWORD ***)(a3 + 32);
        v15 = ((unsigned int)(v11 - 2) >> 1) + 1;
        v28 = 2 * v15;
        v32 = 2 * v15;
        do
        {
          v12 += *(_DWORD *)(**v14 + 20);
          v13 += *(_DWORD *)(*v14[1] + 20);
          v14 += 2;
          --v15;
        }
        while ( v15 );
        v7 = v32;
        v6 = v34;
      }
      if ( v7 < *(_DWORD *)(a3 + 20) )
      {
        v10 += *(_DWORD *)(**(_DWORD **)(*(_DWORD *)(a3 + 32) + 4 * v7) + 20);
        ++v28;
      }
      v8 = *(_DWORD *)(a3 + 4);
      v9 = v12 + v13 + v10;
      v31 = v9;
      v30 = v8;
      if ( v8 > 0 )
      {
        v29 = *(int **)(a3 + 16);
        v33 = *(_DWORD *)(a3 + 4);
        do
        {
          v16 = *v29;
          v17 = *(_DWORD *)(*v29 + 20);
          v18 = 0;
          v19 = 0;
          v20 = 0;
          if ( v17 >= 2 )
          {
            v21 = *(_DWORD ***)(v16 + 32);
            v22 = ((unsigned int)(v17 - 2) >> 1) + 1;
            v28 += 2 * v22;
            v20 = 2 * v22;
            do
            {
              v18 += *(_DWORD *)(**v21 + 20);
              v19 += *(_DWORD *)(*v21[1] + 20);
              v21 += 2;
              --v22;
            }
            while ( v22 );
            v4 = (int *)a3;
            v9 = v31;
          }
          if ( v20 < *(_DWORD *)(v16 + 20) )
          {
            v9 += *(_DWORD *)(**(_DWORD **)(*(_DWORD *)(v16 + 32) + 4 * v20) + 20);
            ++v28;
          }
          ++v29;
          v9 += v18 + v19;
          v23 = v33-- == 1;
          v31 = v9;
        }
        while ( !v23 );
        v8 = v30;
        v6 = v34;
      }
    }
    v27 = v9;
    v26 = v8;
    if ( a2 == -1 )
    {
      v25 = *v4;
      v24 = (const char *)sub_473493((int)&unk_488C4C);
    }
    else
    {
      v25 = a2;
      v24 = (const char *)sub_473493((int)&unk_488C64);
    }
    fprintf(v6, v24, v25, v26, v28, v27, v4 != 0, a4);
    return (FILE *)fclose(v6);
  }
  return result;
}

//----- (00442F90) --------------------------------------------------------
int __cdecl sub_442F90(int a1, int a2)
{
  char *v2; // eax
  char v3; // al
  const char *v4; // eax
  _DWORD *v5; // esi
  _DWORD *v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // edi
  int v12[55]; // [esp+18h] [ebp-E0h] BYREF

  if ( dword_4A9D08 )
    sub_443320();
  v2 = *(char **)(a1 + 4);
  if ( !v2 )
    return 0;
  v3 = *v2;
  if ( v3 == 45 )
    return 0;
  if ( v3 == 104 )
  {
    v4 = (const char *)sub_473493((int)&unk_488C7C);
    if ( !strncmp(*(const char **)(a1 + 4), v4, 7u) )
      return 0;
  }
  dword_4AAEA4 = *(_DWORD *)(a1 + 4);
  qmemcpy(v12, &unk_4A7BF0, 0xD8u);
  v5 = sub_441210((char *)dword_4AAEA4);
  ++*((_DWORD *)dword_4A80FC + 3);
  v6 = dword_4A80FC;
  if ( *((_DWORD *)dword_4A80FC + 3) == *((_DWORD *)dword_4A80FC + 1) )
  {
    sub_4732D9();
    v6 = dword_4A80FC;
  }
  *(_DWORD *)(v6[2] + 4 * v6[3]) = &unk_4A4FF0;
  *(_DWORD *)dword_4A80FC = *(_DWORD *)(*((_DWORD *)dword_4A80FC + 2) + 4 * *((_DWORD *)dword_4A80FC + 3));
  if ( dword_4A7BE0 == dword_4A7BE4 )
  {
    v7 = dword_4A7BE8 + dword_4A7BE4;
    dword_4A7BE4 += dword_4A7BE8;
    if ( dword_4A7BEC )
      v8 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(dword_4A7BEC, 4 * v7);
    else
      v8 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(4 * v7);
    dword_4A7BEC = v8;
  }
  v9 = dword_4A7BE0;
  *(_DWORD *)(dword_4A7BEC + 4 * dword_4A7BE0) = v5;
  dword_4A7BE0 = v9 + 1;
  --*((_DWORD *)dword_4A80FC + 3);
  *(_DWORD *)dword_4A80FC = *(_DWORD *)(*((_DWORD *)dword_4A80FC + 2) + 4 * *((_DWORD *)dword_4A80FC + 3));
  dword_4AAEAC = v12[23];
  v10 = dword_4A7BCC(a1, a2);
  if ( v12[20] && *(_BYTE *)v12[20] )
    sub_442DF0((const char *)v12[20], v12[21], v10 != 0 ? (unsigned int)v5 : 0, 0);
  if ( v10 )
  {
    if ( !sub_441990((int)v12) )
      v10 = 0;
  }
  --dword_4A7BE0;
  sub_441340((int)v5);
  return v10;
}
// 4A7BCC: using guessed type int (__cdecl *dword_4A7BCC)(_DWORD, _DWORD);
// 4A7BE0: using guessed type int dword_4A7BE0;
// 4A7BE4: using guessed type int dword_4A7BE4;
// 4A7BE8: using guessed type int dword_4A7BE8;
// 4A7BEC: using guessed type int dword_4A7BEC;
// 4A9D08: using guessed type int dword_4A9D08;
// 4AAEA4: using guessed type int dword_4AAEA4;
// 4AAEAC: using guessed type int dword_4AAEAC;

//----- (00443190) --------------------------------------------------------
void sub_443190()
{
  _DWORD *v0; // eax
  void *v1; // eax

  if ( !dword_4A9D00 && dword_4A9CFC )
  {
    ++*((_DWORD *)dword_4A80FC + 3);
    v0 = dword_4A80FC;
    if ( *((_DWORD *)dword_4A80FC + 3) == *((_DWORD *)dword_4A80FC + 1) )
    {
      sub_4732D9();
      v0 = dword_4A80FC;
    }
    *(_DWORD *)(v0[2] + 4 * v0[3]) = &unk_4A4FF0;
    *(_DWORD *)dword_4A80FC = *(_DWORD *)(*((_DWORD *)dword_4A80FC + 2) + 4 * *((_DWORD *)dword_4A80FC + 3));
    if ( dword_4A7BDC )
    {
      (*(void (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 16))(dword_4A7BDC);
      dword_4A7BDC = 0;
    }
    dword_4A7BD4 = 0;
    dword_4A7BD0 = 0;
    sub_4462C0();
    --*((_DWORD *)dword_4A80FC + 3);
    *(_DWORD *)dword_4A80FC = *(_DWORD *)(*((_DWORD *)dword_4A80FC + 2) + 4 * *((_DWORD *)dword_4A80FC + 3));
    v1 = dword_4A80FC;
    if ( dword_4A80FC )
    {
      if ( *((_DWORD *)dword_4A80FC + 2) )
      {
        off_4A4FEC(*((_DWORD *)dword_4A80FC + 2));
        v1 = dword_4A80FC;
      }
      off_4A4FEC(v1);
      dword_4A80FC = 0;
    }
  }
}
// 4A4FEC: using guessed type int (__cdecl *off_4A4FEC)(_DWORD);
// 4A7BD0: using guessed type int dword_4A7BD0;
// 4A7BD4: using guessed type int dword_4A7BD4;
// 4A7BDC: using guessed type int dword_4A7BDC;
// 4A9CFC: using guessed type int dword_4A9CFC;
// 4A9D00: using guessed type int dword_4A9D00;

//----- (00443270) --------------------------------------------------------
int (__cdecl *sub_443270())(_DWORD, _DWORD)
{
  int (__cdecl *result)(_DWORD, _DWORD); // eax

  if ( !dword_4A9D00 )
  {
    if ( !dword_4A9CFC )
      sub_441080();
    result = zend_compile_file;
    dword_4A7BCC = zend_compile_file;
    zend_compile_file = sub_442F90;
    dword_4A9D08 = 1;
  }
  return result;
}
// 4A7BCC: using guessed type int (__cdecl *dword_4A7BCC)(_DWORD, _DWORD);
// 4A9CFC: using guessed type int dword_4A9CFC;
// 4A9D00: using guessed type int dword_4A9D00;
// 4A9D08: using guessed type int dword_4A9D08;
// 4AAFBC: using guessed type int (__cdecl *zend_compile_file)(_DWORD, _DWORD);

//----- (004432B0) --------------------------------------------------------
void *sub_4432B0()
{
  _DWORD *v0; // eax
  char *v1; // eax
  void *result; // eax

  if ( !dword_4A9D00 )
  {
    zend_compile_file = dword_4A7BCC;
    dword_4A7BCC = 0;
  }
  v0 = dword_4A80FC;
  if ( *((_DWORD *)dword_4A80FC + 3) != 1 )
  {
    v1 = (char *)sub_473493((int)&unk_488C88);
    sub_444570(v1);
    *((_DWORD *)dword_4A80FC + 3) = 0;
    v0 = dword_4A80FC;
  }
  --v0[3];
  result = dword_4A80FC;
  *(_DWORD *)dword_4A80FC = *(_DWORD *)(*((_DWORD *)dword_4A80FC + 2) + 4 * *((_DWORD *)dword_4A80FC + 3));
  return result;
}
// 4A7BCC: using guessed type int (__cdecl *dword_4A7BCC)(_DWORD, _DWORD);
// 4A9D00: using guessed type int dword_4A9D00;
// 4AAFBC: using guessed type int (__cdecl *zend_compile_file)(_DWORD, _DWORD);

//----- (00443320) --------------------------------------------------------
void sub_443320()
{
  _DWORD *v0; // eax

  if ( dword_4A9D08 )
  {
    *((_DWORD *)dword_4A80FC + 3) = 0;
    ++*((_DWORD *)dword_4A80FC + 3);
    v0 = dword_4A80FC;
    if ( *((_DWORD *)dword_4A80FC + 3) == *((_DWORD *)dword_4A80FC + 1) )
    {
      *((_DWORD *)dword_4A80FC + 1) += 32;
      *((_DWORD *)dword_4A80FC + 2) = off_4A4FE8(*((_DWORD *)dword_4A80FC + 2), 4 * *((_DWORD *)dword_4A80FC + 1));
      v0 = dword_4A80FC;
    }
    *(_DWORD *)(v0[2] + 4 * v0[3]) = &unk_494708;
    *(_DWORD *)dword_4A80FC = *(_DWORD *)(*((_DWORD *)dword_4A80FC + 2) + 4 * *((_DWORD *)dword_4A80FC + 3));
    dword_4A7BD0 = 0;
    dword_4A9D08 = 0;
  }
}
// 4A4FE8: using guessed type int (__cdecl *off_4A4FE8)(_DWORD, _DWORD);
// 4A7BD0: using guessed type int dword_4A7BD0;
// 4A9D08: using guessed type int dword_4A9D08;

//----- (004433B0) --------------------------------------------------------
void __cdecl sub_4433B0(_DWORD *a1)
{
  void *v1; // ebp
  const char *v2; // ebx
  _BYTE *v3; // eax
  int v4; // edi
  int v5; // esi
  const char *v6; // ebx
  int *v7; // eax
  int *v8; // esi
  _BYTE *v9; // eax
  size_t v10; // ecx
  const char *v11; // eax
  _BYTE *v12; // eax
  size_t v13; // edi
  _DWORD *v14; // edi
  int v15; // eax
  int v16; // eax
  int v17; // ecx
  int v18; // eax
  int v19; // edx
  int v20; // edx
  int v21; // edi
  int v22; // esi
  _DWORD *v23; // ebx
  bool v24; // zf
  char *v25; // edi
  const char **v26; // eax
  _DWORD *v27; // eax
  int v28; // ecx
  unsigned int v29; // eax
  char *v30; // edi
  const char *i; // esi
  int v32; // ecx
  int v33; // ecx
  int v34; // eax
  int v35; // ecx
  int v36; // eax
  int v37; // edx
  int v38; // eax
  char *v39; // edi
  int *v40; // esi
  const char **v41; // eax
  _BYTE *v42; // eax
  size_t v43; // ecx
  const char *v44; // eax
  _BYTE *v45; // eax
  size_t v46; // esi
  int v47; // esi
  int v48; // edi
  int v49; // eax
  int v50; // edi
  char *v51; // ebx
  int *v52; // edi
  const char **v53; // eax
  _BYTE *v54; // eax
  size_t v55; // ecx
  char *v56; // esi
  size_t v57; // edi
  _BYTE *v58; // eax
  size_t v59; // ecx
  void *v60; // edi
  int *v61; // eax
  int *v62; // esi
  void *v63; // eax
  _DWORD *v64; // edi
  int v65; // eax
  int v66; // eax
  int v67; // ecx
  int v68; // eax
  char *v69; // ebx
  int *v70; // edi
  const char **v71; // eax
  int *v72; // eax
  unsigned int v73; // ecx
  size_t v74; // ecx
  _DWORD *v75; // esi
  int v76; // eax
  int v77; // eax
  int v78; // ecx
  int v79; // eax
  const char *v80; // ecx
  int *v81; // edx
  _DWORD *v82; // [esp-Ch] [ebp-64h]
  const char *v83; // [esp-Ch] [ebp-64h]
  _BYTE *v84; // [esp-Ch] [ebp-64h]
  const char *v85; // [esp-Ch] [ebp-64h]
  int v86; // [esp-8h] [ebp-60h]
  int v87; // [esp+Ch] [ebp-4Ch] BYREF
  _DWORD *v88; // [esp+10h] [ebp-48h] BYREF
  void *v89; // [esp+14h] [ebp-44h] BYREF
  size_t v90; // [esp+18h] [ebp-40h] BYREF
  int v91; // [esp+1Ch] [ebp-3Ch] BYREF
  char *v92; // [esp+20h] [ebp-38h]
  void *v93; // [esp+24h] [ebp-34h]
  size_t Size; // [esp+28h] [ebp-30h] BYREF
  int v95; // [esp+2Ch] [ebp-2Ch]
  size_t v96; // [esp+30h] [ebp-28h] BYREF
  int v97; // [esp+34h] [ebp-24h] BYREF
  unsigned int v98; // [esp+38h] [ebp-20h]
  const char *v99; // [esp+3Ch] [ebp-1Ch]
  void *Src; // [esp+40h] [ebp-18h] BYREF
  _DWORD *v101; // [esp+44h] [ebp-14h]
  void *v102; // [esp+48h] [ebp-10h] BYREF
  int v103; // [esp+4Ch] [ebp-Ch] BYREF
  void *Block; // [esp+50h] [ebp-8h] BYREF
  char *String1; // [esp+54h] [ebp-4h]

  v101 = *(_DWORD **)(dword_4A7BEC + 4 * dword_4A7BE0 - 4);
  sub_445500((int)&unk_4A7BF0, (int *)&Block, (int)(v101 + 10));
  v1 = Block;
  if ( !dword_4A7BE0 || *(_BYTE *)a1 != 2 )
    goto LABEL_110;
  v2 = (const char *)a1[2];
  if ( dword_4AB2F4 )
  {
    if ( !v2 || !sub_4453E0(v2, *((int **)Block + 7)) )
      goto LABEL_10;
  }
  else if ( !v2 || !sub_4453E0(v2, *((int **)Block + 5)) )
  {
    goto LABEL_10;
  }
  *((_BYTE *)v1 + 10) = 0;
LABEL_10:
  sub_446F10(a1);
  sub_447300(a1);
  sub_447540((int)a1);
  sub_4470C0(a1);
  sub_447720((int)a1);
  sub_447720((int)a1);
  sub_446F10(a1);
  sub_444DE0((int)a1, (int)v1);
  v3 = (_BYTE *)a1[2];
  if ( !v3 || !*v3 )
  {
    v101[9] = sub_445700((int)a1, 0, (int)v1);
    v4 = dword_4AB370;
    v95 = dword_4AB370;
    zend_hash_internal_pointer_reset_ex((_DWORD *)dword_4AB370, &v88);
    if ( !zend_hash_get_current_data_ex(v4, &v87, (int *)&v88) )
    {
      while ( 1 )
      {
        v5 = v87;
        v6 = *(const char **)(v87 + 8);
        zend_hash_get_current_key_ex(v4, &Src, &Size, 0, 0, &v88);
        if ( *((_BYTE *)v1 + 9) && v6 && !sub_4453E0(v6, *((int **)v1 + 5)) )
          v7 = sub_445700(v5, 0, (int)v1);
        else
          v7 = sub_445700(v5, v6, (int)v1);
        v8 = v7;
        if ( *((_BYTE *)v1 + 9) && v6 && !sub_4453E0(v6, *((int **)v1 + 5)) )
        {
          v9 = Src;
          v10 = Size;
          *((_BYTE *)v1 + 13) = 13;
          if ( *v9 )
          {
            v11 = sub_4448D0(v10 - 1, (int)v1, v9);
            v8[7] = (int)v11;
            v8[8] = strlen(v11) + 1;
          }
          else
          {
            v12 = sub_4448D0(v10, (int)v1, v9);
            v8[7] = (int)v12;
            v8[8] = strlen(v12 + 1);
          }
        }
        else
        {
          v13 = Size;
          v8[7] = (int)estrndup(Src, Size);
          v8[8] = v13;
        }
        v14 = v101;
        v15 = v101[6];
        if ( v101[5] == v15 )
        {
          v16 = v101[7] + v15;
          v17 = v101[8];
          v101[6] = v16;
          if ( v17 )
            v18 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v17, 4 * v16);
          else
            v18 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(4 * v16);
          v14[8] = v18;
        }
        *(_DWORD *)(v14[8] + 4 * v14[5]) = v8;
        v19 = v95;
        ++v14[5];
        zend_hash_move_forward_ex(v19, (int)&v88);
        if ( zend_hash_get_current_data_ex(v20, &v87, (int *)&v88) )
          break;
        v4 = v95;
      }
    }
    v21 = dword_4AB374;
    v95 = dword_4AB374;
    zend_hash_internal_pointer_reset_ex((_DWORD *)dword_4AB374, &v88);
    if ( !zend_hash_get_current_data_ex(v21, &v91, (int *)&v88) )
    {
      do
      {
        v22 = v91;
        if ( *(_BYTE *)v91 != 1 )
        {
          String1 = (char *)estrdup(*(const char **)(v91 + 4));
          zend_hash_get_current_key_ex(v21, &v102, &v96, 0, 0, &v88);
          v23 = (_DWORD *)(*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(48);
          *v23 = v22;
          v24 = *((_BYTE *)v1 + 11) == 0;
          Block = v23;
          if ( v24
            || (v25 = *(char **)(v22 + 4), Src = (void *)*((_DWORD *)v1 + 6), !_stricmp(v25, "self"))
            || !_stricmp(v25, "parent")
            || (v26 = sub_445360((int *)Src, v25)) != 0 && v26[1] )
          {
            v27 = estrdup(*(const char **)(*v23 + 4));
            v28 = *v23;
            v23[1] = v27;
            v92 = (char *)estrdup(*(const char **)(v28 + 4));
            v29 = strlen(v92);
            v30 = v92;
            for ( i = &v92[v29]; v30 < i; ++v30 )
              *v30 = tolower(*v30);
          }
          else
          {
            *((_BYTE *)v1 + 13) = 127;
            *(_DWORD *)(v22 + 4) = sub_444A00(*(const char **)(v22 + 4), (int)v1);
            v23[1] = estrdup(*(const char **)(*v23 + 4));
            v92 = (char *)estrdup(*(const char **)(*v23 + 4));
          }
          v86 = v91 + 24;
          v23[5] = 0;
          v23[6] = zend_hash_num_elements(v86);
          if ( zend_hash_num_elements(v32) )
            v34 = zend_hash_num_elements(v33);
          else
            v34 = 32;
          v23[7] = v34;
          if ( zend_hash_num_elements(v33) )
          {
            v36 = zend_hash_num_elements(v35);
            v38 = (*(int (__cdecl **)(int))(v37 + 8))(4 * v36);
          }
          else
          {
            v38 = 0;
          }
          v23[8] = v38;
          if ( !*((_BYTE *)v1 + 11)
            || (v39 = *(char **)(v91 + 4), v40 = (int *)*((_DWORD *)v1 + 6), !_stricmp(v39, "self"))
            || !_stricmp(v39, "parent")
            || (v41 = sub_445360(v40, v39)) != 0 && v41[1] )
          {
            v46 = v96;
            v23[2] = estrndup(v102, v96);
            v23[3] = v46;
          }
          else
          {
            v42 = v102;
            v43 = v96;
            *((_BYTE *)v1 + 13) = 127;
            if ( *v42 )
            {
              v44 = sub_4448D0(v43 - 1, (int)v1, v42);
              v23[2] = v44;
              v23[3] = strlen(v44) + 1;
            }
            else
            {
              v45 = sub_4448D0(v43, (int)v1, v42);
              v23[2] = v45;
              v23[3] = strlen(v45 + 1);
            }
          }
          v47 = v91;
          v48 = v91 + 24;
          v82 = (_DWORD *)(v91 + 24);
          v23[4] = 0;
          zend_hash_internal_pointer_reset_ex(v82, &Size);
          if ( !zend_hash_get_current_data_ex(v48, &v87, (int *)&Size) )
          {
            do
            {
              zend_hash_get_current_key_ex(v48, &v89, &v90, 0, 0, (_DWORD **)&Size);
              v49 = *(_DWORD *)(v47 + 12);
              if ( v49 )
              {
                v50 = v49 + 24;
                zend_hash_internal_pointer_reset_ex((_DWORD *)(v49 + 24), &v97);
                if ( !zend_hash_get_current_data_ex(v50, &v103, &v97) )
                {
                  while ( *(_DWORD *)(v103 + 8) != *(_DWORD *)(v87 + 8) )
                  {
                    zend_hash_move_forward_ex(v50, (int)&v97);
                    if ( zend_hash_get_current_data_ex(v50, &v103, &v97) )
                      goto LABEL_63;
                  }
                  goto LABEL_102;
                }
              }
LABEL_63:
              if ( !*((_BYTE *)v1 + 11)
                || (v51 = (char *)v23[1], v52 = (int *)*((_DWORD *)v1 + 6), !_stricmp(v51, "self"))
                || !_stricmp(v51, "parent")
                || (v53 = sub_445360(v52, v51)) != 0 && v53[1] )
              {
                v57 = v90;
                v56 = (char *)estrndup(v89, v90);
                v93 = v56;
                v98 = v57;
              }
              else
              {
                v54 = v89;
                v55 = v90;
                *((_BYTE *)v1 + 13) = 127;
                if ( *v54 )
                {
                  v56 = sub_4448D0(v55 - 1, (int)v1, v54);
                  v93 = v56;
                  v98 = strlen(v56) + 1;
                }
                else
                {
                  v56 = sub_4448D0(v55, (int)v1, v89);
                  v93 = v56;
                  v98 = strlen(v56 + 1);
                }
              }
              if ( !*((_BYTE *)v1 + 12) || sub_4453E0(*(const char **)(v87 + 8), *((int **)v1 + 7)) )
              {
                v60 = (void *)v90;
                v99 = (const char *)estrndup(v89, v90);
                Src = v60;
              }
              else
              {
                v58 = v89;
                v59 = v90;
                *((_BYTE *)v1 + 13) = 127;
                if ( *v58 )
                {
                  v99 = sub_4448D0(v59 - 1, (int)v1, v58);
                  Src = (void *)(strlen(v99) + 1);
                }
                else
                {
                  v99 = sub_4448D0(v59, (int)v1, v58);
                  Src = (void *)strlen(v99 + 1);
                }
              }
              if ( !*((_BYTE *)v1 + 11) && !*((_BYTE *)v1 + 12) )
                goto LABEL_80;
              *((_BYTE *)v1 + 13) = 127;
              if ( *((_BYTE *)v1 + 11) )
              {
                v69 = String1;
                v70 = (int *)*((_DWORD *)v1 + 6);
                if ( _stricmp(String1, "self") )
                {
                  if ( _stricmp(v69, "parent") )
                  {
                    v71 = sub_445360(v70, v69);
                    if ( (!v71 || !v71[1]) && !strcmp(v92, v56) )
                    {
                      v83 = (const char *)estrdup((const char *)v93);
                      v72 = sub_445700(v87, v83, (int)v1);
LABEL_92:
                      v73 = v98;
                      v62 = v72;
                      v72[7] = (int)v93;
                      v72[8] = v73;
                      goto LABEL_82;
                    }
                  }
                }
              }
              if ( !strcmp(v92, (const char *)v89) )
              {
                v72 = sub_445700(v87, *(const char **)(v87 + 8), (int)v1);
                goto LABEL_92;
              }
              if ( *((_BYTE *)v1 + 12) && !sub_4453E0(*(const char **)(v87 + 8), *((int **)v1 + 7)) )
              {
                v74 = v90 - 1;
                v84 = v89;
                *((_BYTE *)v1 + 13) = 127;
                v85 = sub_4448D0(v74, (int)v1, v84);
                v61 = sub_445700(v87, v85, (int)v1);
              }
              else
              {
LABEL_80:
                v61 = sub_445700(v87, *(const char **)(v87 + 8), (int)v1);
              }
              v62 = v61;
              v63 = Src;
              v62[7] = (int)v99;
              v62[8] = (int)v63;
LABEL_82:
              v64 = Block;
              v65 = *((_DWORD *)Block + 6);
              if ( *((_DWORD *)Block + 5) == v65 )
              {
                v66 = *((_DWORD *)Block + 7) + v65;
                v67 = *((_DWORD *)Block + 8);
                *((_DWORD *)Block + 6) = v66;
                if ( v67 )
                  v68 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v67, 4 * v66);
                else
                  v68 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(4 * v66);
                v64[8] = v68;
              }
              v23 = Block;
              *(_DWORD *)(v64[8] + 4 * v64[5]++) = v62;
              v47 = v91;
LABEL_102:
              v48 = v47 + 24;
              zend_hash_move_forward_ex(v47 + 24, (int)&Size);
            }
            while ( !zend_hash_get_current_data_ex(v47 + 24, &v87, (int *)&Size) );
          }
          v75 = v101;
          v76 = v101[2];
          if ( v101[1] == v76 )
          {
            v77 = v101[3] + v76;
            v78 = v101[4];
            v101[2] = v77;
            if ( v78 )
              v79 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v78, 4 * v77);
            else
              v79 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(4 * v77);
            v75[4] = v79;
          }
          v80 = v92;
          *(_DWORD *)(v75[4] + 4 * v75[1]++) = v23;
          efree((int)v80);
          v21 = v95;
        }
        zend_hash_move_forward_ex(v21, (int)&v88);
      }
      while ( !zend_hash_get_current_data_ex(v21, &v91, v81) );
    }
  }
LABEL_110:
  free(v1);
}
// 4435F4: variable 'v20' is possibly undefined
// 44376F: variable 'v32' is possibly undefined
// 44377C: variable 'v33' is possibly undefined
// 4437A4: variable 'v35' is possibly undefined
// 4437AE: variable 'v37' is possibly undefined
// 443CFC: variable 'v81' is possibly undefined
// 4A7BE0: using guessed type int dword_4A7BE0;
// 4A7BEC: using guessed type int dword_4A7BEC;
// 4AB2F4: using guessed type int dword_4AB2F4;

//----- (00443D20) --------------------------------------------------------
int __usercall sub_443D20@<eax>(_DWORD *a1@<edx>, int a2@<ecx>, _BYTE *a3, size_t Size, int a5)
{
  int v5; // edi
  int v6; // esi
  size_t v7; // ebx
  int *v8; // ebp
  int v9; // eax
  int *v10; // esi
  int v11; // eax
  int v12; // eax
  char *v13; // esi
  int v14; // eax
  int *v16; // edi
  int v17; // eax
  int *v19; // [esp+14h] [ebp-2454h]
  int *v20; // [esp+14h] [ebp-2454h]
  int v21; // [esp+18h] [ebp-2450h] BYREF
  _DWORD *v22; // [esp+1Ch] [ebp-244Ch]
  int v23; // [esp+20h] [ebp-2448h] BYREF
  _BYTE *v24; // [esp+24h] [ebp-2444h]
  int v25[1144]; // [esp+28h] [ebp-2440h] BYREF
  unsigned int v26[1110]; // [esp+1208h] [ebp-1260h] BYREF
  char Src[128]; // [esp+2360h] [ebp-108h] BYREF
  char v28[132]; // [esp+23E0h] [ebp-88h] BYREF

  v24 = a3;
  v22 = a1;
  v5 = sub_413B30(byte_482B30);
  if ( v5 == -1 )
    return 0;
  v6 = sub_413AD0(byte_482B2C);
  if ( v6 == -1 )
    return 0;
  v7 = dword_4A8118[19 * v5];
  v21 = dword_4A8A90[25 * v6];
  if ( ((int (__cdecl *)(int *))dword_4A8134[19 * v5])(&v21) )
    return 0;
  v23 = 128;
  v8 = _errno();
  v9 = sub_413A10(v6, a2, a5, (int)v28, &v23);
  *v8 = v9;
  if ( v9 )
    return 0;
  v10 = _errno();
  v11 = sub_4139B0(byte_482B34);
  v12 = sub_413880(128, v11, (int)v25, 0);
  *v10 = v12;
  if ( v12 || sub_413530(Src, v7, (int)v25) != v7 )
    return 0;
  v13 = (char *)malloc(v7 + Size);
  memcpy(v13, Src, v7);
  v19 = _errno();
  v14 = sub_4137E0(v5, (int)Src, (int)v28, v21, 0, v26);
  *v19 = v14;
  if ( v14 )
  {
    free(v13);
    return 0;
  }
  v16 = (int *)malloc(Size + 1);
  v20 = _errno();
  v17 = sub_413640(v24, v16, Size, v26);
  *v20 = v17;
  if ( v17 )
  {
    free(v13);
    free(v16);
    return 0;
  }
  else
  {
    memcpy(&v13[v7], v16, Size);
    free(v16);
    *v22 = v13;
    return v7 + Size;
  }
}
// 4A8118: using guessed type int dword_4A8118[];
// 4A8134: using guessed type int dword_4A8134[];
// 4A8A90: using guessed type int dword_4A8A90[];
// 443D20: using guessed type unsigned int var_1260[1110];

//----- (00443F30) --------------------------------------------------------
_WORD *__cdecl sub_443F30(int a1, size_t Size)
{
  int *v2; // ecx
  int *v3; // edi
  int *v4; // eax
  int v5; // ecx
  int v6; // edx
  const char *v7; // eax
  unsigned int v8; // eax
  int v9; // ebx
  void *v10; // eax
  __int16 v11; // cx
  char v12; // dl
  int v13; // esi
  int v14; // eax
  const void *v15; // edi
  void *v16; // eax
  __int16 v17; // cx
  char v18; // dl
  int v19; // eax
  int v20; // eax
  size_t v21; // ebx
  int v23; // ebp
  int *v24; // edi
  int *v25; // ebx
  unsigned int v26; // ecx
  int v27; // eax
  int *v28; // ecx
  unsigned int v29; // eax
  int v30; // edx
  int v31; // eax
  int v32; // ecx
  int v33; // ebx
  _WORD *v34; // eax
  char v35; // cl
  _WORD *v36; // ebp
  void *v37; // edx
  size_t v38; // [esp+10h] [ebp-44h]
  int v39; // [esp+10h] [ebp-44h]
  unsigned int v40; // [esp+10h] [ebp-44h]
  void *Src; // [esp+14h] [ebp-40h] BYREF
  int v42; // [esp+18h] [ebp-3Ch]
  void *Block; // [esp+1Ch] [ebp-38h] BYREF
  int v44; // [esp+20h] [ebp-34h] BYREF
  int v45; // [esp+24h] [ebp-30h]
  int v46; // [esp+28h] [ebp-2Ch]
  int v47; // [esp+2Ch] [ebp-28h]
  int v48[4]; // [esp+30h] [ebp-24h] BYREF
  int v49; // [esp+40h] [ebp-14h]
  int v50; // [esp+44h] [ebp-10h]
  int v51; // [esp+48h] [ebp-Ch]
  int v52; // [esp+4Ch] [ebp-8h]

  v3 = v2;
  v42 = a1;
  Block = 0;
  Src = 0;
  v49 = 100808960;
  v50 = 775;
  v4 = (int *)sub_473493((int)&unk_479FEC);
  v5 = *v4;
  v6 = v4[1];
  v7 = (const char *)v3[1];
  v51 = v5;
  v52 = v6;
  if ( v7 )
  {
    v8 = strlen(v7);
    v9 = v8 + 11;
    v38 = v8;
    v10 = malloc(v8 + 11);
    v11 = v50;
    v12 = BYTE2(v50);
    v13 = (int)v10;
    v14 = v49;
    *(_DWORD *)v13 = 67766017;
    *(_DWORD *)(v13 + 4) = v14;
    *(_WORD *)(v13 + 8) = v11;
    *(_BYTE *)(v13 + 10) = v12;
    v15 = (const void *)v3[1];
    if ( v15 )
      memcpy((void *)(v13 + 11), v15, v38);
  }
  else
  {
    v9 = 15;
    v39 = *v3;
    v16 = malloc(0xFu);
    v17 = v50;
    v18 = BYTE2(v50);
    v13 = (int)v16;
    v19 = v49;
    *(_DWORD *)v13 = 67766017;
    *(_DWORD *)(v13 + 4) = v19;
    *(_WORD *)(v13 + 8) = v17;
    *(_BYTE *)(v13 + 10) = v18;
    *(_DWORD *)(v13 + 11) = v39;
  }
  v20 = sub_443D20(&Block, v13, (_BYTE *)v42, Size, v9);
  v21 = v20;
  if ( v20 )
  {
    v23 = v20 + 24;
    v24 = (int *)malloc(v20 + 24);
    memcpy(v24 + 6, Block, v21);
    v24[4] = 1;
    v25 = v24 + 4;
    v24[5] = 0;
    v44 = 1732584193;
    v45 = -271733879;
    v46 = -1732584194;
    v47 = 271733878;
    memset(v48, 0, 12);
    if ( v23 != 16 )
    {
      v26 = (unsigned int)(v23 - 16) >> 6;
      if ( v26 )
      {
        while ( 1 )
        {
          v40 = v26 - 1;
          v27 = 512;
          v28 = v48;
          do
          {
            v29 = *(unsigned __int8 *)v28 + v27;
            *(_BYTE *)v28 = v29;
            v27 = v29 >> 8;
            v28 = (int *)((char *)v28 + 1);
          }
          while ( v27 );
          sub_405D00(v25, &v44);
          v25 += 16;
          if ( !v40 )
            break;
          v26 = v40;
        }
      }
    }
    sub_4446D0(8 * (((_BYTE)v23 - 16) & 0x3F), &v44, v25);
    v30 = v45;
    v31 = v46;
    *v24 = v44;
    v32 = v47;
    v24[1] = v30;
    v24[2] = v31;
    v24[3] = v32;
    v33 = sub_4649EF(v23, v24, &Src);
    *((_BYTE *)Src + v33) = 0;
    v34 = malloc(v33 + 9);
    v35 = BYTE2(v52);
    v36 = v34;
    LOWORD(v34) = v52;
    *(_DWORD *)v36 = v51;
    v37 = Src;
    v36[2] = (_WORD)v34;
    *((_BYTE *)v36 + 6) = v35;
    *((_BYTE *)v36 + 7) = 10;
    v42 = (int)(v36 + 4);
    memcpy(v36 + 4, v37, v33);
    *(_BYTE *)(v42 + v33) = 0;
    free(v24);
    free(Block);
    free((void *)v13);
    free(Src);
    return v36;
  }
  else
  {
    free((void *)v13);
    return 0;
  }
}
// 443F52: variable 'v2' is possibly undefined

//----- (004441E0) --------------------------------------------------------
int __usercall sub_4441E0@<eax>(size_t a1@<edx>, void *Src, FILE *a3)
{
  size_t v4; // edi
  char *v5; // eax
  int *v6; // edx
  char v7; // cl
  _DWORD *v8; // esi
  char *v9; // ebp
  int v11; // esi
  char *v12; // edi
  size_t v13; // eax
  size_t v14; // eax
  int v15; // [esp+18h] [ebp-Ch] BYREF

  v4 = a1 + 4;
  v5 = (char *)sub_473493((int)&unk_488CAC);
  v6 = &v15;
  do
  {
    v7 = *v5;
    *(_BYTE *)v6 = *v5++;
    v6 = (int *)((char *)v6 + 1);
  }
  while ( v7 );
  v8 = malloc(v4);
  *v8 = v15;
  memcpy(v8 + 1, Src, a1);
  v9 = (char *)sub_443F30((int)v8, v4);
  free(v8);
  if ( !v9 )
    return 6;
  v11 = strlen(v9);
  v12 = v9;
  if ( v11 )
  {
    while ( 1 )
    {
      v13 = 0x2000;
      if ( v11 <= 0x2000 )
        v13 = v11;
      v14 = fwrite(v12, 1u, v13, a3);
      if ( !v14 || v14 == -1 )
        break;
      v11 -= v14;
      v12 += v14;
      if ( !v11 )
        goto LABEL_11;
    }
    fclose(a3);
    free(v9);
    return 5;
  }
  else
  {
LABEL_11:
    free(v9);
    return 0;
  }
}

//----- (00444310) --------------------------------------------------------
int __cdecl sub_444310(char *FileName, char *a2)
{
  char *v2; // eax
  FILE *v4; // ebx
  _off_t st_size; // esi
  _BYTE *v6; // ebp
  _BYTE *v7; // edi
  size_t v8; // eax
  FILE *v9; // eax
  FILE *v10; // esi
  char *v11; // eax
  char *v12; // eax
  int v13; // eax
  int v14; // edi
  char *v15; // eax
  char *v16; // eax
  char *v17; // [esp-4h] [ebp-3Ch]
  struct _stat32 Stat; // [esp+14h] [ebp-24h] BYREF

  if ( _stat32(FileName, &Stat) == -1 )
  {
    v17 = FileName;
    v2 = (char *)sub_473493((int)&unk_488CB4);
LABEL_3:
    sub_444630(v2, v17);
    return 4;
  }
  v4 = fopen(FileName, "rb");
  if ( !v4 )
  {
    v17 = FileName;
    v2 = (char *)sub_473493((int)&unk_4790C4);
    goto LABEL_3;
  }
  st_size = Stat.st_size;
  v6 = malloc(Stat.st_size + 1);
  v7 = v6;
  if ( st_size )
  {
    while ( 1 )
    {
      v8 = fread(v7, 1u, st_size, v4);
      if ( !v8 || v8 == -1 )
        break;
      st_size -= v8;
      v7 += v8;
      if ( !st_size )
        goto LABEL_10;
    }
    v12 = (char *)sub_473493((int)&unk_488CD4);
    sub_444630(v12, FileName);
    fclose(v4);
    free(v6);
    return 4;
  }
  else
  {
LABEL_10:
    fclose(v4);
    *v7 = 0;
    v9 = fopen(a2, "wb");
    v10 = v9;
    if ( v9 )
    {
      v13 = sub_4441E0(Stat.st_size, v6, v9);
      v14 = v13;
      if ( v13 == 5 )
      {
        v15 = (char *)sub_473493((int)&unk_488D08);
        sub_4445A0(v15, a2);
      }
      else if ( v13 == 6 )
      {
        v16 = (char *)sub_473493((int)&unk_488D1C);
        sub_4445A0(v16, a2);
      }
      free(v6);
      fclose(v10);
      return v14;
    }
    else
    {
      v11 = (char *)sub_473493((int)&unk_488CE8);
      sub_444630(v11, a2);
      free(v6);
      return 5;
    }
  }
}

//----- (00444480) --------------------------------------------------------
int __usercall sub_444480@<eax>(DWORD a1@<ebx>, int a2@<edi>, char *Format, va_list ArgList, HLOCAL Buffer)
{
  char *v5; // eax
  HLOCAL v6; // ebp
  char *v7; // esi
  const char *v8; // eax
  char *v9; // esi
  bool v10; // zf
  const char *v11; // eax
  const char *v12; // eax
  const char *v13; // eax
  FILE *v14; // eax
  const char *v16; // [esp-4h] [ebp-Ch]

  v5 = dword_4A9D0C;
  v6 = Buffer;
  if ( !dword_4A9D0C )
  {
    v5 = (char *)malloc(0x1000u);
    dword_4A9D0C = v5;
  }
  *v5 = 0;
  v7 = v5;
  if ( a2 )
  {
    v8 = (const char *)sub_473493((int)&unk_479CCC);
    v7 += sprintf(v7, v8, a2);
  }
  v9 = &v7[vsprintf(v7, Format, ArgList)];
  if ( a1 )
  {
    v10 = FormatMessageA(0x1300u, 0, a1, 0x400u, (LPSTR)&Buffer, 0, 0) == 0;
    v11 = (const char *)Buffer;
    if ( v10 )
      v11 = byte_47627C;
    v16 = v11;
    v12 = (const char *)sub_473493((int)&unk_488D34);
    v9 += sprintf(v9, v12, v16);
    LocalFree(Buffer);
  }
  if ( v6 )
  {
    v13 = (const char *)sub_473493((int)&unk_488D3C);
    v9 += sprintf(v9, v13, v6);
  }
  *v9 = 10;
  v9[1] = 0;
  v14 = (FILE *)sub_44F01A();
  return fputs(dword_4A9D0C, v14 + 1);
}

//----- (00444570) --------------------------------------------------------
int sub_444570(char *a1, ...)
{
  void *v1; // eax
  va_list va; // [esp+10h] [ebp+8h] BYREF

  va_start(va, a1);
  v1 = (void *)sub_473493((int)&unk_488D44);
  return sub_444480(0, (int)&unk_488D80, a1, va, v1);
}

//----- (004445A0) --------------------------------------------------------
int sub_4445A0(char *Format, ...)
{
  int v1; // edi
  char *v2; // eax
  char *v3; // esi
  const char *v4; // eax
  char *v5; // esi
  FILE *v6; // eax
  va_list va; // [esp+14h] [ebp+8h] BYREF

  va_start(va, Format);
  v1 = sub_473493((int)&unk_479D44);
  v2 = dword_4A9D0C;
  if ( !dword_4A9D0C )
  {
    v2 = (char *)malloc(0x1000u);
    dword_4A9D0C = v2;
  }
  *v2 = 0;
  v3 = v2;
  if ( v1 )
  {
    v4 = (const char *)sub_473493((int)&unk_479CCC);
    v3 += sprintf(v3, v4, v1);
  }
  v5 = &v3[vsprintf(v3, Format, va)];
  *v5 = 10;
  v5[1] = 0;
  v6 = (FILE *)sub_44F01A();
  return fputs(dword_4A9D0C, v6 + 1);
}

//----- (00444630) --------------------------------------------------------
int sub_444630(char *a1, ...)
{
  DWORD LastError; // ebx
  int v2; // eax
  va_list va; // [esp+10h] [ebp+8h] BYREF

  va_start(va, a1);
  LastError = GetLastError();
  v2 = sub_473493((int)&unk_479D44);
  return sub_444480(LastError, v2, a1, va, 0);
}

//----- (00444660) --------------------------------------------------------
int sub_444660()
{
  _DWORD *v0; // esi
  int result; // eax
  int v2; // edx
  int v3; // ecx
  unsigned __int8 v4; // dl

  v0 = Block;
  if ( !Block )
  {
    v0 = sub_47315E();
    v0[6] = 0;
    v0[7] = 0;
    v0[8] = 0;
    Block = v0;
  }
  result = ((int (__cdecl *)(_DWORD))v0[2])(*v0);
  v2 = v0[6];
  if ( v2 )
  {
    v3 = v0[8];
    v4 = *(_BYTE *)(v3 + v2);
    if ( v3 == v0[7] - 1 )
      v0[8] = 0;
    else
      v0[8] = v3 + 1;
    return result ^ v4;
  }
  return result;
}

//----- (004446D0) --------------------------------------------------------
int *__usercall sub_4446D0@<eax>(unsigned int a1@<edx>, _DWORD *a2@<ecx>, int *Src)
{
  int *result; // eax
  char *v5; // ebp
  unsigned int v6; // ecx
  _BYTE *i; // esi
  unsigned int v8; // ecx
  signed int v9; // esi
  char v10; // bl
  unsigned int v11; // edi
  char v12; // cl
  char v13; // dl
  char v14; // al
  char v15; // cl
  char v16; // al
  char v17; // dl
  char v18; // cl
  int v20[14]; // [esp+8h] [ebp-44h] BYREF
  char v21; // [esp+40h] [ebp-Ch]
  char v22; // [esp+41h] [ebp-Bh]
  char v23; // [esp+42h] [ebp-Ah]
  char v24; // [esp+43h] [ebp-9h]
  char v25; // [esp+44h] [ebp-8h]
  char v26; // [esp+45h] [ebp-7h]
  char v27; // [esp+46h] [ebp-6h]
  char v28; // [esp+47h] [ebp-5h]

  result = Src;
  if ( a1 || !a2[6] )
  {
    v5 = (char *)(a2 + 4);
    v6 = a1;
    for ( i = a2 + 4; v6; ++i )
    {
      v8 = (unsigned __int8)*i + v6;
      *i = v8;
      v6 = v8 >> 8;
    }
    if ( a1 == 512 )
    {
      return sub_405D00(Src, a2);
    }
    else
    {
      v9 = (a1 + 7) >> 3;
      v10 = a1 & 7;
      v11 = a1 >> 3;
      if ( v9 )
        memcpy(v20, Src, (a1 + 7) >> 3);
      if ( v9 < 64 )
        memset((char *)v20 + v9, 0, 64 - v9);
      *((_BYTE *)v20 + v11) = ((1 << (7 - v10)) | *((_BYTE *)v20 + v11)) & ~((1 << (7 - v10)) - 1);
      if ( v11 >= 0x38 )
      {
        sub_405D00(v20, a2);
        memset(v20, 0, sizeof(v20));
      }
      v12 = v5[1];
      v13 = v5[2];
      v21 = *v5;
      v14 = v5[3];
      v22 = v12;
      v15 = v5[4];
      v24 = v14;
      v16 = v5[6];
      v23 = v13;
      v17 = v5[5];
      v25 = v15;
      v18 = v5[7];
      v27 = v16;
      v26 = v17;
      v28 = v18;
      result = sub_405D00(v20, a2);
      a2[6] = 1;
    }
  }
  return result;
}

//----- (00444810) --------------------------------------------------------
int __usercall sub_444810@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>, char a3)
{
  _BYTE *v4; // esi
  int v5; // ebp
  unsigned __int8 v6; // dl
  unsigned __int8 v7; // bl
  _BYTE *v8; // eax
  char v9; // cl
  unsigned __int8 v11; // [esp+13h] [ebp-1h]

  v4 = &unk_4950D0;
  if ( a3 != 127 )
    v4 = &unk_495088;
  v5 = 5;
  do
  {
    v6 = a2[1];
    v7 = a2[2];
    v11 = (v6 >> 4) | (16 * (*a2 & 3));
    *a1 = v4[*a2 >> 2];
    v8 = a1 + 1;
    *v8++ = v4[v11];
    *v8++ = v4[(unsigned __int8)((v7 >> 6) | (4 * (v6 & 0xF)))];
    *v8 = v4[v7 & 0x3F];
    a2 += 3;
    a1 = v8 + 1;
    --v5;
  }
  while ( v5 );
  v9 = *a2 & 3;
  *a1 = v4[*a2 >> 2];
  *(_WORD *)(a1 + 1) = (unsigned __int8)v4[(unsigned __int8)(16 * v9)];
  return 32;
}

//----- (004448D0) --------------------------------------------------------
_BYTE *__usercall sub_4448D0@<eax>(size_t Size@<ecx>, int a2@<edi>, _BYTE *Src)
{
  char *v4; // ebx
  int v5; // ebp
  bool v6; // zf
  size_t v7; // ebp
  size_t i; // esi
  int v9; // eax
  int *v10; // ecx
  unsigned int v11; // eax
  _BYTE *v12; // eax
  _BYTE *v13; // esi
  void *Block; // [esp+Ch] [ebp-28h]
  int v16[4]; // [esp+14h] [ebp-20h] BYREF
  int v17[3]; // [esp+24h] [ebp-10h] BYREF

  v4 = (char *)malloc(Size + *(_DWORD *)(a2 + 4));
  Block = v4;
  memcpy(v4, Src, Size);
  if ( *(_DWORD *)(a2 + 4) )
    memcpy(&v4[Size], *(const void **)a2, *(_DWORD *)(a2 + 4));
  v5 = *(_DWORD *)(a2 + 4);
  v6 = Size + v5 == 0;
  v7 = Size + v5;
  v16[0] = 1732584193;
  v16[1] = -271733879;
  v16[2] = -1732584194;
  v16[3] = 271733878;
  memset(v17, 0, sizeof(v17));
  if ( !v6 )
  {
    for ( i = v7 >> 6; i; v4 += 64 )
    {
      --i;
      v9 = 512;
      v10 = v17;
      do
      {
        v11 = *(unsigned __int8 *)v10 + v9;
        *(_BYTE *)v10 = v11;
        v9 = v11 >> 8;
        v10 = (int *)((char *)v10 + 1);
      }
      while ( v9 );
      sub_405D00((int *)v4, v16);
    }
  }
  sub_4446D0(8 * (v7 & 0x3F), v16, (int *)v4);
  v12 = emalloc(34);
  v13 = v12;
  if ( !*Src )
    *v12++ = 0;
  *v12 = *(_BYTE *)(a2 + 13);
  sub_444810(v12 + 1, v16, *(_BYTE *)(a2 + 13));
  free(Block);
  return v13;
}

//----- (00444A00) --------------------------------------------------------
_BYTE *__usercall sub_444A00@<eax>(const char *a1@<eax>, int a2)
{
  signed int v3; // ebp
  char *v5; // eax
  char *v6; // ebx
  char *v7; // esi
  int v8; // edi
  _BYTE *v9; // esi
  signed int v10; // [esp+8h] [ebp-4h]

  v3 = strlen(a1);
  if ( !a1 )
    return 0;
  v5 = _strdup(a1);
  v6 = v5;
  if ( v3 > 0 )
  {
    v7 = v5;
    v8 = a1 - v5;
    v10 = v3;
    do
    {
      *v7 = tolower(v7[v8]);
      ++v7;
      --v10;
    }
    while ( v10 );
  }
  v9 = sub_4448D0(v3, a2, v6);
  free(v6);
  return v9;
}

//----- (00444A70) --------------------------------------------------------
char *__usercall sub_444A70@<eax>(int a1@<eax>, void *Src)
{
  size_t v3; // esi
  char *v4; // edi
  char *v5; // ebx
  char *i; // esi

  v3 = a1 + 1;
  v4 = (char *)emalloc(a1 + 1);
  memcpy(v4, Src, v3);
  v5 = &v4[a1];
  for ( i = v4; i < v5; ++i )
    *i = tolower(*i);
  return v4;
}

//----- (00444AB0) --------------------------------------------------------
char __usercall sub_444AB0@<al>(int a1@<eax>, int a2, int a3)
{
  size_t v3; // ebx
  _BYTE *v4; // esi
  const char *v6; // eax
  char *v7; // eax
  _BYTE *v9; // [esp-4h] [ebp-14h]

  v3 = *(_DWORD *)(a2 + 4);
  v4 = *(_BYTE **)a2;
  if ( !*(_DWORD *)a2
    || (LOBYTE(v6) = *v4, *v4 != 13) && ((_BYTE)v6 || v4[1] != 13) && (_BYTE)v6 != 127 && ((_BYTE)v6 || v4[1] != 127) )
  {
    v9 = *(_BYTE **)a2;
    if ( a3 )
    {
      v7 = sub_444A70(v3, v9);
      v6 = sub_4448D0(v3, a1, v7);
    }
    else
    {
      v6 = sub_4448D0(v3, a1, v9);
    }
    if ( *v4 )
    {
      *(_DWORD *)a2 = v6;
      *(_DWORD *)(a2 + 4) = strlen(v6);
    }
    else
    {
      *(_DWORD *)a2 = v6;
      *(_DWORD *)(a2 + 4) = strlen(v6 + 1);
    }
  }
  return (char)v6;
}

//----- (00444B50) --------------------------------------------------------
_BYTE *__cdecl sub_444B50(int a1, int a2, int a3)
{
  int v3; // ecx
  _BYTE *result; // eax
  int v5; // edi
  size_t v6; // eax
  int v7; // ebx
  int v8; // esi
  int *v9; // edx
  bool v10; // [esp+7h] [ebp-11h]
  int v11; // [esp+8h] [ebp-10h] BYREF
  _BYTE *v12; // [esp+Ch] [ebp-Ch] BYREF
  int v13; // [esp+10h] [ebp-8h]
  int v14; // [esp+14h] [ebp-4h]

  v3 = a3;
  result = (_BYTE *)a1;
  v5 = *(_DWORD *)(a1 + 20);
  v10 = *(_DWORD *)(a3 + 16) == 0;
  for ( *(_BYTE *)(a2 + 13) = 127; v5; v12 = 0 )
  {
    if ( v10 && *(_DWORD *)(a1 + 16) == v5 )
      *(_DWORD *)(v3 + 16) = 0;
    v6 = *(_DWORD *)(v5 + 4);
    if ( v6 )
      zend_hash_quick_add_or_update(v3, (char *)(v5 + 32), v6, *(_DWORD *)v5, *(_DWORD **)(v5 + 8), 4u, &v11, 1);
    else
      zend_hash_index_update_or_next_insert(v3, *(_DWORD *)v5, *(_DWORD **)(v5 + 8), 4u, &v11, 1);
    v7 = *(_DWORD *)v11;
    v8 = (*(int (__thiscall **)(void *, int))(*(_DWORD *)dword_4A80FC + 8))(dword_4A80FC, 16);
    *(_DWORD *)v8 = 0;
    *(_DWORD *)(v8 + 4) = 0;
    *(_DWORD *)(v8 + 8) = 0;
    *(_DWORD *)(v8 + 12) = 0;
    *(_BYTE *)(v8 + 8) = 3;
    *(_WORD *)(v8 + 10) = 1;
    v14 = 64;
    v13 = 0;
    v12 = (_BYTE *)(*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(65);
    *v12 = 0;
    sub_4404B0(v7, &v12, a2);
    if ( v8 != -4 )
      *(_DWORD *)(v8 + 4) = v13;
    result = v12;
    v9 = (int *)v11;
    v3 = a3;
    *(_DWORD *)v8 = v12;
    *v9 = v8;
    v5 = *(_DWORD *)(v5 + 16);
  }
  if ( !*(_DWORD *)(v3 + 16) )
  {
    result = *(_BYTE **)(v3 + 20);
    *(_DWORD *)(v3 + 16) = result;
  }
  return result;
}

//----- (00444C80) --------------------------------------------------------
void __cdecl sub_444C80(int a1, const char **a2, _DWORD *a3)
{
  char *v3; // eax
  char *v4; // edi
  unsigned int v5; // ebx
  char *v6; // esi
  char *v7; // edi
  unsigned int v8; // kr00_4
  char *v9; // eax
  const char *v10; // [esp+4h] [ebp-4h]

  if ( a1 )
  {
    if ( *(_BYTE *)(a1 + 11) )
    {
      v3 = strchr(*a2, 58);
      v4 = v3;
      if ( v3 )
      {
        v5 = v3 - *a2;
        v6 = (char *)(*(int (__cdecl **)(unsigned int))(*(_DWORD *)dword_4A80FC + 8))(v5 + 1);
        v10 = v4 + 2;
        strncpy(v6, *a2, v5);
        v6[v5] = 0;
        zend_str_tolower(v6, v5);
        if ( sub_4453A0(*(int **)(a1 + 24), v6) )
        {
          v7 = _strdup(v6);
        }
        else
        {
          *(_BYTE *)(a1 + 13) = 127;
          v7 = sub_4448D0(v5, a1, v6);
          v5 = strlen(v7);
        }
        v8 = strlen(v10);
        v9 = (char *)(*(int (__cdecl **)(unsigned int))(*(_DWORD *)dword_4A80FC + 8))(v8 + v5 + 3);
        strcpy(v9, v7);
        strcat(v9, "::");
        strcat(v9, v10);
        *a3 = v8 + v5 + 2;
        *a2 = v9;
        (*(void (__cdecl **)(char *))(*(_DWORD *)dword_4A80FC + 16))(v6);
      }
    }
  }
}

//----- (00444DE0) --------------------------------------------------------
void *__cdecl sub_444DE0(int a1, int a2)
{
  _DWORD *v2; // eax
  int v3; // edi
  _BYTE *v4; // eax
  _BYTE *v5; // esi
  int v6; // ebx
  char *v7; // ebx
  char v8; // al
  const char *v9; // eax
  const char *v10; // ebx
  int v11; // esi
  int *v12; // edi
  const char *v13; // ebx
  int v14; // esi
  char *v15; // edi
  char *v16; // edi
  char *v17; // esi
  const char *v18; // esi
  unsigned int v19; // edi
  void *result; // eax
  _BYTE *v21; // [esp+8h] [ebp-14h]
  const char *v22; // [esp+Ch] [ebp-10h]
  unsigned int v23; // [esp+10h] [ebp-Ch]
  _BYTE *v24; // [esp+14h] [ebp-8h]
  char *v25; // [esp+18h] [ebp-4h]

  ++*((_DWORD *)dword_4A80FC + 3);
  v2 = dword_4A80FC;
  v3 = a1;
  if ( *((_DWORD *)dword_4A80FC + 3) == *((_DWORD *)dword_4A80FC + 1) )
  {
    *((_DWORD *)dword_4A80FC + 1) += 32;
    *((_DWORD *)dword_4A80FC + 2) = off_4A4FE8(*((_DWORD *)dword_4A80FC + 2), 4 * *((_DWORD *)dword_4A80FC + 1));
    v2 = dword_4A80FC;
  }
  *(_DWORD *)(v2[2] + 4 * v2[3]) = &unk_494708;
  *(_DWORD *)dword_4A80FC = *(_DWORD *)(*((_DWORD *)dword_4A80FC + 2) + 4 * *((_DWORD *)dword_4A80FC + 3));
  v4 = *(_BYTE **)(a1 + 16);
  v24 = v4;
  if ( v4 != &v4[88 * *(_DWORD *)(a1 + 20)] )
  {
    v5 = v4 + 44;
    v21 = v4 + 44;
    while ( 1 )
    {
      switch ( *v4 )
      {
        case ';':
          if ( *(_BYTE *)(a2 + 9)
            && !*((_DWORD *)v5 + 9)
            && *((_DWORD *)v5 + 3) == 1
            && !sub_4453E0(*((const char **)v5 + 5), *(int **)(a2 + 20)) )
          {
            *(_BYTE *)(a2 + 13) = 13;
            sub_444AB0(a2, (int)(v5 + 20), 1);
          }
          if ( (v5[36] & 1) != 0 )
          {
            if ( *((_DWORD *)v5 - 3) == 1 )
            {
              if ( *(_BYTE *)(a2 + 11) && !sub_4453A0(*(int **)(a2 + 24), *((char **)v21 - 1)) )
              {
                *(_BYTE *)(a2 + 13) = 127;
                sub_444AB0(a2, (int)(v21 - 4), 1);
              }
              if ( *(_BYTE *)(a2 + 12)
                && *((_DWORD *)v21 + 3) == 1
                && !sub_4453E0(*((const char **)v21 + 5), *(int **)(a2 + 28)) )
              {
                *(_BYTE *)(a2 + 13) = 127;
                sub_444AB0(a2, (int)(v21 + 20), 1);
              }
            }
            else if ( *(_BYTE *)(a2 + 12) )
            {
              if ( *((_DWORD *)v5 + 3) == 1 )
              {
                v12 = *(int **)(a2 + 28);
                *(_BYTE *)(a2 + 13) = 127;
                v13 = (const char *)*((_DWORD *)v5 + 5);
                v14 = (int)(v5 + 20);
                if ( !sub_4453E0(v13, v12) )
                  sub_444AB0(a2, v14, 1);
              }
            }
          }
          goto LABEL_64;
        case '<':
          if ( *(_BYTE *)(a2 + 9) )
          {
            if ( *((_DWORD *)v5 - 3) == 1 )
            {
              v10 = (const char *)*((_DWORD *)v5 - 1);
              v11 = (int)(v5 - 4);
              if ( !sub_4453E0(v10, *(int **)(a2 + 20)) )
              {
                *(_BYTE *)(a2 + 13) = 13;
                sub_444AB0(a2, v11, 0);
              }
            }
          }
          goto LABEL_64;
        case '=':
          if ( *(_BYTE *)(a2 + 9)
            && *((_DWORD *)v5 - 3) == 1
            && !sub_4453E0(*((const char **)v5 - 1), *(int **)(a2 + 20)) )
          {
            *((_DWORD *)v5 - 3) = 8;
          }
          goto LABEL_64;
        case 'D':
          if ( *(_BYTE *)(a2 + 11)
            && *((_DWORD *)v5 - 3) == 1
            && v5[4] == 3
            && !sub_4453A0(*(int **)(a2 + 24), *((char **)v21 - 1)) )
          {
            *(_BYTE *)(a2 + 13) = 127;
            sub_444AB0(a2, (int)(v21 - 4), 1);
          }
          goto LABEL_64;
        case 'J':
        case 'P':
        case 'S':
        case 'V':
        case 'Y':
        case '\\':
        case '_':
          v6 = *((_DWORD *)v5 + 5);
          if ( *(_BYTE *)(a2 + 10)
            && *(_DWORD *)(v3 + 8)
            && *((_DWORD *)v5 - 3) == 1
            && strcmp(*((const char **)v5 - 1), (const char *)sub_473493((int)&unk_488D84))
            && strcmp(*((const char **)v5 - 1), (const char *)sub_473493((int)&unk_4873C8))
            && v6 == 1 )
          {
            *(_BYTE *)(a2 + 13) = 13;
            v7 = (char *)*((_DWORD *)v5 - 1);
            if ( !v7 || (v8 = *v7, *v7 != 13) && (v8 || v7[1] != 13) && v8 != 127 && (v8 || v7[1] != 127) )
            {
              v9 = sub_4448D0(*(_DWORD *)v5, a2, *((_BYTE **)v5 - 1));
              if ( *v7 )
              {
                *((_DWORD *)v5 - 1) = v9;
                *(_DWORD *)v5 = strlen(v9);
              }
              else
              {
                *((_DWORD *)v5 - 1) = v9;
                *(_DWORD *)v5 = strlen(v9 + 1);
              }
            }
          }
          goto LABEL_64;
        case 'd':
          if ( *(_BYTE *)(a2 + 9)
            && *((_DWORD *)v5 + 9) == 2
            && !sub_4453E0(*((const char **)v5 + 5), *(int **)(a2 + 20)) )
          {
            goto LABEL_59;
          }
          if ( *(_BYTE *)(a2 + 11) )
          {
            if ( *((_DWORD *)v5 + 9) != 1 || (v5 = v21, sub_4453A0(*(int **)(a2 + 24), *((char **)v21 + 5))) )
            {
              if ( *(_BYTE *)(a2 + 11) )
              {
                if ( *((_DWORD *)v5 + 9) == 3 )
                {
                  v15 = strchr(*((const char **)v5 + 5), 58);
                  *(_BYTE *)(a2 + 13) = 127;
                  sub_444AB0(a2, (int)(v5 - 4), 0);
                  if ( v15 )
                  {
                    v16 = v15 + 1;
                    v17 = &v16[-*((_DWORD *)v21 + 5)];
                    v22 = sub_4448D0(strlen(v16), a2, v16);
                    v18 = sub_4448D0((size_t)(v17 - 1), a2, *((_BYTE **)v21 + 5));
                    v23 = strlen(v22);
                    v19 = strlen(v18);
                    v25 = (char *)emalloc(v19 + v23 + 2);
                    sprintf(v25, "%s:%s", v18, v22);
                    efree((int)v22);
                    efree((int)v18);
                    *((_DWORD *)v21 + 5) = v25;
                    *((_DWORD *)v21 + 6) = v19 + v23 + 1;
                  }
                }
              }
            }
            else
            {
LABEL_59:
              *(_BYTE *)(a2 + 13) = *((_DWORD *)v5 + 9) != 1 ? 13 : 127;
              sub_444AB0(a2, (int)(v5 - 4), 0);
              sub_444AB0(a2, (int)(v5 + 20), 1);
            }
          }
LABEL_64:
          v3 = a1;
          v4 = v24 + 88;
          v5 = v21 + 88;
          v24 = v4;
          v21 += 88;
          if ( v4 == (_BYTE *)(*(_DWORD *)(a1 + 16) + 88 * *(_DWORD *)(a1 + 20)) )
            goto LABEL_65;
          break;
        default:
          goto LABEL_64;
      }
    }
  }
LABEL_65:
  --*((_DWORD *)dword_4A80FC + 3);
  result = dword_4A80FC;
  *(_DWORD *)dword_4A80FC = *(_DWORD *)(*((_DWORD *)dword_4A80FC + 2) + 4 * *((_DWORD *)dword_4A80FC + 3));
  return result;
}
// 4A4FE8: using guessed type int (__cdecl *off_4A4FE8)(_DWORD, _DWORD);

//----- (00445360) --------------------------------------------------------
const char **__usercall sub_445360@<eax>(int *a1@<edi>, char *String2)
{
  int v2; // esi
  const char **v3; // ebx

  if ( !String2 )
    return 0;
  if ( !a1 )
    return 0;
  v2 = 0;
  if ( *a1 <= 0 )
    return 0;
  while ( 1 )
  {
    v3 = *(const char ***)(a1[3] + 4 * v2);
    if ( !_stricmp(*v3, String2) )
      break;
    if ( ++v2 >= *a1 )
      return 0;
  }
  return v3;
}

//----- (004453A0) --------------------------------------------------------
BOOL __usercall sub_4453A0@<eax>(int *a1@<edi>, char *a2@<esi>)
{
  BOOL result; // eax
  const char **v3; // eax

  result = 1;
  if ( _stricmp(a2, "self") )
  {
    if ( _stricmp(a2, "parent") )
    {
      v3 = sub_445360(a1, a2);
      if ( !v3 || !v3[1] )
        return 0;
    }
  }
  return result;
}

//----- (004453E0) --------------------------------------------------------
int __usercall sub_4453E0@<eax>(const char *a1@<ebx>, int *a2@<edi>)
{
  char *v2; // eax
  char *v3; // edx
  char v4; // cl
  const char *v6; // eax
  char *v7; // eax
  int v8; // esi
  char String1[1024]; // [esp+0h] [ebp-404h] BYREF

  if ( !a1 || !a2 )
    return 0;
  v2 = (char *)sub_473493((int)&unk_488D9C);
  v3 = String1;
  do
  {
    v4 = *v2;
    *v3++ = *v2++;
  }
  while ( v4 );
  if ( !_stricmp(String1, a1) )
    return 1;
  v6 = (const char *)sub_473493((int)&unk_488DAC);
  v7 = strstr(a1, v6);
  if ( !v7 || strlen(v7) != strlen((const char *)sub_473493((int)&unk_488DAC)) )
  {
    v8 = 0;
    if ( *a2 <= 0 )
      return 0;
    while ( _stricmp(*(const char **)(a2[3] + 4 * v8), a1) )
    {
      if ( ++v8 >= *a2 )
        return 0;
    }
  }
  return 1;
}

//----- (00445500) --------------------------------------------------------
int __usercall sub_445500@<eax>(int a1@<edi>, int *a2@<esi>, int a3)
{
  _DWORD *v3; // eax
  int result; // eax

  v3 = malloc(0x20u);
  *a2 = (int)v3;
  *v3 = *(_DWORD *)(a1 + 196);
  if ( *(_DWORD *)(a1 + 196) )
    *(_DWORD *)(*a2 + 4) = 16;
  else
    *(_DWORD *)(*a2 + 4) = 0;
  *(_BYTE *)(*a2 + 8) = *(_BYTE *)(a1 + 176);
  *(_BYTE *)(*a2 + 9) = *(_BYTE *)(a1 + 168);
  *(_BYTE *)(*a2 + 10) = *(_BYTE *)(a1 + 172);
  *(_BYTE *)(*a2 + 11) = *(_BYTE *)(a1 + 160);
  *(_BYTE *)(*a2 + 12) = *(_BYTE *)(a1 + 164);
  *(_DWORD *)(*a2 + 20) = *(_DWORD *)(a1 + 200);
  *(_DWORD *)(*a2 + 24) = *(_DWORD *)(a1 + 204);
  *(_DWORD *)(*a2 + 28) = *(_DWORD *)(a1 + 208);
  *(_BYTE *)(*a2 + 13) = 13;
  result = *a2;
  *(_DWORD *)(*a2 + 16) = a3;
  return result;
}

//----- (004455A0) --------------------------------------------------------
int __usercall sub_4455A0@<eax>(const char *a1@<ebx>, int a2@<edi>)
{
  unsigned int v2; // esi
  void (__cdecl *v3)(int, unsigned int *, int); // ecx
  int result; // eax
  unsigned int v5; // [esp+4h] [ebp-4h] BYREF

  if ( a1 )
    v2 = strlen(a1);
  else
    v2 = 0;
  v3 = *(void (__cdecl **)(int, unsigned int *, int))(a2 + 108);
  v5 = v2;
  v3(a2, &v5, 4);
  result = v2 + 1;
  if ( v2 != -1 )
    return (*(int (__cdecl **)(int, const char *, unsigned int))(a2 + 108))(a2, a1, v2 + 1);
  return result;
}

//----- (004455F0) --------------------------------------------------------
void *__usercall sub_4455F0@<eax>(int *a1@<esi>, int a2)
{
  signed int v2; // edi
  int v3; // ecx
  int v4; // ebx
  void *result; // eax

  v2 = 12 * *(_DWORD *)(a2 + 36);
  if ( a1[11] - a1[12] < v2 )
  {
    v3 = a1[12];
    if ( a1[11] - v3 < v2 )
    {
      v4 = v2 + v3 + (a1[11] >> 1);
      a1[14] = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(a1[14], v4);
      a1[11] = v4;
    }
  }
  result = memcpy((void *)(a1[12] + a1[14]), *(const void **)(a2 + 32), v2);
  if ( a2 != -32 )
  {
    result = (void *)a1[12];
    *(_DWORD *)(a2 + 32) = result;
  }
  a1[12] += v2;
  return result;
}

//----- (00445670) --------------------------------------------------------
unsigned int __usercall sub_445670@<eax>(unsigned int result@<eax>, int a2@<ecx>, int a3, int a4)
{
  unsigned int v4; // ecx
  unsigned int v5; // esi
  unsigned int v6; // ecx
  unsigned int v7; // ebp

  v4 = result + 88 * a2;
  if ( result < v4 )
  {
    v5 = result + 50;
    v6 = v4 - result - 1;
    result = -1171354717 * v6;
    v7 = v6 / 0x58 + 1;
    do
    {
      if ( *(_DWORD *)(v5 - 18) == 1 )
      {
        *(_BYTE *)(v5 - 1) = 1;
        *(_WORD *)v5 = 2;
        result = sub_4468A0((int *)(a3 + 44), v5 - 10, a4);
      }
      if ( *(_DWORD *)(v5 + 6) == 1 )
      {
        *(_BYTE *)(v5 + 23) = 1;
        *(_WORD *)(v5 + 24) = 2;
        result = sub_4468A0((int *)(a3 + 44), v5 + 14, a4);
      }
      v5 += 88;
      --v7;
    }
    while ( v7 );
  }
  return result;
}

//----- (00445700) --------------------------------------------------------
int *__cdecl sub_445700(int a1, const char *Src, int a3)
{
  int *v3; // ebp
  int v4; // ebx
  _DWORD *v5; // eax
  int v6; // ebx
  int v8; // eax
  int v9; // edx
  signed int v10; // esi
  int v11; // ecx
  signed int v12; // esi
  int v13; // ecx
  int v14; // edi
  char *v16; // [esp+Ch] [ebp-8h]
  const char *v17; // [esp+10h] [ebp-4h]
  int v18; // [esp+18h] [ebp+4h]
  void *Srca; // [esp+1Ch] [ebp+8h]
  void *Srcb; // [esp+1Ch] [ebp+8h]

  v17 = 0;
  v3 = (int *)(*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(64);
  memset(v3, 0, 0x40u);
  if ( *(_DWORD *)(a1 + 8) )
    v3[10] = (int)estrdup(*(const char **)(a1 + 8));
  v3[11] = 1024;
  v3[12] = 0;
  v3[13] = 0;
  v3[14] = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(1024);
  if ( *(_DWORD *)(a1 + 48) )
    v4 = zend_hash_num_elements(*(_DWORD *)(a1 + 48));
  else
    v4 = 0;
  v5 = emalloc(40);
  v3[6] = (int)v5;
  zend_hash_init((int)v5, v4, 0, 0, 0);
  v6 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(84);
  memset((void *)v6, 0, 0x54u);
  qmemcpy((void *)v6, (const void *)a1, 0x54u);
  *v3 = v6;
  *(_DWORD *)(v6 + 48) = 0;
  v18 = *(_DWORD *)(a1 + 20);
  v16 = (char *)(*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(88 * v18);
  memcpy(v16, *(const void **)(a1 + 16), 88 * v18);
  *(_DWORD *)(v6 + 16) = v16;
  *(_DWORD *)(v6 + 20) = v18;
  *(_DWORD *)(v6 + 24) = v18;
  v8 = *(_DWORD *)(a1 + 52);
  if ( v8 )
    *(_DWORD *)(v6 + 52) = &v16[88 * ((v8 - *(_DWORD *)(a1 + 16)) / 88)];
  *(_BYTE *)(v3[14] + v3[12]) = -64;
  v9 = v3[14];
  *(_BYTE *)(++v3[12] + v9) = -34;
  ++v3[12];
  if ( Src )
  {
    v17 = (const char *)estrdup(Src);
    *(_DWORD *)(v6 + 8) = v17;
    v10 = strlen(v17) + 1;
    if ( v3[11] - v3[12] < v10 )
    {
      v11 = v3[12];
      if ( v3[11] - v11 < v10 )
      {
        Srca = (void *)(v10 + v11 + (v3[11] >> 1));
        v3[14] = (*(int (__cdecl **)(int, void *))(*(_DWORD *)dword_4A80FC + 12))(v3[14], Srca);
        v3[11] = (int)Srca;
      }
    }
    memcpy((void *)(v3[12] + v3[14]), *(const void **)(v6 + 8), v10);
    if ( v6 != -8 )
      *(_DWORD *)(v6 + 8) = v3[12];
    v3[12] += v10;
  }
  else
  {
    *(_DWORD *)(v6 + 8) = 0;
  }
  if ( *(_DWORD *)(a1 + 4) )
  {
    v12 = **(unsigned __int8 **)(v6 + 4) + 1;
    if ( v3[11] - v3[12] < v12 )
    {
      v13 = v3[12];
      if ( v3[11] - v13 < v12 )
      {
        Srcb = (void *)(v12 + v13 + (v3[11] >> 1));
        v3[14] = (*(int (__cdecl **)(int, void *))(*(_DWORD *)dword_4A80FC + 12))(v3[14], Srcb);
        v3[11] = (int)Srcb;
      }
    }
    memcpy((void *)(v3[12] + v3[14]), *(const void **)(v6 + 4), v12);
    if ( v6 != -4 )
      *(_DWORD *)(v6 + 4) = v3[12];
    v3[12] += v12;
  }
  if ( *(_DWORD *)(v6 + 32) )
    sub_4455F0(v3, v6);
  v14 = *(_DWORD *)(a1 + 48);
  if ( v14 )
    sub_444B50(v14, a3, v3[6]);
  sub_445670((unsigned int)v16, v18, (int)v3, a3);
  v3[1] = v18;
  v3[2] = (int)v16;
  v3[7] = (int)v17;
  if ( v17 )
    v3[8] = strlen(v17) + 1;
  else
    v3[8] = 0;
  return v3;
}

//----- (004459D0) --------------------------------------------------------
BOOL __cdecl sub_4459D0(int a1, char *FileName, int a3)
{
  const char *v3; // eax
  char *v4; // edi
  _BYTE *v5; // eax
  _BYTE *v6; // edx
  char v7; // cl
  FILE *v8; // eax
  int v9; // eax
  _ino_t st_ino; // ax
  _dev_t st_dev; // ecx
  struct _stat32 Stat; // [esp+Ch] [ebp-24h] BYREF

  if ( a3 == 1 )
  {
    v3 = "wb";
  }
  else if ( a3 )
  {
    v3 = (const char *)&unk_47B08C;
    if ( a3 != 2 )
      v3 = "?";
  }
  else
  {
    v3 = "rb";
  }
  v4 = FileName;
  *(_DWORD *)(a1 + 88) = a3;
  *(_DWORD *)(a1 + 36) = 0;
  *(_WORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 12) = -1;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 68) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 76) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 84) = 0;
  if ( a3 == 1 )
    *(_DWORD *)(a1 + 12) = _open(FileName, 33538, 384);
  else
    *(_DWORD *)a1 = fopen(FileName, v3);
  v5 = (_BYTE *)(*(int (__cdecl **)(unsigned int))(*(_DWORD *)dword_4A80FC + 8))(strlen(FileName) + 1);
  v6 = v5;
  do
  {
    v7 = *v4;
    *v5++ = *v4++;
  }
  while ( v7 );
  v8 = *(FILE **)a1;
  *(_DWORD *)(a1 + 40) = v6;
  if ( v8 )
  {
    if ( !a3 )
    {
      v9 = _fileno(v8);
      _fstat32(v9, &Stat);
      st_ino = Stat.st_ino;
      st_dev = Stat.st_dev;
      *(_DWORD *)(a1 + 24) = Stat.st_size;
      *(_WORD *)(a1 + 32) = st_ino;
      *(_DWORD *)(a1 + 36) = st_dev;
    }
    if ( *(_DWORD *)a1 )
      return 1;
  }
  return *(_DWORD *)(a1 + 12) != -1;
}

//----- (00445B10) --------------------------------------------------------
size_t __cdecl sub_445B10(int a1, void *Buffer, size_t ElementCount)
{
  *(_DWORD *)(a1 + 16) += ElementCount;
  return fread(Buffer, 1u, ElementCount, *(FILE **)a1);
}

//----- (00445BA0) --------------------------------------------------------
int __cdecl sub_445BA0(int a1)
{
  char *v2; // eax
  int v3; // [esp-4h] [ebp-8h]

  if ( *(_DWORD *)a1 )
  {
    fclose(*(FILE **)a1);
    *(_DWORD *)a1 = 0;
  }
  else
  {
    if ( *(_DWORD *)(a1 + 12) == -1 )
      return 0;
    _close(*(_DWORD *)(a1 + 12));
    *(_DWORD *)(a1 + 12) = -1;
  }
  if ( *(_DWORD *)(a1 + 60) )
  {
    if ( _unlink(*(const char **)(a1 + 40)) )
    {
      v3 = *(_DWORD *)(a1 + 40);
      v2 = (char *)sub_473493((int)&unk_488DB8);
      sub_444630(v2, v3);
    }
  }
  return 1;
}

//----- (00445CD0) --------------------------------------------------------
_DWORD *sub_445CD0()
{
  _DWORD *v0; // esi

  v0 = (_DWORD *)(*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(128);
  memset(v0, 0, 0x80u);
  v0[24] = sub_4459D0;
  v0[25] = sub_445B10;
  v0[26] = sub_445B30;
  v0[27] = sub_445B60;
  v0[28] = sub_445BA0;
  v0[29] = sub_445C10;
  v0[30] = sub_445CB0;
  v0[3] = -1;
  return v0;
}
// 445B30: using guessed type int sub_445B30();
// 445B60: using guessed type int sub_445B60();
// 445C10: using guessed type int sub_445C10();
// 445CB0: using guessed type int sub_445CB0();

//----- (00445D30) --------------------------------------------------------
size_t __cdecl sub_445D30(int a1, void *a2, size_t Size)
{
  memcpy(a2, (const void *)(*(_DWORD *)(a1 + 16) + *(_DWORD *)(*(_DWORD *)(a1 + 4) + 12)), Size);
  *(_DWORD *)(a1 + 16) += Size;
  return Size;
}

//----- (00445D60) --------------------------------------------------------
int __cdecl sub_445D60(int a1, int a2)
{
  int v2; // edx
  int result; // eax

  v2 = *(_DWORD *)(a1 + 16);
  result = v2 + *(_DWORD *)(*(_DWORD *)(a1 + 4) + 12);
  *(_DWORD *)(a1 + 16) = a2 + v2;
  return result;
}

//----- (00445D80) --------------------------------------------------------
int __cdecl sub_445D80(_DWORD *a1, unsigned __int8 *Src, int Size)
{
  unsigned int v3; // ebp
  int *v4; // edi
  int v5; // eax
  int v6; // esi
  int v7; // eax
  unsigned __int8 *v8; // esi
  int result; // eax
  unsigned int v10; // edi
  unsigned int v11; // ecx
  unsigned int v12; // edi
  int v13; // eax
  unsigned int v14; // edx
  int v15; // ecx
  int v16; // edi
  int v17; // ecx
  int v18; // edi
  int v19; // ecx
  int v20; // edi
  int v21; // ecx
  int v22; // edi
  int v23; // ecx
  int v24; // edi
  int v25; // ecx
  int v26; // edi
  int v27; // ecx
  int v28; // edi
  int v29; // ecx
  int v30; // edi
  int v31; // ecx
  int v32; // edi
  int v33; // ecx
  int v34; // edi
  int v35; // ecx
  int v36; // edi
  int v37; // ecx
  int v38; // edi
  int v39; // ecx
  int v40; // edi
  int v41; // ecx
  int v42; // edi
  int v43; // ecx
  int v44; // edi

  v3 = Size;
  v4 = (int *)a1[1];
  v5 = *v4;
  v6 = Size + a1[4] - *v4;
  if ( v6 > 0 )
  {
    if ( v5 + v6 > v4[1] )
    {
      v7 = v5 + v4[2] + v6;
      v4[1] = v7;
      v4[3] = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v4[3], v7);
    }
    *v4 += v6;
  }
  v8 = Src;
  memcpy((void *)(a1[4] + v4[3]), Src, Size);
  result = Size;
  if ( a1[17] )
  {
    v10 = a1[20];
    v11 = (unsigned __int16)v10;
    v12 = HIWORD(v10);
    if ( Size )
    {
      do
      {
        v13 = v3;
        if ( v3 >= 0x15B0 )
          v13 = 5552;
        v3 -= v13;
        if ( v13 >= 16 )
        {
          v14 = (unsigned int)v13 >> 4;
          v13 += -16 * ((unsigned int)v13 >> 4);
          do
          {
            v15 = *v8 + v11;
            v16 = v15 + v12;
            v17 = v8[1] + v15;
            v18 = v17 + v16;
            v19 = v8[2] + v17;
            v20 = v19 + v18;
            v21 = v8[3] + v19;
            v22 = v21 + v20;
            v23 = v8[4] + v21;
            v24 = v23 + v22;
            v25 = v8[5] + v23;
            v26 = v25 + v24;
            v27 = v8[6] + v25;
            v28 = v27 + v26;
            v29 = v8[7] + v27;
            v30 = v29 + v28;
            v31 = v8[8] + v29;
            v32 = v31 + v30;
            v33 = v8[9] + v31;
            v34 = v33 + v32;
            v35 = v8[10] + v33;
            v36 = v35 + v34;
            v37 = v8[11] + v35;
            v38 = v37 + v36;
            v39 = v8[12] + v37;
            v40 = v39 + v38;
            v41 = v8[13] + v39;
            v42 = v41 + v40;
            v43 = v8[14] + v41;
            v44 = v43 + v42;
            v11 = v8[15] + v43;
            v12 = v11 + v44;
            v8 += 16;
            --v14;
          }
          while ( v14 );
        }
        for ( ; v13; --v13 )
        {
          v11 += *v8++;
          v12 += v11;
        }
        v11 %= 0xFFF1u;
        v12 %= 0xFFF1u;
      }
      while ( v3 );
      result = Size;
    }
    a1[18] += result;
    a1[4] += result;
    a1[20] = v11 | (v12 << 16);
  }
  else
  {
    a1[4] += Size;
  }
  return result;
}

//----- (00445F20) --------------------------------------------------------
int sub_445F20()
{
  return 1;
}

//----- (00445F30) --------------------------------------------------------
int __cdecl sub_445F30(int a1, int a2, int a3)
{
  _DWORD *v3; // esi
  int v4; // eax

  v3 = *(_DWORD **)(a1 + 4);
  if ( a2 )
  {
    if ( a2 == 1 )
      *(_DWORD *)(a1 + 16) += a3;
  }
  else
  {
    *(_DWORD *)(a1 + 16) = a3;
  }
  v4 = *(_DWORD *)(a1 + 16);
  if ( v4 > *v3 )
  {
    if ( v3[1] < v4 )
    {
      v3[1] = v4;
      v3[3] = (*(int (__cdecl **)(_DWORD, int))(*(_DWORD *)dword_4A80FC + 12))(v3[3], v4);
    }
    *v3 = *(_DWORD *)(a1 + 16);
  }
  return 1;
}

//----- (00445F90) --------------------------------------------------------
_DWORD *__usercall sub_445F90@<eax>(int a1@<ebx>)
{
  _DWORD *v1; // esi
  _DWORD *v2; // edi

  v1 = (_DWORD *)(*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(128);
  memset(v1, 0, 0x80u);
  v1[25] = sub_445D30;
  v1[26] = sub_445D60;
  v1[27] = sub_445D80;
  v1[28] = sub_445F20;
  v1[29] = sub_445F30;
  v2 = (_DWORD *)(*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(16);
  *v2 = 0;
  v2[1] = a1;
  v2[2] = a1;
  v2[3] = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(a1);
  v1[1] = v2;
  return v1;
}

//----- (00446010) --------------------------------------------------------
int __cdecl sub_446010(_DWORD **a1)
{
  _DWORD **v1; // ebp
  _DWORD *v2; // esi
  int v3; // edi
  _DWORD *v4; // eax
  int v5; // ecx
  _DWORD *v6; // ebx
  int v7; // eax
  int v9; // [esp-8h] [ebp-14h]

  v1 = a1;
  v2 = *a1;
  v3 = 1;
  if ( *a1 )
  {
    v4 = (_DWORD *)dword_4A9D14;
    do
    {
      for ( ; v3; v2 += 5 )
      {
        if ( !*v2 )
          break;
        if ( *v4 == v4[1] )
        {
          v4[1] += v4[2];
          v5 = v4[3];
          v6 = v4;
          v9 = 4 * v4[1];
          if ( v5 )
            v7 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v5, v9);
          else
            v7 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(v9);
          v6[3] = v7;
          v4 = (_DWORD *)dword_4A9D14;
        }
        *(_DWORD *)(v4[3] + 4 * (*v4)++) = v2;
        v3 &= 1u;
      }
      v2 = v1[1];
      ++v1;
    }
    while ( v2 );
  }
  return v3;
}
// 4A9D14: using guessed type int dword_4A9D14;

//----- (004460B0) --------------------------------------------------------
int __cdecl sub_4460B0(char *String2, int a2)
{
  int v2; // esi
  _DWORD *v3; // ebx
  _DWORD *v4; // edi

  v2 = 0;
  v3 = (_DWORD *)dword_4A9D14;
  if ( *(int *)dword_4A9D14 <= 0 )
    return 0;
  v4 = (_DWORD *)(dword_4A9D14 + 12);
  while ( _stricmp(*(const char **)(*(_DWORD *)(*v4 + 4 * v2) + 4), String2)
       || *(_DWORD *)(*(_DWORD *)(*v4 + 4 * v2) + 8) != a2 )
  {
    if ( ++v2 >= *v3 )
      return 0;
  }
  return *(_DWORD *)(*v4 + 4 * v2);
}
// 4A9D14: using guessed type int dword_4A9D14;

//----- (00446110) --------------------------------------------------------
int __cdecl CompareFunction(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

//----- (00446150) --------------------------------------------------------
void sub_446150()
{
  void *v0; // eax
  size_t v1; // edx
  unsigned int i; // esi
  unsigned __int8 *v3; // ecx
  char *v4; // eax
  _DWORD *v5; // edi
  unsigned __int8 *v6; // eax
  int v7; // ecx
  _BYTE *v8; // eax
  int j; // ebp
  size_t v10; // edx
  size_t v11; // edx
  unsigned int v12; // ecx
  unsigned __int8 **v13; // esi
  int v14; // eax

  if ( !dword_4A9D18 )
  {
    dword_4A9D1C = (void *)off_4A4FE4(2400);
    memset(dword_4A9D1C, 0, 0x960u);
    v0 = (void *)off_4A4FE4(4800);
    v1 = NumOfElements;
    dword_4A9D20 = v0;
    for ( i = 0; i < 0x258; ++i )
    {
      v3 = (unsigned __int8 *)*(&dword_494728 + i);
      if ( v3 )
      {
        v4 = (char *)off_4A4FE4(*v3 + 3);
        v5 = dword_4A9D1C;
        *((_DWORD *)dword_4A9D1C + i) = ++v4;
        memcpy(v4, *(&dword_494728 + i), *(unsigned __int8 *)*(&dword_494728 + i) + 2);
        v6 = (unsigned __int8 *)v5[i];
        v7 = *v6;
        v8 = v6 + 1;
        for ( j = 0; j <= v7; ++j )
          *v8++ ^= byte_4820BC[((_BYTE)v7 + (_BYTE)j) & 0xF];
        ++v5[i];
        v0 = dword_4A9D20;
        v10 = NumOfElements;
        *((_DWORD *)dword_4A9D20 + 2 * NumOfElements) = v5[i];
        *((_DWORD *)v0 + 2 * v10 + 1) = i;
        if ( *(unsigned __int8 *)*(&dword_494728 + i) + 1 > dword_4A9D28 )
          dword_4A9D28 = *(unsigned __int8 *)*(&dword_494728 + i) + 1;
        v1 = v10 + 1;
        NumOfElements = v1;
      }
    }
    qsort(v0, v1, 8u, (_CoreCrtNonSecureSearchSortCompareFunction)CompareFunction);
    memset(dword_4A7CC8, 0, 0x400u);
    v11 = NumOfElements;
    v12 = 0;
    if ( NumOfElements )
    {
      v13 = (unsigned __int8 **)dword_4A9D20;
      do
      {
        v14 = 2 * *v13[2 * v12];
        if ( !dword_4A7CC8[v14] )
          dword_4A7CC8[2 * *v13[2 * v12]] = v12;
        dword_4A7CCC[v14] = v12++;
      }
      while ( v12 < v11 );
    }
    dword_4A9D18 = 1;
  }
}
// 4A4FE4: using guessed type int (__cdecl *off_4A4FE4)(_DWORD);
// 4A7CC8: using guessed type int dword_4A7CC8[];
// 4A7CCC: using guessed type int dword_4A7CCC[255];
// 4A9D18: using guessed type int dword_4A9D18;
// 4A9D28: using guessed type int dword_4A9D28;

//----- (004462C0) --------------------------------------------------------
int sub_4462C0()
{
  size_t i; // esi

  for ( i = 0; i < NumOfElements; ++i )
    off_4A4FEC(*((_DWORD *)dword_4A9D20 + 2 * i));
  off_4A4FEC(&dword_494728);
  off_4A4FEC(dword_4A9D1C);
  return off_4A4FEC(dword_4A9D20);
}
// 4A4FEC: using guessed type int (__cdecl *off_4A4FEC)(_DWORD);

//----- (00446320) --------------------------------------------------------
int __cdecl sub_446320(const char *a1)
{
  int v1; // ecx
  int v3; // edi
  int v4; // esi
  int v5; // eax
  int v6; // ecx

  if ( *a1 >= 0x80u || v1 > dword_4A9D28 )
    return 0;
  v3 = dword_4A7CC8[2 * *(unsigned __int8 *)a1];
  if ( !v3 )
    return 0;
  v4 = dword_4A7CCC[2 * *(unsigned __int8 *)a1] + 1;
  if ( v3 >= v4 )
    return 0;
  while ( 1 )
  {
    v5 = (v4 + v3) / 2;
    v6 = strcmp(a1, *((const char **)dword_4A9D20 + 2 * v5));
    if ( !v6 )
      break;
    if ( v6 >= 0 )
      v3 = v5 + 1;
    else
      v4 = (v4 + v3) / 2;
    if ( v3 >= v4 )
      return 0;
  }
  return *((_DWORD *)dword_4A9D20 + 2 * v5 + 1);
}
// 446333: variable 'v1' is possibly undefined
// 4A7CC8: using guessed type int dword_4A7CC8[];
// 4A7CCC: using guessed type int dword_4A7CCC[255];
// 4A9D28: using guessed type int dword_4A9D28;

//----- (004463C0) --------------------------------------------------------
int __usercall sub_4463C0@<eax>(int result@<eax>, int a2@<ecx>)
{
  const char *v2; // eax
  const char *v3; // eax
  const char *v4; // eax
  double v5; // st7
  const char *v6; // eax
  const char *v7; // eax
  const char *v8; // eax
  const char *v9; // eax
  const char *v10; // eax
  const char *v11; // eax
  int v12; // [esp+8h] [ebp-8h]
  int v13; // [esp+8h] [ebp-8h]
  int v14; // [esp+8h] [ebp-8h]
  int v15; // [esp+8h] [ebp-8h]
  int v16; // [esp+8h] [ebp-8h]
  int v17; // [esp+8h] [ebp-8h]
  int v18; // [esp+8h] [ebp-8h]
  int v19; // [esp+8h] [ebp-8h]
  int v21; // [esp+Ch] [ebp-4h]

  switch ( a2 )
  {
    case 0:
      return result;
    case 1:
      v12 = *(_DWORD *)(result + 52);
      v2 = (const char *)sub_473493((int)&unk_48B048);
      sub_4078E0(v2, v12, a2);
    case 2:
      v13 = *(_DWORD *)(result + 52);
      v3 = (const char *)sub_473493((int)&unk_48B070);
      sub_4078E0(v3, v13, a2);
    case 3:
      v14 = *(_DWORD *)(result + 52);
      v4 = (const char *)sub_473493((int)&unk_48B0A4);
      sub_4078E0(v4, v14, a2);
    case 4:
      v21 = *(_DWORD *)(result + 20);
      if ( v21 <= 10 )
        v5 = (double)v21;
      else
        v5 = (double)v21 / 10.0;
      v15 = *(_DWORD *)(result + 52);
      v6 = (const char *)sub_473493((int)&unk_48B0D8);
      sub_4078E0(v6, v5, v15);
    case 5:
      v16 = *(_DWORD *)(result + 52);
      v7 = (const char *)sub_473493((int)&unk_48B130);
      sub_4078E0(v7, v16, a2);
    case 6:
      v17 = *(_DWORD *)(result + 52);
      v8 = (const char *)sub_473493((int)&unk_48B188);
      sub_4078E0(v8, 0x10000000, v17, a2);
    case 7:
      v19 = *(_DWORD *)(result + 52);
      v10 = (const char *)sub_473493((int)&unk_48B1F8);
      sub_4078E0(v10, v19, a2);
    case 8:
      v18 = *(_DWORD *)(result + 52);
      v9 = (const char *)sub_473493((int)&unk_48B1CC);
      sub_4078E0(v9, v18, a2);
    default:
      v11 = (const char *)sub_473493((int)&unk_48B228);
      sub_4078E0(v11);
  }
}

//----- (004464F0) --------------------------------------------------------
int __usercall sub_4464F0@<eax>(int a1@<edi>, int a2@<esi>)
{
  const char *v3; // eax
  int v4; // [esp-4h] [ebp-70h]
  char Buffer[12]; // [esp+0h] [ebp-6Ch] BYREF
  char v6[92]; // [esp+Ch] [ebp-60h] BYREF

  if ( sprintf(Buffer, "%i%c%x", *(_DWORD *)(a2 + 20), 58, 0) <= 0
    || sprintf(v6, "%s %-65s?>", "<?php //ICB0", Buffer) <= 0 )
  {
    v4 = *(_DWORD *)(a2 + 52);
    v3 = (const char *)sub_473493((int)&unk_48B048);
    sub_4078E0(v3, v4);
  }
  (*(void (__cdecl **)(int, char *, int))(a1 + 108))(a1, v6, 80);
  return 80;
}

//----- (00446580) --------------------------------------------------------
int __cdecl sub_446580(int a1, int a2)
{
  char *Str; // ecx
  char *v3; // esi
  char *v4; // eax
  char *v5; // ebx
  char *v7; // eax
  char *v8; // esi
  _BYTE *v9; // ebp
  int i; // edi
  int v11; // edi
  char *v12; // ebx
  int v13; // edx
  size_t v14; // ebx
  char *v15; // edi
  int v16; // ebx
  unsigned int v17; // [esp+10h] [ebp-6Ch]
  char *v18; // [esp+14h] [ebp-68h]
  char Buffer[12]; // [esp+18h] [ebp-64h] BYREF
  char Destination[12]; // [esp+24h] [ebp-58h] BYREF
  char v21[68]; // [esp+30h] [ebp-4Ch] BYREF
  char v22[4]; // [esp+74h] [ebp-8h] BYREF

  v3 = Str;
  v4 = strstr(Str, "<?php //ICB0");
  v5 = v4;
  v18 = v4;
  if ( !v4 )
    return 8;
  v17 = v3 - v4 + a2 - 80;
  if ( v17 >= 0x10000000 )
    return 6;
  strncpy(Destination, v4, 0x50u);
  v22[0] = 0;
  v7 = strrchr(Destination, 58);
  if ( !v7 )
    return 3;
  v8 = v7;
  v9 = v7 + 1;
  for ( i = v7 + 1 - Destination; i < 80; ++v9 )
  {
    if ( !isxdigit((char)*v9) )
      break;
    ++i;
  }
  v11 = v9 - Destination;
  if ( v9 - Destination == 80 )
    return 3;
  if ( v8 >= v21 )
  {
    do
    {
      if ( *v8 == 58 )
      {
        v12 = v8 - 1;
        do
          v13 = *--v8;
        while ( !isspace(v13) && isdigit(*v8) && v8 >= v21 );
        if ( !isspace(*v8) || v8 < v21 )
          return 3;
        v14 = v12 - v8;
        v15 = (char *)malloc(v14 + 1);
        strncpy(v15, v8 + 1, v14);
        v15[v14] = 0;
        v16 = atoi(v15);
        free(v15);
        if ( v16 == *(_DWORD *)(a1 + 20) )
          return 4;
        v5 = v18;
        v11 = v9 - Destination;
      }
    }
    while ( --v8 >= v21 );
  }
  if ( !v9 || *v9 != 32 )
    return 3;
  if ( v22 - v9 < 12 )
    return 5;
  if ( sprintf(Buffer, "%i%c%x", *(_DWORD *)(a1 + 20), 58, v17) < 0 )
    return 7;
  strncpy(&v5[v11 + 1], Buffer, strlen(Buffer));
  return 0;
}
// 446594: variable 'Str' is possibly undefined
// 446580: using guessed type char var_8[4];

//----- (00446800) --------------------------------------------------------
char __usercall sub_446800@<al>(int *a1@<eax>, int *a2@<edi>, int a3@<esi>, int a4)
{
  void *v5; // eax
  int v6; // ecx
  int v7; // ecx
  const char *v9; // eax
  size_t v10; // [esp-4h] [ebp-Ch]
  int v11; // [esp-4h] [ebp-Ch]
  int v12; // [esp-4h] [ebp-Ch]
  int v13; // [esp-4h] [ebp-Ch]

  if ( !(*(int (__cdecl **)(int, _DWORD, _DWORD))(a3 + 96))(a3, *(_DWORD *)(a4 + 52), 0) )
  {
    (*(void (__cdecl **)(int))(a3 + 112))(a3);
    v13 = *(_DWORD *)(a4 + 52);
    v9 = (const char *)sub_473493((int)&unk_48B070);
    sub_4078E0(v9, v13);
  }
  v10 = *(_DWORD *)(a3 + 24) + 2;
  *a2 = v10;
  v5 = malloc(v10);
  v11 = *(_DWORD *)(a3 + 24);
  *a1 = (int)v5;
  (*(void (__cdecl **)(int, void *, int))(a3 + 100))(a3, v5, v11);
  (*(void (__cdecl **)(int))(a3 + 112))(a3);
  v6 = *a1;
  *(_BYTE *)(v6 + *(_DWORD *)(a3 + 24)) = 61;
  v12 = *a2;
  *(_BYTE *)(*(_DWORD *)(a3 + 24) + v6 + 1) = 10;
  v7 = sub_446580(a4, v12);
  if ( !v7 )
    return 1;
  sub_4463C0(a4, v7);
  return 0;
}

//----- (004468A0) --------------------------------------------------------
int __usercall sub_4468A0@<eax>(int *a1@<edi>, int a2, int a3)
{
  int result; // eax
  const char *v4; // esi
  int v5; // eax
  int v6; // eax
  signed int v7; // ebx
  _BYTE *v8; // eax
  size_t v9; // ebx
  const void *v10; // ebp
  int v11; // edx
  char *v12; // eax
  int v13; // [esp-4h] [ebp-14h]
  int v14; // [esp+Ch] [ebp-4h] BYREF

  result = *(unsigned __int8 *)(a2 + 8);
  switch ( *(_BYTE *)(a2 + 8) )
  {
    case 0:
    case 1:
    case 2:
    case 5:
    case 6:
      return result;
    case 3:
    case 8:
      if ( *(_DWORD *)a2 && *(_DWORD *)(a2 + 4) )
      {
        v4 = *(const char **)a2;
        result = strcmp(*(const char **)a2, (const char *)sub_473493((int)&unk_48B284));
        if ( result )
        {
          result = strcmp(v4, (const char *)dword_4AAEA4);
          if ( result )
          {
            if ( *(int *)(a2 + 4) < 30 && (v5 = sub_446320(v4)) != 0 )
            {
              result = -v5;
              *(_DWORD *)a2 = result;
            }
            else
            {
              v6 = a1[1];
              if ( (v6 & 1) != 0 )
              {
                if ( *a1 - v6 < 1 )
                  sub_4477D0(1, a1);
                *(_BYTE *)(a1[1] + a1[3]) = *((_BYTE *)a1 + 4);
                ++a1[1];
              }
              v7 = *(_DWORD *)(a2 + 4) + 1;
              if ( *a1 - a1[1] < v7 )
                sub_4477D0(*(_DWORD *)(a2 + 4) + 1, a1);
              result = (int)memcpy((void *)(a1[1] + a1[3]), *(const void **)a2, v7);
              *(_DWORD *)a2 = a1[1];
              a1[1] += v7;
            }
          }
          else
          {
            *(_DWORD *)a2 = -1;
          }
        }
        else
        {
          *(_DWORD *)a2 = -2;
        }
      }
      break;
    case 9:
      if ( *(_DWORD *)a2 )
      {
        v8 = sub_440950(&v14, a2, a3);
        v9 = v14 + 1;
        v10 = v8;
        if ( *a1 - a1[1] < v14 + 1 )
          sub_4477D0(v14 + 1, a1);
        memcpy((void *)(a1[1] + a1[3]), v10, v9);
        result = a2;
        v11 = v14;
        *(_DWORD *)a2 = a1[1];
        a1[1] += v9;
        *(_DWORD *)(a2 + 4) = v11;
      }
      break;
    default:
      v13 = *(unsigned __int8 *)(a2 + 8);
      v12 = (char *)sub_473493((int)&unk_48B298);
      result = sub_4445A0(v12, v13);
      break;
  }
  return result;
}
// 4AAEA4: using guessed type int dword_4AAEA4;

//----- (00446A80) --------------------------------------------------------
_DWORD *__cdecl sub_446A80(int a1, int a2)
{
  return erealloc(a1, a2, 0);
}

//----- (00446AC0) --------------------------------------------------------
_DWORD *__usercall sub_446AC0@<eax>(int a1@<edi>, int a2@<esi>)
{
  _DWORD *result; // eax
  _DWORD *v3; // edx

  result = *(_DWORD **)a2;
  if ( *(_DWORD *)a2 )
  {
    if ( result == (_DWORD *)1 )
    {
      result = malloc(8u);
      *result = *(_DWORD *)(a2 + 4);
      result[1] = a1;
      ++*(_DWORD *)a2;
      *(_DWORD *)(a2 + 4) = result;
    }
    else
    {
      result = realloc(*(void **)(a2 + 4), 4 * *(_DWORD *)a2 + 4);
      v3 = *(_DWORD **)a2;
      *(_DWORD *)(a2 + 4) = result;
      result[(_DWORD)v3] = a1;
      ++*(_DWORD *)a2;
    }
  }
  else
  {
    ++*(_DWORD *)a2;
    *(_DWORD *)(a2 + 4) = a1;
  }
  return result;
}

//----- (00446B10) --------------------------------------------------------
void __usercall sub_446B10(int a1@<ebx>, void **Block)
{
  unsigned int v2; // esi
  void **v3; // edi

  v2 = 0;
  if ( *(_DWORD *)(a1 + 20) != -1 )
  {
    v3 = Block;
    do
    {
      if ( (int)*v3 >= 2 )
        free(v3[1]);
      ++v2;
      v3 += 3;
    }
    while ( v2 < *(_DWORD *)(a1 + 20) + 1 );
  }
  free(Block);
}

//----- (00446B50) --------------------------------------------------------
char *__cdecl sub_446B50(_DWORD *a1)
{
  unsigned int v1; // ebx
  unsigned int v2; // esi
  int v3; // edi
  char *result; // eax
  char *v5; // ecx
  int v6; // eax
  int v7; // esi
  char *v8; // esi
  _DWORD *v9; // eax
  int v10; // edx
  _DWORD *v11; // eax
  int v12; // esi
  int v13; // eax
  int v14; // ebp
  int v15; // ebx
  int v16; // eax
  char *v17; // esi
  _DWORD *v18; // eax
  int v19; // edx
  _DWORD *v20; // eax
  int v21; // eax
  char *v22; // esi
  _DWORD *v23; // eax
  int v24; // edx
  _DWORD *v25; // eax
  char *v26; // [esp+Ch] [ebp-14h]
  _DWORD *v27; // [esp+10h] [ebp-10h]
  char *v28; // [esp+14h] [ebp-Ch]
  int v29; // [esp+18h] [ebp-8h]
  unsigned int v30; // [esp+1Ch] [ebp-4h]

  v1 = a1[4];
  v2 = v1 + 88 * a1[5];
  v3 = 0;
  result = (char *)calloc(a1[5] + 1, 0xCu);
  v5 = result;
  v26 = result;
  if ( v1 < v2 )
  {
    v27 = (_DWORD *)(v1 + 64);
    v28 = result + 16;
    v30 = (v2 - v1 - 1) / 0x58 + 1;
    do
    {
      switch ( *((_BYTE *)v27 - 64) )
      {
        case '*':
          v6 = *(v27 - 6);
          v7 = (int)&v5[12 * v6];
          if ( v6 != v3 + 1 )
            goto LABEL_6;
          *(_DWORD *)(v7 + 8) = 1;
          break;
        case '+':
        case ',':
        case '.':
        case '/':
        case 'E':
        case 'N':
          v8 = &v5[12 * *v27];
          if ( *v27 == v3 + 1 )
          {
            *((_DWORD *)v8 + 2) = 1;
            *((_DWORD *)v28 + 1) = 1;
          }
          else
          {
            if ( *(_DWORD *)v8 )
            {
              if ( *(_DWORD *)v8 == 1 )
              {
                v11 = malloc(8u);
                *v11 = *((_DWORD *)v8 + 1);
                v11[1] = v3;
                *((_DWORD *)v8 + 1) = v11;
              }
              else
              {
                v9 = realloc(*((void **)v8 + 1), 4 * *(_DWORD *)v8 + 4);
                v10 = *(_DWORD *)v8;
                *((_DWORD *)v8 + 1) = v9;
                v9[v10] = v3;
              }
            }
            else
            {
              *((_DWORD *)v8 + 1) = v3;
            }
            ++*(_DWORD *)v8;
            v5 = v26;
            *((_DWORD *)v28 + 1) = 1;
          }
          break;
        case '-':
          v12 = (int)&v5[12 * *v27];
          if ( *v27 == v3 + 1 )
          {
            *(_DWORD *)(v12 + 8) = 1;
          }
          else
          {
            sub_446AC0(v3, v12);
            v5 = v26;
          }
          v13 = v27[4];
          v7 = (int)&v5[12 * v13];
          if ( v13 == v3 + 1 )
          {
            *(_DWORD *)(v7 + 8) = 1;
          }
          else
          {
LABEL_6:
            sub_446AC0(v3, v7);
            v5 = v26;
          }
          break;
        case '2':
        case '3':
          v29 = 0;
          if ( (int)a1[9] > 0 )
          {
            v14 = v3 + 1;
            v15 = 0;
            do
            {
              v16 = *(_DWORD *)(v15 + a1[8] + 4);
              v17 = &v5[12 * v16];
              if ( v16 == v14 )
              {
                *((_DWORD *)v17 + 2) = 1;
              }
              else
              {
                if ( *(_DWORD *)v17 )
                {
                  if ( *(_DWORD *)v17 == 1 )
                  {
                    v20 = malloc(8u);
                    *v20 = *((_DWORD *)v17 + 1);
                    v20[1] = v3;
                    *((_DWORD *)v17 + 1) = v20;
                  }
                  else
                  {
                    v18 = realloc(*((void **)v17 + 1), 4 * *(_DWORD *)v17 + 4);
                    v19 = *(_DWORD *)v17;
                    *((_DWORD *)v17 + 1) = v18;
                    v18[v19] = v3;
                  }
                }
                else
                {
                  *((_DWORD *)v17 + 1) = v3;
                }
                ++*(_DWORD *)v17;
                v5 = v26;
              }
              v21 = *(_DWORD *)(v15 + a1[8]);
              v22 = &v5[12 * v21];
              if ( v21 == v14 )
              {
                *((_DWORD *)v22 + 2) = 1;
              }
              else
              {
                if ( *(_DWORD *)v22 )
                {
                  if ( *(_DWORD *)v22 == 1 )
                  {
                    v25 = malloc(8u);
                    *v25 = *((_DWORD *)v22 + 1);
                    v25[1] = v3;
                    *((_DWORD *)v22 + 1) = v25;
                  }
                  else
                  {
                    v23 = realloc(*((void **)v22 + 1), 4 * *(_DWORD *)v22 + 4);
                    v24 = *(_DWORD *)v22;
                    *((_DWORD *)v22 + 1) = v23;
                    v23[v24] = v3;
                  }
                }
                else
                {
                  *((_DWORD *)v22 + 1) = v3;
                }
                ++*(_DWORD *)v22;
                v5 = v26;
              }
              v15 += 12;
              ++v29;
            }
            while ( v29 < a1[9] );
          }
          break;
        case '>':
          break;
        default:
          *((_DWORD *)v28 + 1) = 1;
          break;
      }
      v27 += 22;
      v28 += 12;
      ++v3;
      --v30;
    }
    while ( v30 );
    return v5;
  }
  return result;
}

//----- (00446E30) --------------------------------------------------------
int *__usercall sub_446E30@<eax>(int a1@<edx>, _DWORD *a2@<edi>)
{
  unsigned int v2; // eax
  unsigned int i; // esi
  int v4; // ecx
  int *result; // eax
  int *j; // ebx
  int v7; // ecx
  int v8; // esi
  int v9; // ecx
  int v10; // esi

  v2 = a2[4];
  for ( i = v2 + 88 * a2[5]; v2 < i; v2 += 88 )
  {
    switch ( *(_BYTE *)v2 )
    {
      case '*':
        *(_DWORD *)(v2 + 40) += *(_DWORD *)(a1 + 4 * *(_DWORD *)(v2 + 40));
        break;
      case '+':
      case ',':
      case '.':
      case '/':
      case 'E':
      case 'N':
        *(_DWORD *)(v2 + 64) += *(_DWORD *)(a1 + 4 * *(_DWORD *)(v2 + 64));
        break;
      case '-':
        v4 = *(_DWORD *)(v2 + 80);
        *(_DWORD *)(v2 + 64) += *(_DWORD *)(a1 + 4 * *(_DWORD *)(v2 + 64));
        *(_DWORD *)(v2 + 80) = v4 + *(_DWORD *)(a1 + 4 * v4);
        break;
      default:
        continue;
    }
  }
  result = (int *)a2[8];
  for ( j = &result[3 * a2[9]]; result < j; result += 3 )
  {
    v7 = *(_DWORD *)(a1 + 4 * *result) + *result;
    *result = v7;
    v8 = a2[5];
    if ( v7 >= v8 )
      *result = v8 - 1;
    v9 = *(_DWORD *)(a1 + 4 * result[1]) + result[1];
    result[1] = v9;
    v10 = a2[5];
    if ( v9 >= v10 )
      result[1] = v10 - 1;
  }
  return result;
}

//----- (00446F10) --------------------------------------------------------
void __cdecl sub_446F10(_DWORD *a1)
{
  _DWORD *v1; // ebx
  _DWORD *v2; // edi
  int v3; // ebp
  int v4; // esi
  _DWORD *v5; // edx
  int v6; // ecx
  int v7; // [esp+10h] [ebp-Ch]
  int v8; // [esp+14h] [ebp-8h]
  _DWORD *v9; // [esp+18h] [ebp-4h]

  v1 = (_DWORD *)a1[4];
  v2 = &v1[22 * a1[5]];
  v3 = 0;
  v4 = 0;
  v9 = v2;
  v7 = 0;
  v8 = 0;
  v5 = malloc(4 * a1[5]);
  if ( v1 < v2 )
  {
    do
    {
      v6 = v8;
      v5[v8] = -v4;
      switch ( *(_BYTE *)v1 )
      {
        case 0:
          goto LABEL_4;
        case 0x24:
          if ( *((_BYTE *)v1 + 88) != 70 )
            goto LABEL_8;
          *(_BYTE *)v1 = 34;
          goto LABEL_7;
        case 0x25:
          if ( *((_BYTE *)v1 + 88) != 70 )
            goto LABEL_8;
          *(_BYTE *)v1 = 35;
LABEL_7:
          v3 = 1;
          v1[5] |= 1u;
LABEL_8:
          if ( v4 )
          {
            qmemcpy(&v1[-22 * v4], v1, 0x58u);
            v4 = v7;
            v2 = v9;
            v6 = v8;
          }
          break;
        case 0x2A:
          if ( v1[10] != v8 + 1 )
            goto LABEL_8;
LABEL_4:
          v7 = ++v4;
          break;
        default:
          goto LABEL_8;
      }
      if ( v3 )
      {
        v4 += v3;
        v1 += 22 * v3;
        v6 += v3;
        v7 = v4;
        v3 = 0;
      }
      v1 += 22;
      v8 = v6 + 1;
    }
    while ( v1 < v2 );
    if ( v4 )
    {
      a1[5] -= v4;
      sub_446E30((int)v5, a1);
    }
  }
  free(v5);
}
// 446FF1: variable 'v5' is possibly undefined

//----- (00447050) --------------------------------------------------------
_DWORD *__usercall sub_447050@<eax>(_DWORD *a1@<edi>, int a2)
{
  int v2; // edx
  int v3; // ebx
  int v4; // esi
  int v5; // ecx
  _DWORD *result; // eax
  bool v7; // zf

  v2 = a1[16];
  v3 = *(unsigned __int8 *)a1;
  v4 = 1;
  while ( 1 )
  {
    v5 = *(unsigned __int8 *)(88 * v2 + a2);
    result = (_DWORD *)(a2 + 88 * v2);
    if ( v5 != 43 && v5 != 46 && v5 != 44 && v5 != 47 )
      break;
    if ( v5 != v3 )
    {
      if ( v3 == 46 )
      {
        v7 = v5 == 43;
      }
      else
      {
        if ( v3 != 47 )
          break;
        v7 = v5 == 44;
      }
      if ( !v7 )
        break;
    }
    if ( result[8] != a1[8] || result[10] != a1[10] )
      break;
    v2 = result[16];
    if ( ++v4 > 100 )
      return result;
  }
  a1[16] = v2;
  return result;
}

//----- (004470C0) --------------------------------------------------------
void __cdecl sub_4470C0(_DWORD *a1)
{
  _DWORD *v2; // edi
  _DWORD *v3; // ebx
  char *v4; // eax
  _DWORD *v5; // esi
  int v6; // ecx
  int v7; // edx
  int i; // eax
  int v9; // eax
  int v10; // edx
  _DWORD *v11; // eax
  int v12; // ecx
  int v13; // edx
  int j; // eax
  int v15; // ecx
  int v16; // edx
  int n; // eax
  int v18; // ecx
  int v19; // edx
  int k; // eax
  int v21; // ecx
  int v22; // edx
  int m; // eax
  char *v24; // [esp+Ch] [ebp-4h]
  _DWORD *v25; // [esp+14h] [ebp+4h]

  v2 = (_DWORD *)a1[4];
  v3 = &v2[22 * a1[5]];
  v4 = sub_446B50(a1);
  v24 = v4;
  if ( v2 < v3 )
  {
    v5 = v2 + 22;
    v25 = v4 + 12;
    do
    {
      switch ( *(_BYTE *)v2 )
      {
        case '*':
          v6 = *(v5 - 12);
          v7 = a1[4];
          for ( i = v7 + 88 * v6; *(_BYTE *)i == 42; i = v7 + 88 * v6 )
            v6 = *(_DWORD *)(i + 40);
          *(v5 - 12) = v6;
          v9 = a1[4] + 88 * v6;
          if ( *(_BYTE *)v9 == 62 && *(_DWORD *)(v9 + 32) == 1 && *(_BYTE *)(v9 + 48) <= 2u )
          {
            *(_BYTE *)v2 = 62;
            *(v5 - 14) = *(_DWORD *)(v9 + 32);
            *(v5 - 13) = *(_DWORD *)(v9 + 36);
            *(v5 - 12) = *(_DWORD *)(v9 + 40);
            *(v5 - 11) = *(_DWORD *)(v9 + 44);
            *(v5 - 10) = *(_DWORD *)(v9 + 48);
            v10 = *(_DWORD *)(v9 + 52);
            v11 = (_DWORD *)(v9 + 56);
            *(v5 - 9) = v10;
            *(v5 - 8) = *v11;
            *(v5 - 7) = v11[1];
            *(v5 - 6) = v11[2];
            *(v5 - 5) = v11[3];
            *(v5 - 4) = v11[4];
            *(v5 - 3) = v11[5];
          }
          break;
        case '+':
        case ',':
        case '.':
        case '/':
          v12 = *(v5 - 6);
          v13 = a1[4];
          for ( j = v13 + 88 * v12; *(_BYTE *)j == 42; j = v13 + 88 * v12 )
            v12 = *(_DWORD *)(j + 40);
          *(v5 - 6) = v12;
          sub_447050(v2, a1[4]);
          break;
        case '-':
          v18 = *(v5 - 6);
          v19 = a1[4];
          for ( k = v19 + 88 * v18; *(_BYTE *)k == 42; k = v19 + 88 * v18 )
            v18 = *(_DWORD *)(k + 40);
          *(v5 - 6) = v18;
          v21 = *(v5 - 2);
          v22 = a1[4];
          for ( m = v22 + 88 * v21; *(_BYTE *)m == 42; m = v22 + 88 * v21 )
            v21 = *(_DWORD *)(m + 40);
          *(v5 - 2) = v21;
          break;
        case '>':
          if ( v5 != v3 && *(_BYTE *)v5 == 42 && !*v25 )
          {
            *(_BYTE *)v5 = 0;
            v5[8] = 8;
            v5[14] = 8;
            v5[2] = 8;
          }
          break;
        case 'E':
        case 'N':
          v15 = *(v5 - 6);
          v16 = a1[4];
          for ( n = v16 + 88 * v15; *(_BYTE *)n == 42; n = v16 + 88 * v15 )
            v15 = *(_DWORD *)(n + 40);
          *(v5 - 6) = v15;
          break;
        default:
          break;
      }
      v25 += 3;
      v2 += 22;
      v5 += 22;
    }
    while ( v2 < v3 );
    v4 = v24;
  }
  sub_446B10((int)a1, (void **)v4);
}

//----- (00447300) --------------------------------------------------------
void __cdecl sub_447300(_DWORD *a1)
{
  _DWORD *v1; // esi
  char *v2; // ebp
  char *v3; // edi
  unsigned int v4; // ebx
  _DWORD *v5; // edx
  bool v6; // zf
  unsigned int v7; // eax
  unsigned int v8; // esi
  int v9; // ecx
  int v10; // edx
  unsigned int v11; // ecx
  unsigned int v12; // ebx
  int v13; // edi
  size_t v14; // esi
  char *v15; // ebp
  char *v16; // eax
  unsigned int v17; // ecx
  int v18; // edx
  char *v19; // edx
  const void *v20; // esi
  char *v21; // edi
  char *v22; // edi
  void *v23; // edx
  unsigned int v24; // [esp+10h] [ebp-20h]
  unsigned int v25; // [esp+14h] [ebp-1Ch]
  _DWORD *v26; // [esp+18h] [ebp-18h]
  size_t v27; // [esp+1Ch] [ebp-14h]
  int Block; // [esp+20h] [ebp-10h]
  unsigned int v29; // [esp+24h] [ebp-Ch]
  unsigned int v30; // [esp+28h] [ebp-8h]
  unsigned int v31; // [esp+28h] [ebp-8h]
  char *v32; // [esp+2Ch] [ebp-4h]

  do
  {
    v1 = a1;
    v2 = (char *)a1[4];
    v3 = &v2[88 * a1[5]];
    v32 = v3;
    v4 = 0;
    v5 = malloc(4 * a1[5]);
    v26 = v5;
    Block = 0;
    if ( v2 < v3 )
    {
      do
      {
        v6 = *v2 == 45;
        v5[v4] = 0;
        if ( v6 )
        {
          v7 = *((_DWORD *)v2 + 20);
          v8 = *((_DWORD *)v2 + 16);
          v29 = v7;
          v30 = v8;
          if ( v7 < v4 || v8 < v4 )
          {
            sub_444570("O1");
          }
          else
          {
            v9 = a1[4];
            if ( *(_BYTE *)(88 * v7 + v9 - 88) == 42 )
            {
              v10 = v9 + 88 * v8;
              if ( *(_BYTE *)(v10 - 88) == 42 )
              {
                if ( v8 > v7 )
                {
                  v11 = v4 + 1;
                  if ( *(_DWORD *)(v10 - 48) == v4 + 1 )
                  {
                    v12 = v4 + 1;
                    v13 = v7 - v11;
                    v14 = 88 * (v7 - v11);
                    *v2 = 43;
                    v15 = v2 + 88;
                    v25 = v7 - v11;
                    v27 = v14;
                    v16 = (char *)malloc(v14);
                    v17 = v30;
                    v24 = 0;
                    if ( v12 < v29 )
                    {
                      v18 = 88 * v13;
                      qmemcpy(v16, v15, 4 * ((unsigned int)(88 * v13) >> 2));
                      memset32(&v26[v12], v30 - v29 - 1, v25);
                      v13 = v25;
                      v17 = v30;
                      v15 += v18;
                      v12 += v25;
                      v24 = v25;
                    }
                    if ( v12 < v17 )
                    {
                      v19 = &v15[-88 * v24];
                      v31 = v17 - v12;
                      memset32(&v26[v12], -v24, v17 - v12);
                      v12 = v17;
                      do
                      {
                        v20 = v15;
                        v21 = v19;
                        v15 += 88;
                        v19 += 88;
                        v6 = v31-- == 1;
                        qmemcpy(v21, v20, 0x58u);
                      }
                      while ( !v6 );
                      v14 = v27;
                      v13 = v25;
                    }
                    v2 = &v15[-88 - 88 * v24];
                    v4 = -1 - v24 + v12;
                    if ( v13 > 0 )
                    {
                      v22 = v2;
                      v2 += v27;
                      v4 += v25;
                      qmemcpy(v22, v16, 4 * (v14 >> 2));
                    }
                    *v2 = 0;
                    *((_DWORD *)v2 + 8) = 8;
                    *((_DWORD *)v2 + 14) = 8;
                    *((_DWORD *)v2 + 2) = 8;
                    free(v16);
                    v3 = v32;
                    Block = 1;
                  }
                  else
                  {
                    sub_444570("O5");
                  }
                }
                else
                {
                  sub_444570("O4");
                }
              }
              else
              {
                sub_444570("O3");
              }
            }
            else
            {
              sub_444570("O2");
            }
          }
        }
        v5 = v26;
        v2 += 88;
        ++v4;
      }
      while ( v2 < v3 );
      v1 = a1;
    }
    sub_446E30((int)v5, v1);
    free(v23);
  }
  while ( Block );
}
// 447525: variable 'v23' is possibly undefined

//----- (00447540) --------------------------------------------------------
int __usercall sub_447540@<eax>(int a1@<eax>)
{
  unsigned int v1; // esi
  int result; // eax
  int v3; // edi
  int v4; // eax
  int v5; // ebx
  _DWORD *v6; // ebp
  int v7; // ebx
  _DWORD *v8; // ebp
  int v9; // ebx
  _BYTE *v10; // ebp
  int v11; // [esp+4h] [ebp-8h]
  unsigned int i; // [esp+8h] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 16);
  result = v1 + 88 * *(_DWORD *)(a1 + 20);
  for ( i = result; v1 < i; v1 += 88 * v11 )
  {
    v11 = 1;
    v3 = 88;
    do
    {
      while ( 1 )
      {
        v4 = 0;
        if ( *(_BYTE *)v1 == 55 )
        {
          if ( *(_DWORD *)(v1 + 32) != 8 && *(_BYTE *)(v3 + v1) == 55 && *(_DWORD *)(v3 + v1 + 32) != 8 )
          {
            v5 = *(_DWORD *)(v3 + v1 + 68) + *(_DWORD *)(v1 + 68);
            v6 = emalloc(v5 + 1);
            memcpy(v6, *(const void **)(v1 + 64), *(_DWORD *)(v1 + 68));
            memcpy((char *)v6 + *(_DWORD *)(v1 + 68), *(const void **)(v3 + v1 + 64), *(_DWORD *)(v3 + v1 + 68));
            *((_BYTE *)v6 + v5) = 0;
            efree(*(_DWORD *)(v1 + 64));
            *(_DWORD *)(v1 + 64) = v6;
            *(_DWORD *)(v1 + 68) = v5;
            efree(*(_DWORD *)(v3 + v1 + 64));
            *(_DWORD *)(v3 + v1 + 32) = 8;
            *(_DWORD *)(v3 + v1 + 56) = 8;
            *(_DWORD *)(v3 + v1 + 8) = 8;
            v4 = 1;
            ++v11;
            *(_BYTE *)(v3 + v1) = 0;
            v3 += 88;
          }
          if ( *(_BYTE *)v1 == 55
            && *(_DWORD *)(v1 + 32) != 8
            && *(_BYTE *)(v3 + v1) == 54
            && *(_DWORD *)(v3 + v1 + 32) != 8 )
          {
            v7 = *(_DWORD *)(v1 + 68) + 1;
            v8 = emalloc(*(_DWORD *)(v1 + 68) + 2);
            memcpy(v8, *(const void **)(v1 + 64), *(_DWORD *)(v1 + 68));
            *((_BYTE *)v8 + *(_DWORD *)(v1 + 68)) = *(_BYTE *)(v3 + v1 + 64);
            *((_BYTE *)v8 + v7) = 0;
            efree(*(_DWORD *)(v1 + 64));
            *(_DWORD *)(v1 + 64) = v8;
            *(_DWORD *)(v1 + 68) = v7;
            *(_DWORD *)(v3 + v1 + 32) = 8;
            *(_DWORD *)(v3 + v1 + 56) = 8;
            *(_DWORD *)(v3 + v1 + 8) = 8;
            v4 = 1;
            ++v11;
            *(_BYTE *)(v3 + v1) = 0;
            v3 += 88;
          }
        }
        if ( *(_BYTE *)v1 != 54
          || *(_DWORD *)(v1 + 32) == 8
          || *(_BYTE *)(v3 + v1) != 55
          || *(_DWORD *)(v3 + v1 + 32) == 8 )
        {
          break;
        }
        v9 = *(_DWORD *)(v3 + v1 + 68) + 1;
        v10 = emalloc(*(_DWORD *)(v3 + v1 + 68) + 2);
        *v10 = *(_BYTE *)(v1 + 64);
        memcpy(v10 + 1, *(const void **)(v3 + v1 + 64), *(_DWORD *)(v3 + v1 + 68));
        v10[v9] = 0;
        efree(*(_DWORD *)(v3 + v1 + 64));
        *(_DWORD *)(v3 + v1 + 64) = v10;
        *(_DWORD *)(v3 + v1 + 68) = v9;
        *(_BYTE *)v1 = 0;
        *(_DWORD *)(v1 + 32) = 8;
        *(_DWORD *)(v1 + 56) = 8;
        *(_DWORD *)(v1 + 8) = 8;
        v1 += 88;
      }
    }
    while ( v4 );
    result = 88 * v11;
  }
  return result;
}

//----- (00447720) --------------------------------------------------------
void __usercall sub_447720(int a1@<esi>)
{
  char *v1; // eax
  unsigned int v2; // ecx
  char *v3; // ebp
  int v4; // edi
  int v5; // eax
  char *v6; // edx
  unsigned int v7; // edi
  char *v8; // ebx
  _DWORD *v9; // [esp+0h] [ebp-14h]
  char *v10; // [esp+10h] [ebp-4h]

  v1 = sub_446B50(v9);
  v2 = 0;
  v3 = v1;
  v4 = 0;
  v10 = v1;
  if ( *(_DWORD *)(a1 + 20) )
  {
    v5 = 0;
    v6 = v3;
    do
    {
      if ( v2 && !*((_DWORD *)v6 + 2) )
      {
        if ( *(_DWORD *)v6 )
          goto LABEL_8;
        v4 = 1;
      }
      if ( !*(_DWORD *)v6 )
      {
        if ( v4 )
        {
          *(_BYTE *)(v5 + *(_DWORD *)(a1 + 16)) = 0;
          *(_DWORD *)(v5 + *(_DWORD *)(a1 + 16) + 32) = 8;
          *(_DWORD *)(v5 + *(_DWORD *)(a1 + 16) + 56) = 8;
          *(_DWORD *)(v5 + *(_DWORD *)(a1 + 16) + 8) = 8;
          v3 = v10;
        }
        goto LABEL_11;
      }
LABEL_8:
      v4 = 0;
LABEL_11:
      ++v2;
      v6 += 12;
      v5 += 88;
    }
    while ( v2 < *(_DWORD *)(a1 + 20) );
  }
  v7 = 0;
  if ( *(_DWORD *)(a1 + 20) != -1 )
  {
    v8 = v3;
    do
    {
      if ( *(int *)v8 >= 2 )
        free(*((void **)v8 + 1));
      ++v7;
      v8 += 12;
    }
    while ( v7 < *(_DWORD *)(a1 + 20) + 1 );
  }
  free(v3);
}
// 447725: variable 'v9' is possibly undefined

//----- (004477D0) --------------------------------------------------------
int __usercall sub_4477D0@<eax>(int a1@<edx>, int *a2@<esi>)
{
  int result; // eax
  int v3; // ecx
  int v4; // edi

  result = *a2;
  v3 = a2[1];
  if ( *a2 - v3 < a1 )
  {
    v4 = a1 + v3 + (result >> 1);
    result = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(a2[3], v4);
    a2[3] = result;
    *a2 = v4;
  }
  return result;
}

//----- (00447810) --------------------------------------------------------
int __usercall sub_447810@<eax>(int a1@<eax>, int a2@<ecx>, unsigned int *a3@<edi>, unsigned int a4@<esi>)
{
  unsigned int v4; // eax
  int v5; // edx
  int result; // eax
  unsigned int v7; // edx

  if ( **(_DWORD **)(a1 + 28) % 2 )
    v4 = *(_DWORD *)(a1 + 8) + **(_DWORD **)(a1 + 16) + *(_DWORD *)(a1 + 4) + 3;
  else
    v4 = *(_DWORD *)(a1 + 12) + **(_DWORD **)(a1 + 20) + *(_DWORD *)a1 + 4;
  v5 = v4 % a4;
  result = a2 * a4;
  v7 = *a3 + a2 * v5;
  if ( v7 >= a2 * a4 )
    v7 -= result;
  *a3 = v7;
  return result;
}

//----- (00447860) --------------------------------------------------------
int __usercall sub_447860@<eax>(int a1@<eax>, int a2@<ebx>, int a3)
{
  int result; // eax
  int v5; // eax
  unsigned int v6; // esi
  int v7; // ecx
  unsigned int v8; // [esp+8h] [ebp-4h]

  result = *(_DWORD *)(a1 + 56);
  if ( result == 1 )
  {
    result = *(unsigned __int8 *)(a1 + 72) - 1;
    if ( *(_BYTE *)(a1 + 72) == 1 )
    {
      v5 = **(_DWORD **)(a2 + 28);
      if ( v5 % 2 )
        result = *(_DWORD *)(a2 + 4) + v5 % 10 + **(_DWORD **)(a2 + 16) + *(_DWORD *)a2 + 1;
      else
        result = *(_DWORD *)(a2 + 12) + v5 % 9 + **(_DWORD **)(a2 + 24) + *(_DWORD *)(a2 + 8) + 2;
      *(_DWORD *)(a1 + 64) += result;
    }
  }
  else
  {
    if ( result == 16 )
    {
      v6 = v8;
      v7 = v8;
    }
    else
    {
      v6 = *(_DWORD *)(a3 + 28);
      v7 = 1;
    }
    if ( result != 8 && result != 2 )
      return sub_447810(a2, v7, (unsigned int *)(a1 + 64), v6);
  }
  return result;
}
// 4478E1: variable 'v8' is possibly undefined

//----- (00447910) --------------------------------------------------------
_DWORD *__usercall sub_447910@<eax>(unsigned int a1@<eax>, int a2@<esi>)
{
  _DWORD *result; // eax
  unsigned int v4; // edi
  unsigned int v5; // ebx
  _DWORD *v6; // ebp
  int v7; // eax
  int v8; // edx
  int v9; // ecx
  unsigned __int8 v10; // dl
  int v11; // ecx

  result = malloc(a1 + 4);
  v4 = a1 >> 2;
  v5 = 0;
  v6 = result;
  if ( v4 != -1 )
  {
    do
    {
      v7 = (*(int (__cdecl **)(_DWORD))(a2 + 12))(*(_DWORD *)a2);
      v8 = *(_DWORD *)(a2 + 24);
      if ( v8 )
      {
        v9 = *(_DWORD *)(a2 + 32);
        v10 = *(_BYTE *)(v9 + v8);
        if ( v9 == *(_DWORD *)(a2 + 28) - 1 )
          *(_DWORD *)(a2 + 32) = 0;
        else
          *(_DWORD *)(a2 + 32) = v9 + 1;
        v11 = v7 ^ v10;
      }
      else
      {
        v11 = v7;
      }
      v6[v5++] = v11;
    }
    while ( v5 < v4 + 1 );
    return v6;
  }
  return result;
}

//----- (00447980) --------------------------------------------------------
int __usercall sub_447980@<eax>(int a1@<ebx>, int a2@<esi>)
{
  int v2; // edi
  int result; // eax
  int v4; // edx
  int v5; // ecx
  char v6; // dl
  char v7; // cl

  v2 = 0;
  do
  {
    result = (*(int (__cdecl **)(_DWORD))(a2 + 12))(*(_DWORD *)a2);
    v4 = *(_DWORD *)(a2 + 24);
    if ( v4 )
    {
      v5 = *(_DWORD *)(a2 + 32);
      v6 = *(_BYTE *)(v5 + v4);
      if ( v5 == *(_DWORD *)(a2 + 28) - 1 )
        *(_DWORD *)(a2 + 32) = 0;
      else
        *(_DWORD *)(a2 + 32) = v5 + 1;
      v7 = result ^ v6;
    }
    else
    {
      v7 = result;
    }
    *(_BYTE *)(v2 + a1) = v7;
  }
  while ( v7 == 60 || ++v2 < 8 );
  return result;
}

//----- (004479D0) --------------------------------------------------------
void __cdecl sub_4479D0(int a1, int a2, int a3)
{
  unsigned int v3; // ebp
  void *v4; // edi
  void *v5; // ebx
  void *Block; // [esp+4h] [ebp-Ch]
  unsigned int v7; // [esp+8h] [ebp-8h] BYREF
  unsigned int v8; // [esp+Ch] [ebp-4h]

  v3 = a1;
  Block = malloc(0x58u);
  if ( a1 > 0 )
  {
    do
    {
      sub_447980((int)&v7, a3);
      v7 %= v3;
      v4 = (void *)(a2 + 88 * v7);
      v8 %= v3;
      v5 = (void *)(a2 + 88 * v8);
      memcpy(Block, v4, 0x58u);
      memcpy(v4, v5, 0x58u);
      memcpy(v5, Block, 0x58u);
      --a1;
    }
    while ( a1 );
  }
  free(Block);
}

//----- (00447A70) --------------------------------------------------------
void __usercall sub_447A70(int *a1@<eax>, int a2@<ecx>, int a3@<edi>, _BYTE *Block)
{
  int v4; // ebx
  _DWORD *v6; // edx
  int v7; // eax
  _BYTE *v8; // ecx
  _DWORD *v9; // [esp+Ch] [ebp-4h]

  v4 = *a1;
  v6 = sub_447910(4 * a3, a2);
  v9 = v6;
  if ( (v4 & 0x2000) != 0 )
  {
    sub_4479D0(a3, (int)Block, a2);
    v6 = v9;
  }
  v7 = 0;
  if ( a3 > 0 )
  {
    v8 = Block;
    do
    {
      if ( (v4 & 0x80) != 0 )
        *v8 ^= *((_BYTE *)v6 + v7);
      ++v7;
      v8 += 88;
    }
    while ( v7 < a3 );
  }
  free(v6);
}

//----- (00447AE0) --------------------------------------------------------
int __cdecl sub_447AE0(int a1)
{
  int v1; // ebp
  _DWORD *v2; // esi
  _DWORD *v3; // eax
  int result; // eax
  int v5; // edx
  int v6; // ecx
  char v7; // dl
  char v8; // cl
  int v9; // [esp+Ch] [ebp-4h]

  v1 = 0;
  v9 = 0;
  while ( 1 )
  {
    v2 = Block;
    if ( !Block )
    {
      v2 = malloc(0x24u);
      v3 = malloc(0x1Cu);
      *v2 = v3;
      *v3 = 4096;
      *(_DWORD *)(*v2 + 4) = 4097;
      *(_DWORD *)(*v2 + 8) = 1236789;
      *(_DWORD *)(*v2 + 12) = 521288629;
      *(_DWORD *)(*v2 + 16) = 362;
      *(_DWORD *)(*v2 + 20) = 0;
      *(_DWORD *)(*v2 + 24) = 0;
      v2[1] = sub_472D69;
      v2[2] = sub_4730D6;
      v2[3] = sub_47314A;
      v2[4] = sub_472AAE;
      v2[5] = sub_472AB6;
      v2[6] = 0;
      v2[7] = 0;
      v2[8] = 0;
      Block = v2;
    }
    result = ((int (__cdecl *)(_DWORD))v2[2])(*v2);
    v5 = v2[6];
    if ( v5 )
    {
      v6 = v2[8];
      v7 = *(_BYTE *)(v6 + v5);
      v1 = v9;
      if ( v6 == v2[7] - 1 )
        v2[8] = 0;
      else
        v2[8] = v6 + 1;
      v8 = result ^ v7;
    }
    else
    {
      v8 = result;
    }
    *(_BYTE *)(a1 + v1) = v8;
    if ( v8 != 60 )
    {
      v9 = ++v1;
      if ( v1 >= 2 )
        break;
    }
  }
  return result;
}
// 472AAE: using guessed type int sub_472AAE();
// 472AB6: using guessed type int sub_472AB6();
// 47314A: using guessed type int sub_47314A();

//----- (00447BE0) --------------------------------------------------------
int __usercall sub_447BE0@<eax>(int a1@<esi>, int a2)
{
  _DWORD *v2; // ebp
  int v3; // eax
  void (__cdecl *v4)(int, int *, int); // ecx
  int result; // eax
  const char *v6; // ebx
  unsigned int v7; // edi
  void (__cdecl *v8)(int, int *, int); // edx
  int v9; // edi
  int v10; // ebx
  void (__cdecl *v11)(int, int *, int); // eax
  int *v12; // edx
  int (__cdecl *v13)(int, int *, int); // eax
  int **v14; // [esp+4h] [ebp-Ch] BYREF
  const char *v15; // [esp+8h] [ebp-8h] BYREF
  int v16; // [esp+Ch] [ebp-4h] BYREF

  v2 = (_DWORD *)a2;
  if ( a2 )
  {
    v3 = zend_hash_num_elements(a2);
    v4 = *(void (__cdecl **)(int, int *, int))(a1 + 108);
    a2 = v3;
    v4(a1, &a2, 4);
    zend_hash_internal_pointer_reset_ex(v2, &a2);
    for ( result = zend_hash_get_current_data_ex((int)v2, &v14, &a2);
          !result;
          result = zend_hash_get_current_data_ex((int)v2, &v14, v12) )
    {
      zend_hash_get_current_key_ex((int)v2, &v15, 0, 0, 0, (_DWORD **)&a2);
      v6 = v15;
      if ( v15 )
        v7 = strlen(v15);
      else
        v7 = 0;
      v8 = *(void (__cdecl **)(int, int *, int))(a1 + 108);
      v16 = v7;
      v8(a1, &v16, 4);
      if ( v7 != -1 )
        (*(void (__cdecl **)(int, const char *, unsigned int))(a1 + 108))(a1, v6, v7 + 1);
      v10 = **v14;
      v11 = *(void (__cdecl **)(int, int *, int))(a1 + 108);
      v16 = (*v14)[1];
      v9 = v16;
      v11(a1, &v16, 4);
      if ( v9 != -1 )
        (*(void (__cdecl **)(int, int, int))(a1 + 108))(a1, v10, v9 + 1);
      zend_hash_move_forward_ex((int)v2, (int)&a2);
    }
  }
  else
  {
    v13 = *(int (__cdecl **)(int, int *, int))(a1 + 108);
    a2 = 0;
    return v13(a1, &a2, 4);
  }
  return result;
}
// 447CD0: variable 'v12' is possibly undefined

//----- (00447D10) --------------------------------------------------------
int __cdecl sub_447D10(int a1, int a2, int *a3, int a4)
{
  int v4; // ebx
  int v5; // ebp
  int v6; // eax
  int v7; // eax
  int v8; // eax
  bool v9; // zf
  int v10; // ebx
  int *v11; // edi
  void (__cdecl *v12)(int, int *, int); // ecx
  int v13; // esi
  void *v14; // eax
  int v15; // ecx
  _WORD *v16; // eax
  _DWORD *v17; // ecx
  unsigned __int8 *v18; // esi
  unsigned __int8 v19; // al
  _DWORD *v20; // edi
  _DWORD *v21; // ecx
  int *v22; // eax
  int v23; // esi
  int v24; // edx
  int v25; // ebp
  int v26; // esi
  int v27; // esi
  int v28; // esi
  int v29; // esi
  int v30; // esi
  unsigned int v31; // esi
  unsigned int v32; // edx
  int v33; // esi
  void (__cdecl *v34)(int, int *, int); // edx
  void (__cdecl *v35)(int, int *, int); // ecx
  void (__cdecl *v36)(int, int *, int); // edx
  void (__cdecl *v37)(int, int *, int); // eax
  int result; // eax
  int v39; // [esp-4h] [ebp-58h]
  int v40; // [esp+10h] [ebp-44h]
  int v41; // [esp+14h] [ebp-40h]
  _WORD *Block; // [esp+18h] [ebp-3Ch]
  int v43; // [esp+1Ch] [ebp-38h]
  void *v44; // [esp+20h] [ebp-34h] BYREF
  int v45; // [esp+24h] [ebp-30h]
  int v46; // [esp+28h] [ebp-2Ch] BYREF
  _DWORD *v47; // [esp+2Ch] [ebp-28h]
  int v48[8]; // [esp+30h] [ebp-24h] BYREF

  v4 = a2;
  v5 = *(_DWORD *)a2;
  memset(v48, 0, 16);
  v6 = dword_4AE2E4;
  v48[4] = (int)&dword_4AE2F0;
  v48[5] = (int)&dword_4AE2F4;
  v48[6] = (int)&dword_4AE2F8;
  v48[7] = (int)&dword_4AE2FC;
  if ( dword_4AE2E0 == dword_4AE2E4 )
  {
    dword_4AE2E4 += dword_4AE2E8;
    v39 = 32 * (dword_4AE2E8 + v6);
    if ( dword_4AE2EC )
      v7 = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(dword_4AE2EC, v39);
    else
      v7 = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(v39);
    dword_4AE2EC = v7;
  }
  v8 = dword_4AE2E0 + 1;
  qmemcpy((void *)(dword_4AE2EC + 32 * dword_4AE2E0), v48, 0x20u);
  v9 = *(_DWORD *)(v4 + 4) == 0;
  dword_4AE2E0 = v8;
  if ( v9 )
    v44 = 0;
  else
    v44 = *(void **)(*(_DWORD *)(v4 + 8) + 84);
  v10 = a1;
  (*(void (__cdecl **)(int, void **, int))(a1 + 108))(a1, &v44, 4);
  v11 = (int *)a2;
  v12 = *(void (__cdecl **)(int, int *, int))(a1 + 108);
  v46 = *(unsigned __int16 *)(a2 + 32);
  v12(a1, &v46, 2);
  if ( v11[8] )
    (*(void (__cdecl **)(int, int, int))(a1 + 108))(a1, v11[7], v11[8]);
  (*(void (__cdecl **)(int, int, int))(a1 + 108))(a1, v5, 64);
  sub_447BE0(a1, v11[6]);
  v13 = 32 * dword_4AE2E0 + dword_4AE2EC;
  *(_DWORD *)(v13 - 24) = *(_DWORD *)(v5 + 36);
  *(_DWORD *)(v13 - 20) = 20;
  v43 = v11[1];
  v14 = malloc(48 * v43);
  v15 = v11[2];
  v44 = v14;
  v9 = (*a3 & 0x800) == 0;
  v40 = 0;
  v41 = 0;
  v46 = v15;
  if ( v9 )
    v16 = malloc(12 * v43);
  else
    v16 = malloc(6 * v43);
  Block = v16;
  v17 = (_DWORD *)(v13 - 32);
  *(_DWORD *)(v13 - 28) = v43;
  v47 = v17;
  *v17 = 1;
  if ( v43 > 0 )
  {
    v18 = (unsigned __int8 *)v46;
    v45 = v43;
    do
    {
      v19 = *v18;
      if ( *v18 >= 0x17u && (v19 <= 0x21u || v19 == 38) )
      {
        sub_447860((int)v18, (int)v17, v5);
        v10 = a1;
        v11 = (int *)a2;
        v17 = v47;
      }
      v18 += 88;
      --v45;
    }
    while ( v45 );
  }
  if ( a4 )
  {
    sub_447A70(a3, a4, v11[1], (_BYTE *)v11[2]);
    v11 = (int *)a2;
  }
  if ( v43 > 0 )
  {
    v20 = v44;
    v21 = (char *)v44 + 4;
    v22 = (int *)(v46 + 8);
    v46 = v43;
    do
    {
      v23 = *v22;
      v24 = *((unsigned __int8 *)v22 - 8);
      v25 = 0;
      a4 = 0;
      if ( v23 != 8 || v22[2] || v22[3] )
      {
        ++v41;
        *v20 = v23;
        *v21 = v22[2];
        v21[1] = v22[3];
        v24 |= 0x100u;
        v21[2] = v22[4];
        v20 += 4;
        v21 += 4;
      }
      v26 = v22[6];
      if ( v26 != 8 || v22[8] || v22[9] )
      {
        ++v41;
        *v20 = v26;
        *v21 = v22[8];
        v21[1] = v22[9];
        v24 |= 0x200u;
        v21[2] = v22[10];
        v20 += 4;
        v21 += 4;
      }
      v27 = v22[12];
      if ( v27 != 8 || v22[14] || v22[15] )
      {
        ++v41;
        *v20 = v27;
        *v21 = v22[14];
        v21[1] = v22[15];
        v24 |= 0x400u;
        v21[2] = v22[16];
        v20 += 4;
        v21 += 4;
      }
      v28 = v22[18];
      if ( v28 )
      {
        v29 = v28 - 1;
        if ( v29 )
        {
          if ( v29 == 59 )
          {
            v24 |= 0x1000u;
          }
          else
          {
            v24 |= 0x1800u;
            v25 = v22[18];
          }
        }
        else
        {
          v24 |= 0x800u;
        }
      }
      if ( (*a3 & 0x800) != 0 )
      {
        Block[v40] = v24;
        v30 = ++v40;
        if ( v25 )
        {
          Block[v30] = v25;
          v40 = v30 + 1;
        }
      }
      else
      {
        v31 = v22[19];
        if ( v31 >= 0xFFFF )
        {
          v32 = v24 | 0xFFFF0000;
          a4 = v22[19];
        }
        else
        {
          v32 = (v31 << 16) | v24;
        }
        *(_DWORD *)&Block[2 * v40] = v32;
        v33 = ++v40;
        if ( v25 )
        {
          *(_DWORD *)&Block[2 * v33] = v25;
          v40 = v33 + 1;
        }
        if ( a4 )
          *(_DWORD *)&Block[2 * v40++] = a4;
      }
      v22 += 22;
      --v46;
    }
    while ( v46 );
    v10 = a1;
    v11 = (int *)a2;
  }
  v34 = *(void (__cdecl **)(int, int *, int))(v10 + 108);
  a2 = v43;
  v34(v10, &a2, 4);
  v35 = *(void (__cdecl **)(int, int *, int))(v10 + 108);
  a2 = v40;
  v35(v10, &a2, 4);
  if ( v40 )
  {
    if ( (*a3 & 0x800) != 0 )
    {
      if ( 2 * v40 )
        (*(void (__cdecl **)(int, _WORD *, int))(v10 + 108))(v10, Block, 2 * v40);
    }
    else if ( 4 * v40 )
    {
      (*(void (__cdecl **)(int, _WORD *, int))(v10 + 108))(v10, Block, 4 * v40);
    }
  }
  v36 = *(void (__cdecl **)(int, int *, int))(v10 + 108);
  a2 = v41;
  v36(v10, &a2, 4);
  if ( v41 && 16 * v41 )
    (*(void (__cdecl **)(int, void *, int))(v10 + 108))(v10, v44, 16 * v41);
  free(Block);
  free(v44);
  v37 = *(void (__cdecl **)(int, int *, int))(v10 + 108);
  a2 = v11[12];
  v37(v10, &a2, 4);
  result = v11[12];
  if ( result )
    return (*(int (__cdecl **)(int, int, int))(v10 + 108))(v10, v11[14], v11[12]);
  return result;
}
// 4AE2E0: using guessed type int dword_4AE2E0;
// 4AE2E4: using guessed type int dword_4AE2E4;
// 4AE2E8: using guessed type int dword_4AE2E8;
// 4AE2EC: using guessed type int dword_4AE2EC;
// 4AE2F0: using guessed type int dword_4AE2F0;
// 4AE2F4: using guessed type int dword_4AE2F4;
// 4AE2F8: using guessed type int dword_4AE2F8;
// 4AE2FC: using guessed type int dword_4AE2FC;

//----- (004481A0) --------------------------------------------------------
int __cdecl sub_4481A0(int a1, char **a2, int *a3, int a4)
{
  int *v4; // ebp
  char **v5; // esi
  void (__cdecl *v6)(int, char *, int); // eax
  int v7; // edi
  unsigned int v8; // esi
  void (__cdecl *v9)(int, unsigned int *, int); // eax
  char **v10; // esi
  void (__cdecl *v11)(int, char *, int); // edx
  int v12; // eax
  const char *v13; // ebx
  void (__cdecl *v14)(int, unsigned int *, int); // eax
  char **v15; // ebx
  int v16; // edi
  void (__cdecl *v17)(int, unsigned int *, int); // ecx
  int v18; // esi
  int v19; // ebx
  char *v20; // ecx
  int v21; // eax
  int v22; // esi
  int v23; // ebp
  const char *v24; // edi
  int v25; // esi
  char *v26; // eax
  int v27; // ebx
  int v28; // esi
  char *v29; // ebp
  const char *v30; // ecx
  const char *v31; // esi
  void (__cdecl *v32)(int, const char **, int); // edx
  const char *v33; // esi
  void (__cdecl *v34)(int, char ***, int); // edx
  void (__cdecl *v35)(int, char ***, int); // eax
  _DWORD *v36; // ebx
  int v37; // eax
  void (__cdecl *v38)(int, char ***, int); // edx
  int result; // eax
  int v40; // esi
  char *v41; // edi
  const char *v42; // edi
  _BYTE *v43; // ebp
  const char *v44; // esi
  void (__cdecl *v45)(int, const char **, int); // eax
  const char *v46; // esi
  const char *v47; // esi
  void (__cdecl *v48)(int, const char **, int); // eax
  int *v49; // edx
  char v50[4]; // [esp+10h] [ebp-24h] BYREF
  _DWORD *v51; // [esp+14h] [ebp-20h] BYREF
  char *v52; // [esp+18h] [ebp-1Ch]
  unsigned int v53; // [esp+1Ch] [ebp-18h] BYREF
  const char *v54; // [esp+20h] [ebp-14h] BYREF
  const char *v55; // [esp+24h] [ebp-10h] BYREF
  _BYTE *v56; // [esp+28h] [ebp-Ch] BYREF
  const char *v57; // [esp+2Ch] [ebp-8h]
  int v58; // [esp+30h] [ebp-4h]

  v4 = a3;
  v5 = a2;
  v6 = *(void (__cdecl **)(int, char *, int))(a1 + 108);
  v50[0] = **a2;
  v6(a1, v50, 1);
  v7 = *((_DWORD *)*v5 + 1);
  if ( v7 )
    v8 = strlen(*((const char **)*v5 + 1));
  else
    v8 = 0;
  v9 = *(void (__cdecl **)(int, unsigned int *, int))(a1 + 108);
  v53 = v8;
  v9(a1, &v53, 4);
  if ( v8 != -1 )
    (*(void (__cdecl **)(int, int, unsigned int))(a1 + 108))(a1, v7, v8 + 1);
  v10 = a2;
  v11 = *(void (__cdecl **)(int, char *, int))(a1 + 108);
  v50[0] = (*a2)[20];
  v11(a1, v50, 1);
  v12 = *((_DWORD *)*v10 + 3);
  if ( v12 )
  {
    v13 = *(const char **)(v12 + 4);
  }
  else
  {
    v13 = v10[4];
    if ( !v13 )
      v13 = byte_47627C;
  }
  sub_4455A0(v13, a1);
  v14 = *(void (__cdecl **)(int, unsigned int *, int))(a1 + 108);
  v53 = *((unsigned __int16 *)v10 + 6);
  v14(a1, &v53, 2);
  if ( v10[3] )
    (*(void (__cdecl **)(int, char *, char *))(a1 + 108))(a1, v10[2], v10[3]);
  v15 = a2;
  v16 = a1;
  v17 = *(void (__cdecl **)(int, unsigned int *, int))(a1 + 108);
  v53 = (unsigned __int16)(*((_WORD *)a2 + 10) + (*((_DWORD *)*a2 + 3) != 0) + 1);
  v17(a1, &v53, 2);
  v18 = 0;
  if ( (int)v15[5] > 0 )
  {
    v19 = a4;
    do
      sub_447D10(a1, *(_DWORD *)&a2[8][4 * v18++], v4, v19);
    while ( v18 < (int)a2[5] );
    v15 = a2;
  }
  v20 = *v15;
  v21 = *((_DWORD *)*v15 + 3);
  if ( v21 || v15[4] )
  {
    v50[0] = 0;
    if ( v21 )
    {
      v22 = (int)(v20 + 24);
      v52 = v20 + 24;
      zend_hash_internal_pointer_reset_ex((_DWORD *)v20 + 6, &v51);
      if ( !zend_hash_get_current_data_ex(v22, &v53, (int *)&v51) )
      {
        v23 = v22;
        do
        {
          zend_hash_get_current_key_ex(v23, &v54, 0, 0, 0, &v51);
          v24 = v54;
          if ( !strcmp(*(const char **)(v53 + 8), v54) || strcmp(v54, *((const char **)*a2 + 1)) )
          {
            v27 = (int)a2[5];
            v28 = 0;
            if ( v27 <= 0 )
            {
LABEL_33:
              if ( v54 )
                v31 = (const char *)strlen(v54);
              else
                v31 = 0;
              v32 = *(void (__cdecl **)(int, const char **, int))(a1 + 108);
              v55 = v31;
              v32(a1, &v55, 4);
              v33 = v31 + 1;
              if ( v33 )
                (*(void (__cdecl **)(int, const char *, const char *))(a1 + 108))(a1, v24, v33);
            }
            else
            {
              v29 = a2[8];
              while ( 1 )
              {
                v30 = *(const char **)(*(_DWORD *)v29 + 40);
                if ( v30 )
                {
                  if ( !strcmp(v54, v30) )
                    break;
                }
                ++v28;
                v29 += 4;
                if ( v28 >= v27 )
                  goto LABEL_33;
              }
            }
            v23 = (int)v52;
          }
          else
          {
            v25 = *((_DWORD *)*a2 + 3);
            if ( v25 )
            {
              while ( strcmp(*(const char **)(v25 + 4), *(const char **)(v53 + 8)) )
              {
                v25 = *(_DWORD *)(v25 + 12);
                if ( !v25 )
                  goto LABEL_26;
              }
              v50[0] = 1;
            }
            else
            {
LABEL_26:
              v26 = (char *)sub_473493((int)&unk_48B2D4);
              sub_444570(v26);
            }
          }
          zend_hash_move_forward_ex(v23, (int)&v51);
        }
        while ( !zend_hash_get_current_data_ex(v23, &v53, (int *)&v51) );
        v16 = a1;
        v15 = a2;
      }
    }
    v34 = *(void (__cdecl **)(int, char ***, int))(v16 + 108);
    a2 = 0;
    v34(v16, &a2, 4);
    (*(void (__cdecl **)(int, const char *, int))(v16 + 108))(v16, byte_47627C, 1);
    v35 = *(void (__cdecl **)(int, char ***, int))(v16 + 108);
    LOBYTE(a2) = v50[0];
    v35(v16, &a2, 1);
  }
  v36 = *v15 + 64;
  v37 = zend_hash_num_elements((int)v36);
  v38 = *(void (__cdecl **)(int, char ***, int))(v16 + 108);
  a2 = (char **)v37;
  v38(v16, &a2, 4);
  zend_hash_internal_pointer_reset_ex(v36, &v51);
  for ( result = zend_hash_get_current_data_ex((int)v36, &a2, (int *)&v51);
        !result;
        result = zend_hash_get_current_data_ex((int)v36, &a2, v49) )
  {
    zend_hash_get_current_key_ex((int)v36, &v55, 0, 0, 0, &v51);
    v40 = a3[1];
    v41 = *a2;
    v58 = 64;
    v57 = 0;
    v56 = (_BYTE *)(*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(65);
    *v56 = 0;
    sub_4404B0((int)v41, &v56, v40);
    v42 = v55;
    v43 = v56;
    v56 = 0;
    if ( v55 )
      v44 = (const char *)strlen(v55);
    else
      v44 = 0;
    v45 = *(void (__cdecl **)(int, const char **, int))(a1 + 108);
    v54 = v44;
    v45(a1, &v54, 4);
    v46 = v44 + 1;
    if ( v46 )
      (*(void (__cdecl **)(int, const char *, const char *))(a1 + 108))(a1, v42, v46);
    v47 = v57;
    v48 = *(void (__cdecl **)(int, const char **, int))(a1 + 108);
    v54 = v57;
    v48(a1, &v54, 4);
    if ( v47 != (const char *)-1 )
      (*(void (__cdecl **)(int, _BYTE *, const char *))(a1 + 108))(a1, v43, v47 + 1);
    (*(void (__cdecl **)(_BYTE *))(*(_DWORD *)dword_4A80FC + 16))(v43);
    zend_hash_move_forward_ex((int)v36, (int)&v51);
  }
  return result;
}
// 44867E: variable 'v49' is possibly undefined
// 4481A0: using guessed type char var_24[4];

//----- (004486A0) --------------------------------------------------------
int __cdecl sub_4486A0(int a1, int a2)
{
  int result; // eax
  char v3; // al
  void (__cdecl *v4)(int, char *, int); // eax
  _DWORD *v5; // esi
  char v6; // al
  int v7; // edx
  int v8; // ecx
  char v9; // dl
  char v10; // cl
  void (__cdecl *v11)(int, char *, int); // eax
  _DWORD *v12; // esi
  _DWORD *v13; // eax
  char v14; // al
  int v15; // edx
  int v16; // ecx
  char v17; // dl
  char v18[4]; // [esp+10h] [ebp-8h] BYREF
  int i; // [esp+14h] [ebp-4h]

  result = 0;
  for ( i = 0; i < 4; ++i )
  {
    v3 = *(_BYTE *)(result + a2);
    if ( v3 == 60 )
    {
      v11 = *(void (__cdecl **)(int, char *, int))(a1 + 108);
      v18[0] = -1;
      v11(a1, v18, 1);
      do
      {
        v12 = Block;
        if ( !Block )
        {
          v12 = malloc(0x24u);
          v13 = malloc(0x1Cu);
          *v12 = v13;
          *v13 = 4096;
          *(_DWORD *)(*v12 + 4) = 4097;
          *(_DWORD *)(*v12 + 8) = 1236789;
          *(_DWORD *)(*v12 + 12) = 521288629;
          *(_DWORD *)(*v12 + 16) = 362;
          *(_DWORD *)(*v12 + 20) = 0;
          *(_DWORD *)(*v12 + 24) = 0;
          v12[1] = sub_472D69;
          v12[2] = sub_4730D6;
          v12[3] = sub_47314A;
          v12[4] = sub_472AAE;
          v12[5] = sub_472AB6;
          v12[6] = 0;
          v12[7] = 0;
          v12[8] = 0;
          Block = v12;
        }
        v14 = ((int (__cdecl *)(_DWORD))v12[2])(*v12);
        v15 = v12[6];
        if ( v15 )
        {
          v16 = v12[8];
          v17 = *(_BYTE *)(v16 + v15);
          if ( v16 == v12[7] - 1 )
            v12[8] = 0;
          else
            v12[8] = v16 + 1;
          v10 = v14 ^ v17;
        }
        else
        {
          v10 = v14;
        }
      }
      while ( v10 >= 0 );
    }
    else
    {
      if ( v3 != -1 )
      {
        v18[0] = v3;
        goto LABEL_28;
      }
      v4 = *(void (__cdecl **)(int, char *, int))(a1 + 108);
      v18[0] = -1;
      v4(a1, v18, 1);
      do
      {
        v5 = Block;
        if ( !Block )
        {
          v5 = sub_47315E();
          v5[6] = 0;
          v5[7] = 0;
          v5[8] = 0;
          Block = v5;
        }
        v6 = ((int (__cdecl *)(_DWORD))v5[2])(*v5);
        v7 = v5[6];
        if ( v7 )
        {
          v8 = v5[8];
          v9 = *(_BYTE *)(v8 + v7);
          if ( v8 == v5[7] - 1 )
            v5[8] = 0;
          else
            v5[8] = v8 + 1;
          v10 = v6 ^ v9;
        }
        else
        {
          v10 = v6;
        }
      }
      while ( v10 == 60 || v10 < 0 );
    }
    v18[0] = v10;
LABEL_28:
    (*(void (__cdecl **)(int, char *))(a1 + 108))(a1, v18);
    result = i + 1;
  }
  return result;
}
// 472AAE: using guessed type int sub_472AAE();
// 472AB6: using guessed type int sub_472AB6();
// 47314A: using guessed type int sub_47314A();
// 4486A0: using guessed type char var_8[4];

//----- (00448860) --------------------------------------------------------
void __usercall sub_448860(_DWORD *a1@<esi>)
{
  char v1; // al
  void (__cdecl *v2)(_DWORD *, char *, int); // edx
  char v3[4]; // [esp+0h] [ebp-8h] BYREF
  int v4; // [esp+4h] [ebp-4h] BYREF

  if ( a1[17] )
  {
    if ( a1[18] )
    {
      v4 = a1[20];
      a1[17] = 0;
      v1 = sub_444660();
      v2 = (void (__cdecl *)(_DWORD *, char *, int))a1[27];
      v3[0] = v1 & 0x1F | 0xA0;
      v2(a1, v3, 1);
      sub_4486A0((int)a1, (int)&v4);
      a1[18] = 0;
      a1[17] = 1;
    }
  }
}
// 448860: using guessed type char var_8[4];

//----- (004488C0) --------------------------------------------------------
void __cdecl sub_4488C0(_DWORD *a1, int a2, unsigned int a3)
{
  unsigned int i; // esi
  unsigned int v4; // ebx
  _DWORD *v5; // esi
  char v6; // al
  int v7; // edi
  int v8; // ecx
  char v9; // dl
  char v10; // cl
  char v11; // al
  _DWORD *v12; // esi
  int v13; // eax
  _DWORD *v14; // esi
  int v15; // eax
  int v16; // eax
  char v17; // al
  void (__cdecl *v18)(_DWORD *, unsigned int *, int); // ecx
  void (__cdecl *v19)(_DWORD *, char *, int); // ecx
  char v20; // cl
  char v21; // al
  char v22; // [esp+Ch] [ebp-Ch] BYREF
  char v23; // [esp+Dh] [ebp-Bh]
  unsigned int v24; // [esp+10h] [ebp-8h]
  int v25; // [esp+14h] [ebp-4h] BYREF

  if ( !dword_4A9D30 )
    dword_4A9D30 = (int)malloc(0xFFu);
  for ( i = a3; i; a3 = i )
  {
    v4 = 0;
    if ( i >= 0xFF )
    {
      v24 = 255;
LABEL_6:
      while ( 1 )
      {
        v5 = (_DWORD *)dword_4A9D2C;
        v6 = (*(int (__cdecl **)(_DWORD))(dword_4A9D2C + 8))(*(_DWORD *)dword_4A9D2C);
        v7 = v5[6];
        if ( v7 )
        {
          v8 = v5[8];
          v9 = *(_BYTE *)(v8 + v7);
          v5[8] = v8 == v5[7] - 1 ? 0 : v8 + 1;
          v10 = v6 ^ v9;
        }
        else
        {
          v10 = v6;
        }
        v11 = v10 ^ *(_BYTE *)(v4 + a2);
        *(_BYTE *)(dword_4A9D30 + v4) = v11;
        if ( v11 == 60 )
          break;
        if ( ++v4 >= v24 )
          goto LABEL_20;
      }
      v12 = (_DWORD *)dword_4A9D2C;
      (*(void (__cdecl **)(_DWORD))(dword_4A9D2C + 16))(*(_DWORD *)dword_4A9D2C);
      if ( v12[6] )
      {
        v13 = v12[8];
        if ( v13 )
          v12[8] = v13 - 1;
        else
          v12[8] = v12[7] - 1;
      }
LABEL_20:
      if ( v4 == 60 )
      {
        v14 = (_DWORD *)dword_4A9D2C;
        (*(void (__cdecl **)(_DWORD))(dword_4A9D2C + 16))(*(_DWORD *)dword_4A9D2C);
        if ( v14[6] )
        {
          v15 = v14[8];
          if ( v15 )
            v14[8] = v15 - 1;
          else
            v14[8] = v14[7] - 1;
        }
        v4 = 59;
      }
      i = a3;
    }
    else
    {
      v24 = i;
      if ( i )
        goto LABEL_6;
    }
    sub_447AE0((int)&v22);
    if ( a1[17] )
    {
      v16 = a1[18];
      if ( v16 + v4 + 10 > 0x2000 )
      {
        if ( v16 )
        {
          v25 = a1[20];
          a1[17] = 0;
          v17 = sub_444660();
          v18 = (void (__cdecl *)(_DWORD *, unsigned int *, int))a1[27];
          LOBYTE(a3) = v17 & 0x1F | 0xA0;
          v18(a1, &a3, 1);
          sub_4486A0((int)a1, (int)&v25);
          a1[18] = 0;
          a1[17] = 1;
        }
      }
    }
    if ( v4 )
    {
      v22 &= ~0x80u;
      if ( v22 == 60 )
        v22 = 61;
      v19 = (void (__cdecl *)(_DWORD *, char *, int))a1[27];
      v23 = v4;
      v19(a1, &v22, 2);
      ((void (__cdecl *)(_DWORD *, int, unsigned int))a1[27])(a1, dword_4A9D30, v4);
    }
    if ( v4 < v24 && *(_BYTE *)(dword_4A9D30 + v4) == 60 )
    {
      v20 = *(_BYTE *)(v4 + a2);
      v21 = v22 & 0x1F | 0x80;
      v22 = v21;
      v23 = v20;
      if ( v20 == 60 )
      {
        v22 = v21 | 0xC0;
        v23 = 123;
      }
      ((void (__cdecl *)(_DWORD *, char *, int))a1[27])(a1, &v22, 2);
      ++v4;
    }
    a2 += v4;
    i -= v4;
  }
}
// 4A9D2C: using guessed type int dword_4A9D2C;
// 4A9D30: using guessed type int dword_4A9D30;

//----- (00448AE0) --------------------------------------------------------
size_t __cdecl sub_448AE0(int a1, void *Src, size_t Size)
{
  _DWORD *v3; // esi
  int v4; // eax

  v3 = *(_DWORD **)(a1 + 44);
  v4 = Size + v3[5];
  if ( v3[1] < v4 )
  {
    v3[1] = v4;
    v3[3] = (*(int (__cdecl **)(_DWORD, int))(*(_DWORD *)dword_4A80FC + 12))(v3[3], v4);
  }
  memcpy((void *)(v3[5] + v3[3]), Src, Size);
  *(_DWORD *)(a1 + 16) += Size;
  v3[5] += Size;
  *v3 += Size;
  return Size;
}

//----- (00448B40) --------------------------------------------------------
int __usercall sub_448B40@<eax>(int a1@<eax>, int a2)
{
  int v3; // ebx
  int v4; // edx
  int v5; // eax
  int v6; // edx
  unsigned int v7; // ecx
  unsigned int v8; // eax

  v3 = *(_DWORD *)(a2 + 44);
  v4 = *(_DWORD *)(v3 + 12);
  *(_DWORD *)(v3 + 28) = *(_DWORD *)v3;
  *(_DWORD *)(v3 + 24) = v4;
  *(_DWORD *)(v3 + 112) = 0;
  while ( 1 )
  {
    if ( !*(_DWORD *)(v3 + 28) && !*(_DWORD *)(v3 + 112) )
    {
      if ( !a1 )
        goto LABEL_13;
      *(_DWORD *)(v3 + 112) = 4;
    }
    v5 = sub_44B090(v3 + 24, *(_DWORD *)(v3 + 112));
    if ( v5 == 1 )
      break;
    if ( v5 )
      goto LABEL_13;
    if ( !*(_DWORD *)(v3 + 40) )
    {
      sub_4488C0(*(_DWORD **)(v3 + 196), *(_DWORD *)(v3 + 84), *(_DWORD *)(v3 + 80));
      v6 = *(_DWORD *)(v3 + 80);
      *(_DWORD *)(v3 + 36) = *(_DWORD *)(v3 + 84);
      *(_DWORD *)(v3 + 40) = v6;
    }
  }
  v7 = *(_DWORD *)(v3 + 40);
  v8 = *(_DWORD *)(v3 + 80);
  if ( v7 < v8 )
  {
    sub_4488C0(*(_DWORD **)(v3 + 196), *(_DWORD *)(v3 + 84), v8 - v7);
    sub_448860(*(_DWORD **)(v3 + 196));
  }
LABEL_13:
  *(_DWORD *)(v3 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(v3 + 20) = 0;
  *(_DWORD *)v3 = 0;
  return 1;
}
// 448BB9: conditional instruction was optimized away because eax.4>=2u

//----- (00448C10) --------------------------------------------------------
int __cdecl sub_448C10(int a1)
{
  return sub_448B40(0, a1);
}

//----- (00448C20) --------------------------------------------------------
int __cdecl sub_448C20(int a1)
{
  return sub_448B40(1, a1);
}

//----- (00448C30) --------------------------------------------------------
int __cdecl sub_448C30(int a1, int a2, int a3)
{
  int *v3; // esi
  int v4; // eax
  int v5; // eax
  char *v7; // eax
  int v8; // [esp-14h] [ebp-1Ch]
  int v9; // [esp-10h] [ebp-18h]
  int v10; // [esp-Ch] [ebp-14h]
  int v11; // [esp-8h] [ebp-10h]
  int v12; // [esp-4h] [ebp-Ch]

  v3 = *(int **)(a1 + 44);
  v4 = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      v4 = a3;
  }
  else
  {
    v4 = a3 - *(_DWORD *)(a1 + 16);
  }
  if ( v3[5] + v4 < 0 )
  {
    v12 = *v3;
    v11 = v3[4];
    v10 = v3[5];
    v9 = *(_DWORD *)(a1 + 16);
    v8 = v4;
    v7 = (char *)sub_473493((int)&unk_48B310);
    sub_444570(v7, v8, v9, v10, v11, v12);
    return 1;
  }
  else
  {
    *(_DWORD *)(a1 + 16) += v4;
    v3[5] += v4;
    v5 = v3[5];
    if ( v3[1] < v5 )
    {
      v3[1] = v5;
      v3[3] = (*(int (__cdecl **)(int, int))(*(_DWORD *)dword_4A80FC + 12))(v3[3], v5);
    }
    *v3 = v3[5];
    return 1;
  }
}

//----- (00448CC0) --------------------------------------------------------
int __usercall sub_448CC0@<eax>(int a1@<eax>, int a2@<ebx>, unsigned int a3)
{
  _DWORD *v3; // esi
  int result; // eax
  int v6; // edx

  v3 = *(_DWORD **)(a2 + 44);
  v3[49] = a1;
  *v3 = 0;
  v3[1] = 0x10000;
  v3[2] = 0x10000;
  v3[3] = (*(int (__thiscall **)(void *, int))(*(_DWORD *)dword_4A80FC + 8))(dword_4A80FC, 0x10000);
  v3[4] = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 16);
  v3[5] = 0;
  memset(v3 + 6, 0, 0xACu);
  v3[20] = 255;
  v3[21] = malloc(0xFFu);
  v3[28] = 0;
  result = sub_44AE30(v3 + 6, a3);
  v6 = v3[20];
  v3[9] = v3[21];
  v3[10] = v6;
  return result;
}

//----- (00448D50) --------------------------------------------------------
_DWORD *__cdecl sub_448D50(int a1, unsigned int a2)
{
  _DWORD *v2; // ebx

  v2 = (_DWORD *)(*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(128);
  memset(v2, 0, 0x80u);
  v2[27] = sub_448AE0;
  v2[28] = sub_448C20;
  v2[29] = sub_448C30;
  v2[30] = sub_448C10;
  v2[11] = (*(int (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 8))(200);
  sub_448CC0(a1, (int)v2, a2);
  return v2;
}

//----- (00448DD0) --------------------------------------------------------
int __cdecl sub_448DD0(int a1, int a2, int *a3, _DWORD *a4)
{
  _DWORD *v4; // ebx
  int v5; // esi
  void *v6; // edi
  void (__cdecl *v7)(int); // edx
  int *v8; // eax
  void (__cdecl *v9)(void *, int); // edx
  void (__cdecl *v10)(int, void **, int); // ecx
  void (__cdecl *v11)(int, void *); // eax
  unsigned int v12; // eax
  int v13; // eax
  int i; // ecx
  void (__cdecl *v15)(_DWORD *, int *, int); // eax
  int j; // esi
  void (__cdecl *v17)(_DWORD *, int *, int); // edx
  int k; // esi
  int v19; // edi
  int v21; // [esp-4h] [ebp-24h]
  int v22; // [esp-4h] [ebp-24h]
  void *v23; // [esp-4h] [ebp-24h]
  void **v24; // [esp+Ch] [ebp-14h]
  void *Block; // [esp+10h] [ebp-10h] BYREF
  int v26; // [esp+14h] [ebp-Ch]
  int v27; // [esp+18h] [ebp-8h]
  int v28; // [esp+1Ch] [ebp-4h] BYREF

  v4 = (_DWORD *)a2;
  v5 = 0;
  v24 = (void **)sub_47315E();
  v24[6] = 0;
  v24[7] = 0;
  v24[8] = 0;
  v28 = *a3;
  v26 = v28 & 0xF;
  v27 = 0;
  v6 = (void *)sub_444660();
  if ( dword_4A9D2C )
  {
    v7 = *(void (__cdecl **)(int))(dword_4A9D2C + 20);
    v21 = *(_DWORD *)dword_4A9D2C;
    Block = (void *)dword_4A9D2C;
    v7(v21);
    free(*(void **)Block);
    free(Block);
  }
  v8 = sub_47315E();
  v8[6] = 0;
  v8[7] = 0;
  v8[8] = 0;
  v9 = (void (__cdecl *)(void *, int))v8[1];
  v22 = *v8;
  dword_4A9D2C = (int)v8;
  v9(v6, v22);
  v10 = *(void (__cdecl **)(int, void **, int))(a2 + 108);
  Block = v6;
  v10(a2, &Block, 4);
  if ( (v28 & 0x80u) != 0 || (v28 & 0x2C00) != 0 )
  {
    v11 = (void (__cdecl *)(int, void *))v24[1];
    v23 = *v24;
    v5 = (int)&a4[64 * a2] + dword_4AE100;
    v27 = 1;
    v11(v5, v23);
  }
  v28 = v5;
  (*(void (__cdecl **)(int, int *, int))(a2 + 108))(a2, &v28, 4);
  v12 = v26;
  *(_DWORD *)(a2 + 68) = 1;
  if ( v12 )
    v4 = sub_448D50(a2, v12);
  sub_449070((int)v4, a4 + 10);
  dword_4AE2F8 = a4[1];
  v13 = a4[5] + 1;
  dword_4AE2F4 = v13;
  if ( a4[1] )
  {
    for ( i = 0; i < a4[1]; dword_4AE2F4 = v13 )
      v13 += *(_DWORD *)(*(_DWORD *)(a4[4] + 4 * i++) + 20);
  }
  sub_447D10((int)v4, a4[9], a3, (int)v24);
  v15 = (void (__cdecl *)(_DWORD *, int *, int))v4[27];
  v28 = (unsigned __int16)(*((_WORD *)a4 + 10) + 7);
  v15(v4, &v28, 2);
  for ( j = 0; j < a4[5]; ++j )
    sub_447D10((int)v4, *(_DWORD *)(a4[8] + 4 * j), a3, (int)v24);
  v17 = (void (__cdecl *)(_DWORD *, int *, int))v4[27];
  v28 = (unsigned __int16)(*((_WORD *)a4 + 2) + 2);
  v17(v4, &v28, 2);
  for ( k = 0; k < a4[1]; ++k )
    sub_4481A0((int)v4, *(char ***)(a4[4] + 4 * k), a3, (int)v24);
  if ( v26 )
  {
    ((void (__cdecl *)(_DWORD *))v4[28])(v4);
    v19 = v4[11];
    sub_44B2E0(v19 + 24);
    free(*(void **)(v19 + 84));
    if ( *(_DWORD *)(v19 + 12) )
    {
      (*(void (__cdecl **)(_DWORD))(*(_DWORD *)dword_4A80FC + 16))(*(_DWORD *)(v19 + 12));
      *(_DWORD *)(v19 + 12) = 0;
    }
    *(_DWORD *)(v19 + 4) = 0;
    *(_DWORD *)v19 = 0;
    (*(void (__cdecl **)(int))(*(_DWORD *)dword_4A80FC + 16))(v19);
    (*(void (__cdecl **)(_DWORD *))(*(_DWORD *)dword_4A80FC + 16))(v4);
  }
  if ( v27 )
  {
    ((void (__cdecl *)(void *))v24[5])(*v24);
    free(*v24);
    free(v24);
  }
  return 1;
}
// 4A9D2C: using guessed type int dword_4A9D2C;
// 4AE100: using guessed type int dword_4AE100;
// 4AE2F4: using guessed type int dword_4AE2F4;
// 4AE2F8: using guessed type int dword_4AE2F8;

//----- (00449070) --------------------------------------------------------
int __usercall sub_449070@<eax>(int a1@<esi>, _DWORD *a2)
{
  int (__cdecl *v2)(int, _DWORD **, int); // ecx
  _DWORD *v3; // ebp
  int v4; // edi
  int result; // eax
  int v6; // ebx
  int v7; // edx
  _DWORD *v8; // eax
  _DWORD *v9; // edi
  void (__cdecl *v10)(int, _DWORD **, int); // edx
  _DWORD *v11; // [esp+Ch] [ebp-4h]

  v2 = *(int (__cdecl **)(int, _DWORD **, int))(a1 + 108);
  v3 = a2;
  v11 = (_DWORD *)*a2;
  a2 = (_DWORD *)*a2;
  v4 = (int)a2;
  result = v2(a1, &a2, 4);
  v6 = 0;
  if ( v4 > 0 )
  {
    do
    {
      v7 = v3[3];
      v8 = *(_DWORD **)(v7 + 8 * v6 + 4);
      v9 = (_DWORD *)(v7 + 8 * v6);
      v10 = *(void (__cdecl **)(int, _DWORD **, int))(a1 + 108);
      a2 = v8;
      v10(a1, &a2, 4);
      result = v9[1];
      if ( result )
        result = (*(int (__cdecl **)(int, _DWORD, _DWORD))(a1 + 108))(a1, *v9, v9[1]);
      ++v6;
    }
    while ( v6 < (int)v11 );
  }
  return result;
}

//----- (004490E0) --------------------------------------------------------
int __usercall sub_4490E0@<eax>(int a1@<edx>, int a2)
{
  int v2; // esi
  unsigned __int8 *v3; // ecx
  unsigned __int64 v4; // rt0
  int v5; // eax
  unsigned int v6; // edx
  unsigned int v7; // edi
  int v8; // eax
  char *v9; // eax
  unsigned int v10; // ecx
  unsigned int v11; // edx
  unsigned int v12; // esi
  unsigned int v13; // eax
  unsigned __int64 v14; // kr18_8
  unsigned int v15; // edx
  unsigned __int64 v16; // kr20_8
  unsigned int v17; // ecx
  unsigned int v18; // esi
  unsigned int v19; // eax
  unsigned __int64 v20; // kr30_8
  int v21; // ecx
  unsigned int v22; // ecx
  unsigned int v23; // eax
  unsigned __int64 v24; // kr40_8
  unsigned __int64 v25; // rcx
  bool v26; // zf
  __int64 v27; // rax
  __int64 v28; // rdi
  __int64 v29; // rcx
  unsigned int v30; // krD0_4
  unsigned __int64 v31; // rax
  unsigned __int64 v32; // kr110_8
  unsigned __int64 v33; // rax
  unsigned __int64 v34; // kr160_8
  bool v35; // cc
  bool v36; // cf
  __int64 v38; // [esp+Ch] [ebp-31Ch]
  char *v39; // [esp+10h] [ebp-318h]
  unsigned __int64 v40; // [esp+10h] [ebp-318h]
  unsigned __int64 v41; // [esp+10h] [ebp-318h]
  unsigned __int64 v42; // [esp+10h] [ebp-318h]
  unsigned __int64 v43; // [esp+10h] [ebp-318h]
  unsigned __int64 v44; // [esp+10h] [ebp-318h]
  unsigned __int64 v45; // [esp+10h] [ebp-318h]
  unsigned __int64 v46; // [esp+10h] [ebp-318h]
  char *v47; // [esp+1Ch] [ebp-30Ch]
  char *v48; // [esp+1Ch] [ebp-30Ch]
  unsigned int v49; // [esp+1Ch] [ebp-30Ch]
  unsigned __int64 v50; // [esp+20h] [ebp-308h]
  unsigned __int64 v51; // [esp+20h] [ebp-308h]
  unsigned __int64 v52; // [esp+28h] [ebp-300h]
  unsigned __int64 v53; // [esp+28h] [ebp-300h]
  unsigned __int64 v54; // [esp+30h] [ebp-2F8h]
  unsigned __int64 v55; // [esp+30h] [ebp-2F8h]
  unsigned __int64 v56; // [esp+38h] [ebp-2F0h]
  unsigned __int64 v57; // [esp+38h] [ebp-2F0h]
  unsigned __int64 v58; // [esp+40h] [ebp-2E8h]
  unsigned __int64 v59; // [esp+40h] [ebp-2E8h]
  unsigned __int64 v60; // [esp+48h] [ebp-2E0h]
  unsigned __int64 v61; // [esp+48h] [ebp-2E0h]
  unsigned __int64 v62; // [esp+50h] [ebp-2D8h]
  unsigned __int64 v63; // [esp+50h] [ebp-2D8h]
  unsigned __int64 v64; // [esp+58h] [ebp-2D0h]
  unsigned __int64 v65; // [esp+58h] [ebp-2D0h]
  char *v66; // [esp+64h] [ebp-2C4h]
  int v67; // [esp+64h] [ebp-2C4h]
  unsigned __int64 v68; // [esp+68h] [ebp-2C0h]
  unsigned __int64 v69; // [esp+78h] [ebp-2B0h]
  unsigned __int64 v70; // [esp+80h] [ebp-2A8h]
  unsigned __int64 v71; // [esp+90h] [ebp-298h]
  _WORD v72[3]; // [esp+A8h] [ebp-280h]
  char v73[8]; // [esp+AEh] [ebp-27Ah] BYREF
  char v74[8]; // [esp+B6h] [ebp-272h] BYREF
  char v75[90]; // [esp+BEh] [ebp-26Ah] BYREF
  char v76[528]; // [esp+118h] [ebp-210h] BYREF

  v50 = *(_QWORD *)(a2 + 8);
  v52 = *(_QWORD *)(a2 + 16);
  v54 = *(_QWORD *)(a2 + 24);
  v56 = *(_QWORD *)(a2 + 32);
  v58 = *(_QWORD *)(a2 + 40);
  v60 = *(_QWORD *)(a2 + 48);
  v62 = *(_QWORD *)(a2 + 56);
  v64 = *(_QWORD *)(a2 + 64);
  v66 = &v73[-a1];
  v47 = &v74[-a1];
  v2 = 0;
  v3 = (unsigned __int8 *)(a1 + 2);
  v39 = &v75[-a1];
  do
  {
    HIDWORD(v4) = (unsigned __int64)*(v3 - 2) >> 24;
    LODWORD(v4) = *(v3 - 1) | (*(v3 - 2) << 8);
    HIDWORD(v4) = v4 >> 24;
    LODWORD(v4) = *v3 | ((_DWORD)v4 << 8);
    HIDWORD(v4) = v4 >> 24;
    LODWORD(v4) = v3[1] | ((_DWORD)v4 << 8);
    HIDWORD(v4) = v4 >> 24;
    LODWORD(v4) = v3[2] | ((_DWORD)v4 << 8);
    HIDWORD(v4) = v4 >> 24;
    LODWORD(v4) = v3[3] | ((_DWORD)v4 << 8);
    HIDWORD(v4) = v4 >> 24;
    LODWORD(v4) = v3[4] | ((_DWORD)v4 << 8);
    v5 = v3[6];
    v6 = (unsigned __int64)v3[6] >> 24;
    *(_DWORD *)&v72[4 * v2] = v3[5] | ((_DWORD)v4 << 8);
    v7 = v5 << 8;
    v8 = v3[7];
    *(_DWORD *)&v72[4 * v2 + 2] = v4 >> 24;
    HIDWORD(v4) = (v8 | __PAIR64__(v6, v7)) >> 24;
    LODWORD(v4) = v3[8] | ((v8 | v7) << 8);
    HIDWORD(v4) = v4 >> 24;
    LODWORD(v4) = v3[9] | ((_DWORD)v4 << 8);
    HIDWORD(v4) = v4 >> 24;
    LODWORD(v4) = v3[10] | ((_DWORD)v4 << 8);
    HIDWORD(v4) = v4 >> 24;
    LODWORD(v4) = v3[11] | ((_DWORD)v4 << 8);
    HIDWORD(v4) = v4 >> 24;
    LODWORD(v4) = v3[12] | ((_DWORD)v4 << 8);
    *(_DWORD *)&v3[(_DWORD)v66] = v3[13] | ((_DWORD)v4 << 8);
    *(_DWORD *)&v3[(_DWORD)v66 + 4] = v4 >> 24;
    HIDWORD(v4) = (unsigned __int64)v3[14] >> 24;
    LODWORD(v4) = v3[15] | (v3[14] << 8);
    HIDWORD(v4) = v4 >> 24;
    LODWORD(v4) = v3[16] | ((_DWORD)v4 << 8);
    HIDWORD(v4) = v4 >> 24;
    LODWORD(v4) = v3[17] | ((_DWORD)v4 << 8);
    HIDWORD(v4) = v4 >> 24;
    LODWORD(v4) = v3[18] | ((_DWORD)v4 << 8);
    HIDWORD(v4) = v4 >> 24;
    LODWORD(v4) = v3[19] | ((_DWORD)v4 << 8);
    HIDWORD(v4) = v4 >> 24;
    LODWORD(v4) = v3[20] | ((_DWORD)v4 << 8);
    *(_QWORD *)&v3[(_DWORD)v47] = v3[21] | (v4 << 8);
    HIDWORD(v4) = (unsigned __int64)v3[22] >> 24;
    LODWORD(v4) = v3[23] | (v3[22] << 8);
    HIDWORD(v4) = v4 >> 24;
    LODWORD(v4) = v3[24] | ((_DWORD)v4 << 8);
    HIDWORD(v4) = v4 >> 24;
    LODWORD(v4) = v3[25] | ((_DWORD)v4 << 8);
    HIDWORD(v4) = v4 >> 24;
    LODWORD(v4) = v3[26] | ((_DWORD)v4 << 8);
    HIDWORD(v4) = v4 >> 24;
    LODWORD(v4) = v3[27] | ((_DWORD)v4 << 8);
    HIDWORD(v4) = v4 >> 24;
    LODWORD(v4) = v3[28] | ((_DWORD)v4 << 8);
    *(_DWORD *)&v39[(_DWORD)v3] = v3[29] | ((_DWORD)v4 << 8);
    *(_DWORD *)&v39[(_DWORD)v3 + 4] = v4 >> 24;
    v2 += 4;
    v3 += 32;
  }
  while ( v2 < 16 );
  v9 = v76;
  v48 = v76;
  v67 = 16;
  do
  {
    v10 = *((_DWORD *)v9 - 26);
    v11 = *((_DWORD *)v9 - 25);
    v12 = *(_DWORD *)v9;
    v13 = *((_DWORD *)v9 + 1);
    v71 = __PAIR64__(v11, v10);
    v14 = __PAIR64__(
            (v13 >> 6) ^ (__PAIR64__(v13, v12) >> 29) ^ ((v13 >> 19) | (v12 << 13)),
            (__PAIR64__(v13, v12) >> 6) ^ ((8 * v12) | (v13 >> 29)) ^ (__PAIR64__(v13, v12) >> 19))
        + __PAIR64__(
            (v11 >> 7) ^ (__SPAIR64__(v10, v11) >> 1) ^ (__SPAIR64__(v10, v11) >> 8),
            (__PAIR64__(v11, v10) >> 7) ^ (__PAIR64__(v11, v10) >> 1) ^ (__PAIR64__(v11, v10) >> 8));
    HIDWORD(v69) = *((_DWORD *)v48 - 23);
    v15 = HIDWORD(v69);
    v16 = *((_QWORD *)v48 - 5) + *((_QWORD *)v48 - 14) + v14;
    *((_DWORD *)v48 + 4) = v16;
    v17 = *((_DWORD *)v48 - 24);
    *((_DWORD *)v48 + 5) = HIDWORD(v16);
    v18 = *((_DWORD *)v48 + 2);
    v19 = *((_DWORD *)v48 + 3);
    LODWORD(v69) = v17;
    HIDWORD(v38) = (HIDWORD(v69) >> 7) ^ (__SPAIR64__(v17, v15) >> 1) ^ (__SPAIR64__(v17, v15) >> 8);
    LODWORD(v38) = (v69 >> 7) ^ (__PAIR64__(v15, v17) >> 1) ^ (__PAIR64__(v15, v17) >> 8);
    LODWORD(v68) = *((_DWORD *)v48 - 22);
    v20 = v71
        + *((_QWORD *)v48 - 4)
        + __PAIR64__(
            (v19 >> 6) ^ (__PAIR64__(v19, v18) >> 29) ^ ((v19 >> 19) | (v18 << 13)),
            (__PAIR64__(v19, v18) >> 6) ^ ((8 * v18) | (v19 >> 29)) ^ (__PAIR64__(v19, v18) >> 19))
        + v38;
    *((_DWORD *)v48 + 6) = v20;
    v21 = *((_DWORD *)v48 - 21);
    *((_DWORD *)v48 + 7) = HIDWORD(v20);
    HIDWORD(v68) = v21;
    v22 = *((_DWORD *)v48 + 4);
    v23 = *((_DWORD *)v48 + 5);
    LODWORD(v38) = (__PAIR64__(v23, v22) >> 6) ^ ((8 * v22) | (v23 >> 29)) ^ (__PAIR64__(v23, v22) >> 19);
    HIDWORD(v38) = (v23 >> 6) ^ (__PAIR64__(v23, v22) >> 29) ^ ((v23 >> 19) | (v22 << 13));
    LODWORD(v70) = *((_DWORD *)v48 - 20);
    v24 = v69
        + *((_QWORD *)v48 - 3)
        + __PAIR64__(
            (HIDWORD(v68) >> 7) ^ ((HIDWORD(v68) >> 1) | ((_DWORD)v68 << 31)) ^ ((HIDWORD(v68) >> 8) | ((_DWORD)v68 << 24)),
            (v68 >> 7) ^ (v68 >> 1) ^ (v68 >> 8))
        + v38;
    *((_DWORD *)v48 + 8) = v24;
    HIDWORD(v70) = *((_DWORD *)v48 - 19);
    LODWORD(v25) = *((_DWORD *)v48 + 6);
    *((_DWORD *)v48 + 9) = HIDWORD(v24);
    HIDWORD(v25) = *((_DWORD *)v48 + 7);
    LODWORD(v38) = (v25 >> 6) ^ ((8 * v25) | (HIDWORD(v25) >> 29)) ^ (v25 >> 19);
    HIDWORD(v38) = (HIDWORD(v25) >> 6) ^ (v25 >> 29) ^ ((HIDWORD(v25) >> 19) | ((_DWORD)v25 << 13));
    *((_QWORD *)v48 + 5) = v68
                         + *((_QWORD *)v48 - 2)
                         + __PAIR64__(
                             (HIDWORD(v70) >> 7) ^ ((HIDWORD(v70) >> 1) | ((_DWORD)v70 << 31)) ^ ((HIDWORD(v70) >> 8) | ((_DWORD)v70 << 24)),
                             (v70 >> 7) ^ (v70 >> 1) ^ (v70 >> 8))
                         + v38;
    v9 = v48 + 32;
    v26 = v67-- == 1;
    v48 += 32;
  }
  while ( !v26 );
  v49 = 0;
  do
  {
    v40 = v64
        + __PAIR64__(*(_DWORD *)&v72[v49 / 2 + 2], *(_DWORD *)&v72[v49 / 2])
        + __PAIR64__(dword_47BC14[v49 / 4], dword_47BC10[v49 / 4])
        + (v62 ^ v58 & (v62 ^ v60))
        + __PAIR64__(
            ((HIDWORD(v58) >> 14) | ((_DWORD)v58 << 18)) ^ ((HIDWORD(v58) >> 18) | ((_DWORD)v58 << 14)) ^ (v58 >> 9),
            (v58 >> 14) ^ (v58 >> 18) ^ (((_DWORD)v58 << 23) | (HIDWORD(v58) >> 9)));
    v57 = v40 + v56;
    HIDWORD(v27) = (v50 >> 7) ^ (v50 >> 2) ^ ((HIDWORD(v50) >> 28) | (16 * v50));
    LODWORD(v27) = (((_DWORD)v50 << 25) | (HIDWORD(v50) >> 7)) ^ (((_DWORD)v50 << 30) | (HIDWORD(v50) >> 2)) ^ (v50 >> 28);
    v65 = v40 + (v50 & v52 | v54 & (v50 | v52)) + v27;
    v41 = v62
        + __PAIR64__(*(_DWORD *)&v73[v49 + 6], *(_DWORD *)&v73[v49 + 2])
        + __PAIR64__(dword_47BC1C[v49 / 4], dword_47BC18[v49 / 4])
        + (v60 ^ v57 & (v58 ^ v60))
        + __PAIR64__(
            ((HIDWORD(v57) >> 14) | ((_DWORD)v57 << 18)) ^ ((HIDWORD(v57) >> 18) | ((_DWORD)v57 << 14)) ^ (v57 >> 9),
            (v57 >> 14) ^ (v57 >> 18) ^ (((_DWORD)v57 << 23) | (HIDWORD(v57) >> 9)));
    v55 = v41 + v54;
    HIDWORD(v28) = (v65 >> 7) ^ (v65 >> 2) ^ ((HIDWORD(v65) >> 28) | (16 * v65));
    LODWORD(v28) = v65 & v50 | v52 & (v65 | v50);
    LODWORD(v29) = (((_DWORD)v65 << 25) | (HIDWORD(v65) >> 7)) ^ (((_DWORD)v65 << 30) | (HIDWORD(v65) >> 2)) ^ (v65 >> 28);
    HIDWORD(v29) = HIDWORD(v65) & HIDWORD(v50) | HIDWORD(v52) & (HIDWORD(v65) | HIDWORD(v50));
    v63 = v41 + v28 + v29;
    v42 = v60
        + __PAIR64__(*(_DWORD *)&v74[v49 + 6], *(_DWORD *)&v74[v49 + 2])
        + __PAIR64__(dword_47BC24[v49 / 4], dword_47BC20[v49 / 4])
        + (v58 ^ v55 & (v58 ^ v57))
        + __PAIR64__(
            ((HIDWORD(v55) >> 14) | ((_DWORD)v55 << 18)) ^ ((HIDWORD(v55) >> 18) | ((_DWORD)v55 << 14)) ^ (v55 >> 9),
            (v55 >> 14) ^ (v55 >> 18) ^ (((_DWORD)v55 << 23) | (HIDWORD(v55) >> 9)));
    v53 = v42 + v52;
    HIDWORD(v28) = (v63 >> 7) ^ (v63 >> 2) ^ ((HIDWORD(v63) >> 28) | (16 * v63));
    LODWORD(v29) = (((_DWORD)v63 << 25) | (HIDWORD(v63) >> 7)) ^ (((_DWORD)v63 << 30) | (HIDWORD(v63) >> 2)) ^ (v63 >> 28);
    HIDWORD(v29) = HIDWORD(v65) & HIDWORD(v63) | HIDWORD(v50) & (HIDWORD(v65) | HIDWORD(v63));
    LODWORD(v28) = v65 & v63 | v50 & (v65 | v63);
    v61 = v42 + v28 + v29;
    v43 = v58
        + __PAIR64__(*(_DWORD *)&v75[v49 + 6], *(_DWORD *)&v75[v49 + 2])
        + __PAIR64__(dword_47BC2C[v49 / 4], dword_47BC28[v49 / 4])
        + (v57 ^ v53 & (v55 ^ v57))
        + __PAIR64__(
            ((HIDWORD(v53) >> 14) | ((_DWORD)v53 << 18)) ^ ((HIDWORD(v53) >> 18) | ((_DWORD)v53 << 14)) ^ (v53 >> 9),
            (v53 >> 14) ^ (v53 >> 18) ^ (((_DWORD)v53 << 23) | (HIDWORD(v53) >> 9)));
    v51 = v43 + v50;
    HIDWORD(v28) = (v61 >> 7) ^ (v61 >> 2) ^ ((HIDWORD(v61) >> 28) | (16 * v61));
    LODWORD(v28) = v63 & v61 | v65 & (v63 | v61);
    LODWORD(v29) = (((_DWORD)v61 << 25) | (HIDWORD(v61) >> 7)) ^ (((_DWORD)v61 << 30) | (HIDWORD(v61) >> 2)) ^ (v61 >> 28);
    HIDWORD(v29) = HIDWORD(v63) & HIDWORD(v61) | HIDWORD(v65) & (HIDWORD(v63) | HIDWORD(v61));
    v30 = v43 + v28 + v29;
    HIDWORD(v28) = (v43 + v28 + v29) >> 32;
    v59 = __PAIR64__(HIDWORD(v28), v30);
    v44 = v57
        + __PAIR64__(*(_DWORD *)&v75[v49 + 14], *(_DWORD *)&v75[v49 + 10])
        + __PAIR64__(dword_47BC34[v49 / 4], dword_47BC30[v49 / 4])
        + (v55 ^ v51 & (v53 ^ v55))
        + __PAIR64__(
            ((HIDWORD(v51) >> 14) | ((_DWORD)v51 << 18)) ^ ((HIDWORD(v51) >> 18) | ((_DWORD)v51 << 14)) ^ (v51 >> 9),
            (v51 >> 14) ^ (v51 >> 18) ^ (((_DWORD)v51 << 23) | (HIDWORD(v51) >> 9)));
    v64 = v44 + v65;
    HIDWORD(v27) = (v59 >> 7) ^ (__PAIR64__(HIDWORD(v28), v59) >> 2) ^ ((HIDWORD(v28) >> 28) | (16 * v59));
    LODWORD(v27) = (((_DWORD)v59 << 25) | (HIDWORD(v28) >> 7)) ^ (((_DWORD)v59 << 30) | (HIDWORD(v28) >> 2)) ^ (__PAIR64__(HIDWORD(v28), v59) >> 28);
    v31 = v44 + (v59 & v61 | v63 & (v59 | v61)) + v27;
    v56 = v31;
    v32 = v55
        + __PAIR64__(*(_DWORD *)&v75[v49 + 22], *(_DWORD *)&v75[v49 + 18])
        + __PAIR64__(dword_47BC3C[v49 / 4], dword_47BC38[v49 / 4])
        + (v53 ^ v64 & (v51 ^ v53))
        + __PAIR64__(
            ((HIDWORD(v64) >> 14) | ((_DWORD)v64 << 18)) ^ ((HIDWORD(v64) >> 18) | ((_DWORD)v64 << 14)) ^ (v64 >> 9),
            (v64 >> 14) ^ (v64 >> 18) ^ (((_DWORD)v64 << 23) | (HIDWORD(v64) >> 9)));
    v62 = v32 + v63;
    v54 = v32
        + (v59 & v31 | v61 & (v59 | v31))
        + __PAIR64__(
            (v31 >> 7) ^ (v31 >> 2) ^ ((HIDWORD(v31) >> 28) | (16 * v31)),
            (((_DWORD)v31 << 25) | (HIDWORD(v31) >> 7)) ^ (((_DWORD)v31 << 30) | (HIDWORD(v31) >> 2)) ^ (v31 >> 28));
    v45 = v53
        + __PAIR64__(*(_DWORD *)&v75[v49 + 30], *(_DWORD *)&v75[v49 + 26])
        + __PAIR64__(dword_47BC44[v49 / 4], dword_47BC40[v49 / 4])
        + (v51 ^ v62 & (v64 ^ v51))
        + __PAIR64__(
            ((HIDWORD(v62) >> 14) | ((_DWORD)v62 << 18)) ^ ((HIDWORD(v62) >> 18) | ((_DWORD)v62 << 14)) ^ (v62 >> 9),
            (v62 >> 14) ^ (v62 >> 18) ^ (((_DWORD)v62 << 23) | (HIDWORD(v62) >> 9)));
    v60 = v45 + v61;
    HIDWORD(v31) = (v54 >> 7) ^ (v54 >> 2) ^ ((HIDWORD(v54) >> 28) | (16 * v54));
    LODWORD(v31) = (((_DWORD)v54 << 25) | (HIDWORD(v54) >> 7)) ^ (((_DWORD)v54 << 30) | (HIDWORD(v54) >> 2)) ^ (v54 >> 28);
    v33 = v45 + (v54 & v56 | __PAIR64__(HIDWORD(v28), v30) & (v54 | v56)) + v31;
    v52 = v33;
    v46 = v51
        + __PAIR64__(*(_DWORD *)&v75[v49 + 38], *(_DWORD *)&v75[v49 + 34])
        + __PAIR64__(dword_47BC4C[v49 / 4], dword_47BC48[v49 / 4])
        + (v64 ^ v60 & (v64 ^ v62))
        + __PAIR64__(
            ((HIDWORD(v60) >> 14) | ((_DWORD)v60 << 18)) ^ ((HIDWORD(v60) >> 18) | ((_DWORD)v60 << 14)) ^ (v60 >> 9),
            (v60 >> 14) ^ (v60 >> 18) ^ (((_DWORD)v60 << 23) | (HIDWORD(v60) >> 9)));
    v58 = v46 + __PAIR64__(HIDWORD(v28), v30);
    v34 = v46
        + (v33 & v54 | v56 & (v33 | v54))
        + __PAIR64__(
            (v33 >> 7) ^ (v33 >> 2) ^ ((HIDWORD(v33) >> 28) | (16 * v33)),
            (((_DWORD)v33 << 25) | (HIDWORD(v33) >> 7)) ^ (((_DWORD)v33 << 30) | (HIDWORD(v33) >> 2)) ^ (v33 >> 28));
    v35 = (int)(v49 + 64) < 640;
    v50 = v34;
    v49 += 64;
  }
  while ( v35 );
  v36 = __CFADD__((_DWORD)v34, *(_DWORD *)(a2 + 8));
  *(_DWORD *)(a2 + 8) += v34;
  *(_DWORD *)(a2 + 12) += HIDWORD(v34) + v36;
  v36 = __CFADD__((_DWORD)v33, *(_DWORD *)(a2 + 16));
  *(_DWORD *)(a2 + 16) += v33;
  *(_DWORD *)(a2 + 20) += HIDWORD(v33) + v36;
  v36 = __CFADD__((_DWORD)v54, *(_DWORD *)(a2 + 24));
  *(_DWORD *)(a2 + 24) += v54;
  *(_DWORD *)(a2 + 28) += HIDWORD(v54) + v36;
  v36 = __CFADD__((_DWORD)v56, *(_DWORD *)(a2 + 32));
  *(_DWORD *)(a2 + 32) += v56;
  *(_DWORD *)(a2 + 36) += HIDWORD(v56) + v36;
  v36 = __CFADD__((_DWORD)v58, *(_DWORD *)(a2 + 40));
  *(_DWORD *)(a2 + 40) += v58;
  *(_DWORD *)(a2 + 44) += HIDWORD(v58) + v36;
  v36 = __CFADD__((_DWORD)v60, *(_DWORD *)(a2 + 48));
  *(_DWORD *)(a2 + 48) += v60;
  *(_DWORD *)(a2 + 52) += HIDWORD(v60) + v36;
  v36 = __CFADD__((_DWORD)v62, *(_DWORD *)(a2 + 56));
  *(_DWORD *)(a2 + 56) += v62;
  *(_DWORD *)(a2 + 60) += HIDWORD(v62) + v36;
  v36 = __CFADD__((_DWORD)v64, *(_DWORD *)(a2 + 64));
  *(_DWORD *)(a2 + 64) += v64;
  *(_DWORD *)(a2 + 68) += HIDWORD(v64) + v36;
  return 0;
}
// 47BC10: using guessed type int dword_47BC10[];
// 47BC14: using guessed type int dword_47BC14[];
// 47BC18: using guessed type int dword_47BC18[];
// 47BC1C: using guessed type int dword_47BC1C[];
// 47BC20: using guessed type int dword_47BC20[];
// 47BC24: using guessed type int dword_47BC24[];
// 47BC28: using guessed type int dword_47BC28[];
// 47BC2C: using guessed type int dword_47BC2C[];
// 47BC30: using guessed type int dword_47BC30[];
// 47BC34: using guessed type int dword_47BC34[];
// 47BC38: using guessed type int dword_47BC38[];
// 47BC3C: using guessed type int dword_47BC3C[];
// 47BC40: using guessed type int dword_47BC40[];
// 47BC44: using guessed type int dword_47BC44[];
// 47BC48: using guessed type int dword_47BC48[];
// 47BC4C: using guessed type int dword_47BC4C[];

//----- (0044A210) --------------------------------------------------------
int __cdecl sub_44A210(_DWORD *a1)
{
  a1[18] = 0;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = -205731576;
  a1[3] = 1779033703;
  a1[4] = -2067093701;
  a1[5] = -1150833019;
  a1[6] = -23791573;
  a1[7] = 1013904242;
  a1[8] = 1595750129;
  a1[9] = -1521486534;
  a1[10] = -1377402159;
  a1[11] = 1359893119;
  a1[12] = 725511199;
  a1[13] = -1694144372;
  a1[14] = -79577749;
  a1[15] = 528734635;
  a1[16] = 327033209;
  a1[17] = 1541459225;
  return 0;
}

//----- (0044A2A0) --------------------------------------------------------
int __cdecl sub_44A2A0(_DWORD *a1, char *Src, int a3)
{
  unsigned int v5; // ebx
  int v6; // eax
  int v7; // edx
  size_t v8; // edi
  bool v9; // cf

  if ( a1[18] > 0x80u )
    return 16;
  v5 = a3;
  if ( !a3 )
    return 0;
  while ( 1 )
  {
    v6 = a1[18];
    if ( v6 || v5 < 0x80 )
      break;
    sub_4490E0((int)Src, (int)a1);
    sub_413B90(0x2B4u);
    if ( v7 )
      return v7;
    *(_QWORD *)a1 += 1024i64;
    Src += 128;
    v5 -= 128;
LABEL_13:
    if ( !v5 )
      return 0;
  }
  v8 = 128 - v6;
  if ( v5 < 128 - v6 )
    v8 = v5;
  memcpy((char *)a1 + v6 + 76, Src, v8);
  a1[18] += v8;
  Src += v8;
  v5 -= v8;
  if ( a1[18] != 128 )
    goto LABEL_13;
  sub_4490E0((int)(a1 + 19), (int)a1);
  sub_413B90(0x2B4u);
  if ( !v7 )
  {
    v9 = __CFADD__(*a1, 1024);
    *a1 += 1024;
    a1[18] = 0;
    a1[1] += v9;
    goto LABEL_13;
  }
  return v7;
}
// 44A308: variable 'v7' is possibly undefined

//----- (0044A3B0) --------------------------------------------------------
int __cdecl sub_44A3B0(_DWORD *a1, int a2)
{
  unsigned int v2; // ecx
  __int64 v4; // rax
  bool v5; // cf
  unsigned int v6; // eax
  char v7; // al
  char v8; // cl
  char v9; // dl
  char v10; // al
  char v11; // dl
  char v12; // cl
  char v13; // al
  _BYTE *v14; // ecx
  char *v15; // eax
  int v16; // edi

  v2 = a1[18];
  if ( v2 >= 0x80 )
    return 16;
  v4 = 8i64 * v2;
  v5 = __CFADD__((_DWORD)v4, *a1);
  *a1 += v4;
  a1[1] += HIDWORD(v4) + v5;
  *((_BYTE *)a1 + v2 + 76) = 0x80;
  v6 = ++a1[18];
  if ( v6 > 0x70 )
  {
    for ( ; v6 < 0x80; v6 = a1[18] )
    {
      *((_BYTE *)a1 + v6 + 76) = 0;
      ++a1[18];
    }
    sub_4490E0((int)(a1 + 19), (int)a1);
    sub_413B90(0x2B4u);
    a1[18] = 0;
  }
  for ( ; a1[18] < 0x78u; ++a1[18] )
    *((_BYTE *)a1 + a1[18] + 76) = 0;
  v7 = *((_BYTE *)a1 + 6);
  v8 = *((_BYTE *)a1 + 5);
  *((_BYTE *)a1 + 196) = *((_BYTE *)a1 + 7);
  v9 = *((_BYTE *)a1 + 4);
  *((_BYTE *)a1 + 197) = v7;
  v10 = *((_BYTE *)a1 + 3);
  *((_BYTE *)a1 + 199) = v9;
  v11 = *((_BYTE *)a1 + 1);
  *((_BYTE *)a1 + 198) = v8;
  v12 = *((_BYTE *)a1 + 2);
  *((_BYTE *)a1 + 200) = v10;
  v13 = *(_BYTE *)a1;
  *((_BYTE *)a1 + 202) = v11;
  *((_BYTE *)a1 + 201) = v12;
  *((_BYTE *)a1 + 203) = v13;
  sub_4490E0((int)(a1 + 19), (int)a1);
  sub_413B90(0x2B4u);
  v14 = (_BYTE *)(a2 + 2);
  v15 = (char *)a1 + 14;
  v16 = 8;
  do
  {
    *(v14 - 2) = v15[1];
    *(v14 - 1) = *v15;
    *v14 = *(v15 - 1);
    v14[1] = *(v15 - 2);
    v14[2] = *(v15 - 3);
    v14[3] = *(v15 - 4);
    v14[4] = *(v15 - 5);
    v14[5] = *(v15 - 6);
    v15 += 8;
    v14 += 8;
    --v16;
  }
  while ( v16 );
  memset(a1, 0, 0xD0u);
  return 0;
}

//----- (0044A540) --------------------------------------------------------
int sub_44A540()
{
  return 2;
}

//----- (0044A550) --------------------------------------------------------
int __usercall sub_44A550@<eax>(int *a1@<eax>, _DWORD *a2)
{
  int v2; // ecx
  int v3; // edx
  int v4; // esi
  int v5; // eax
  int v6; // ecx
  int v7; // edx
  int v8; // esi
  int v9; // edi
  int v10; // ecx
  int v11; // edx
  int v12; // esi
  int v13; // edi
  int v14; // ecx
  int v15; // edx
  int v16; // esi
  int v17; // edi
  int v18; // ecx
  int v19; // ebx
  int v20; // edx
  int v21; // esi
  int v22; // ecx
  int v23; // edi
  int v24; // edx
  int v25; // esi
  int v26; // ecx
  int v27; // edi
  int v28; // edx
  int v29; // esi
  int v30; // ecx
  int v31; // edi
  int v32; // edx
  int v33; // esi
  int v34; // ecx
  int v35; // edi
  int v36; // eax
  int v37; // edx
  int v38; // ecx
  int v39; // edi
  int v40; // eax
  int v41; // edx
  int v42; // ecx
  int v43; // esi
  int v44; // eax
  int v45; // edx
  int v46; // ecx
  int v47; // esi
  int v48; // eax
  int v49; // edx
  int v50; // ecx
  int v51; // esi
  int v52; // edi
  int v53; // edx
  int v54; // ecx
  int v55; // esi
  int v56; // edi
  int v57; // edx
  int v58; // ecx
  int v59; // esi
  int v60; // edi
  int v61; // edx
  int v62; // ecx
  int v63; // esi
  int v64; // edi
  int v65; // edx
  int v66; // eax
  int v67; // esi
  int v68; // edi
  int v69; // edx
  int v71; // [esp+10h] [ebp-40h]
  int v72; // [esp+14h] [ebp-3Ch]
  int v73; // [esp+18h] [ebp-38h]
  int v74; // [esp+1Ch] [ebp-34h]
  int v75; // [esp+20h] [ebp-30h]
  int v76; // [esp+24h] [ebp-2Ch]
  int v77; // [esp+28h] [ebp-28h]
  int v78; // [esp+2Ch] [ebp-24h]
  int v79; // [esp+30h] [ebp-20h]
  int v80; // [esp+34h] [ebp-1Ch]
  int v81; // [esp+38h] [ebp-18h]
  int v82; // [esp+3Ch] [ebp-14h]
  int v83; // [esp+40h] [ebp-10h]
  int v84; // [esp+44h] [ebp-Ch]
  int v85; // [esp+48h] [ebp-8h]
  int v86; // [esp+4Ch] [ebp-4h]

  v72 = a1[1];
  v73 = a1[2];
  v74 = a1[3];
  v75 = a1[4];
  v2 = *a1;
  v76 = a1[5];
  v77 = a1[6];
  v78 = a1[7];
  v79 = a1[8];
  v80 = a1[9];
  v81 = a1[10];
  v82 = a1[11];
  v83 = a1[12];
  v84 = a1[13];
  v85 = a1[14];
  v3 = a2[5];
  v4 = a2[4];
  v86 = a1[15];
  v5 = a2[3];
  v71 = v2;
  v6 = v5 + __ROL4__(a2[2] + (v3 ^ v5 & (v4 ^ v3)) + v2 - 680876936, 7);
  v7 = v6 + __ROL4__(v72 + (v4 ^ v6 & (v5 ^ v4)) + v3 - 389564586, 12);
  v8 = v7 + __ROL4__(v73 + (v5 ^ v7 & (v6 ^ v5)) + v4 + 606105819, 17);
  v9 = v8 + __ROL4__(v74 + (v6 ^ v8 & (v6 ^ v7)) + v5 - 1044525330, 22);
  v10 = v9 + __ROL4__(v75 + (v7 ^ v9 & (v8 ^ v7)) + v6 - 176418897, 7);
  v11 = v10 + __ROL4__(v76 + (v8 ^ v10 & (v9 ^ v8)) + v7 + 1200080426, 12);
  v12 = v11 + __ROL4__(v77 + (v9 ^ v11 & (v10 ^ v9)) + v8 - 1473231341, 17);
  v13 = v12 + __ROL4__(v78 + (v10 ^ v12 & (v10 ^ v11)) + v9 - 45705983, 22);
  v14 = v13 + __ROL4__(v79 + (v11 ^ v13 & (v12 ^ v11)) + v10 + 1770035416, 7);
  v15 = v14 + __ROL4__(v80 + (v12 ^ v14 & (v13 ^ v12)) + v11 - 1958414417, 12);
  v16 = v15 + __ROL4__(v81 + (v13 ^ v15 & (v14 ^ v13)) + v12 - 42063, 17);
  v17 = v16 + __ROL4__(v82 + (v14 ^ v16 & (v14 ^ v15)) + v13 - 1990404162, 22);
  v18 = v17 + __ROL4__(v83 + (v15 ^ v17 & (v16 ^ v15)) + v14 + 1804603682, 7);
  v19 = v18 + __ROL4__(v84 + (v16 ^ v18 & (v17 ^ v16)) + v15 - 40341101, 12);
  v20 = v19 + __ROL4__(v85 + (v17 ^ v19 & (v18 ^ v17)) + v16 - 1502002290, 17);
  v21 = v20 + __ROL4__(v86 + (v18 ^ v20 & (v18 ^ v19)) + v17 + 1236535329, 22);
  v22 = v21 + __ROL4__(v72 + (v20 ^ v19 & (v21 ^ v20)) + v18 - 165796510, 5);
  v23 = v22 + __ROL4__(v77 + (v21 ^ v20 & (v22 ^ v21)) + v19 - 1069501632, 9);
  v24 = v23 + __ROL4__(v82 + (v22 ^ v21 & (v22 ^ v23)) + v20 + 643717713, 14);
  v25 = v24 + __ROL4__(v71 + (v23 ^ v22 & (v24 ^ v23)) + v21 - 373897302, 20);
  v26 = v25 + __ROL4__(v76 + (v24 ^ v23 & (v25 ^ v24)) + v22 - 701558691, 5);
  v27 = v26 + __ROL4__(v81 + (v25 ^ v24 & (v26 ^ v25)) + v23 + 38016083, 9);
  v28 = v27 + __ROL4__(v86 + (v26 ^ v25 & (v26 ^ v27)) + v24 - 660478335, 14);
  v29 = v28 + __ROL4__(v75 + (v27 ^ v26 & (v28 ^ v27)) + v25 - 405537848, 20);
  v30 = v29 + __ROL4__(v80 + (v28 ^ v27 & (v29 ^ v28)) + v26 + 568446438, 5);
  v31 = v30 + __ROL4__(v85 + (v29 ^ v28 & (v30 ^ v29)) + v27 - 1019803690, 9);
  v32 = v31 + __ROL4__(v74 + (v30 ^ v29 & (v30 ^ v31)) + v28 - 187363961, 14);
  v33 = v32 + __ROL4__(v79 + (v31 ^ v30 & (v32 ^ v31)) + v29 + 1163531501, 20);
  v34 = v33 + __ROL4__(v84 + (v32 ^ v31 & (v33 ^ v32)) + v30 - 1444681467, 5);
  v35 = v34 + __ROL4__(v73 + (v33 ^ v32 & (v34 ^ v33)) + v31 - 51403784, 9);
  v36 = v35 + __ROL4__(v78 + (v34 ^ v33 & (v34 ^ v35)) + v32 + 1735328473, 14);
  v37 = v36 + __ROL4__(v83 + (v35 ^ v34 & (v36 ^ v35)) + v33 - 1926607734, 20);
  v38 = v37 + __ROL4__(v76 + (v37 ^ v36 ^ v35) + v34 - 378558, 4);
  v39 = v38 + __ROL4__(v79 + (v38 ^ v37 ^ v36) + v35 - 2022574463, 11);
  v40 = v39 + __ROL4__(v82 + (v38 ^ v37 ^ v39) + v36 + 1839030562, 16);
  v41 = v40 + __ROL4__(v85 + (v38 ^ v40 ^ v39) + v37 - 35309556, 23);
  v42 = v41 + __ROL4__(v72 + (v41 ^ v40 ^ v39) + v38 - 1530992060, 4);
  v43 = v42 + __ROL4__(v75 + (v42 ^ v41 ^ v40) + v39 + 1272893353, 11);
  v44 = v43 + __ROL4__(v78 + (v42 ^ v41 ^ v43) + v40 - 155497632, 16);
  v45 = v44 + __ROL4__(v81 + (v42 ^ v44 ^ v43) + v41 - 1094730640, 23);
  v46 = v45 + __ROL4__(v84 + (v45 ^ v44 ^ v43) + v42 + 681279174, 4);
  v47 = v46 + __ROL4__(v71 + (v46 ^ v45 ^ v44) + v43 - 358537222, 11);
  v48 = v47 + __ROL4__(v74 + (v46 ^ v45 ^ v47) + v44 - 722521979, 16);
  v49 = v48 + __ROL4__(v77 + (v46 ^ v48 ^ v47) + v45 + 76029189, 23);
  v50 = v49 + __ROL4__(v80 + (v49 ^ v48 ^ v47) + v46 - 640364487, 4);
  v51 = v50 + __ROL4__(v83 + (v50 ^ v49 ^ v48) + v47 - 421815835, 11);
  v52 = v51 + __ROL4__(v86 + (v50 ^ v49 ^ v51) + v48 + 530742520, 16);
  v53 = v52 + __ROL4__(v73 + (v50 ^ v52 ^ v51) + v49 - 995338651, 23);
  v54 = v53 + __ROL4__(v71 + (v52 ^ (v53 | ~v51)) + v50 - 198630844, 6);
  v55 = v54 + __ROL4__(v78 + (v53 ^ (v54 | ~v52)) + v51 + 1126891415, 10);
  v56 = v55 + __ROL4__(v85 + (v54 ^ (v55 | ~v53)) + v52 - 1416354905, 15);
  v57 = v56 + __ROL4__(v76 + (v55 ^ (v56 | ~v54)) + v53 - 57434055, 21);
  v58 = v57 + __ROL4__(v83 + (v56 ^ (v57 | ~v55)) + v54 + 1700485571, 6);
  v59 = v58 + __ROL4__(v74 + (v57 ^ (v58 | ~v56)) + v55 - 1894986606, 10);
  v60 = v59 + __ROL4__(v81 + (v58 ^ (v59 | ~v57)) + v56 - 1051523, 15);
  v61 = v60 + __ROL4__(v72 + (v59 ^ (v60 | ~v58)) + v57 - 2054922799, 21);
  v62 = v61 + __ROL4__(v79 + (v60 ^ (v61 | ~v59)) + v58 + 1873313359, 6);
  v63 = v62 + __ROL4__(v86 + (v61 ^ (v62 | ~v60)) + v59 - 30611744, 10);
  v64 = v63 + __ROL4__(v77 + (v62 ^ (v63 | ~v61)) + v60 - 1560198380, 15);
  v65 = v64 + __ROL4__(v84 + (v63 ^ (v64 | ~v62)) + v61 + 1309151649, 21);
  v66 = v65 + __ROL4__(v75 + (v64 ^ (v65 | ~v63)) + v62 - 145523070, 6);
  v67 = v66 + __ROL4__(v82 + (v65 ^ (v66 | ~v64)) + v63 - 1120210379, 10);
  v68 = v67 + __ROL4__(v73 + (v66 ^ (v67 | ~v65)) + v64 + 718787259, 15);
  a2[2] += v66;
  v69 = a2[3] + __ROL4__(v80 + (v67 ^ (v68 | ~v66)) + v65 - 343485551, 21);
  a2[4] += v68;
  a2[5] += v67;
  a2[3] = v68 + v69;
  return 0;
}

//----- (0044ABE0) --------------------------------------------------------
int __cdecl sub_44ABE0(_DWORD *a1)
{
  a1[2] = 1732584193;
  a1[3] = -271733879;
  a1[4] = -1732584194;
  a1[5] = 271733878;
  a1[6] = 0;
  *a1 = 0;
  a1[1] = 0;
  return 0;
}

//----- (0044AC10) --------------------------------------------------------
int __cdecl sub_44AC10(_DWORD *a1, int *Src, int a3)
{
  unsigned int v5; // ebx
  int v6; // eax
  int v7; // edx
  size_t v8; // edi
  bool v9; // cf

  if ( a1[6] > 0x40u )
    return 16;
  v5 = a3;
  if ( !a3 )
    return 0;
  while ( 1 )
  {
    v6 = a1[6];
    if ( v6 || v5 < 0x40 )
      break;
    sub_44A550(Src, a1);
    sub_413B90(0x34u);
    if ( v7 )
      return v7;
    *(_QWORD *)a1 += 512i64;
    Src += 16;
    v5 -= 64;
LABEL_13:
    if ( !v5 )
      return 0;
  }
  v8 = 64 - v6;
  if ( v5 < 64 - v6 )
    v8 = v5;
  memcpy((char *)a1 + v6 + 28, Src, v8);
  a1[6] += v8;
  Src = (int *)((char *)Src + v8);
  v5 -= v8;
  if ( a1[6] != 64 )
    goto LABEL_13;
  sub_44A550(a1 + 7, a1);
  sub_413B90(0x34u);
  if ( !v7 )
  {
    v9 = __CFADD__(*a1, 512);
    *a1 += 512;
    a1[6] = 0;
    a1[1] += v9;
    goto LABEL_13;
  }
  return v7;
}
// 44AC72: variable 'v7' is possibly undefined

//----- (0044AD10) --------------------------------------------------------
int __cdecl sub_44AD10(_DWORD *a1, _DWORD *a2)
{
  unsigned int v2; // eax
  bool v4; // cf
  unsigned int v5; // eax
  char v6; // cl
  char v7; // dl
  char v8; // al
  char v9; // cl
  char v10; // al
  char v11; // dl
  char v12; // cl

  v2 = a1[6];
  if ( v2 >= 0x40 )
    return 16;
  v4 = __CFADD__(8 * v2, *a1);
  *a1 += 8 * v2;
  a1[1] += v4;
  *((_BYTE *)a1 + v2 + 28) = 0x80;
  v5 = ++a1[6];
  if ( v5 > 0x38 )
  {
    for ( ; v5 < 0x40; v5 = a1[6] )
    {
      *((_BYTE *)a1 + v5 + 28) = 0;
      ++a1[6];
    }
    sub_44A550(a1 + 7, a1);
    sub_413B90(0x34u);
    a1[6] = 0;
  }
  for ( ; a1[6] < 0x38u; ++a1[6] )
    *((_BYTE *)a1 + a1[6] + 28) = 0;
  v6 = *((_BYTE *)a1 + 6);
  v7 = *((_BYTE *)a1 + 5);
  *((_BYTE *)a1 + 91) = *((_BYTE *)a1 + 7);
  v8 = *((_BYTE *)a1 + 4);
  *((_BYTE *)a1 + 90) = v6;
  v9 = *((_BYTE *)a1 + 3);
  *((_BYTE *)a1 + 88) = v8;
  v10 = *((_BYTE *)a1 + 1);
  *((_BYTE *)a1 + 89) = v7;
  v11 = *((_BYTE *)a1 + 2);
  *((_BYTE *)a1 + 87) = v9;
  v12 = *(_BYTE *)a1;
  *((_BYTE *)a1 + 85) = v10;
  *((_BYTE *)a1 + 86) = v11;
  *((_BYTE *)a1 + 84) = v12;
  sub_44A550(a1 + 7, a1);
  sub_413B90(0x34u);
  *a2 = a1[2];
  a2[1] = a1[3];
  a2[2] = a1[4];
  a2[3] = a1[5];
  memset(a1, 0, 0xD0u);
  return 0;
}

//----- (0044AE30) --------------------------------------------------------
int __usercall sub_44AE30@<eax>(_DWORD *a1@<eax>, unsigned int a2)
{
  int v2; // ebp
  bool v5; // zf
  _DWORD *v6; // eax
  _DWORD *v7; // edi
  int v8; // eax
  int v9; // ecx
  int v10; // eax
  int v11; // ecx
  int v12; // eax
  unsigned int v13; // ecx
  _DWORD *v14; // eax
  _DWORD *v15; // edx
  bool v16; // sf
  int v17; // esi
  int v18; // edx

  v2 = a2;
  if ( !a1 )
    return -2;
  v5 = a1[8] == 0;
  a1[6] = 0;
  if ( v5 )
  {
    a1[8] = sub_44C020;
    a1[10] = 0;
  }
  if ( !a1[9] )
    a1[9] = sub_44C040;
  if ( a2 == -1 )
  {
    v2 = 6;
  }
  else if ( a2 > 9 )
  {
    return -2;
  }
  v6 = (_DWORD *)((int (__cdecl *)(_DWORD, int, int))a1[8])(a1[10], 1, 5816);
  v7 = v6;
  if ( !v6 )
    return -4;
  a1[7] = v6;
  *v6 = a1;
  v6[6] = 1;
  v6[10] = 15;
  v6[9] = 0x8000;
  v6[11] = 0x7FFF;
  v6[18] = 15;
  v6[17] = 0x8000;
  v6[19] = 0x7FFF;
  v6[20] = 5;
  v8 = ((int (__cdecl *)(_DWORD, int, int))a1[8])(a1[10], 0x8000, 2);
  v9 = v7[9];
  v7[12] = v8;
  v10 = ((int (__cdecl *)(_DWORD, int, int))a1[8])(a1[10], v9, 2);
  v11 = v7[17];
  v7[14] = v10;
  v7[15] = ((int (__cdecl *)(_DWORD, int, int))a1[8])(a1[10], v11, 2);
  v7[1445] = 0x4000;
  v12 = ((int (__cdecl *)(_DWORD, int, int))a1[8])(a1[10], 0x4000, 4);
  v13 = v7[1445];
  v5 = v7[12] == 0;
  v7[2] = v12;
  v7[3] = 4 * v13;
  if ( v5 || !v7[14] || !v7[15] || !v12 )
  {
    a1[6] = byte_47627C;
    sub_44B2E0((int)a1);
    return -4;
  }
  v7[1444] = v13 + v12 + 2 * v13;
  v7[31] = v2;
  v7[1447] = v12 + 2 * (v13 >> 1);
  v7[32] = 0;
  *((_BYTE *)v7 + 29) = 8;
  v14 = a1;
  if ( !a1 )
    return -2;
  v15 = (_DWORD *)a1[7];
  if ( !v15 || !a1[8] || !a1[9] )
    return -2;
  a1[5] = 0;
  a1[2] = 0;
  a1[6] = 0;
  a1[11] = 2;
  v16 = (int)v15[6] < 0;
  v17 = v15[2];
  v15[5] = 0;
  v15[4] = v17;
  if ( v16 )
    v15[6] = 0;
  v15[1] = v15[6] != 0 ? 113 : 42;
  v14[12] = 1;
  v15[8] = 0;
  sub_44C050(0, (int)v15);
  sub_44B3A0(v18);
  return 0;
}
// 44AFFA: variable 'v18' is possibly undefined

//----- (0044B010) --------------------------------------------------------
int __usercall sub_44B010@<eax>(int result@<eax>, __int16 a2@<cx>)
{
  int v2; // edi

  *(_BYTE *)(*(_DWORD *)(result + 8) + *(_DWORD *)(result + 20)) = HIBYTE(a2);
  v2 = *(_DWORD *)(result + 8);
  *(_BYTE *)(++*(_DWORD *)(result + 20) + v2) = a2;
  ++*(_DWORD *)(result + 20);
  return result;
}

//----- (0044B040) --------------------------------------------------------
int __usercall sub_44B040@<eax>(int a1@<eax>)
{
  int result; // eax
  size_t v3; // edi
  int v4; // eax
  _DWORD *v5; // esi

  result = *(_DWORD *)(a1 + 28);
  v3 = *(_DWORD *)(result + 20);
  if ( v3 > *(_DWORD *)(a1 + 16) )
    v3 = *(_DWORD *)(a1 + 16);
  if ( v3 )
  {
    memcpy(*(void **)(a1 + 12), *(const void **)(result + 16), v3);
    v4 = *(_DWORD *)(a1 + 28);
    *(_DWORD *)(a1 + 12) += v3;
    *(_DWORD *)(v4 + 16) += v3;
    *(_DWORD *)(a1 + 20) += v3;
    *(_DWORD *)(a1 + 16) -= v3;
    result = *(_DWORD *)(a1 + 28);
    *(_DWORD *)(result + 20) -= v3;
    v5 = *(_DWORD **)(a1 + 28);
    if ( !v5[5] )
      v5[4] = v5[2];
  }
  return result;
}

//----- (0044B090) --------------------------------------------------------
int __usercall sub_44B090@<eax>(int a1@<edi>, int a2)
{
  int v2; // esi
  int v3; // eax
  int v5; // ebx
  unsigned int v6; // eax
  unsigned int v7; // ecx
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  bool v13; // zf

  if ( !a1 )
    return -2;
  v2 = *(_DWORD *)(a1 + 28);
  if ( !v2 || (unsigned int)a2 > 4 )
    return -2;
  if ( !*(_DWORD *)(a1 + 12)
    || !*(_DWORD *)a1 && *(_DWORD *)(a1 + 4)
    || (v3 = *(_DWORD *)(v2 + 4), v3 == 666) && a2 != 4 )
  {
    *(_DWORD *)(a1 + 24) = byte_47627C;
    return -2;
  }
  if ( !*(_DWORD *)(a1 + 16) )
  {
    *(_DWORD *)(a1 + 24) = byte_47627C;
    return -5;
  }
  v5 = *(_DWORD *)(v2 + 32);
  *(_DWORD *)v2 = a1;
  *(_DWORD *)(v2 + 32) = a2;
  if ( v3 == 42 )
  {
    v6 = (*(_DWORD *)(v2 + 124) - 1) >> 1;
    if ( v6 > 3 )
      v6 = 3;
    v7 = (v6 << 6) | (((*(_DWORD *)(v2 + 40) - 8) << 12) + 2048);
    if ( *(_DWORD *)(v2 + 100) )
      v7 |= 0x20u;
    *(_DWORD *)(v2 + 4) = 113;
    v8 = sub_44B010(v2, 31 * (v7 / 0x1F + 1));
    if ( *(_DWORD *)(v2 + 100) )
    {
      v9 = sub_44B010(v8, *(_WORD *)(a1 + 50));
      sub_44B010(v9, *(_WORD *)(a1 + 48));
    }
    *(_DWORD *)(a1 + 48) = 1;
  }
  if ( *(_DWORD *)(v2 + 20) )
  {
    sub_44B040(a1);
    if ( !*(_DWORD *)(a1 + 16) )
    {
LABEL_21:
      *(_DWORD *)(v2 + 32) = -1;
      return 0;
    }
  }
  else if ( !*(_DWORD *)(a1 + 4) && a2 <= v5 && a2 != 4 )
  {
    goto LABEL_28;
  }
  v10 = *(_DWORD *)(v2 + 4);
  if ( v10 == 666 )
  {
    if ( *(_DWORD *)(a1 + 4) )
    {
LABEL_28:
      *(_DWORD *)(a1 + 24) = byte_47627C;
      return -5;
    }
LABEL_30:
    if ( !*(_DWORD *)(v2 + 108) && (!a2 || v10 == 666) )
      goto LABEL_44;
    goto LABEL_33;
  }
  if ( !*(_DWORD *)(a1 + 4) )
    goto LABEL_30;
LABEL_33:
  v11 = funcs_44B1F0[3 * *(_DWORD *)(v2 + 124)](v2, a2);
  if ( v11 == 2 || v11 == 3 )
    *(_DWORD *)(v2 + 4) = 666;
  if ( !v11 || v11 == 2 )
  {
    if ( *(_DWORD *)(a1 + 16) )
      return 0;
    *(_DWORD *)(v2 + 32) = -1;
    return 0;
  }
  if ( v11 == 1 )
  {
    if ( a2 == 1 )
    {
      sub_44D060(v2);
    }
    else
    {
      sub_44CFD0(v2, 0, 0, 0);
      if ( a2 == 3 )
      {
        *(_WORD *)(*(_DWORD *)(v2 + 60) + 2 * *(_DWORD *)(v2 + 68) - 2) = 0;
        memset(*(void **)(v2 + 60), 0, 2 * *(_DWORD *)(v2 + 68) - 2);
      }
    }
    sub_44B040(a1);
    if ( !*(_DWORD *)(a1 + 16) )
      goto LABEL_21;
  }
LABEL_44:
  if ( a2 != 4 )
    return 0;
  if ( *(_DWORD *)(v2 + 24) )
    return 1;
  v12 = sub_44B010(v2, *(_WORD *)(a1 + 50));
  sub_44B010(v12, *(_WORD *)(a1 + 48));
  sub_44B040(a1);
  v13 = *(_DWORD *)(v2 + 20) == 0;
  *(_DWORD *)(v2 + 24) = -1;
  return v13;
}
// 47BAD0: using guessed type int (__cdecl *funcs_44B1F0[3])(int, int);

//----- (0044B2E0) --------------------------------------------------------
unsigned int __usercall sub_44B2E0@<eax>(int a1@<esi>)
{
  int v1; // eax
  int v2; // edi
  int v4; // eax
  int v5; // edx
  int v6; // edx
  int v7; // edx

  if ( !a1 )
    return -2;
  v1 = *(_DWORD *)(a1 + 28);
  if ( !v1 )
    return -2;
  v2 = *(_DWORD *)(v1 + 4);
  if ( v2 != 42 && v2 != 113 && v2 != 666 )
    return -2;
  v4 = *(_DWORD *)(v1 + 8);
  if ( v4 )
    (*(void (__cdecl **)(_DWORD, int))(a1 + 36))(*(_DWORD *)(a1 + 40), v4);
  v5 = *(_DWORD *)(a1 + 28);
  if ( *(_DWORD *)(v5 + 60) )
    (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40), *(_DWORD *)(v5 + 60));
  v6 = *(_DWORD *)(a1 + 28);
  if ( *(_DWORD *)(v6 + 56) )
    (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40), *(_DWORD *)(v6 + 56));
  v7 = *(_DWORD *)(a1 + 28);
  if ( *(_DWORD *)(v7 + 48) )
    (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40), *(_DWORD *)(v7 + 48));
  (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40), *(_DWORD *)(a1 + 28));
  *(_DWORD *)(a1 + 28) = 0;
  return v2 != 113 ? 0 : 0xFFFFFFFD;
}

//----- (0044B3A0) --------------------------------------------------------
int __usercall sub_44B3A0@<eax>(int a1@<esi>)
{
  int v1; // ecx
  int v2; // edx
  int v3; // eax
  int v4; // edx
  int result; // eax

  v1 = *(_DWORD *)(a1 + 68);
  v2 = *(_DWORD *)(a1 + 60);
  *(_DWORD *)(a1 + 52) = 2 * *(_DWORD *)(a1 + 36);
  *(_WORD *)(v2 + 2 * v1 - 2) = 0;
  memset(*(void **)(a1 + 60), 0, 2 * *(_DWORD *)(a1 + 68) - 2);
  v3 = 6 * *(_DWORD *)(a1 + 124);
  *(_DWORD *)(a1 + 120) = (unsigned __int16)word_47BACA[v3];
  *(_DWORD *)(a1 + 132) = (unsigned __int16)word_47BAC8[v3];
  *(_DWORD *)(a1 + 136) = (unsigned __int16)word_47BACC[v3];
  v4 = (unsigned __int16)word_47BACE[v3];
  result = 2;
  *(_DWORD *)(a1 + 100) = 0;
  *(_DWORD *)(a1 + 84) = 0;
  *(_DWORD *)(a1 + 108) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 116) = v4;
  *(_DWORD *)(a1 + 112) = 2;
  *(_DWORD *)(a1 + 88) = 2;
  return result;
}
// 47BAC8: using guessed type __int16 word_47BAC8[];
// 47BACA: using guessed type __int16 word_47BACA[];
// 47BACC: using guessed type __int16 word_47BACC[];
// 47BACE: using guessed type __int16 word_47BACE[];

//----- (0044B430) --------------------------------------------------------
unsigned int __usercall sub_44B430@<eax>(unsigned int a1@<eax>, _DWORD *a2@<edi>)
{
  unsigned int v2; // edx
  unsigned int v3; // ebp
  int v4; // esi
  _BYTE *v5; // ecx
  _BYTE *v6; // esi
  _BYTE *v7; // edx
  char v8; // bl
  _BYTE *v9; // edx
  _BYTE *v10; // ecx
  _BYTE *v11; // edx
  char v12; // bl
  _BYTE *v13; // edx
  char v14; // bl
  _BYTE *v15; // edx
  char v16; // bl
  _BYTE *v17; // edx
  char v18; // bl
  _BYTE *v19; // edx
  char v20; // bl
  _BYTE *v21; // edx
  char v22; // bl
  _BYTE *v23; // edx
  char v24; // bl
  _BYTE *v25; // edx
  char v26; // bl
  int v27; // edx
  unsigned int result; // eax
  char v29; // [esp+Eh] [ebp-12h]
  char v30; // [esp+Fh] [ebp-11h]
  unsigned int v31; // [esp+10h] [ebp-10h]
  int v32; // [esp+14h] [ebp-Ch]
  unsigned int v33; // [esp+18h] [ebp-8h]

  v2 = a2[25];
  v3 = a2[28];
  v31 = a2[29];
  v32 = a2[34];
  v4 = a2[9];
  v5 = (_BYTE *)(v2 + a2[12]);
  if ( v2 <= v4 - 262 )
    v33 = 0;
  else
    v33 = v2 - v4 + 262;
  v29 = v5[v3 - 1];
  v6 = v5 + 258;
  v30 = v5[v3];
  if ( v3 >= a2[33] )
    v31 >>= 2;
  if ( (unsigned int)v32 > a2[27] )
    v32 = a2[27];
  do
  {
    v7 = (_BYTE *)(a1 + a2[12]);
    if ( v7[v3] == v30 && v7[v3 - 1] == v29 && *v7 == *v5 )
    {
      v8 = v7[1];
      v9 = v7 + 1;
      if ( v8 == v5[1] )
      {
        v10 = v5 + 2;
        v11 = v9 + 1;
        do
        {
          v12 = *++v10;
          v13 = v11 + 1;
          if ( v12 != *v13 )
            break;
          v14 = *++v10;
          v15 = v13 + 1;
          if ( v14 != *v15 )
            break;
          v16 = *++v10;
          v17 = v15 + 1;
          if ( v16 != *v17 )
            break;
          v18 = *++v10;
          v19 = v17 + 1;
          if ( v18 != *v19 )
            break;
          v20 = *++v10;
          v21 = v19 + 1;
          if ( v20 != *v21 )
            break;
          v22 = *++v10;
          v23 = v21 + 1;
          if ( v22 != *v23 )
            break;
          v24 = *++v10;
          v25 = v23 + 1;
          if ( v24 != *v25 )
            break;
          v26 = *++v10;
          v11 = v25 + 1;
          if ( v26 != *v11 )
            break;
        }
        while ( v10 < v6 );
        v27 = v10 - v6 + 258;
        v5 = v6 - 258;
        if ( v27 > (int)v3 )
        {
          a2[26] = a1;
          v3 = v27;
          if ( v27 >= v32 )
            break;
          v29 = v5[v27 - 1];
          v30 = v5[v27];
        }
      }
    }
    a1 = *(unsigned __int16 *)(a2[14] + 2 * (a1 & a2[11]));
    if ( a1 <= v33 )
      break;
    --v31;
  }
  while ( v31 );
  result = a2[27];
  if ( v3 <= result )
    return v3;
  return result;
}

//----- (0044B590) --------------------------------------------------------
void *__usercall sub_44B590@<eax>(int *a1@<esi>)
{
  size_t v1; // ebp
  void *result; // eax
  int v3; // ecx
  unsigned int v4; // edx
  int v5; // edi
  int v6; // eax
  _WORD *v7; // ecx
  unsigned int v8; // eax
  __int16 v9; // ax
  size_t v10; // edi
  _WORD *v11; // ecx
  unsigned int v12; // eax
  int v13; // edi
  size_t v14; // ebx
  int v15; // edx
  unsigned int v16; // edi
  int v17; // ecx
  unsigned __int8 *v18; // edx
  int v19; // eax
  unsigned int v20; // [esp+Ch] [ebp-4h]

  v1 = a1[9];
  do
  {
    result = (void *)a1[25];
    v3 = a1[27];
    v4 = a1[13] - (_DWORD)result - v3;
    v20 = v4;
    if ( v4 )
    {
      if ( v4 == -1 )
      {
        v4 = -2;
        goto LABEL_22;
      }
    }
    else if ( !result && !v3 )
    {
      v4 = v1;
      goto LABEL_22;
    }
    if ( (unsigned int)result >= a1[9] + v1 - 262 )
    {
      if ( v1 )
      {
        memcpy((void *)a1[12], (const void *)(a1[12] + v1), v1);
        v4 = v20;
      }
      v5 = a1[17];
      v6 = a1[15];
      a1[26] -= v1;
      a1[25] -= v1;
      a1[21] -= v1;
      v7 = (_WORD *)(v6 + 2 * v5);
      do
      {
        v8 = (unsigned __int16)*--v7;
        if ( v8 < v1 )
          v9 = 0;
        else
          v9 = v8 - v1;
        --v5;
        *v7 = v9;
      }
      while ( v5 );
      v10 = v1;
      v11 = (_WORD *)(a1[14] + 2 * v1);
      do
      {
        v12 = (unsigned __int16)*--v11;
        if ( v12 < v1 )
          result = 0;
        else
          result = (void *)(v12 - v1);
        --v10;
        *v11 = (_WORD)result;
      }
      while ( v10 );
      v4 += v1;
    }
LABEL_22:
    v13 = *a1;
    if ( !*(_DWORD *)(*a1 + 4) )
      break;
    result = (void *)(a1[25] + a1[12] + a1[27]);
    v14 = *(_DWORD *)(v13 + 4);
    if ( v14 > v4 )
      v14 = v4;
    if ( v14 )
    {
      v15 = *(_DWORD *)(v13 + 28);
      *(_DWORD *)(v13 + 4) -= v14;
      if ( !*(_DWORD *)(v15 + 24) )
        *(_DWORD *)(v13 + 48) = 0;
      result = memcpy(result, *(const void **)v13, v14);
      *(_DWORD *)v13 += v14;
      *(_DWORD *)(v13 + 8) += v14;
    }
    a1[27] += v14;
    v16 = a1[27];
    if ( v16 >= 3 )
    {
      v17 = a1[20];
      v18 = (unsigned __int8 *)(a1[25] + a1[12]);
      v19 = *v18;
      a1[16] = v19;
      result = (void *)(a1[19] & (v18[1] ^ (v19 << v17)));
      a1[16] = (int)result;
    }
  }
  while ( v16 < 0x106 && *(_DWORD *)(*a1 + 4) );
  return result;
}

//----- (0044B6D0) --------------------------------------------------------
int __cdecl sub_44B6D0(int *a1, int a2)
{
  int v2; // ebp
  unsigned int v3; // eax
  bool v4; // zf
  int v5; // ecx
  unsigned int v6; // edx
  unsigned int v7; // eax
  _BYTE *v8; // edx
  int v9; // edi
  int v10; // eax
  size_t v11; // ebx
  int v12; // eax
  _DWORD *v13; // edi
  int v14; // edx
  unsigned int v15; // eax
  _BYTE *v16; // ecx
  int v17; // edi
  int v18; // eax
  size_t v19; // ebx
  int v20; // eax
  _DWORD *v21; // edi
  int v23; // edi
  _BYTE *v24; // ecx
  int v25; // eax

  v2 = 0xFFFF;
  if ( (unsigned int)(a1[3] - 5) < 0xFFFF )
    v2 = a1[3] - 5;
  while ( 1 )
  {
    v3 = a1[27];
    if ( v3 <= 1 )
    {
      sub_44B590(a1);
      v3 = a1[27];
      if ( !v3 )
        break;
    }
    v4 = v3 + a1[25] == 0;
    a1[25] += v3;
    v5 = a1[21];
    v6 = a1[25];
    a1[27] = 0;
    v7 = v5 + v2;
    if ( !v4 && v6 < v7 )
      goto LABEL_36;
    a1[27] = v6 - v7;
    a1[25] = v7;
    if ( v5 < 0 )
      v8 = 0;
    else
      v8 = (_BYTE *)(v5 + a1[12]);
    sub_44D250(v2, (int)a1, 0, v8);
    v9 = *a1;
    a1[21] = a1[25];
    v10 = *(_DWORD *)(v9 + 28);
    v11 = *(_DWORD *)(v10 + 20);
    if ( v11 > *(_DWORD *)(v9 + 16) )
      v11 = *(_DWORD *)(v9 + 16);
    if ( v11 )
    {
      memcpy(*(void **)(v9 + 12), *(const void **)(v10 + 16), v11);
      v12 = *(_DWORD *)(v9 + 28);
      *(_DWORD *)(v9 + 12) += v11;
      *(_DWORD *)(v12 + 16) += v11;
      *(_DWORD *)(v9 + 20) += v11;
      *(_DWORD *)(v9 + 16) -= v11;
      *(_DWORD *)(*(_DWORD *)(v9 + 28) + 20) -= v11;
      v13 = *(_DWORD **)(v9 + 28);
      if ( !v13[5] )
        v13[4] = v13[2];
    }
    if ( *(_DWORD *)(*a1 + 16) )
    {
LABEL_36:
      v14 = a1[21];
      v15 = a1[25] - v14;
      if ( v15 < a1[9] - 262 )
        continue;
      if ( v14 < 0 )
        v16 = 0;
      else
        v16 = (_BYTE *)(v14 + a1[12]);
      sub_44D250(v15, (int)a1, 0, v16);
      v17 = *a1;
      a1[21] = a1[25];
      v18 = *(_DWORD *)(v17 + 28);
      v19 = *(_DWORD *)(v18 + 20);
      if ( v19 > *(_DWORD *)(v17 + 16) )
        v19 = *(_DWORD *)(v17 + 16);
      if ( v19 )
      {
        memcpy(*(void **)(v17 + 12), *(const void **)(v18 + 16), v19);
        v20 = *(_DWORD *)(v17 + 28);
        *(_DWORD *)(v17 + 12) += v19;
        *(_DWORD *)(v20 + 16) += v19;
        *(_DWORD *)(v17 + 20) += v19;
        *(_DWORD *)(v17 + 16) -= v19;
        *(_DWORD *)(*(_DWORD *)(v17 + 28) + 20) -= v19;
        v21 = *(_DWORD **)(v17 + 28);
        if ( !v21[5] )
          v21[4] = v21[2];
      }
      if ( *(_DWORD *)(*a1 + 16) )
        continue;
    }
    return 0;
  }
  if ( !a2 )
    return 0;
  v23 = a1[21];
  if ( v23 < 0 )
    v24 = 0;
  else
    v24 = (_BYTE *)(v23 + a1[12]);
  sub_44D250(a1[25] - v23, (int)a1, a2 == 4, v24);
  a1[21] = a1[25];
  sub_44B040(*a1);
  v25 = 0;
  if ( !*(_DWORD *)(*a1 + 16) )
    return a2 != 4 ? 0 : 2;
  LOBYTE(v25) = a2 == 4;
  return 2 * v25 + 1;
}

//----- (0044B8B0) --------------------------------------------------------
int __cdecl sub_44B8B0(int a1, int a2)
{
  unsigned int v2; // ebx
  unsigned int v3; // eax
  int v4; // edx
  int v5; // eax
  int v6; // ecx
  unsigned __int8 v7; // al
  __int16 v8; // cx
  unsigned __int16 v9; // cx
  int v10; // eax
  unsigned int v11; // eax
  BOOL v12; // ecx
  BOOL v13; // edi
  int v14; // edx
  int v15; // eax
  int v16; // edx
  int v17; // ecx
  int v18; // eax
  unsigned __int8 *v20; // edx
  int v21; // ecx
  int v22; // eax
  unsigned __int8 v23; // al
  BOOL v24; // eax
  int v25; // edx
  _BYTE *v26; // ecx
  int v27; // edi
  int v28; // eax
  size_t v29; // ebp
  int v30; // eax
  _DWORD *v31; // edi
  int v33; // edi
  _BYTE *v34; // ecx
  int v35; // eax

  v2 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 108);
    if ( v3 < 0x106 )
    {
      sub_44B590((int *)a1);
      v3 = *(_DWORD *)(a1 + 108);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 100);
      v5 = *(_DWORD *)(a1 + 76) & (*(unsigned __int8 *)(*(_DWORD *)(a1 + 48) + v4 + 2) ^ (*(_DWORD *)(a1 + 64) << *(_DWORD *)(a1 + 80)));
      v6 = *(_DWORD *)(a1 + 60);
      *(_DWORD *)(a1 + 64) = v5;
      v2 = *(unsigned __int16 *)(v6 + 2 * v5);
      *(_WORD *)(*(_DWORD *)(a1 + 56) + 2 * (v4 & *(_DWORD *)(a1 + 44))) = v2;
      *(_WORD *)(*(_DWORD *)(a1 + 60) + 2 * *(_DWORD *)(a1 + 64)) = *(_WORD *)(a1 + 100);
    }
    if ( v2 && *(_DWORD *)(a1 + 100) - v2 <= *(_DWORD *)(a1 + 36) - 262 && *(_DWORD *)(a1 + 128) != 2 )
      *(_DWORD *)(a1 + 88) = sub_44B430(v2, (_DWORD *)a1);
    if ( *(_DWORD *)(a1 + 88) < 3u )
    {
      v23 = *(_BYTE *)(*(_DWORD *)(a1 + 100) + *(_DWORD *)(a1 + 48));
      *(_WORD *)(*(_DWORD *)(a1 + 5788) + 2 * *(_DWORD *)(a1 + 5784)) = 0;
      *(_BYTE *)(*(_DWORD *)(a1 + 5776) + (*(_DWORD *)(a1 + 5784))++) = v23;
      ++*(_WORD *)(a1 + 4 * v23 + 140);
      v24 = *(_DWORD *)(a1 + 5784) == *(_DWORD *)(a1 + 5780) - 1;
      --*(_DWORD *)(a1 + 108);
      ++*(_DWORD *)(a1 + 100);
      v13 = v24;
    }
    else
    {
      v7 = *(_BYTE *)(a1 + 88);
      v8 = *(_WORD *)(a1 + 100) - *(_WORD *)(a1 + 104);
      *(_WORD *)(*(_DWORD *)(a1 + 5788) + 2 * *(_DWORD *)(a1 + 5784)) = v8;
      v7 -= 3;
      *(_BYTE *)(*(_DWORD *)(a1 + 5776) + (*(_DWORD *)(a1 + 5784))++) = v7;
      ++*(_WORD *)(a1 + 4 * (unsigned __int8)byte_47B8D8[v7] + 1168);
      v9 = v8 - 1;
      if ( v9 >= 0x100u )
        v10 = (unsigned __int8)byte_47B7D8[v9 >> 7];
      else
        v10 = (unsigned __int8)byte_47B6D8[v9];
      ++*(_WORD *)(a1 + 4 * v10 + 2432);
      v11 = *(_DWORD *)(a1 + 88);
      v12 = *(_DWORD *)(a1 + 5784) == *(_DWORD *)(a1 + 5780) - 1;
      *(_DWORD *)(a1 + 108) -= v11;
      v13 = v12;
      if ( v11 > *(_DWORD *)(a1 + 120) || *(_DWORD *)(a1 + 108) < 3u )
      {
        *(_DWORD *)(a1 + 100) += v11;
        v20 = (unsigned __int8 *)(*(_DWORD *)(a1 + 100) + *(_DWORD *)(a1 + 48));
        v21 = *(_DWORD *)(a1 + 80);
        *(_DWORD *)(a1 + 88) = 0;
        v22 = *v20;
        *(_DWORD *)(a1 + 64) = v22;
        *(_DWORD *)(a1 + 64) = *(_DWORD *)(a1 + 76) & (v20[1] ^ (v22 << v21));
      }
      else
      {
        *(_DWORD *)(a1 + 88) = v11 - 1;
        do
        {
          v14 = ++*(_DWORD *)(a1 + 100);
          v15 = *(unsigned __int8 *)(v14 + *(_DWORD *)(a1 + 48) + 2);
          v16 = *(_DWORD *)(a1 + 44) & v14;
          v17 = *(_DWORD *)(a1 + 60);
          v18 = *(_DWORD *)(a1 + 76) & ((*(_DWORD *)(a1 + 64) << *(_DWORD *)(a1 + 80)) ^ v15);
          *(_DWORD *)(a1 + 64) = v18;
          v2 = *(unsigned __int16 *)(v17 + 2 * v18);
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 2 * v16) = v2;
          *(_WORD *)(*(_DWORD *)(a1 + 60) + 2 * *(_DWORD *)(a1 + 64)) = *(_WORD *)(a1 + 100);
        }
        while ( (*(_DWORD *)(a1 + 88))-- != 1 );
        ++*(_DWORD *)(a1 + 100);
      }
    }
    if ( v13 )
    {
      v25 = *(_DWORD *)(a1 + 84);
      if ( v25 < 0 )
        v26 = 0;
      else
        v26 = (_BYTE *)(v25 + *(_DWORD *)(a1 + 48));
      sub_44D250(*(_DWORD *)(a1 + 100) - v25, a1, 0, v26);
      v27 = *(_DWORD *)a1;
      *(_DWORD *)(a1 + 84) = *(_DWORD *)(a1 + 100);
      v28 = *(_DWORD *)(v27 + 28);
      v29 = *(_DWORD *)(v28 + 20);
      if ( v29 > *(_DWORD *)(v27 + 16) )
        v29 = *(_DWORD *)(v27 + 16);
      if ( v29 )
      {
        memcpy(*(void **)(v27 + 12), *(const void **)(v28 + 16), v29);
        v30 = *(_DWORD *)(v27 + 28);
        *(_DWORD *)(v27 + 12) += v29;
        *(_DWORD *)(v30 + 16) += v29;
        *(_DWORD *)(v27 + 20) += v29;
        *(_DWORD *)(v27 + 16) -= v29;
        *(_DWORD *)(*(_DWORD *)(v27 + 28) + 20) -= v29;
        v31 = *(_DWORD **)(v27 + 28);
        if ( !v31[5] )
          v31[4] = v31[2];
      }
      if ( !*(_DWORD *)(*(_DWORD *)a1 + 16) )
        return 0;
    }
  }
  v33 = *(_DWORD *)(a1 + 84);
  if ( v33 < 0 )
    v34 = 0;
  else
    v34 = (_BYTE *)(v33 + *(_DWORD *)(a1 + 48));
  sub_44D250(*(_DWORD *)(a1 + 100) - v33, a1, a2 == 4, v34);
  *(_DWORD *)(a1 + 84) = *(_DWORD *)(a1 + 100);
  sub_44B040(*(_DWORD *)a1);
  v35 = 0;
  if ( !*(_DWORD *)(*(_DWORD *)a1 + 16) )
    return a2 != 4 ? 0 : 2;
  LOBYTE(v35) = a2 == 4;
  return 2 * v35 + 1;
}

//----- (0044BBE0) --------------------------------------------------------
int __cdecl sub_44BBE0(int *a1, int a2)
{
  unsigned int v2; // eax
  int v3; // edx
  int v4; // eax
  int v5; // ecx
  unsigned int v6; // eax
  int v7; // ecx
  unsigned int v8; // eax
  unsigned int v9; // eax
  int v10; // ecx
  unsigned int v11; // edi
  unsigned __int8 v12; // al
  unsigned __int16 v13; // cx
  int v14; // eax
  int v15; // eax
  BOOL v16; // ebx
  unsigned int v17; // edx
  int v18; // eax
  int v19; // ecx
  unsigned int v20; // eax
  int v21; // eax
  int v22; // edx
  _BYTE *v23; // ecx
  int v24; // edi
  int v25; // eax
  size_t v26; // ebx
  int v27; // eax
  _DWORD *v28; // edi
  bool v29; // zf
  unsigned __int8 v31; // al
  int v32; // edx
  _BYTE *v33; // ecx
  int v34; // edi
  int v35; // eax
  size_t v36; // ebx
  int v37; // eax
  _DWORD *v38; // edi
  int v39; // eax
  unsigned __int8 v40; // al
  int v41; // edi
  _BYTE *v42; // ecx
  int v43; // eax
  unsigned int v44; // [esp+10h] [ebp-4h]

  v44 = 0;
  while ( 1 )
  {
    v2 = a1[27];
    if ( v2 < 0x106 )
    {
      sub_44B590(a1);
      v2 = a1[27];
      if ( v2 < 0x106 && !a2 )
        return 0;
      if ( !v2 )
        break;
    }
    if ( v2 >= 3 )
    {
      v3 = a1[25];
      v4 = a1[19] & (*(unsigned __int8 *)(a1[12] + v3 + 2) ^ (a1[16] << a1[20]));
      v5 = a1[15];
      a1[16] = v4;
      v6 = *(unsigned __int16 *)(v5 + 2 * v4);
      *(_WORD *)(a1[14] + 2 * (v3 & a1[11])) = v6;
      v44 = v6;
      *(_WORD *)(a1[15] + 2 * a1[16]) = *((_WORD *)a1 + 50);
    }
    v7 = a1[26];
    a1[28] = a1[22];
    a1[23] = v7;
    a1[22] = 2;
    if ( v44 && a1[28] < (unsigned int)a1[30] && a1[25] - v44 <= a1[9] - 262 )
    {
      if ( a1[32] != 2 )
        a1[22] = sub_44B430(v44, a1);
      v8 = a1[22];
      if ( v8 <= 5 && (a1[32] == 1 || v8 == 3 && (unsigned int)(a1[25] - a1[26]) > 0x1000) )
        a1[22] = 2;
    }
    v9 = a1[28];
    if ( v9 < 3 || a1[22] > v9 )
    {
      if ( a1[24] )
      {
        v31 = *(_BYTE *)(a1[25] + a1[12] - 1);
        *(_WORD *)(a1[1447] + 2 * a1[1446]) = 0;
        *(_BYTE *)(a1[1444] + a1[1446]++) = v31;
        ++LOWORD(a1[v31 + 35]);
        if ( a1[1446] == a1[1445] - 1 )
        {
          v32 = a1[21];
          if ( v32 < 0 )
            v33 = 0;
          else
            v33 = (_BYTE *)(v32 + a1[12]);
          sub_44D250(a1[25] - v32, (int)a1, 0, v33);
          v34 = *a1;
          a1[21] = a1[25];
          v35 = *(_DWORD *)(v34 + 28);
          v36 = *(_DWORD *)(v35 + 20);
          if ( v36 > *(_DWORD *)(v34 + 16) )
            v36 = *(_DWORD *)(v34 + 16);
          if ( v36 )
          {
            memcpy(*(void **)(v34 + 12), *(const void **)(v35 + 16), v36);
            v37 = *(_DWORD *)(v34 + 28);
            *(_DWORD *)(v34 + 12) += v36;
            *(_DWORD *)(v37 + 16) += v36;
            *(_DWORD *)(v34 + 20) += v36;
            *(_DWORD *)(v34 + 16) -= v36;
            *(_DWORD *)(*(_DWORD *)(v34 + 28) + 20) -= v36;
            v38 = *(_DWORD **)(v34 + 28);
            if ( !v38[5] )
              v38[4] = v38[2];
          }
        }
        v39 = *a1;
        ++a1[25];
        --a1[27];
        v29 = *(_DWORD *)(v39 + 16) == 0;
        goto LABEL_37;
      }
      ++a1[25];
      --a1[27];
      a1[24] = 1;
    }
    else
    {
      v10 = a1[25];
      v11 = v10 + a1[27] - 3;
      LOWORD(v10) = v10 - *((_WORD *)a1 + 46) - 1;
      *(_WORD *)(a1[1447] + 2 * a1[1446]) = v10;
      v12 = v9 - 3;
      *(_BYTE *)(a1[1444] + a1[1446]++) = v12;
      ++LOWORD(a1[(unsigned __int8)byte_47B8D8[v12] + 292]);
      v13 = v10 - 1;
      if ( v13 >= 0x100u )
        v14 = (unsigned __int8)byte_47B7D8[v13 >> 7];
      else
        v14 = (unsigned __int8)byte_47B6D8[v13];
      ++LOWORD(a1[v14 + 608]);
      v15 = a1[28];
      v16 = a1[1446] == a1[1445] - 1;
      a1[27] += 1 - v15;
      a1[28] = v15 - 2;
      do
      {
        v17 = ++a1[25];
        if ( v17 <= v11 )
        {
          v18 = a1[19] & (*(unsigned __int8 *)(a1[12] + v17 + 2) ^ (a1[16] << a1[20]));
          v19 = a1[15];
          a1[16] = v18;
          v20 = *(unsigned __int16 *)(v19 + 2 * v18);
          *(_WORD *)(a1[14] + 2 * (v17 & a1[11])) = v20;
          v44 = v20;
          *(_WORD *)(a1[15] + 2 * a1[16]) = *((_WORD *)a1 + 50);
        }
        v29 = a1[28]-- == 1;
      }
      while ( !v29 );
      v21 = ++a1[25];
      a1[24] = 0;
      a1[22] = 2;
      if ( v16 )
      {
        v22 = a1[21];
        if ( v22 < 0 )
          v23 = 0;
        else
          v23 = (_BYTE *)(v22 + a1[12]);
        sub_44D250(v21 - v22, (int)a1, 0, v23);
        v24 = *a1;
        a1[21] = a1[25];
        v25 = *(_DWORD *)(v24 + 28);
        v26 = *(_DWORD *)(v25 + 20);
        if ( v26 > *(_DWORD *)(v24 + 16) )
          v26 = *(_DWORD *)(v24 + 16);
        if ( v26 )
        {
          memcpy(*(void **)(v24 + 12), *(const void **)(v25 + 16), v26);
          v27 = *(_DWORD *)(v24 + 28);
          *(_DWORD *)(v24 + 12) += v26;
          *(_DWORD *)(v27 + 16) += v26;
          *(_DWORD *)(v24 + 20) += v26;
          *(_DWORD *)(v24 + 16) -= v26;
          *(_DWORD *)(*(_DWORD *)(v24 + 28) + 20) -= v26;
          v28 = *(_DWORD **)(v24 + 28);
          if ( !v28[5] )
            v28[4] = v28[2];
        }
        v29 = *(_DWORD *)(*a1 + 16) == 0;
LABEL_37:
        if ( v29 )
          return 0;
      }
    }
  }
  if ( a1[24] )
  {
    v40 = *(_BYTE *)(a1[25] + a1[12] - 1);
    *(_WORD *)(a1[1447] + 2 * a1[1446]) = 0;
    *(_BYTE *)(a1[1444] + a1[1446]++) = v40;
    ++LOWORD(a1[v40 + 35]);
    a1[24] = 0;
  }
  v41 = a1[21];
  if ( v41 < 0 )
    v42 = 0;
  else
    v42 = (_BYTE *)(v41 + a1[12]);
  sub_44D250(a1[25] - v41, (int)a1, a2 == 4, v42);
  a1[21] = a1[25];
  sub_44B040(*a1);
  v43 = 0;
  if ( !*(_DWORD *)(*a1 + 16) )
    return a2 != 4 ? 0 : 2;
  LOBYTE(v43) = a2 == 4;
  return 2 * v43 + 1;
}

//----- (0044C020) --------------------------------------------------------
void *__cdecl sub_44C020(int a1, size_t Count, size_t Size)
{
  return calloc(Count, Size);
}

//----- (0044C040) --------------------------------------------------------
void __cdecl sub_44C040(int a1, void *Block)
{
  free(Block);
}

//----- (0044C050) --------------------------------------------------------
int __fastcall sub_44C050(int a1, int a2)
{
  *(_DWORD *)(a2 + 2832) = a2 + 140;
  *(_DWORD *)(a2 + 2844) = a2 + 2432;
  *(_DWORD *)(a2 + 2840) = &off_494600;
  *(_DWORD *)(a2 + 2852) = &off_494614;
  *(_DWORD *)(a2 + 2856) = a2 + 2676;
  *(_DWORD *)(a2 + 2864) = &unk_494628;
  *(_WORD *)(a2 + 5808) = 0;
  *(_DWORD *)(a2 + 5812) = 0;
  *(_DWORD *)(a2 + 5804) = 8;
  return sub_44C0B0(0, a2);
}
// 494600: using guessed type void *off_494600;
// 494614: using guessed type void *off_494614;

//----- (0044C0B0) --------------------------------------------------------
int __fastcall sub_44C0B0(int a1, int a2)
{
  _WORD *v2; // eax
  int v3; // ecx
  _WORD *v4; // eax
  int v5; // ecx
  _WORD *v6; // eax
  int v7; // ecx
  int result; // eax

  v2 = (_WORD *)(a2 + 140);
  v3 = 286;
  do
  {
    *v2 = 0;
    v2 += 2;
    --v3;
  }
  while ( v3 );
  v4 = (_WORD *)(a2 + 2432);
  v5 = 30;
  do
  {
    *v4 = 0;
    v4 += 2;
    --v5;
  }
  while ( v5 );
  v6 = (_WORD *)(a2 + 2676);
  v7 = 19;
  do
  {
    *v6 = 0;
    v6 += 2;
    --v7;
  }
  while ( v7 );
  *(_WORD *)(a2 + 1164) = 1;
  result = 0;
  *(_DWORD *)(a2 + 5796) = 0;
  *(_DWORD *)(a2 + 5792) = 0;
  *(_DWORD *)(a2 + 5800) = 0;
  *(_DWORD *)(a2 + 5784) = 0;
  return result;
}

//----- (0044C130) --------------------------------------------------------
int __usercall sub_44C130@<eax>(int result@<eax>, int a2@<edi>, int a3)
{
  int v3; // edx
  int v4; // ebp
  int v5; // ecx
  bool v6; // cc
  int v7; // esi
  int v8; // ebp
  unsigned __int16 v9; // dx
  unsigned __int16 v10; // bx
  int v11; // esi
  unsigned __int16 v12; // dx
  unsigned __int16 v13; // bx
  int v14; // edx
  int v15; // [esp+8h] [ebp-4h]

  v3 = *(_DWORD *)(result + 5192);
  v4 = *(_DWORD *)(result + 4 * a3 + 2900);
  v5 = 2 * a3;
  v6 = 2 * a3 < v3;
  v15 = v4;
  if ( 2 * a3 > v3 )
  {
    *(_DWORD *)(result + 4 * a3 + 2900) = v4;
  }
  else
  {
    while ( 1 )
    {
      if ( v6 )
      {
        v7 = *(_DWORD *)(result + 4 * v5 + 2904);
        v8 = *(_DWORD *)(result + 4 * v5 + 2900);
        v9 = *(_WORD *)(a2 + 4 * v7);
        v10 = *(_WORD *)(a2 + 4 * v8);
        if ( v9 < v10 || v9 == v10 && *(_BYTE *)(v7 + result + 5200) <= *(_BYTE *)(result + v8 + 5200) )
          ++v5;
        v4 = v15;
      }
      v11 = *(_DWORD *)(result + 4 * v5 + 2900);
      v12 = *(_WORD *)(a2 + 4 * v4);
      v13 = *(_WORD *)(a2 + 4 * v11);
      if ( v12 < v13 )
      {
LABEL_12:
        *(_DWORD *)(result + 4 * a3 + 2900) = v4;
        return result;
      }
      if ( v12 == v13 && *(_BYTE *)(result + v4 + 5200) <= *(_BYTE *)(v11 + result + 5200) )
        break;
      *(_DWORD *)(result + 4 * a3 + 2900) = v11;
      v14 = *(_DWORD *)(result + 5192);
      a3 = v5;
      v5 *= 2;
      v6 = v5 < v14;
      if ( v5 > v14 )
        goto LABEL_12;
    }
    *(_DWORD *)(result + 4 * a3 + 2900) = v4;
  }
  return result;
}

//----- (0044C200) --------------------------------------------------------
_DWORD *__usercall sub_44C200@<eax>(_DWORD *result@<eax>, int *a2@<ecx>)
{
  int v2; // edx
  int v3; // ebx
  int *v4; // ecx
  int v5; // ebp
  int v6; // esi
  int v7; // edi
  int v8; // ecx
  int v9; // edx
  int v10; // edi
  int v11; // edx
  int v12; // ecx
  int v13; // esi
  int v14; // edi
  int v15; // ebp
  _WORD *v16; // esi
  int v17; // ecx
  _WORD *i; // edx
  int v19; // edx
  int v20; // esi
  int v21; // ebp
  int v22; // ecx
  int v23; // edi
  int v24; // [esp+10h] [ebp-20h]
  int *v25; // [esp+14h] [ebp-1Ch]
  int v26; // [esp+18h] [ebp-18h]
  int v27; // [esp+1Ch] [ebp-14h]
  int v28; // [esp+1Ch] [ebp-14h]
  int v29; // [esp+20h] [ebp-10h]
  int v30; // [esp+20h] [ebp-10h]
  int v31; // [esp+24h] [ebp-Ch]
  int v32; // [esp+28h] [ebp-8h]
  int v33; // [esp+2Ch] [ebp-4h]

  v2 = a2[1];
  v3 = *a2;
  v4 = (int *)a2[2];
  v31 = v2;
  v5 = *v4;
  v33 = v4[1];
  v6 = v4[4];
  v32 = v4[2];
  result[717] = 0;
  result[718] = 0;
  result[719] = 0;
  result[720] = 0;
  result[721] = 0;
  result[722] = 0;
  result[723] = 0;
  result[724] = 0;
  *(_WORD *)(v3 + 4 * result[result[1299] + 725] + 2) = 0;
  v7 = result[1299] + 1;
  v27 = v6;
  v26 = 0;
  if ( v7 < 573 )
  {
    v8 = 573 - v7;
    v9 = (int)&result[v7 + 725];
    v10 = 573;
    v25 = (int *)v9;
    v29 = v8;
    v24 = 573;
    while ( 1 )
    {
      v11 = *v25;
      v12 = *(unsigned __int16 *)(v3 + 4 * *(unsigned __int16 *)(v3 + 4 * *v25 + 2) + 2) + 1;
      if ( v12 > v6 )
      {
        ++v26;
        v12 = v6;
      }
      *(_WORD *)(v3 + 4 * v11 + 2) = v12;
      if ( v11 <= v31 )
      {
        ++*((_WORD *)result + v12 + 1434);
        v13 = 0;
        if ( v11 >= v32 )
          v13 = *(_DWORD *)(v33 + 4 * (v11 - v32));
        v14 = *(unsigned __int16 *)(v3 + 4 * v11);
        result[1448] += v14 * (v13 + v12);
        if ( v5 )
          result[1449] += v14 * (v13 + *(unsigned __int16 *)(v5 + 4 * v11 + 2));
        v10 = 573;
      }
      ++v25;
      if ( !--v29 )
        break;
      v6 = v27;
    }
    v15 = v26;
    if ( v26 )
    {
      v16 = (_WORD *)result + v27 + 1434;
      do
      {
        v17 = v27 - 1;
        for ( i = (_WORD *)result + v27 + 1433; !*i; --v17 )
          --i;
        *((_WORD *)result + v17 + 1435) += 2;
        --*((_WORD *)result + v17 + 1434);
        --*v16;
        v15 -= 2;
      }
      while ( v15 > 0 );
      v19 = v27;
      if ( v27 )
      {
        v30 = (int)result + 2 * v27 + 2868;
        do
        {
          v20 = (unsigned __int16)*v16;
          v28 = v20;
          if ( v20 )
          {
            v21 = (int)&result[v10 + 725];
            do
            {
              v22 = *(_DWORD *)(v21 - 4);
              --v24;
              v21 -= 4;
              if ( v22 <= v31 )
              {
                v23 = *(unsigned __int16 *)(v3 + 4 * v22 + 2);
                if ( v23 != v19 )
                {
                  result[1448] += *(unsigned __int16 *)(v3 + 4 * v22) * (v19 - v23);
                  *(_WORD *)(v3 + 4 * v22 + 2) = v19;
                }
                v20 = --v28;
              }
            }
            while ( v20 );
            v10 = v24;
          }
          --v19;
          v16 = (_WORD *)(v30 - 2);
          v30 -= 2;
        }
        while ( v19 );
      }
    }
  }
  return result;
}

//----- (0044C420) --------------------------------------------------------
int __usercall sub_44C420@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>)
{
  __int16 v3; // cx
  int result; // eax
  int v5; // edx
  int i; // esi
  int v7; // edx
  unsigned __int16 v8; // ax
  unsigned int v9; // ecx
  unsigned int v10; // eax
  int v11; // ebp
  __int16 v12; // [esp+4h] [ebp-24h]
  char v13; // [esp+6h] [ebp-22h] BYREF

  v3 = 0;
  result = 1;
  v5 = a1 - (_DWORD)&v13;
  do
  {
    v3 = 2 * (v3 + *(__int16 *)((char *)&v12 + 2 * result + v5));
    *(&v12 + result++) = v3;
  }
  while ( result <= 15 );
  for ( i = 0; i <= a2; ++i )
  {
    v7 = *(unsigned __int16 *)(a3 + 4 * i + 2);
    if ( *(_WORD *)(a3 + 4 * i + 2) )
    {
      v8 = *(&v12 + v7);
      v9 = v8;
      *(&v12 + v7) = v8 + 1;
      v10 = 0;
      do
      {
        v11 = v9 & 1;
        --v7;
        v9 >>= 1;
        v10 = 2 * (v11 | v10);
      }
      while ( v7 > 0 );
      result = v10 >> 1;
      *(_WORD *)(a3 + 4 * i) = result;
    }
  }
  return result;
}

//----- (0044C4B0) --------------------------------------------------------
int __usercall sub_44C4B0@<eax>(_DWORD *a1@<esi>, int *a2)
{
  int v2; // edi
  int *v3; // eax
  int v4; // ecx
  int v5; // edx
  int v6; // ebp
  int v7; // eax
  int v8; // eax
  int i; // ebp
  int v10; // ebx
  int v11; // eax
  int v12; // edx
  int v13; // ebp
  int v14; // eax
  unsigned __int8 v15; // cl
  int v17; // [esp+Ch] [ebp-8h]
  int v18; // [esp+10h] [ebp-4h]

  v2 = *a2;
  v3 = (int *)a2[2];
  v4 = v3[3];
  v5 = *v3;
  v6 = -1;
  v7 = 0;
  v18 = v4;
  v17 = -1;
  a1[1298] = 0;
  for ( a1[1299] = 573; v7 < v4; ++v7 )
  {
    if ( *(_WORD *)(v2 + 4 * v7) )
    {
      a1[++a1[1298] + 725] = v7;
      v17 = v7;
      *((_BYTE *)a1 + v7 + 5200) = 0;
      v6 = v7;
    }
    else
    {
      *(_WORD *)(v2 + 4 * v7 + 2) = 0;
    }
  }
  if ( (int)a1[1298] < 2 )
  {
    do
    {
      if ( v6 >= 2 )
        v8 = 0;
      else
        v8 = ++v6;
      a1[++a1[1298] + 725] = v8;
      *(_WORD *)(v2 + 4 * v8) = 1;
      *((_BYTE *)a1 + v8 + 5200) = 0;
      --a1[1448];
      if ( v5 )
        a1[1449] -= *(unsigned __int16 *)(v5 + 4 * v8 + 2);
    }
    while ( (int)a1[1298] < 2 );
    v17 = v6;
  }
  a2[1] = v6;
  for ( i = a1[1298] / 2; i >= 1; --i )
    sub_44C130((int)a1, v2, i);
  v10 = v18;
  do
  {
    v11 = a1[1298];
    v12 = a1[v11 + 725];
    v13 = a1[726];
    a1[1298] = v11 - 1;
    a1[726] = v12;
    sub_44C130((int)a1, v2, 1);
    v14 = a1[726];
    --a1[1299];
    a1[a1[1299]-- + 725] = v13;
    a1[a1[1299] + 725] = v14;
    *(_WORD *)(v2 + 4 * v10) = *(_WORD *)(v2 + 4 * v13) + *(_WORD *)(v2 + 4 * v14);
    v15 = *((_BYTE *)a1 + v14 + 5200);
    if ( *((_BYTE *)a1 + v13 + 5200) >= v15 )
      v15 = *((_BYTE *)a1 + v13 + 5200);
    *((_BYTE *)a1 + v10 + 5200) = v15 + 1;
    *(_WORD *)(v2 + 4 * v14 + 2) = v10;
    *(_WORD *)(v2 + 4 * v13 + 2) = v10;
    a1[726] = v10++;
    sub_44C130((int)a1, v2, 1);
  }
  while ( (int)a1[1298] >= 2 );
  a1[--a1[1299] + 725] = a1[726];
  sub_44C200(a1, a2);
  return sub_44C420((int)(a1 + 717), v17, v2);
}

//----- (0044C6B0) --------------------------------------------------------
int __usercall sub_44C6B0@<eax>(int result@<eax>, int a2@<ecx>, _WORD *a3)
{
  int v3; // edi
  int v4; // edx
  int v6; // ecx
  int v7; // esi
  int v8; // ebp
  unsigned __int16 *v9; // [esp+10h] [ebp-Ch]
  int v10; // [esp+14h] [ebp-8h]

  v3 = *(unsigned __int16 *)(result + 2);
  v4 = 0;
  v6 = 7;
  v7 = 4;
  if ( !*(_WORD *)(result + 2) )
  {
    v6 = 138;
    v7 = 3;
  }
  *(_WORD *)(result + 4 * a2 + 6) = -1;
  if ( a2 >= 0 )
  {
    v8 = -1;
    v10 = a2 + 1;
    v9 = (unsigned __int16 *)(result + 6);
    do
    {
      result = v3;
      v3 = *v9;
      if ( ++v4 >= v6 || result != v3 )
      {
        if ( v4 >= v7 )
        {
          if ( result )
          {
            if ( result != v8 )
              ++a3[2 * result + 1338];
            ++a3[1370];
          }
          else if ( v4 > 10 )
          {
            ++a3[1374];
          }
          else
          {
            ++a3[1372];
          }
        }
        else
        {
          a3[2 * result + 1338] += v4;
        }
        v4 = 0;
        v8 = result;
        if ( v3 )
        {
          if ( result == v3 )
          {
            v6 = 6;
            v7 = 3;
          }
          else
          {
            v6 = 7;
            v7 = 4;
          }
        }
        else
        {
          v6 = 138;
          v7 = 3;
        }
      }
      v9 += 2;
      --v10;
    }
    while ( v10 );
  }
  return result;
}

//----- (0044C790) --------------------------------------------------------
int __usercall sub_44C790@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // esi
  int v5; // ecx
  int v6; // edi
  int v7; // edx
  int v8; // edi
  int v9; // ecx
  unsigned __int16 v10; // si
  int v11; // edx
  int v12; // ecx
  int v13; // edx
  __int16 v14; // si
  int v15; // ecx
  int v16; // ecx
  unsigned __int16 v17; // si
  int v18; // edi
  int v19; // ecx
  int v20; // ebx
  int v21; // ecx
  int v22; // ecx
  unsigned __int16 v23; // si
  int v24; // edi
  int v25; // ecx
  int v26; // ebx
  int v27; // ecx
  int v28; // esi
  int v29; // edi
  int v30; // ecx
  int v31; // ebx
  int v32; // ecx
  int v33; // ecx
  unsigned __int16 v34; // si
  int v35; // edi
  int v36; // ecx
  int v37; // ebx
  int v38; // ecx
  int v39; // esi
  int v40; // edi
  int v41; // ecx
  int v42; // ebx
  unsigned __int16 v43; // si
  int v44; // edi
  int v45; // ecx
  int v46; // ebx
  int v47; // ecx
  int v48; // esi
  int v49; // edi
  int v50; // ecx
  int v51; // ebx
  int v52; // [esp+10h] [ebp-18h]
  int v53; // [esp+14h] [ebp-14h]
  unsigned __int16 *v54; // [esp+18h] [ebp-10h]
  int v55; // [esp+1Ch] [ebp-Ch]
  int v56; // [esp+1Ch] [ebp-Ch]
  int v57; // [esp+1Ch] [ebp-Ch]
  int v58; // [esp+1Ch] [ebp-Ch]
  int v59; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]
  int v61; // [esp+24h] [ebp-4h]

  v3 = 0;
  v55 = -1;
  v53 = *(unsigned __int16 *)(a2 + 2);
  v5 = 7;
  v6 = 4;
  if ( !*(_WORD *)(a2 + 2) )
  {
    v5 = 138;
    v6 = 3;
  }
  if ( a3 >= 0 )
  {
    v54 = (unsigned __int16 *)(a2 + 6);
    for ( i = a3 + 1; i; --i )
    {
      v7 = v53;
      ++v3;
      v61 = v53;
      v53 = *v54;
      v52 = v3;
      if ( v3 < v5 && v7 == *v54 )
        goto LABEL_44;
      if ( v3 < v6 )
      {
        do
        {
          v8 = *(unsigned __int16 *)(result + 4 * v7 + 2678);
          v9 = *(_DWORD *)(result + 5812);
          if ( v9 <= 16 - v8 )
          {
            *(_WORD *)(result + 5808) |= *(_WORD *)(result + 4 * v7 + 2676) << v9;
            v15 = v8 + v9;
          }
          else
          {
            v10 = *(_WORD *)(result + 4 * v7 + 2676);
            v11 = v10 << v9;
            v12 = *(_DWORD *)(result + 8);
            *(_WORD *)(result + 5808) |= v11;
            *(_BYTE *)(v12 + (*(_DWORD *)(result + 20))++) = *(_BYTE *)(result + 5808);
            *(_BYTE *)(*(_DWORD *)(result + 20) + *(_DWORD *)(result + 8)) = *(_BYTE *)(result + 5809);
            v13 = *(_DWORD *)(result + 5812);
            ++*(_DWORD *)(result + 20);
            v14 = v10 >> (16 - v13);
            v15 = v13 + v8 - 16;
            v7 = v61;
            *(_WORD *)(result + 5808) = v14;
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 5812) = v15;
          v52 = v3;
        }
        while ( v3 );
        goto LABEL_39;
      }
      if ( v7 )
      {
        if ( v7 != v55 )
        {
          v16 = *(_DWORD *)(result + 5812);
          v56 = *(unsigned __int16 *)(result + 4 * v7 + 2678);
          if ( v16 <= 16 - v56 )
          {
            *(_WORD *)(result + 5808) |= *(_WORD *)(result + 4 * v7 + 2676) << v16;
            v21 = v56 + v16;
          }
          else
          {
            v17 = *(_WORD *)(result + 4 * v7 + 2676);
            v18 = v17 << v16;
            v19 = *(_DWORD *)(result + 8);
            *(_WORD *)(result + 5808) |= v18;
            *(_BYTE *)(v19 + (*(_DWORD *)(result + 20))++) = *(_BYTE *)(result + 5808);
            *(_BYTE *)(*(_DWORD *)(result + 20) + *(_DWORD *)(result + 8)) = *(_BYTE *)(result + 5809);
            v20 = *(_DWORD *)(result + 5812);
            ++*(_DWORD *)(result + 20);
            v21 = v20 + v56 - 16;
            *(_WORD *)(result + 5808) = v17 >> (16 - v20);
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 5812) = v21;
          v52 = v3;
        }
        v22 = *(_DWORD *)(result + 5812);
        v57 = *(unsigned __int16 *)(result + 2742);
        if ( v22 <= 16 - v57 )
        {
          *(_WORD *)(result + 5808) |= *(_WORD *)(result + 2740) << v22;
          v27 = v57 + v22;
        }
        else
        {
          v23 = *(_WORD *)(result + 2740);
          v24 = v23 << v22;
          v25 = *(_DWORD *)(result + 8);
          *(_WORD *)(result + 5808) |= v24;
          *(_BYTE *)(v25 + (*(_DWORD *)(result + 20))++) = *(_BYTE *)(result + 5808);
          *(_BYTE *)(*(_DWORD *)(result + 20) + *(_DWORD *)(result + 8)) = *(_BYTE *)(result + 5809);
          v26 = *(_DWORD *)(result + 5812);
          ++*(_DWORD *)(result + 20);
          v27 = v26 + v57 - 16;
          *(_WORD *)(result + 5808) = v23 >> (16 - v26);
          v3 = v52;
        }
        v28 = v3 - 3;
        *(_DWORD *)(result + 5812) = v27;
        if ( v27 > 14 )
        {
          v29 = v28 << v27;
          v30 = *(_DWORD *)(result + 8);
          *(_WORD *)(result + 5808) |= v29;
          *(_BYTE *)(v30 + (*(_DWORD *)(result + 20))++) = *(_BYTE *)(result + 5808);
          *(_BYTE *)(*(_DWORD *)(result + 20) + *(_DWORD *)(result + 8)) = *(_BYTE *)(result + 5809);
          v31 = *(_DWORD *)(result + 5812);
          ++*(_DWORD *)(result + 20);
          *(_DWORD *)(result + 5812) = v31 - 14;
          *(_WORD *)(result + 5808) = (unsigned __int16)v28 >> (16 - v31);
          goto LABEL_39;
        }
        *(_WORD *)(result + 5808) |= v28 << v27;
        v32 = v27 + 2;
      }
      else
      {
        v33 = *(_DWORD *)(result + 5812);
        if ( v3 > 10 )
        {
          v59 = *(unsigned __int16 *)(result + 2750);
          if ( v33 <= 16 - v59 )
          {
            *(_WORD *)(result + 5808) |= *(_WORD *)(result + 2748) << v33;
            v47 = v59 + v33;
          }
          else
          {
            v43 = *(_WORD *)(result + 2748);
            v44 = v43 << v33;
            v45 = *(_DWORD *)(result + 8);
            *(_WORD *)(result + 5808) |= v44;
            *(_BYTE *)(v45 + (*(_DWORD *)(result + 20))++) = *(_BYTE *)(result + 5808);
            *(_BYTE *)(*(_DWORD *)(result + 20) + *(_DWORD *)(result + 8)) = *(_BYTE *)(result + 5809);
            v46 = *(_DWORD *)(result + 5812);
            ++*(_DWORD *)(result + 20);
            v47 = v46 + v59 - 16;
            *(_WORD *)(result + 5808) = v43 >> (16 - v46);
            v3 = v52;
          }
          v48 = v3 - 11;
          *(_DWORD *)(result + 5812) = v47;
          if ( v47 > 9 )
          {
            v49 = v48 << v47;
            v50 = *(_DWORD *)(result + 8);
            *(_WORD *)(result + 5808) |= v49;
            *(_BYTE *)(v50 + (*(_DWORD *)(result + 20))++) = *(_BYTE *)(result + 5808);
            *(_BYTE *)(*(_DWORD *)(result + 20) + *(_DWORD *)(result + 8)) = *(_BYTE *)(result + 5809);
            v51 = *(_DWORD *)(result + 5812);
            ++*(_DWORD *)(result + 20);
            *(_DWORD *)(result + 5812) = v51 - 9;
            *(_WORD *)(result + 5808) = (unsigned __int16)v48 >> (16 - v51);
            goto LABEL_39;
          }
          *(_WORD *)(result + 5808) |= v48 << v47;
          v32 = v47 + 7;
        }
        else
        {
          v58 = *(unsigned __int16 *)(result + 2746);
          if ( v33 <= 16 - v58 )
          {
            *(_WORD *)(result + 5808) |= *(_WORD *)(result + 2744) << v33;
            v38 = v58 + v33;
          }
          else
          {
            v34 = *(_WORD *)(result + 2744);
            v35 = v34 << v33;
            v36 = *(_DWORD *)(result + 8);
            *(_WORD *)(result + 5808) |= v35;
            *(_BYTE *)(v36 + (*(_DWORD *)(result + 20))++) = *(_BYTE *)(result + 5808);
            *(_BYTE *)(*(_DWORD *)(result + 20) + *(_DWORD *)(result + 8)) = *(_BYTE *)(result + 5809);
            v37 = *(_DWORD *)(result + 5812);
            ++*(_DWORD *)(result + 20);
            v38 = v37 + v58 - 16;
            *(_WORD *)(result + 5808) = v34 >> (16 - v37);
            v3 = v52;
          }
          v39 = v3 - 3;
          *(_DWORD *)(result + 5812) = v38;
          if ( v38 > 13 )
          {
            v40 = v39 << v38;
            v41 = *(_DWORD *)(result + 8);
            *(_WORD *)(result + 5808) |= v40;
            *(_BYTE *)(v41 + (*(_DWORD *)(result + 20))++) = *(_BYTE *)(result + 5808);
            *(_BYTE *)(*(_DWORD *)(result + 20) + *(_DWORD *)(result + 8)) = *(_BYTE *)(result + 5809);
            v42 = *(_DWORD *)(result + 5812);
            ++*(_DWORD *)(result + 20);
            *(_DWORD *)(result + 5812) = v42 - 13;
            *(_WORD *)(result + 5808) = (unsigned __int16)v39 >> (16 - v42);
            goto LABEL_39;
          }
          *(_WORD *)(result + 5808) |= v39 << v38;
          v32 = v38 + 3;
        }
      }
      *(_DWORD *)(result + 5812) = v32;
LABEL_39:
      v3 = 0;
      v55 = v7;
      if ( v53 )
      {
        if ( v7 == v53 )
        {
          v5 = 6;
          v6 = 3;
        }
        else
        {
          v5 = 7;
          v6 = 4;
        }
      }
      else
      {
        v5 = 138;
        v6 = 3;
      }
LABEL_44:
      v54 += 2;
    }
  }
  return result;
}

//----- (0044CCA0) --------------------------------------------------------
int __usercall sub_44CCA0@<eax>(int a1@<eax>)
{
  int result; // eax

  sub_44C6B0(a1 + 140, *(_DWORD *)(a1 + 2836), (_WORD *)a1);
  sub_44C6B0(a1 + 2432, *(_DWORD *)(a1 + 2848), (_WORD *)a1);
  sub_44C4B0((_DWORD *)a1, (int *)(a1 + 2856));
  result = 18;
  while ( !*(_WORD *)(a1 + 4 * (unsigned __int8)byte_47B104[result] + 2678) )
  {
    if ( *(_WORD *)(a1 + 4 * (unsigned __int8)byte_47B103[result] + 2678) )
    {
      --result;
      *(_DWORD *)(a1 + 5792) += 3 * result + 17;
      return result;
    }
    if ( *(_WORD *)(a1 + 4 * (unsigned __int8)byte_47B102[result] + 2678) )
    {
      result -= 2;
      *(_DWORD *)(a1 + 5792) += 3 * result + 17;
      return result;
    }
    if ( *(_WORD *)(a1 + 4 * (unsigned __int8)byte_47B101[result] + 2678) )
    {
      result -= 3;
      break;
    }
    result -= 4;
    if ( result < 3 )
    {
      *(_DWORD *)(a1 + 5792) += 3 * result + 17;
      return result;
    }
  }
  *(_DWORD *)(a1 + 5792) += 3 * result + 17;
  return result;
}

//----- (0044CD70) --------------------------------------------------------
int __usercall sub_44CD70@<eax>(int a1@<eax>, int a2, int a3, int a4)
{
  int v4; // ecx
  int v5; // ebx
  int v6; // edx
  int v7; // ecx
  int v8; // edx
  int v9; // ecx
  int v10; // edx
  int v11; // ecx
  int v12; // edx
  int v13; // ecx
  int v14; // edx
  int v15; // ecx
  int v16; // edx
  int i; // edi
  int v18; // ecx
  int v19; // edx
  unsigned __int16 v20; // si
  int v21; // edx
  int v22; // ecx
  int v23; // edx
  int v24; // eax

  v4 = *(_DWORD *)(a1 + 5812);
  v5 = a4;
  if ( v4 <= 11 )
  {
    *(_WORD *)(a1 + 5808) |= (a2 - 257) << v4;
    *(_DWORD *)(a1 + 5812) = v4 + 5;
  }
  else
  {
    v6 = (a2 - 257) << v4;
    v7 = *(_DWORD *)(a1 + 20);
    *(_WORD *)(a1 + 5808) |= v6;
    *(_BYTE *)(v7 + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(++*(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5809);
    v8 = *(_DWORD *)(a1 + 5812);
    ++*(_DWORD *)(a1 + 20);
    v5 = a4;
    *(_DWORD *)(a1 + 5812) = v8 - 11;
    *(_WORD *)(a1 + 5808) = (unsigned __int16)(a2 - 257) >> (16 - v8);
  }
  v9 = *(_DWORD *)(a1 + 5812);
  if ( v9 <= 11 )
  {
    *(_WORD *)(a1 + 5808) |= (a3 - 1) << v9;
    *(_DWORD *)(a1 + 5812) = v9 + 5;
  }
  else
  {
    v10 = (a3 - 1) << v9;
    v11 = *(_DWORD *)(a1 + 20);
    *(_WORD *)(a1 + 5808) |= v10;
    *(_BYTE *)(v11 + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(++*(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5809);
    v12 = *(_DWORD *)(a1 + 5812);
    ++*(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 5812) = v12 - 11;
    *(_WORD *)(a1 + 5808) = (unsigned __int16)(a3 - 1) >> (16 - v12);
  }
  v13 = *(_DWORD *)(a1 + 5812);
  if ( v13 <= 12 )
  {
    *(_WORD *)(a1 + 5808) |= (v5 - 4) << v13;
    *(_DWORD *)(a1 + 5812) = v13 + 4;
  }
  else
  {
    v14 = (v5 - 4) << v13;
    v15 = *(_DWORD *)(a1 + 20);
    *(_WORD *)(a1 + 5808) |= v14;
    *(_BYTE *)(v15 + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(++*(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5809);
    v16 = *(_DWORD *)(a1 + 5812);
    ++*(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 5812) = v16 - 12;
    *(_WORD *)(a1 + 5808) = (unsigned __int16)(v5 - 4) >> (16 - v16);
  }
  for ( i = 0; i < v5; ++i )
  {
    v18 = *(_DWORD *)(a1 + 5812);
    v19 = (unsigned __int8)byte_47B104[i];
    if ( v18 <= 13 )
    {
      *(_WORD *)(a1 + 5808) |= *(_WORD *)(a1 + 4 * v19 + 2678) << v18;
      *(_DWORD *)(a1 + 5812) = v18 + 3;
    }
    else
    {
      v20 = *(_WORD *)(a1 + 4 * v19 + 2678);
      v21 = v20 << v18;
      v22 = *(_DWORD *)(a1 + 20);
      *(_WORD *)(a1 + 5808) |= v21;
      *(_BYTE *)(v22 + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5808);
      *(_BYTE *)(++*(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5809);
      v23 = *(_DWORD *)(a1 + 5812);
      ++*(_DWORD *)(a1 + 20);
      v5 = a4;
      *(_DWORD *)(a1 + 5812) = v23 - 13;
      *(_WORD *)(a1 + 5808) = v20 >> (16 - v23);
    }
  }
  v24 = sub_44C790(a1, a1 + 140, a2 - 1);
  return sub_44C790(v24, v24 + 2432, a3 - 1);
}

//----- (0044CFD0) --------------------------------------------------------
_DWORD *__usercall sub_44CFD0@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4)
{
  int v5; // ecx
  int v6; // edx
  int v7; // ecx
  int v8; // edx

  v5 = *(_DWORD *)(a1 + 5812);
  if ( v5 <= 13 )
  {
    *(_WORD *)(a1 + 5808) |= a2 << v5;
    *(_DWORD *)(a1 + 5812) = v5 + 3;
  }
  else
  {
    v6 = a2 << v5;
    v7 = *(_DWORD *)(a1 + 8);
    *(_WORD *)(a1 + 5808) |= v6;
    *(_BYTE *)(v7 + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5809);
    v8 = *(_DWORD *)(a1 + 5812);
    ++*(_DWORD *)(a1 + 20);
    *(_WORD *)(a1 + 5808) = (unsigned __int16)a2 >> (16 - v8);
    *(_DWORD *)(a1 + 5812) = v8 - 13;
  }
  return sub_44D9D0(a1, a3, a4);
}

//----- (0044D060) --------------------------------------------------------
int __usercall sub_44D060@<eax>(int a1@<eax>)
{
  int v1; // ecx
  int v2; // edx
  int v3; // ecx
  int v4; // edx
  int result; // eax
  int v6; // ecx
  int v7; // edx
  int v8; // ecx
  int v9; // edx

  v1 = *(_DWORD *)(a1 + 5812);
  *(_WORD *)(a1 + 5808) |= 2 << v1;
  if ( v1 <= 13 )
  {
    *(_DWORD *)(a1 + 5812) = v1 + 3;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5809);
    v2 = *(_DWORD *)(a1 + 5812);
    ++*(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 5812) = v2 - 13;
    *(_WORD *)(a1 + 5808) = 2u >> (16 - v2);
  }
  v3 = *(_DWORD *)(a1 + 5812);
  *(_WORD *)(a1 + 5808) = *(_WORD *)(a1 + 5808);
  if ( v3 <= 9 )
  {
    *(_DWORD *)(a1 + 5812) = v3 + 7;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5809);
    v4 = *(_DWORD *)(a1 + 5812);
    ++*(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 5812) = v4 - 9;
    *(_WORD *)(a1 + 5808) = 0;
  }
  result = sub_44D8F0(a1);
  v6 = *(_DWORD *)(result + 5812);
  if ( *(_DWORD *)(result + 5804) - v6 + 11 < 9 )
  {
    *(_WORD *)(result + 5808) |= 2 << v6;
    if ( v6 <= 13 )
    {
      *(_DWORD *)(result + 5812) = v6 + 3;
    }
    else
    {
      *(_BYTE *)(*(_DWORD *)(result + 8) + (*(_DWORD *)(result + 20))++) = *(_BYTE *)(result + 5808);
      *(_BYTE *)(*(_DWORD *)(result + 20) + *(_DWORD *)(result + 8)) = *(_BYTE *)(result + 5809);
      v7 = *(_DWORD *)(result + 5812);
      ++*(_DWORD *)(result + 20);
      *(_DWORD *)(result + 5812) = v7 - 13;
      *(_WORD *)(result + 5808) = 2u >> (16 - v7);
    }
    v8 = *(_DWORD *)(result + 5812);
    *(_WORD *)(result + 5808) = *(_WORD *)(result + 5808);
    if ( v8 > 9 )
    {
      *(_BYTE *)(*(_DWORD *)(result + 8) + (*(_DWORD *)(result + 20))++) = *(_BYTE *)(result + 5808);
      *(_BYTE *)(*(_DWORD *)(result + 20) + *(_DWORD *)(result + 8)) = *(_BYTE *)(result + 5809);
      v9 = *(_DWORD *)(result + 5812);
      ++*(_DWORD *)(result + 20);
      *(_DWORD *)(result + 5812) = v9 - 9;
      *(_WORD *)(result + 5808) = 0;
      result = sub_44D8F0(result);
      *(_DWORD *)(result + 5804) = 7;
      return result;
    }
    *(_DWORD *)(result + 5812) = v8 + 7;
    result = sub_44D8F0(result);
  }
  *(_DWORD *)(result + 5804) = 7;
  return result;
}

//----- (0044D250) --------------------------------------------------------
int __usercall sub_44D250@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<edi>, _BYTE *a4)
{
  int v6; // eax
  unsigned int v7; // edx
  unsigned int v8; // ecx
  int v9; // ecx
  bool v10; // zf
  int v11; // ecx
  int v12; // eax
  int v13; // edx
  int v14; // ecx
  int v15; // edx
  int v16; // edx
  int v17; // eax
  int v18; // ecx
  int v19; // ebx
  int result; // eax
  int v21; // [esp+Ch] [ebp-4h]

  v21 = 0;
  if ( *(int *)(a2 + 124) <= 0 )
  {
    v8 = a1 + 5;
LABEL_7:
    v7 = v8;
    goto LABEL_8;
  }
  if ( *(_BYTE *)(a2 + 28) == 2 )
    sub_44D840(a2);
  sub_44C4B0((_DWORD *)a2, (int *)(a2 + 2832));
  sub_44C4B0((_DWORD *)a2, (int *)(a2 + 2844));
  v6 = sub_44CCA0(a2);
  v7 = (unsigned int)(*(_DWORD *)(a2 + 5792) + 10) >> 3;
  v8 = (unsigned int)(*(_DWORD *)(a2 + 5796) + 10) >> 3;
  v21 = v6;
  if ( v8 <= v7 )
    goto LABEL_7;
LABEL_8:
  if ( a1 + 4 <= v7 && a4 )
  {
    sub_44CFD0(a2, a3, a4, a1);
  }
  else
  {
    v10 = v8 == v7;
    v11 = *(_DWORD *)(a2 + 5812);
    if ( v10 )
    {
      v12 = a3 + 2;
      if ( v11 <= 13 )
      {
        *(_WORD *)(a2 + 5808) |= v12 << v11;
        *(_DWORD *)(a2 + 5812) = v11 + 3;
      }
      else
      {
        v13 = v12 << v11;
        v14 = *(_DWORD *)(a2 + 8);
        *(_WORD *)(a2 + 5808) |= v13;
        *(_BYTE *)(v14 + (*(_DWORD *)(a2 + 20))++) = *(_BYTE *)(a2 + 5808);
        *(_BYTE *)(*(_DWORD *)(a2 + 20) + *(_DWORD *)(a2 + 8)) = *(_BYTE *)(a2 + 5809);
        v15 = *(_DWORD *)(a2 + 5812);
        ++*(_DWORD *)(a2 + 20);
        *(_DWORD *)(a2 + 5812) = v15 - 13;
        *(_WORD *)(a2 + 5808) = (unsigned __int16)v12 >> (16 - v15);
      }
      sub_44D440(a2, (int)&unk_47B1E0, (int)&unk_47B660);
    }
    else
    {
      v16 = a3 + 4;
      if ( v11 <= 13 )
      {
        *(_WORD *)(a2 + 5808) |= v16 << v11;
        *(_DWORD *)(a2 + 5812) = v11 + 3;
      }
      else
      {
        v17 = v16 << v11;
        v18 = *(_DWORD *)(a2 + 8);
        *(_WORD *)(a2 + 5808) |= v17;
        *(_BYTE *)(v18 + (*(_DWORD *)(a2 + 20))++) = *(_BYTE *)(a2 + 5808);
        *(_BYTE *)(*(_DWORD *)(a2 + 20) + *(_DWORD *)(a2 + 8)) = *(_BYTE *)(a2 + 5809);
        v19 = *(_DWORD *)(a2 + 5812);
        ++*(_DWORD *)(a2 + 20);
        *(_DWORD *)(a2 + 5812) = v19 - 13;
        *(_WORD *)(a2 + 5808) = (unsigned __int16)v16 >> (16 - v19);
      }
      sub_44CD70(a2, *(_DWORD *)(a2 + 2836) + 1, *(_DWORD *)(a2 + 2848) + 1, v21 + 1);
      sub_44D440(a2, a2 + 140, a2 + 2432);
    }
  }
  result = sub_44C0B0(v9, a2);
  if ( a3 )
    return sub_44D970(a2);
  return result;
}
// 44D41C: variable 'v9' is possibly undefined

//----- (0044D440) --------------------------------------------------------
int __usercall sub_44D440@<eax>(int result@<eax>, int a2, int a3)
{
  int v3; // ebx
  unsigned int v4; // ecx
  int v5; // ebp
  int v6; // esi
  int v7; // ecx
  int v8; // edi
  int v9; // esi
  int v10; // edx
  int v11; // ecx
  int v12; // edx
  int v13; // ecx
  int v14; // edx
  int v15; // edi
  int v16; // edx
  int v17; // ecx
  int v18; // edx
  int v19; // edi
  int v20; // esi
  int v21; // ecx
  int v22; // edx
  int v23; // ecx
  int v24; // edx
  int v25; // ecx
  unsigned int v26; // ebp
  int v27; // edi
  int v28; // edx
  int v29; // ecx
  unsigned __int16 v30; // si
  int v31; // edx
  int v32; // ecx
  int v33; // edx
  int v34; // esi
  int v35; // ecx
  unsigned int v36; // ebp
  unsigned int v37; // edx
  int v38; // ecx
  int v39; // edx
  int v40; // edi
  int v41; // ecx
  unsigned __int16 v42; // si
  int v43; // edx
  int v44; // ecx
  int v45; // edx
  int v46; // [esp+10h] [ebp-Ch]
  int v47; // [esp+14h] [ebp-8h]
  int v48; // [esp+14h] [ebp-8h]
  unsigned int v49; // [esp+18h] [ebp-4h]

  v3 = a2;
  v4 = 0;
  if ( *(_DWORD *)(result + 5784) )
  {
    do
    {
      v5 = *(unsigned __int16 *)(*(_DWORD *)(result + 5788) + 2 * v4);
      v6 = *(unsigned __int8 *)(v4 + *(_DWORD *)(result + 5776));
      v49 = v4 + 1;
      v7 = *(_DWORD *)(result + 5812);
      if ( v5 )
      {
        v14 = (unsigned __int8)byte_47B8D8[v6];
        v46 = *(unsigned __int16 *)(v3 + 4 * v14 + 1030);
        v47 = v14;
        if ( v7 <= 16 - v46 )
        {
          *(_WORD *)(result + 5808) |= *(_WORD *)(a2 + 4 * v14 + 1028) << v7;
          *(_DWORD *)(result + 5812) = v46 + v7;
        }
        else
        {
          v15 = *(unsigned __int16 *)(a2 + 4 * v14 + 1028);
          v16 = v15 << v7;
          v17 = *(_DWORD *)(result + 8);
          *(_WORD *)(result + 5808) |= v16;
          *(_BYTE *)(v17 + (*(_DWORD *)(result + 20))++) = *(_BYTE *)(result + 5808);
          *(_BYTE *)(*(_DWORD *)(result + 20) + *(_DWORD *)(result + 8)) = *(_BYTE *)(result + 5809);
          v18 = *(_DWORD *)(result + 5812);
          ++*(_DWORD *)(result + 20);
          LOWORD(v15) = (unsigned __int16)v15 >> (16 - v18);
          *(_DWORD *)(result + 5812) = v18 + v46 - 16;
          v14 = v47;
          *(_WORD *)(result + 5808) = v15;
        }
        v19 = dword_47B090[v14];
        v3 = a2;
        if ( v19 )
        {
          v20 = v6 - dword_47B9D8[v14];
          v21 = *(_DWORD *)(result + 5812);
          if ( v21 <= 16 - v19 )
          {
            *(_WORD *)(result + 5808) |= v20 << v21;
            v25 = v19 + v21;
          }
          else
          {
            v22 = v20 << v21;
            v23 = *(_DWORD *)(result + 8);
            *(_WORD *)(result + 5808) |= v22;
            *(_BYTE *)(v23 + (*(_DWORD *)(result + 20))++) = *(_BYTE *)(result + 5808);
            *(_BYTE *)(*(_DWORD *)(result + 20) + *(_DWORD *)(result + 8)) = *(_BYTE *)(result + 5809);
            v24 = *(_DWORD *)(result + 5812);
            ++*(_DWORD *)(result + 20);
            v3 = a2;
            v25 = v24 + v19 - 16;
            *(_WORD *)(result + 5808) = (unsigned __int16)v20 >> (16 - v24);
          }
          *(_DWORD *)(result + 5812) = v25;
        }
        v26 = v5 - 1;
        if ( v26 >= 0x100 )
          v27 = (unsigned __int8)byte_47B7D8[v26 >> 7];
        else
          v27 = (unsigned __int8)byte_47B6D8[v26];
        v28 = *(unsigned __int16 *)(a3 + 4 * v27 + 2);
        v29 = *(_DWORD *)(result + 5812);
        v48 = v28;
        if ( v29 <= 16 - v28 )
        {
          *(_WORD *)(result + 5808) |= *(_WORD *)(a3 + 4 * v27) << v29;
          *(_DWORD *)(result + 5812) = v28 + v29;
        }
        else
        {
          v30 = *(_WORD *)(a3 + 4 * v27);
          v31 = v30 << v29;
          v32 = *(_DWORD *)(result + 8);
          *(_WORD *)(result + 5808) |= v31;
          *(_BYTE *)(v32 + (*(_DWORD *)(result + 20))++) = *(_BYTE *)(result + 5808);
          *(_BYTE *)(*(_DWORD *)(result + 20) + *(_DWORD *)(result + 8)) = *(_BYTE *)(result + 5809);
          v33 = *(_DWORD *)(result + 5812);
          ++*(_DWORD *)(result + 20);
          v3 = a2;
          *(_DWORD *)(result + 5812) = v33 + v48 - 16;
          *(_WORD *)(result + 5808) = v30 >> (16 - v33);
        }
        v34 = dword_47B118[v27];
        if ( !v34 )
          goto LABEL_25;
        v35 = *(_DWORD *)(result + 5812);
        v36 = v26 - dword_47BA50[v27];
        if ( v35 <= 16 - v34 )
        {
          *(_WORD *)(result + 5808) |= v36 << v35;
          v13 = v34 + v35;
        }
        else
        {
          v37 = v36 << v35;
          v38 = *(_DWORD *)(result + 8);
          *(_WORD *)(result + 5808) |= v37;
          *(_BYTE *)(v38 + (*(_DWORD *)(result + 20))++) = *(_BYTE *)(result + 5808);
          *(_BYTE *)(*(_DWORD *)(result + 20) + *(_DWORD *)(result + 8)) = *(_BYTE *)(result + 5809);
          v39 = *(_DWORD *)(result + 5812);
          ++*(_DWORD *)(result + 20);
          v13 = v39 + v34 - 16;
          *(_WORD *)(result + 5808) = (unsigned __int16)v36 >> (16 - v39);
        }
      }
      else
      {
        v8 = *(unsigned __int16 *)(v3 + 4 * v6 + 2);
        if ( v7 <= 16 - v8 )
        {
          *(_WORD *)(result + 5808) |= *(_WORD *)(v3 + 4 * v6) << v7;
          v13 = v8 + v7;
        }
        else
        {
          v9 = *(unsigned __int16 *)(v3 + 4 * v6);
          v10 = v9 << v7;
          v11 = *(_DWORD *)(result + 8);
          *(_WORD *)(result + 5808) |= v10;
          *(_BYTE *)(v11 + (*(_DWORD *)(result + 20))++) = *(_BYTE *)(result + 5808);
          *(_BYTE *)(*(_DWORD *)(result + 20) + *(_DWORD *)(result + 8)) = *(_BYTE *)(result + 5809);
          v12 = *(_DWORD *)(result + 5812);
          ++*(_DWORD *)(result + 20);
          v13 = v12 + v8 - 16;
          *(_WORD *)(result + 5808) = (unsigned __int16)v9 >> (16 - v12);
        }
      }
      *(_DWORD *)(result + 5812) = v13;
LABEL_25:
      v4 = v49;
    }
    while ( v49 < *(_DWORD *)(result + 5784) );
  }
  v40 = *(unsigned __int16 *)(v3 + 1026);
  v41 = *(_DWORD *)(result + 5812);
  if ( v41 <= 16 - v40 )
  {
    *(_WORD *)(result + 5808) |= *(_WORD *)(v3 + 1024) << v41;
    *(_DWORD *)(result + 5812) = v40 + v41;
  }
  else
  {
    v42 = *(_WORD *)(v3 + 1024);
    v43 = v42 << v41;
    v44 = *(_DWORD *)(result + 8);
    *(_WORD *)(result + 5808) |= v43;
    *(_BYTE *)(v44 + (*(_DWORD *)(result + 20))++) = *(_BYTE *)(result + 5808);
    *(_BYTE *)(*(_DWORD *)(result + 8) + *(_DWORD *)(result + 20)) = *(_BYTE *)(result + 5809);
    v45 = *(_DWORD *)(result + 5812);
    ++*(_DWORD *)(result + 20);
    *(_DWORD *)(result + 5812) = v45 + v40 - 16;
    *(_WORD *)(result + 5808) = v42 >> (16 - v45);
  }
  *(_DWORD *)(result + 5804) = *(unsigned __int16 *)(v3 + 1026);
  return result;
}
// 47B090: using guessed type int dword_47B090[28];
// 47B118: using guessed type int dword_47B118[30];
// 47B9D8: using guessed type int dword_47B9D8[30];
// 47BA50: using guessed type int dword_47BA50[30];

//----- (0044D840) --------------------------------------------------------
int __usercall sub_44D840@<eax>(int result@<eax>)
{
  int v1; // edi
  int v2; // ebx
  unsigned __int16 *v3; // edx
  int v4; // esi
  unsigned int v5; // esi
  int v6; // edi
  int v7; // ebx
  unsigned __int16 *v8; // edx
  int v9; // [esp+10h] [ebp-4h]

  v1 = 0;
  v2 = 0;
  v3 = (unsigned __int16 *)(result + 172);
  v4 = 60;
  do
  {
    v1 += *(v3 - 2);
    v2 += *v3;
    v3 += 4;
    --v4;
  }
  while ( v4 );
  v5 = v1 + v2 + *(unsigned __int16 *)(result + 648);
  v6 = 0;
  v7 = 0;
  v8 = (unsigned __int16 *)(result + 656);
  v9 = 64;
  do
  {
    v6 += *(v8 - 2);
    v7 += *v8;
    v8 += 4;
    --v9;
  }
  while ( v9 );
  *(_BYTE *)(result + 28) = v6
                          + v7
                          + *(unsigned __int16 *)(result + 140)
                          + *(unsigned __int16 *)(result + 144)
                          + *(unsigned __int16 *)(result + 148)
                          + *(unsigned __int16 *)(result + 152)
                          + *(unsigned __int16 *)(result + 156)
                          + *(unsigned __int16 *)(result + 160)
                          + (unsigned int)*(unsigned __int16 *)(result + 164) <= v5 >> 2;
  return result;
}

//----- (0044D8F0) --------------------------------------------------------
int __usercall sub_44D8F0@<eax>(int result@<eax>)
{
  int v1; // ecx
  __int16 v2; // dx

  v1 = *(_DWORD *)(result + 5812);
  if ( v1 == 16 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 8) + (*(_DWORD *)(result + 20))++) = *(_BYTE *)(result + 5808);
    *(_BYTE *)(*(_DWORD *)(result + 20) + *(_DWORD *)(result + 8)) = *(_BYTE *)(result + 5809);
    ++*(_DWORD *)(result + 20);
    *(_WORD *)(result + 5808) = 0;
    *(_DWORD *)(result + 5812) = 0;
  }
  else if ( v1 >= 8 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 8) + *(_DWORD *)(result + 20)) = *(_BYTE *)(result + 5808);
    v2 = *(unsigned __int8 *)(result + 5809);
    ++*(_DWORD *)(result + 20);
    *(_DWORD *)(result + 5812) -= 8;
    *(_WORD *)(result + 5808) = v2;
  }
  return result;
}

//----- (0044D970) --------------------------------------------------------
int __usercall sub_44D970@<eax>(int result@<eax>)
{
  int v1; // ecx
  int v2; // ecx
  int v3; // edx
  char v4; // bl

  v1 = *(_DWORD *)(result + 5812);
  if ( v1 > 8 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 8) + (*(_DWORD *)(result + 20))++) = *(_BYTE *)(result + 5808);
    v2 = *(_DWORD *)(result + 20);
    v3 = *(_DWORD *)(result + 8);
    v4 = *(_BYTE *)(result + 5809);
LABEL_5:
    *(_BYTE *)(v2 + v3) = v4;
    ++*(_DWORD *)(result + 20);
    goto LABEL_6;
  }
  if ( v1 > 0 )
  {
    v2 = *(_DWORD *)(result + 8);
    v3 = *(_DWORD *)(result + 20);
    v4 = *(_BYTE *)(result + 5808);
    goto LABEL_5;
  }
LABEL_6:
  *(_WORD *)(result + 5808) = 0;
  *(_DWORD *)(result + 5812) = 0;
  return result;
}

//----- (0044D9D0) --------------------------------------------------------
_DWORD *__usercall sub_44D9D0@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)
{
  _DWORD *result; // eax
  int v6; // ecx
  int v7; // edx
  int v8; // edx
  int i; // esi

  result = (_DWORD *)sub_44D970(a1);
  v6 = result[5];
  v7 = result[2];
  result[1451] = 8;
  *(_BYTE *)(v6 + v7) = a3;
  v8 = result[2];
  *(_BYTE *)(++result[5] + v8) = BYTE1(a3);
  *(_BYTE *)(++result[5] + result[2]) = ~(_BYTE)a3;
  *(_BYTE *)(++result[5] + result[2]) = (unsigned __int16)~(_WORD)a3 >> 8;
  for ( i = ++result[5]; a3; ++a2 )
  {
    *(_BYTE *)(i + result[2]) = *a2;
    i = ++result[5];
    --a3;
  }
  return result;
}

//----- (0044F01A) --------------------------------------------------------
void **sub_44F01A()
{
  return &off_4931F0;
}
// 4931F0: using guessed type void *off_4931F0;

//----- (0044F3AC) --------------------------------------------------------
int sub_44F3AC()
{
  return flsall(1);
}
// 44F27F: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (00456950) --------------------------------------------------------
int __cdecl sub_456950(int a1)
{
  int result; // eax

  result = a1;
  dword_4A67EC = a1;
  return result;
}
// 4A67EC: using guessed type int dword_4A67EC;

//----- (0045792E) --------------------------------------------------------
int __cdecl sub_45792E(int a1)
{
  int result; // eax

  result = a1;
  dword_4A6844 = a1;
  return result;
}
// 4A6844: using guessed type int dword_4A6844;

//----- (0045A552) --------------------------------------------------------
int __cdecl sub_45A552(_DWORD *a1)
{
  if ( a1 )
  {
    *a1 = dword_4A6A70;
    return 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return 22;
  }
}
// 457A65: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A6A70: using guessed type int dword_4A6A70;

//----- (0045B0E4) --------------------------------------------------------
int __cdecl sub_45B0E4(_DWORD *a1)
{
  if ( a1 )
  {
    *a1 = dword_493F7C;
    return 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return 22;
  }
}
// 457A65: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 493F7C: using guessed type int dword_493F7C;

//----- (0045B11D) --------------------------------------------------------
int __cdecl sub_45B11D(_DWORD *a1)
{
  if ( a1 )
  {
    *a1 = dword_493F80;
    return 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return 22;
  }
}
// 457A65: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 493F80: using guessed type int dword_493F80;

//----- (0045B156) --------------------------------------------------------
int __cdecl sub_45B156(_DWORD *a1)
{
  if ( a1 )
  {
    *a1 = dword_493F78;
    return 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return 22;
  }
}
// 457A65: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 493F78: using guessed type int dword_493F78;

//----- (0045B18F) --------------------------------------------------------
int *sub_45B18F()
{
  return &dword_493F7C;
}
// 493F7C: using guessed type int dword_493F7C;

//----- (0045B195) --------------------------------------------------------
int *sub_45B195()
{
  return &dword_493F80;
}
// 493F80: using guessed type int dword_493F80;

//----- (0045B19B) --------------------------------------------------------
int *sub_45B19B()
{
  return &dword_493F78;
}
// 493F78: using guessed type int dword_493F78;

//----- (0045B1A1) --------------------------------------------------------
void **sub_45B1A1()
{
  return &off_494008;
}
// 494008: using guessed type void *off_494008;

//----- (0045C6DA) --------------------------------------------------------
void *sub_45C6DA()
{
  return &unk_48B3F0;
}

//----- (0045C700) --------------------------------------------------------
void __cdecl sub_45C700()
{
  ;
}

//----- (0045CA9C) --------------------------------------------------------
int sub_45CA9C()
{
  return _decode_pointer(dword_4A6928);
}
// 45740C: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 4A6928: using guessed type int dword_4A6928;

//----- (0045CC59) --------------------------------------------------------
int __cdecl sub_45CC59(int a1)
{
  int result; // eax

  result = a1;
  dword_4A6934 = a1;
  return result;
}
// 4A6934: using guessed type int dword_4A6934;

//----- (0045CC68) --------------------------------------------------------
int __cdecl sub_45CC68(int a1)
{
  int result; // eax

  result = a1;
  dword_4A6940 = a1;
  return result;
}
// 4A6940: using guessed type int dword_4A6940;

//----- (0045CC77) --------------------------------------------------------
int __cdecl sub_45CC77(int a1)
{
  int result; // eax

  result = a1;
  dword_4A6944 = a1;
  return result;
}
// 4A6944: using guessed type int dword_4A6944;

//----- (0045D298) --------------------------------------------------------
int sub_45D298()
{
  SetUnhandledExceptionFilter(__CxxUnhandledExceptionFilter);
  return 0;
}

//----- (0045DBDE) --------------------------------------------------------
int sub_45DBDE()
{
  dword_4A9D3C = _get_sse2_info();
  return 0;
}
// 45DB7C: using guessed type int _get_sse2_info(void);
// 4A9D3C: using guessed type int dword_4A9D3C;

//----- (0045E40C) --------------------------------------------------------
void sub_45E40C()
{
  dword_4A9D38 = 0;
}
// 4A9D38: using guessed type int dword_4A9D38;

//----- (0045E414) --------------------------------------------------------
int __cdecl sub_45E414(int a1, int a2, int a3)
{
  int v3; // ebx
  HMODULE LibraryA; // eax
  HMODULE v5; // edi
  int (__stdcall *MessageBoxA)(HWND, LPCSTR, LPCSTR, UINT); // eax
  HWND (__stdcall *GetActiveWindow)(); // eax
  HWND (__stdcall *GetLastActivePopup)(HWND); // eax
  BOOL (__stdcall *GetUserObjectInformationA)(HANDLE, int, PVOID, DWORD, LPDWORD); // eax
  HWINSTA (__stdcall *GetProcessWindowStation)(); // eax
  int (*v11)(void); // esi
  int (__stdcall *v12)(int, int, char *, int, char *); // eax
  int (__stdcall *v13)(int, int, char *, int, char *); // edi
  int v14; // eax
  int (*v15)(void); // eax
  int (__stdcall *v16)(int); // eax
  int (__stdcall *v17)(int, int, int, int); // eax
  char v19[12]; // [esp+10h] [ebp-14h] BYREF
  char v20[4]; // [esp+1Ch] [ebp-8h] BYREF
  int v21; // [esp+20h] [ebp-4h]

  v21 = 0;
  v3 = _encoded_null();
  if ( !dword_4A6A54 )
  {
    LibraryA = LoadLibraryA("USER32.DLL");
    v5 = LibraryA;
    if ( !LibraryA )
      return 0;
    MessageBoxA = (int (__stdcall *)(HWND, LPCSTR, LPCSTR, UINT))GetProcAddress(LibraryA, "MessageBoxA");
    if ( !MessageBoxA )
      return 0;
    dword_4A6A54 = _encode_pointer(MessageBoxA);
    GetActiveWindow = (HWND (__stdcall *)())GetProcAddress(v5, "GetActiveWindow");
    dword_4A6A58 = _encode_pointer(GetActiveWindow);
    GetLastActivePopup = (HWND (__stdcall *)(HWND))GetProcAddress(v5, "GetLastActivePopup");
    dword_4A6A5C = _encode_pointer(GetLastActivePopup);
    GetUserObjectInformationA = (BOOL (__stdcall *)(HANDLE, int, PVOID, DWORD, LPDWORD))GetProcAddress(
                                                                                          v5,
                                                                                          "GetUserObjectInformationA");
    dword_4A6A64 = _encode_pointer(GetUserObjectInformationA);
    if ( dword_4A6A64 )
    {
      GetProcessWindowStation = (HWINSTA (__stdcall *)())GetProcAddress(v5, "GetProcessWindowStation");
      dword_4A6A60 = _encode_pointer(GetProcessWindowStation);
    }
  }
  if ( dword_4A6A60 == v3
    || dword_4A6A64 == v3
    || (v11 = (int (*)(void))_decode_pointer(dword_4A6A60),
        v12 = (int (__stdcall *)(int, int, char *, int, char *))_decode_pointer(dword_4A6A64),
        v13 = v12,
        !v11)
    || !v12
    || (v14 = v11()) != 0 && v13(v14, 1, v19, 12, v20) && (v19[8] & 1) != 0 )
  {
    if ( dword_4A6A58 != v3 )
    {
      v15 = (int (*)(void))_decode_pointer(dword_4A6A58);
      if ( v15 )
      {
        v21 = v15();
        if ( v21 )
        {
          if ( dword_4A6A5C != v3 )
          {
            v16 = (int (__stdcall *)(int))_decode_pointer(dword_4A6A5C);
            if ( v16 )
              v21 = v16(v21);
          }
        }
      }
    }
  }
  else
  {
    a3 |= 0x200000u;
  }
  v17 = (int (__stdcall *)(int, int, int, int))_decode_pointer(dword_4A6A54);
  if ( v17 )
    return v17(v21, a1, a2, a3);
  return 0;
}
// 457391: using guessed type _DWORD __cdecl _encode_pointer(_DWORD);
// 457403: using guessed type int _encoded_null(void);
// 45740C: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 4A6A54: using guessed type int dword_4A6A54;
// 4A6A58: using guessed type int dword_4A6A58;
// 4A6A5C: using guessed type int dword_4A6A5C;
// 4A6A60: using guessed type int dword_4A6A60;
// 4A6A64: using guessed type int dword_4A6A64;
// 45E414: using guessed type char var_8[4];

//----- (0045EBC6) --------------------------------------------------------
int __cdecl sub_45EBC6(unsigned __int16 *a1, _DWORD *a2)
{
  unsigned __int16 v2; // bx
  int v3; // ebx
  int v4; // eax
  int v5; // ebx
  int v6; // eax
  int result; // eax
  int v8; // esi
  int *v9; // edi
  int v10; // eax
  bool i; // zf
  int v12; // eax
  unsigned int v13; // edx
  int *v14; // ecx
  bool v15; // cf
  unsigned int v16; // esi
  int v17; // eax
  int v18; // edx
  int *v19; // ebx
  unsigned int v20; // esi
  char v21; // cl
  int v22; // edx
  int *v23; // ecx
  int v24; // esi
  int v25; // eax
  int *v26; // ebx
  bool j; // zf
  int v28; // eax
  unsigned int v29; // edx
  int *v30; // ecx
  unsigned int v31; // edi
  int k; // ecx
  int *v33; // ecx
  unsigned int v34; // esi
  int v35; // edi
  int v36; // eax
  int v37; // edx
  int *v38; // ebx
  unsigned int v39; // esi
  char v40; // cl
  int v41; // edx
  int *v42; // ecx
  int v43; // eax
  int v44; // edx
  int *v45; // ebx
  unsigned int v46; // esi
  char v47; // cl
  int v48; // edx
  int *v49; // ecx
  int v50; // eax
  int v51; // edx
  unsigned int v52; // edi
  int v53; // edx
  int *v54; // ecx
  unsigned int v55; // ebx
  int v56; // edx
  int v57; // [esp+8h] [ebp-2Ch]
  int v58; // [esp+Ch] [ebp-28h]
  int v59; // [esp+10h] [ebp-24h]
  int v60; // [esp+14h] [ebp-20h] BYREF
  int v61; // [esp+18h] [ebp-1Ch]
  int v62; // [esp+1Ch] [ebp-18h] BYREF
  int v63; // [esp+20h] [ebp-14h]
  int v64; // [esp+24h] [ebp-10h]
  int v65; // [esp+28h] [ebp-Ch]
  int v66; // [esp+2Ch] [ebp-8h]
  int v67; // [esp+30h] [ebp-4h]
  int v68; // [esp+3Ch] [ebp+8h]
  unsigned int v69; // [esp+3Ch] [ebp+8h]
  int v70; // [esp+3Ch] [ebp+8h]
  int v71; // [esp+3Ch] [ebp+8h]
  int v72; // [esp+3Ch] [ebp+8h]
  int v73; // [esp+3Ch] [ebp+8h]
  int v74; // [esp+3Ch] [ebp+8h]

  v2 = a1[5];
  v63 = v2 & 0x8000;
  v60 = *(_DWORD *)(a1 + 3);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *a1 << 16;
  v61 = *(_DWORD *)(a1 + 1);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_494308 - 1;
    v64 = v3;
    v65 = dword_494308 / 32;
    v9 = &v60 + dword_494308 / 32;
    v66 = 31 - dword_494308 % 32;
    if ( ((1 << (31 - dword_494308 % 32)) & *v9) != 0 )
    {
      v10 = v65;
      for ( i = (~(-1 << (31 - dword_494308 % 32)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v10) == 0 )
      {
        if ( ++v10 >= 3 )
          goto LABEL_22;
      }
      v12 = v8 / 32;
      v67 = 0;
      v13 = 1 << (31 - v8 % 32);
      v14 = &v60 + v8 / 32;
      v69 = v13 + *v14;
      if ( v69 >= *v14 )
      {
        v15 = v69 < v13;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v12;
        *v14 = v69;
        if ( v12 < 0 || !v67 )
          break;
        v67 = 0;
        v14 = &v60 + v12;
        v16 = *v14 + 1;
        v69 = v16;
        if ( v16 >= *v14 )
        {
          v15 = v16 == 0;
LABEL_18:
          if ( !v15 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v9 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_494304 - dword_494308 )
    {
      if ( v3 > dword_494304 )
      {
        if ( v3 < dword_494300 )
        {
          v60 &= ~0x80000000;
          v5 = dword_494314 + v3;
          v50 = dword_49430C / 32;
          v51 = dword_49430C % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_49430C % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & v52;
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 0x80000000;
          v43 = dword_49430C / 32;
          v44 = dword_49430C % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_49430C % 32;
          do
          {
            v45 = &v60 + v73;
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_494314 + dword_494300;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_494304 - v64) / 32;
      v62 = v59;
      v18 = (dword_494304 - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = &v60 + v70;
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_494308 - 1;
      v25 = dword_494308 / 32;
      v65 = dword_494308 / 32;
      v26 = &v60 + dword_494308 / 32;
      v64 = 31 - dword_494308 % 32;
      if ( ((1 << (31 - dword_494308 % 32)) & *v26) != 0 )
      {
        for ( j = (~(-1 << (31 - dword_494308 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = &v60 + v24 / 32;
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = &v60 + v28;
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || *v33 == -1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_49430C + 1) / 32;
      v37 = (dword_49430C + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = &v60 + v72;
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_49430C));
  if ( dword_494310 == 64 )
  {
    v56 = v61;
    a2[1] = v55;
    *a2 = v56;
  }
  else if ( dword_494310 == 32 )
  {
    *a2 = v55;
  }
  return result;
}
// 494300: using guessed type int dword_494300;
// 494304: using guessed type int dword_494304;
// 494308: using guessed type int dword_494308;
// 49430C: using guessed type int dword_49430C;
// 494310: using guessed type int dword_494310;
// 494314: using guessed type int dword_494314;

//----- (0045F10A) --------------------------------------------------------
int __cdecl sub_45F10A(unsigned __int16 *a1, _DWORD *a2)
{
  unsigned __int16 v2; // bx
  int v3; // ebx
  int v4; // eax
  int v5; // ebx
  int v6; // eax
  int result; // eax
  int v8; // esi
  int *v9; // edi
  int v10; // eax
  bool i; // zf
  int v12; // eax
  unsigned int v13; // edx
  int *v14; // ecx
  bool v15; // cf
  unsigned int v16; // esi
  int v17; // eax
  int v18; // edx
  int *v19; // ebx
  unsigned int v20; // esi
  char v21; // cl
  int v22; // edx
  int *v23; // ecx
  int v24; // esi
  int v25; // eax
  int *v26; // ebx
  bool j; // zf
  int v28; // eax
  unsigned int v29; // edx
  int *v30; // ecx
  unsigned int v31; // edi
  int k; // ecx
  int *v33; // ecx
  unsigned int v34; // esi
  int v35; // edi
  int v36; // eax
  int v37; // edx
  int *v38; // ebx
  unsigned int v39; // esi
  char v40; // cl
  int v41; // edx
  int *v42; // ecx
  int v43; // eax
  int v44; // edx
  int *v45; // ebx
  unsigned int v46; // esi
  char v47; // cl
  int v48; // edx
  int *v49; // ecx
  int v50; // eax
  int v51; // edx
  unsigned int v52; // edi
  int v53; // edx
  int *v54; // ecx
  unsigned int v55; // ebx
  int v56; // edx
  int v57; // [esp+8h] [ebp-2Ch]
  int v58; // [esp+Ch] [ebp-28h]
  int v59; // [esp+10h] [ebp-24h]
  int v60; // [esp+14h] [ebp-20h] BYREF
  int v61; // [esp+18h] [ebp-1Ch]
  int v62; // [esp+1Ch] [ebp-18h] BYREF
  int v63; // [esp+20h] [ebp-14h]
  int v64; // [esp+24h] [ebp-10h]
  int v65; // [esp+28h] [ebp-Ch]
  int v66; // [esp+2Ch] [ebp-8h]
  int v67; // [esp+30h] [ebp-4h]
  int v68; // [esp+3Ch] [ebp+8h]
  unsigned int v69; // [esp+3Ch] [ebp+8h]
  int v70; // [esp+3Ch] [ebp+8h]
  int v71; // [esp+3Ch] [ebp+8h]
  int v72; // [esp+3Ch] [ebp+8h]
  int v73; // [esp+3Ch] [ebp+8h]
  int v74; // [esp+3Ch] [ebp+8h]

  v2 = a1[5];
  v63 = v2 & 0x8000;
  v60 = *(_DWORD *)(a1 + 3);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *a1 << 16;
  v61 = *(_DWORD *)(a1 + 1);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_494320 - 1;
    v64 = v3;
    v65 = dword_494320 / 32;
    v9 = &v60 + dword_494320 / 32;
    v66 = 31 - dword_494320 % 32;
    if ( ((1 << (31 - dword_494320 % 32)) & *v9) != 0 )
    {
      v10 = v65;
      for ( i = (~(-1 << (31 - dword_494320 % 32)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v10) == 0 )
      {
        if ( ++v10 >= 3 )
          goto LABEL_22;
      }
      v12 = v8 / 32;
      v67 = 0;
      v13 = 1 << (31 - v8 % 32);
      v14 = &v60 + v8 / 32;
      v69 = v13 + *v14;
      if ( v69 >= *v14 )
      {
        v15 = v69 < v13;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v12;
        *v14 = v69;
        if ( v12 < 0 || !v67 )
          break;
        v67 = 0;
        v14 = &v60 + v12;
        v16 = *v14 + 1;
        v69 = v16;
        if ( v16 >= *v14 )
        {
          v15 = v16 == 0;
LABEL_18:
          if ( !v15 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v9 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_49431C - dword_494320 )
    {
      if ( v3 > dword_49431C )
      {
        if ( v3 < dword_494318 )
        {
          v60 &= ~0x80000000;
          v5 = dword_49432C + v3;
          v50 = dword_494324 / 32;
          v51 = dword_494324 % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_494324 % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & v52;
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 0x80000000;
          v43 = dword_494324 / 32;
          v44 = dword_494324 % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_494324 % 32;
          do
          {
            v45 = &v60 + v73;
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_49432C + dword_494318;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_49431C - v64) / 32;
      v62 = v59;
      v18 = (dword_49431C - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = &v60 + v70;
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_494320 - 1;
      v25 = dword_494320 / 32;
      v65 = dword_494320 / 32;
      v26 = &v60 + dword_494320 / 32;
      v64 = 31 - dword_494320 % 32;
      if ( ((1 << (31 - dword_494320 % 32)) & *v26) != 0 )
      {
        for ( j = (~(-1 << (31 - dword_494320 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = &v60 + v24 / 32;
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = &v60 + v28;
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || *v33 == -1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_494324 + 1) / 32;
      v37 = (dword_494324 + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = &v60 + v72;
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_494324));
  if ( dword_494328 == 64 )
  {
    v56 = v61;
    a2[1] = v55;
    *a2 = v56;
  }
  else if ( dword_494328 == 32 )
  {
    *a2 = v55;
  }
  return result;
}
// 494318: using guessed type int dword_494318;
// 49431C: using guessed type int dword_49431C;
// 494320: using guessed type int dword_494320;
// 494324: using guessed type int dword_494324;
// 494328: using guessed type int dword_494328;
// 49432C: using guessed type int dword_49432C;

//----- (00462536) --------------------------------------------------------
int __cdecl sub_462536(int a1, LPCWSTR lpFileName, int a3, int a4, int a5)
{
  return _sopen_helper_0(lpFileName, a3, a4, a5, a1, 1);
}

//----- (00462AD7) --------------------------------------------------------
int __cdecl sub_462AD7(_DWORD *a1, int a2, struct localeinfo_struct *a3)
{
  int v3; // eax
  char v6[4]; // [esp+Ch] [ebp-28h] BYREF
  char v7[8]; // [esp+10h] [ebp-24h] BYREF
  int v8; // [esp+18h] [ebp-1Ch]
  char v9; // [esp+1Ch] [ebp-18h]
  int v10; // [esp+20h] [ebp-14h]
  unsigned __int16 v11[6]; // [esp+24h] [ebp-10h] BYREF

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)v7, a3);
  v10 = __strgtold12_l(v11, v6, a2, 0, 0, 0, 0, v7);
  v3 = sub_45EBC6(v11, a1);
  if ( (v10 & 3) != 0 )
  {
    if ( (v10 & 1) != 0 )
      goto LABEL_8;
    if ( (v10 & 2) != 0 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= ~2u;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= ~2u;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= ~2u;
  return 0;
}
// 45F64E: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 462AD7: using guessed type char var_28[4];
// 462AD7: using guessed type unsigned __int16 var_10[6];

//----- (00462B7F) --------------------------------------------------------
int __cdecl sub_462B7F(_DWORD *a1, int a2, struct localeinfo_struct *a3)
{
  int v3; // eax
  char v6[4]; // [esp+Ch] [ebp-28h] BYREF
  char v7[8]; // [esp+10h] [ebp-24h] BYREF
  int v8; // [esp+18h] [ebp-1Ch]
  char v9; // [esp+1Ch] [ebp-18h]
  int v10; // [esp+20h] [ebp-14h]
  unsigned __int16 v11[6]; // [esp+24h] [ebp-10h] BYREF

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)v7, a3);
  v10 = __strgtold12_l(v11, v6, a2, 0, 0, 0, 0, v7);
  v3 = sub_45F10A(v11, a1);
  if ( (v10 & 3) != 0 )
  {
    if ( (v10 & 1) != 0 )
      goto LABEL_8;
    if ( (v10 & 2) != 0 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= ~2u;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= ~2u;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= ~2u;
  return 0;
}
// 45F64E: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 462B7F: using guessed type char var_28[4];
// 462B7F: using guessed type unsigned __int16 var_10[6];

//----- (00463FAA) --------------------------------------------------------
int __usercall sub_463FAA@<eax>(int a1@<ebx>, _BYTE *a2, int a3)
{
  int v3; // esi
  int v4; // edi
  char *v5; // eax
  int v6; // edx
  char v7; // al
  int v8; // edx
  char v9; // al
  int v10; // esi
  bool v12; // zf
  int v13; // [esp+8h] [ebp-8h]
  int v14; // [esp+Ch] [ebp-4h]
  char *v15; // [esp+18h] [ebp+8h]

  v3 = (char)*a2;
  v4 = 0;
  v13 = 0;
  if ( *a2 )
  {
    v14 = 1;
    do
    {
      ++a2;
      if ( !isspace(v3) )
      {
        if ( v3 == 61 )
          goto LABEL_27;
        v5 = strchr(dword_4A9D34, v3);
        if ( !v5 )
          return -1;
        if ( v13 )
        {
          if ( v13 == 1 )
          {
            if ( a1 )
            {
              if ( v14 >= a3 )
                return -1;
              v8 = v5 - dword_4A9D34;
              v9 = (_BYTE)v5 - (_BYTE)dword_4A9D34;
              *(_BYTE *)(v4 + a1) |= v8 >> 4;
              *(_BYTE *)(v4 + a1 + 1) = 16 * v9;
            }
            ++v4;
            ++v14;
            v13 = 2;
          }
          else if ( v13 == 2 )
          {
            if ( a1 )
            {
              if ( v14 >= a3 )
                return -1;
              v6 = v5 - dword_4A9D34;
              v7 = (_BYTE)v5 - (_BYTE)dword_4A9D34;
              *(_BYTE *)(v4 + a1) |= v6 >> 2;
              *(_BYTE *)(v4 + a1 + 1) = v7 << 6;
            }
            ++v4;
            ++v14;
            v13 = 3;
          }
          else
          {
            if ( a1 )
            {
              if ( v4 >= a3 )
                return -1;
              *(_BYTE *)(v4 + a1) |= (_BYTE)v5 - (_BYTE)dword_4A9D34;
            }
            ++v4;
            ++v14;
            v13 = 0;
          }
        }
        else
        {
          if ( a1 )
          {
            if ( v4 >= a3 )
              return -1;
            *(_BYTE *)(v4 + a1) = 4 * ((_BYTE)v5 - (_BYTE)dword_4A9D34);
          }
          v13 = 1;
        }
      }
      v3 = (char)*a2;
    }
    while ( *a2 );
  }
  ++a2;
  if ( v3 != 61 )
  {
    v12 = v13 == 0;
    goto LABEL_42;
  }
LABEL_27:
  v10 = (char)*a2;
  v15 = a2 + 1;
  if ( v13 > 1 )
  {
    if ( v13 == 2 )
    {
      while ( v10 && isspace(v10) )
        v10 = *v15++;
      if ( v10 == 61 )
        goto LABEL_38;
      return -1;
    }
    while ( v10 )
    {
      if ( !isspace(v10) )
        return -1;
LABEL_38:
      v10 = *v15++;
    }
    if ( !a1 )
      return v4;
    v12 = *(_BYTE *)(v4 + a1) == 0;
LABEL_42:
    if ( !v12 )
      return -1;
    return v4;
  }
  return -1;
}
// 4640E4: conditional instruction was optimized away because %var_8.4<4u
// 4640F3: conditional instruction was optimized away because %var_8.4==3
// 46400F: conditional instruction was optimized away because %var_8.4==3

//----- (00464149) --------------------------------------------------------
char *__usercall sub_464149@<eax>(char *a1@<eax>, _BYTE *a2@<ecx>)
{
  int v3; // eax
  char v5; // dl
  char *v6; // esi
  char v7; // cl
  char v8; // dl
  char v9; // cl

  v3 = 4;
  do
  {
    v5 = *a1;
    v6 = a1 + 1;
    if ( v5 > 57 )
      v7 = 16 * (2 - v5);
    else
      v7 = 16 * v5;
    v8 = *v6;
    a1 = v6 + 1;
    if ( v8 > 57 )
      v9 = (99 - v8) | v7;
    else
      v9 = (v8 - 48) | v7;
    *a2++ = v9;
    --v3;
  }
  while ( v3 );
  return a1;
}

//----- (0046418A) --------------------------------------------------------
_BYTE *__usercall sub_46418A@<eax>(_BYTE *result@<eax>, _BYTE *a2@<ecx>)
{
  int v2; // edi
  unsigned __int8 v4; // cl
  unsigned __int8 v5; // cl
  _BYTE *v6; // eax

  v2 = 4;
  do
  {
    v4 = *a2 >> 4;
    if ( v4 >= 0xAu )
      *result = 98 - v4;
    else
      *result = v4 + 48;
    v5 = *a2 & 0xF;
    v6 = result + 1;
    if ( v5 >= 0xAu )
      *v6 = 99 - v5;
    else
      *v6 = v5 + 48;
    result = v6 + 1;
    ++a2;
    --v2;
  }
  while ( v2 );
  return result;
}

//----- (004641C8) --------------------------------------------------------
int __usercall sub_4641C8@<eax>(int *a1@<eax>, _DWORD *a2@<ecx>)
{
  int v2; // ebx
  int v3; // edi
  int v4; // edx
  int v5; // esi
  int v6; // edi
  int v7; // edx
  int v8; // esi
  int v9; // ebx
  int v10; // edi
  int v11; // edx
  int v12; // esi
  int v13; // edi
  int v14; // edx
  int v15; // ebx
  int v16; // esi
  int v17; // edi
  int v18; // edx
  int v19; // ebx
  int v20; // esi
  int v21; // edi
  int v22; // eax
  int v23; // ebx
  int v24; // edx
  int v25; // edi
  int v26; // eax
  int v27; // ebx
  int v28; // edx
  int v29; // eax
  int v30; // ebx
  int v31; // edx
  int v32; // esi
  int v33; // eax
  int v34; // ebx
  int v35; // edx
  int v36; // esi
  int v37; // edi
  int v38; // eax
  int v39; // edx
  int v40; // esi
  int v41; // edi
  int v42; // eax
  int v43; // edx
  int v44; // esi
  int v45; // edi
  int v46; // eax
  int result; // eax
  int v48; // [esp+Ch] [ebp-50h]
  int v49; // [esp+10h] [ebp-4Ch]
  int v50; // [esp+14h] [ebp-48h]
  int v51; // [esp+18h] [ebp-44h]
  int v52; // [esp+1Ch] [ebp-40h]
  int v53; // [esp+20h] [ebp-3Ch]
  int v54; // [esp+24h] [ebp-38h]
  int v55; // [esp+28h] [ebp-34h]
  int v56; // [esp+2Ch] [ebp-30h]
  int v57; // [esp+30h] [ebp-2Ch]
  int v58; // [esp+34h] [ebp-28h]
  int v59; // [esp+38h] [ebp-24h]
  int v60; // [esp+3Ch] [ebp-20h]
  int v61; // [esp+40h] [ebp-1Ch]
  int v62; // [esp+44h] [ebp-18h]
  int v63; // [esp+48h] [ebp-14h]
  int v64; // [esp+4Ch] [ebp-10h]
  int v65; // [esp+50h] [ebp-Ch]
  int v66; // [esp+50h] [ebp-Ch]
  int v67; // [esp+58h] [ebp-4h]
  int v68; // [esp+58h] [ebp-4h]

  v2 = a2[1];
  v3 = a2[2];
  v63 = *a1;
  v55 = a1[1];
  v4 = __ROL4__(*a2 + *a1 + (v2 & v3 | a2[3] & ~v2), 3);
  v59 = a1[2];
  v5 = __ROL4__(a2[3] + v55 + (v4 & v2 | v3 & ~v4), 7);
  v52 = a1[3];
  v65 = __ROL4__(v3 + v59 + (v4 & v5 | v2 & ~v5), 11);
  v61 = a1[4];
  v67 = __ROR4__(v2 + v52 + (v65 & v5 | v4 & ~v65), 13);
  v53 = a1[5];
  v6 = __ROL4__(v4 + v61 + (v67 & v65 | v5 & ~v67), 3);
  v7 = __ROL4__(v5 + v53 + (v6 & v67 | v65 & ~v6), 7);
  v57 = a1[6];
  v50 = a1[7];
  v66 = __ROL4__(v65 + v57 + (v6 & v7 | v67 & ~v7), 11);
  v62 = a1[8];
  v8 = __ROR4__(v67 + v50 + (v66 & v7 | v6 & ~v66), 13);
  v54 = a1[9];
  v9 = __ROL4__(v6 + v62 + (v8 & v66 | v7 & ~v8), 3);
  v10 = __ROL4__(v7 + v54 + (v9 & v8 | v66 & ~v9), 7);
  v58 = a1[10];
  v51 = a1[11];
  v11 = __ROL4__(v66 + v58 + (v9 & v10 | v8 & ~v10), 11);
  v60 = a1[12];
  v68 = __ROR4__(v8 + v51 + (v11 & v10 | v9 & ~v11), 13);
  v12 = __ROL4__(v9 + v60 + (v68 & v11 | v10 & ~v68), 3);
  v48 = a1[13];
  v49 = a1[15];
  v13 = __ROL4__(v10 + v48 + (v12 & v68 | v11 & ~v12), 7);
  v56 = a1[14];
  v14 = __ROL4__(v11 + v56 + (v12 & v13 | v68 & ~v13), 11);
  v15 = __ROR4__(v68 + v49 + (v14 & v13 | v12 & ~v14), 13);
  v16 = __ROL4__(*a1 + (v15 & v14 | v13 & (v15 | v14)) + v12 + 1518500249, 3);
  v17 = __ROL4__(v61 + (v16 & v15 | v14 & (v16 | v15)) + v13 + 1518500249, 5);
  v18 = __ROL4__(v62 + (v16 & v15 | v17 & (v16 | v15)) + v14 + 1518500249, 9);
  v19 = __ROL4__(v60 + (v16 & v18 | v17 & (v16 | v18)) + v15 + 1518500249, 13);
  v20 = __ROL4__(v55 + (v19 & v18 | v17 & (v19 | v18)) + v16 + 1518500249, 3);
  v21 = __ROL4__(v53 + (v20 & v19 | v18 & (v20 | v19)) + v17 + 1518500249, 5);
  v22 = __ROL4__(v54 + (v20 & v19 | v21 & (v20 | v19)) + v18 + 1518500249, 9);
  v23 = __ROL4__(v48 + (v20 & v22 | v21 & (v20 | v22)) + v19 + 1518500249, 13);
  v24 = __ROL4__(v59 + (v23 & v22 | v21 & (v23 | v22)) + v20 + 1518500249, 3);
  v25 = __ROL4__(v57 + (v24 & v23 | v22 & (v24 | v23)) + v21 + 1518500249, 5);
  v26 = __ROL4__(v58 + (v24 & v23 | v25 & (v24 | v23)) + v22 + 1518500249, 9);
  v27 = __ROL4__(v56 + (v24 & v26 | v25 & (v24 | v26)) + v23 + 1518500249, 13);
  v28 = __ROL4__(v52 + (v27 & v26 | v25 & (v27 | v26)) + v24 + 1518500249, 3);
  v64 = __ROL4__(v50 + (v28 & v27 | v26 & (v28 | v27)) + v25 + 1518500249, 5);
  v29 = __ROL4__(v51 + (v28 & v27 | v64 & (v28 | v27)) + v26 + 1518500249, 9);
  v30 = __ROL4__(v49 + (v28 & v29 | v64 & (v28 | v29)) + v27 + 1518500249, 13);
  v31 = __ROL4__(v63 + (v30 ^ v29 ^ v64) + v28 + 1859775393, 3);
  v32 = __ROL4__(v62 + (v31 ^ v30 ^ v29) + v64 + 1859775393, 9);
  v33 = __ROL4__(v61 + (v31 ^ v30 ^ v32) + v29 + 1859775393, 11);
  v34 = __ROL4__(v60 + (v31 ^ v33 ^ v32) + v30 + 1859775393, 15);
  v35 = __ROL4__(v59 + (v34 ^ v33 ^ v32) + v31 + 1859775393, 3);
  v36 = __ROL4__(v58 + (v35 ^ v34 ^ v33) + v32 + 1859775393, 9);
  v37 = __ROL4__(v57 + (v35 ^ v34 ^ v36) + v33 + 1859775393, 11);
  v38 = __ROL4__(v56 + (v35 ^ v37 ^ v36) + v34 + 1859775393, 15);
  v39 = __ROL4__(v55 + (v38 ^ v37 ^ v36) + v35 + 1859775393, 3);
  v40 = __ROL4__(v54 + (v39 ^ v38 ^ v37) + v36 + 1859775393, 9);
  v41 = __ROL4__(v53 + (v39 ^ v38 ^ v40) + v37 + 1859775393, 11);
  v42 = __ROL4__(v48 + (v39 ^ v41 ^ v40) + v38 + 1859775393, 15);
  v43 = __ROL4__(v52 + (v42 ^ v41 ^ v40) + v39 + 1859775393, 3);
  v44 = __ROL4__(v51 + (v43 ^ v42 ^ v41) + v40 + 1859775393, 9);
  v45 = __ROL4__(v50 + (v43 ^ v42 ^ v44) + v41 + 1859775393, 11);
  v46 = a2[1] + __ROL4__(v49 + (v43 ^ v45 ^ v44) + v42 + 1859775393, 15);
  *a2 += v43;
  a2[1] = v46;
  a2[2] += v45;
  result = v44 + a2[3];
  a2[3] = result;
  return result;
}

//----- (004646CF) --------------------------------------------------------
int __thiscall sub_4646CF(_DWORD *this)
{
  int result; // eax

  *this = 1732584193;
  this[1] = -271733879;
  this[2] = -1732584194;
  this[3] = 271733878;
  result = 0;
  this[4] = 0;
  this[5] = 0;
  this[6] = 0;
  return result;
}

//----- (004646F8) --------------------------------------------------------
int __usercall sub_4646F8@<eax>(unsigned int a1@<edx>, _DWORD *a2@<ecx>, int *a3)
{
  int result; // eax
  char *v5; // edi
  unsigned int v6; // eax
  _BYTE *i; // edx
  unsigned int v8; // eax
  unsigned int v9; // ebx
  char v10; // al
  signed int v11; // esi
  unsigned int v12; // ebx
  int v13; // ecx
  char v14; // [esp+4h] [ebp-50h]
  int v16[14]; // [esp+10h] [ebp-44h] BYREF
  char v17; // [esp+48h] [ebp-Ch]
  char v18; // [esp+49h] [ebp-Bh]
  char v19; // [esp+4Ah] [ebp-Ah]
  char v20; // [esp+4Bh] [ebp-9h]
  char v21; // [esp+4Ch] [ebp-8h]
  char v22; // [esp+4Dh] [ebp-7h]
  char v23; // [esp+4Eh] [ebp-6h]
  char v24; // [esp+4Fh] [ebp-5h]

  result = (int)a3;
  if ( a1 || !a2[6] )
  {
    v5 = (char *)(a2 + 4);
    v6 = a1;
    for ( i = a2 + 4; v6; ++i )
    {
      v8 = (unsigned __int8)*i + v6;
      *i = v8;
      v6 = v8 >> 8;
    }
    if ( a1 == 512 )
    {
      return sub_4641C8(a3, a2);
    }
    else
    {
      v9 = a1;
      v10 = a1 & 7;
      v11 = (a1 + 7) >> 3;
      v12 = v9 >> 3;
      v14 = v10;
      if ( v11 )
        memcpy(v16, a3, v11);
      if ( v11 < 64 )
        memset((char *)v16 + v11, 0, 64 - v11);
      *((_BYTE *)v16 + v12) = ((1 << (7 - v14)) | *((_BYTE *)v16 + v12)) & ~((1 << (7 - v14)) - 1);
      if ( v12 >= 0x38 )
      {
        sub_4641C8(v16, a2);
        memset(v16, 0, sizeof(v16));
      }
      v17 = *v5;
      v18 = v5[1];
      v19 = v5[2];
      v20 = v5[3];
      v21 = v5[4];
      v22 = v5[5];
      v23 = v5[6];
      v24 = v5[7];
      result = sub_4641C8(v16, a2);
      *(_DWORD *)(v13 + 24) = 1;
    }
  }
  return result;
}
// 46480A: variable 'v13' is possibly undefined

//----- (0046486C) --------------------------------------------------------
void __cdecl sub_46486C(int a1)
{
  void **v1; // esi
  unsigned int v2; // eax
  char *v3; // edi
  char *v4; // ecx
  int i; // [esp+10h] [ebp-10h]
  char v6[8]; // [esp+14h] [ebp-Ch] BYREF

  v1 = (void **)sub_47305B();
  v1[6] = 0;
  v1[7] = 0;
  v1[8] = 0;
  v6[0] = 0;
  v6[1] = 0;
  v6[2] = 0;
  v6[3] = 0;
  v6[4] = 0;
  v6[5] = 0;
  v6[6] = 0;
  v6[7] = 0;
  if ( !dword_4A9D34 )
    dword_4A9D34 = (char *)malloc(0x41u);
  if ( a1 )
    ((void (__cdecl *)(int, void *))v1[1])(a1, *v1);
  memset(dword_4A9D34, 0, 0x41u);
  for ( i = 0; i < 64; ++i )
  {
    do
    {
      if ( a1 )
        v2 = sub_47304A((int)v1) & 0x3F;
      else
        v2 = i;
      v3 = &v6[v2 >> 3];
    }
    while ( ((unsigned __int8)(1 << (v2 & 7)) & (unsigned __int8)*v3) != 0 );
    v4 = &dword_4A9D34[i];
    *v3 |= 1 << (v2 & 7);
    *v4 = v2 + 48;
    if ( v2 >= 0xA )
      *v4 = v2 + 55;
    if ( v2 >= 0x24 )
      *v4 = v2 + 61;
    if ( v2 >= 0x3E )
      *v4 = byte_494626[v2];
  }
  dword_4A9D34[64] = 61;
  sub_472BE5(v1);
}

//----- (004649EF) --------------------------------------------------------
int __usercall sub_4649EF@<eax>(int a1@<eax>, _BYTE *a2, _DWORD *a3)
{
  int v3; // edi
  int v5; // kr00_4
  void *v6; // esi
  char *v7; // ebx
  unsigned __int8 v8; // cl
  unsigned __int8 v9; // al
  char v10; // dl
  int v11; // eax
  void *v12; // eax
  int v13; // edi
  void *v14; // eax
  int v15; // edi
  void *v16; // eax
  int v17; // edi
  void *v18; // eax
  void *v19; // eax
  void *v20; // eax
  int v21; // edi
  void *v22; // eax
  int v23; // edi
  void *v24; // eax
  int v25; // edi
  void *v26; // eax
  size_t v28; // [esp-4h] [ebp-34h]
  size_t v29; // [esp-4h] [ebp-34h]
  size_t v30; // [esp-4h] [ebp-34h]
  size_t v31; // [esp-4h] [ebp-34h]
  size_t v32; // [esp-4h] [ebp-34h]
  size_t v33; // [esp-4h] [ebp-34h]
  size_t v34; // [esp-4h] [ebp-34h]
  size_t v35; // [esp-4h] [ebp-34h]
  size_t v36; // [esp+10h] [ebp-20h]
  int v37; // [esp+10h] [ebp-20h]
  int v38; // [esp+10h] [ebp-20h]
  int v39; // [esp+10h] [ebp-20h]
  int v40; // [esp+14h] [ebp-1Ch]
  int v41; // [esp+1Ch] [ebp-14h]
  int v42; // [esp+20h] [ebp-10h]
  int v43; // [esp+24h] [ebp-Ch]
  unsigned __int8 v45; // [esp+2Dh] [ebp-3h]
  unsigned __int8 v46; // [esp+2Dh] [ebp-3h]
  unsigned __int8 v47; // [esp+2Eh] [ebp-2h]
  unsigned __int8 v48; // [esp+2Eh] [ebp-2h]
  unsigned __int8 v49; // [esp+2Fh] [ebp-1h]
  unsigned __int8 v50; // [esp+2Fh] [ebp-1h]
  int v51; // [esp+38h] [ebp+8h]
  unsigned __int8 v52; // [esp+3Bh] [ebp+Bh]
  unsigned __int8 v53; // [esp+3Bh] [ebp+Bh]

  v3 = 0;
  sub_46486C(0);
  v51 = a1 / 3;
  v41 = a1 % 3;
  v5 = 4 * ((a1 + 2) / 3) + 1;
  v36 = (v5 / 1024 + 1) << 10;
  v40 = v36;
  if ( v36 )
  {
    v6 = malloc((v5 / 1024 + 1) << 10);
  }
  else
  {
    v40 = 32;
    v6 = 0;
  }
  v7 = dword_4A9D34;
  v43 = 0;
  if ( v51 <= 0 )
  {
    v11 = (v5 / 1024 + 1) << 10;
  }
  else
  {
    v42 = v51;
    do
    {
      v47 = *a2 >> 2;
      v8 = a2[1];
      v52 = (v8 >> 4) | (16 * (*a2 & 3));
      v9 = a2[2];
      a2 += 3;
      v10 = v9 >> 6;
      v45 = v9 & 0x3F;
      v11 = v36;
      v49 = v10 | (4 * (v8 & 0xF));
      if ( v3 == v36 )
      {
        v36 += v40;
        if ( v6 )
          v12 = realloc(v6, v36);
        else
          v12 = malloc(v36);
        v6 = v12;
        v11 = v36;
      }
      *((_BYTE *)v6 + v3) = v7[v47];
      v13 = v3 + 1;
      if ( v13 == v11 )
      {
        v36 = v40 + v11;
        v28 = v40 + v11;
        if ( v6 )
          v14 = realloc(v6, v28);
        else
          v14 = malloc(v28);
        v6 = v14;
        v11 = v36;
      }
      *((_BYTE *)v6 + v13) = v7[v52];
      v15 = v13 + 1;
      if ( v15 == v11 )
      {
        v36 = v40 + v11;
        v29 = v40 + v11;
        if ( v6 )
          v16 = realloc(v6, v29);
        else
          v16 = malloc(v29);
        v6 = v16;
        v11 = v36;
      }
      *((_BYTE *)v6 + v15) = v7[v49];
      v17 = v15 + 1;
      if ( v17 == v11 )
      {
        v36 = v40 + v11;
        v30 = v40 + v11;
        if ( v6 )
          v18 = realloc(v6, v30);
        else
          v18 = malloc(v30);
        v6 = v18;
        v11 = v36;
      }
      v43 += 4;
      *((_BYTE *)v6 + v17) = v7[v45];
      v3 = v17 + 1;
      if ( v43 >= 76 )
      {
        if ( v3 == v11 )
        {
          v36 = v40 + v11;
          v31 = v40 + v11;
          if ( v6 )
            v19 = realloc(v6, v31);
          else
            v19 = malloc(v31);
          v6 = v19;
          v11 = v36;
        }
        *((_BYTE *)v6 + v3++) = 10;
        v43 = 0;
      }
      --v42;
    }
    while ( v42 );
  }
  if ( v41 )
  {
    v50 = 64;
    v48 = *a2 >> 2;
    v53 = 16 * (*a2 & 3);
    if ( v41 == 2 )
    {
      v46 = a2[1];
      v53 |= v46 >> 4;
      v50 = 4 * (v46 & 0xF);
    }
    if ( v3 == v11 )
    {
      v37 = v40 + v11;
      v32 = v40 + v11;
      if ( v6 )
        v20 = realloc(v6, v32);
      else
        v20 = malloc(v32);
      v6 = v20;
      v11 = v37;
    }
    *((_BYTE *)v6 + v3) = v7[v48];
    v21 = v3 + 1;
    if ( v21 == v11 )
    {
      v38 = v40 + v11;
      v33 = v40 + v11;
      if ( v6 )
        v22 = realloc(v6, v33);
      else
        v22 = malloc(v33);
      v6 = v22;
      v11 = v38;
    }
    *((_BYTE *)v6 + v21) = v7[v53];
    v23 = v21 + 1;
    if ( v23 == v11 )
    {
      v39 = v40 + v11;
      v34 = v40 + v11;
      if ( v6 )
        v24 = realloc(v6, v34);
      else
        v24 = malloc(v34);
      v6 = v24;
      v11 = v39;
    }
    *((_BYTE *)v6 + v23) = v7[v50];
    v25 = v23 + 1;
    if ( v25 == v11 )
    {
      v35 = v40 + v11;
      if ( v6 )
        v26 = realloc(v6, v35);
      else
        v26 = malloc(v35);
      v6 = v26;
    }
    *((_BYTE *)v6 + v25) = 61;
    v3 = v25 + 1;
  }
  memset(v7, 0, 0x41u);
  *a3 = v6;
  return v3;
}

//----- (00464CBD) --------------------------------------------------------
int __cdecl sub_464CBD(int a1, int Size, _BYTE *a3, signed int a4)
{
  void **v4; // ebx
  int v5; // esi
  int v6; // edi
  char v7; // cl
  int v8; // eax
  bool v9; // zf
  _BYTE *v10; // esi
  _BYTE *v11; // edi
  char *v12; // eax
  int v13; // ecx
  unsigned __int8 v14; // bl
  unsigned __int8 v15; // dl
  _BYTE *v16; // edi
  unsigned __int8 v17; // dl
  unsigned __int8 v18; // cl
  _BYTE *v19; // edi
  void **v21; // [esp+Ch] [ebp-20h]
  int v22; // [esp+10h] [ebp-1Ch] BYREF
  int v23; // [esp+14h] [ebp-18h]
  int v24; // [esp+18h] [ebp-14h]
  int v25; // [esp+1Ch] [ebp-10h]
  int v26; // [esp+20h] [ebp-Ch]
  void *Block; // [esp+24h] [ebp-8h]
  unsigned __int8 v28; // [esp+2Bh] [ebp-1h]
  unsigned __int8 v29; // [esp+3Fh] [ebp+13h]
  unsigned __int8 v30; // [esp+3Fh] [ebp+13h]

  v4 = (void **)sub_47305B();
  v21 = v4;
  v4[6] = 0;
  v4[7] = 0;
  v4[8] = 0;
  v24 = 8;
  Block = malloc(Size);
  v5 = rand() << 16;
  v6 = v5 | rand();
  v22 = v6;
  memset(a3, 0, a4);
  ((void (__cdecl *)(int, void *))v4[1])(v6, *v4);
  if ( Size > 0 )
  {
    v26 = (int)Block;
    v23 = a1 - (_DWORD)Block;
    v25 = Size;
    do
    {
      v7 = sub_47304A((int)v4);
      v8 = v26;
      *(_BYTE *)v26 = *(_BYTE *)(v23 + v26) ^ v7;
      v9 = v25-- == 1;
      v26 = v8 + 1;
    }
    while ( !v9 );
  }
  sub_46486C(v6);
  v10 = Block;
  v11 = sub_46418A(a3, &v22);
  v26 = Size % 3;
  v12 = dword_4A9D34;
  v13 = 4 * ((Size + 2) / 3);
  if ( v13 < a4 )
  {
    v24 = v13 + 8;
    if ( Size / 3 > 0 )
    {
      v25 = Size / 3;
      do
      {
        v14 = v10[2];
        v29 = (v10[1] >> 4) | (16 * (*v10 & 3));
        v15 = (v14 >> 6) | (4 * (v10[1] & 0xF));
        *v11 = v12[*v10 >> 2];
        v10 += 3;
        v16 = v11 + 1;
        *v16++ = v12[v29];
        *v16++ = v12[v15];
        *v16 = v12[v14 & 0x3F];
        v11 = v16 + 1;
        --v25;
      }
      while ( v25 );
      v4 = v21;
    }
    if ( v26 )
    {
      v17 = *v10 >> 2;
      v18 = 16 * (*v10 & 3);
      v28 = 64;
      v30 = v18;
      if ( v26 == 2 )
      {
        v30 = (v10[1] >> 4) | v18;
        v28 = 4 * (v10[1] & 0xF);
      }
      *v11 = v12[v17];
      v19 = v11 + 1;
      *v19++ = v12[v30];
      *v19++ = v12[v28];
      *v19 = 61;
      v11 = v19 + 1;
    }
    *v11 = 0;
  }
  memset(v12, 0, 0x41u);
  sub_472BE5(v4);
  memset(Block, 0, Size);
  free(Block);
  return v24;
}

//----- (0046506E) --------------------------------------------------------
void __cdecl sub_46506E(FILE *a1, int *a2)
{
  size_t Size; // ecx
  size_t v3; // esi
  size_t v4; // ebx
  char *v5; // edi
  size_t v6; // eax
  char *v7; // edi
  int v8; // eax
  int v9; // esi
  _BYTE *v10; // [esp+10h] [ebp-3Ch]
  int Sizea; // [esp+14h] [ebp-38h]
  size_t v12; // [esp+18h] [ebp-34h]
  void *Block; // [esp+20h] [ebp-2Ch]
  char v14; // [esp+27h] [ebp-25h]
  int *v15; // [esp+28h] [ebp-24h]
  int v16; // [esp+28h] [ebp-24h]
  _DWORD v17[7]; // [esp+2Ch] [ebp-20h] BYREF

  v3 = Size;
  v4 = Size + 16;
  v5 = (char *)malloc(Size + 16);
  Block = v5;
  Sizea = 2 * v4;
  v10 = malloc(2 * v4);
  v15 = a2;
  sub_4646CF(v17);
  if ( v3 )
  {
    v6 = v3 >> 6;
    if ( v3 >> 6 )
    {
      while ( 1 )
      {
        v12 = v6 - 1;
        sub_4646F8(0x200u, v17, v15);
        v15 += 16;
        if ( !v12 )
          break;
        v6 = v12;
      }
    }
  }
  sub_4646F8(8 * (v3 & 0x3F), v17, v15);
  memcpy(v5, a2, v3);
  v7 = &v5[v3];
  *(_DWORD *)v7 = v17[0];
  v7 += 4;
  *(_DWORD *)v7 = v17[1];
  v7 += 4;
  *(_DWORD *)v7 = v17[2];
  *((_DWORD *)v7 + 1) = v17[3];
  v16 = sub_464CBD((int)Block, v4, v10, Sizea);
  v8 = 0;
  if ( v16 > 0 )
  {
    do
    {
      v9 = v8 + 64;
      if ( v8 + 64 > v16 )
        v9 = v16;
      v14 = v10[v9];
      v10[v9] = 0;
      fprintf(a1, "%s\n", &v10[v8]);
      v10[v9] = v14;
      v8 = v9;
    }
    while ( v9 < v16 );
  }
  memset(Block, 0, v4);
  memset(v10, 0, Sizea);
  free(Block);
  free(v10);
}
// 465083: variable 'Size' is possibly undefined
// 46506E: using guessed type _DWORD var_20[7];

//----- (004651F0) --------------------------------------------------------
_BYTE *__usercall sub_4651F0@<eax>(_BYTE *result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // esi

  if ( a3 > 0 )
  {
    v3 = a2 - (_DWORD)result;
    do
    {
      --a3;
      result[v3] = *result;
      ++result;
    }
    while ( a3 > 0 );
  }
  return result;
}

//----- (00465210) --------------------------------------------------------
int sub_465210()
{
  int v0; // eax
  char *v1; // esi
  char *v2; // edi
  char *v3; // eax
  int v4; // ecx
  char *v5; // esi
  int v6; // esi
  int v7; // ebx
  void *v8; // esp
  void *v9; // esp
  int v10; // esi
  int v11; // ebx
  int v12; // esi
  int v13; // ecx
  int v14; // eax
  unsigned int v15; // esi
  int v16; // eax
  char *v17; // eax
  int v18; // edx
  int v19; // edx
  int v20; // eax
  bool v21; // zf
  int v22; // eax
  unsigned int v23; // esi
  int v24; // ebx
  unsigned int v25; // kr04_4
  char *v26; // eax
  char *v27; // ebx
  unsigned int v28; // ecx
  bool v29; // cc
  int v30; // eax
  char *v31; // eax
  char *v32; // ecx
  int v33; // eax
  unsigned int v34; // eax
  char *v35; // eax
  int v36; // edx
  int v37; // eax
  int v38; // ecx
  int v39; // edx
  int v40; // eax
  int v41; // edx
  int v42; // eax
  int v43; // ecx
  int v44; // edx
  int v45; // eax
  int v46; // edx
  int v47; // eax
  int v48; // ecx
  int v49; // edx
  int v50; // eax
  int v51; // eax
  int v52; // edx
  int v53; // ecx
  int v54; // eax
  int v55; // edx
  int v56; // ecx
  int v57; // ecx
  int v58; // edx
  int v59; // eax
  int v60; // ecx
  int v61; // edx
  int v62; // ecx
  int v63; // eax
  int v64; // edx
  int v65; // ecx
  int v66; // ecx
  int v67; // edx
  int v68; // ecx
  int v69; // edx
  char *v70; // ebx
  int v71; // ecx
  int v72; // edx
  int v73; // eax
  int v74; // ecx
  int v75; // edx
  int v76; // ecx
  int v77; // edx
  int v78; // eax
  int v79; // ecx
  int v80; // edx
  int v81; // eax
  int v82; // ecx
  int v83; // edx
  int v84; // eax
  int v85; // ecx
  int v86; // ecx
  int v87; // edx
  int v88; // eax
  int v89; // ecx
  int v90; // edx
  int v91; // eax
  int v92; // edx
  int v93; // ecx
  int v94; // eax
  int v95; // edx
  int v96; // ecx
  int v97; // edx
  int v98; // eax
  int v99; // ecx
  int v100; // edx
  int v101; // eax
  int v102; // ecx
  int v103; // edx
  int v104; // eax
  int v105; // ecx
  char *v106; // eax
  int v107; // edx
  int v108; // ecx
  int v109; // edx
  int v110; // ecx
  int v111; // edx
  int v112; // ecx
  int v113; // edx
  __int16 v114; // cx
  unsigned int v115; // eax
  char *v116; // eax
  int *v118; // [esp-10h] [ebp-1500h]
  char *v119; // [esp-Ch] [ebp-14FCh]
  int v120; // [esp-8h] [ebp-14F8h]
  int v121; // [esp-4h] [ebp-14F4h]
  _BYTE v122[16]; // [esp+0h] [ebp-14F0h] BYREF
  char v123[4800]; // [esp+10h] [ebp-14E0h] BYREF
  int v124; // [esp+12D0h] [ebp-220h] BYREF
  char v125; // [esp+12D8h] [ebp-218h]
  int v126; // [esp+12E0h] [ebp-210h] BYREF
  int v127; // [esp+12E4h] [ebp-20Ch]
  int v128; // [esp+12E8h] [ebp-208h]
  int v129; // [esp+12ECh] [ebp-204h]
  int v130; // [esp+12F0h] [ebp-200h]
  int v131; // [esp+12F4h] [ebp-1FCh]
  int v132; // [esp+12F8h] [ebp-1F8h]
  int *v133; // [esp+12FCh] [ebp-1F4h]
  int v134[6]; // [esp+1300h] [ebp-1F0h] BYREF
  char *v135; // [esp+1318h] [ebp-1D8h]
  int v136; // [esp+131Ch] [ebp-1D4h]
  char *v137; // [esp+1320h] [ebp-1D0h]
  int i; // [esp+1324h] [ebp-1CCh]
  int v139; // [esp+1328h] [ebp-1C8h]
  char *v140; // [esp+132Ch] [ebp-1C4h]
  char *v141; // [esp+1330h] [ebp-1C0h]
  int v142; // [esp+1334h] [ebp-1BCh]
  int v143; // [esp+1338h] [ebp-1B8h]
  char *v144; // [esp+133Ch] [ebp-1B4h]
  int v145; // [esp+1340h] [ebp-1B0h] BYREF
  int v146; // [esp+1344h] [ebp-1ACh]
  int v147; // [esp+1348h] [ebp-1A8h] BYREF
  int v148; // [esp+134Ch] [ebp-1A4h]
  int v149; // [esp+1350h] [ebp-1A0h]
  int v150; // [esp+1354h] [ebp-19Ch] BYREF
  char v151; // [esp+1358h] [ebp-198h] BYREF

  v135 = &v151;
  v0 = 0;
  v137 = v123;
  v136 = 200;
  v142 = 0;
  v132 = 0;
  v139 = -2;
  v1 = (char *)&v150 + 2;
  v2 = v123;
  while ( 2 )
  {
    v144 = v2;
LABEL_3:
    while ( 2 )
    {
      for ( i = v0; ; i = word_496AD0[v115] )
      {
        v3 = v135;
        v4 = v136;
        v5 = v1 + 2;
        *(_WORD *)v5 = i;
        v140 = v5;
        if ( v5 >= &v3[2 * v4 - 2] )
        {
          v6 = ((v5 - v3) >> 1) + 1;
          v141 = v137;
          v137 = v3;
          if ( v4 >= 10000 )
          {
            v116 = (char *)sub_473493((int)&unk_488898);
            sub_468060(v116);
            return 2;
          }
          v7 = 2 * v4;
          v136 = 2 * v4;
          if ( 2 * v4 > 10000 )
          {
            v136 = 10000;
            v7 = 10000;
          }
          v133 = (int *)(2 * v7);
          v8 = alloca(2 * v7);
          v135 = v122;
          v143 = 2 * v6;
          sub_4651F0(v137, (int)v122, 2 * v6);
          v9 = alloca(24 * v7);
          v10 = 24 * v6;
          v137 = v122;
          sub_4651F0(v141, (int)v122, v10);
          v144 = &v122[v10 - 24];
          v140 = &v122[v143 - 2];
          if ( v140 >= &v122[(int)v133 - 2] )
            return 1;
          v2 = v144;
        }
        v11 = i;
        v12 = word_496498[i];
        v13 = v139;
        if ( v12 != -32768 )
        {
          if ( v139 == -2 )
          {
            v139 = sub_46C960((int)&v126);
            v13 = v139;
          }
          v14 = 0;
          if ( v13 > 0 )
          {
            v14 = (unsigned int)v13 > 0x169 ? 263 : word_4951F8[v13];
          }
          else
          {
            v139 = 0;
            v13 = 0;
          }
          v15 = v14 + v12;
          if ( v15 <= 0xE16 && word_498700[v15] == v14 )
            break;
        }
        v143 = word_495E60[v11];
        if ( !v143 )
          goto LABEL_34;
LABEL_23:
        v16 = word_495BA8[v143];
        v141 = (char *)v16;
        if ( v16 > 0 )
        {
          v17 = &v2[-24 * v16];
          v18 = *((_DWORD *)v17 + 6);
          v17 += 24;
          v145 = v18;
          v146 = *((_DWORD *)v17 + 1);
          v147 = *((_DWORD *)v17 + 2);
          v148 = *((_DWORD *)v17 + 3);
          v19 = *((_DWORD *)v17 + 4);
          v20 = *((_DWORD *)v17 + 5);
          v149 = v19;
          v150 = v20;
        }
        switch ( v143 )
        {
          case 2:
          case 7:
            sub_46CAF0();
            break;
          case 6:
            sub_470410();
            break;
          case 12:
          case 60:
            sub_46CA40();
            break;
          case 14:
          case 95:
            sub_46E8F0((_DWORD *)v2 - 6, (int)v2);
            break;
          case 15:
            sub_46E850((int)(v2 - 48), 1);
            break;
          case 16:
          case 19:
            sub_46C130();
            break;
          case 17:
          case 98:
            sub_46E8F0((_DWORD *)v2 - 12, (int)(v2 - 24));
            break;
          case 18:
            sub_46E850((int)(v2 - 72), 1);
            break;
          case 20:
            *((_DWORD *)v2 - 4) = *(_DWORD *)(dword_4AB36C + 20);
            break;
          case 21:
            sub_46EBE0((_DWORD *)v2 - 6, (int)v2);
            break;
          case 22:
            sub_46EB80((int)(v2 - 144), (int)(v2 - 48));
            break;
          case 23:
            *((_DWORD *)v2 + 2) = *(_DWORD *)(dword_4AB36C + 20);
            sub_46DA40();
            break;
          case 24:
            *((_DWORD *)v2 + 2) = *(_DWORD *)(dword_4AB36C + 20);
            break;
          case 25:
            sub_46D9D0((_DWORD *)v2 - 12, (int)(v2 - 192), (int)(v2 - 96));
            break;
          case 26:
            sub_46E2C0((int)(v2 - 24));
            *((_DWORD *)v2 + 2) = *(_DWORD *)(dword_4AB36C + 20);
            break;
          case 27:
            sub_46CAF0();
            sub_46EB30((_DWORD *)v2 - 6, (int)v2);
            break;
          case 28:
            sub_46E2C0((int)(v2 - 24));
            sub_46EAD0((int)(v2 - 144), (int)(v2 - 72));
            break;
          case 29:
            sub_46EA70((int)(v2 - 120));
            break;
          case 30:
            sub_46D8A0((int *)v2 - 6);
            break;
          case 31:
            sub_46D780(v2);
            break;
          case 32:
            sub_46D960(0, 50);
            break;
          case 33:
            sub_46D960((_DWORD *)v2 - 6, 50);
            break;
          case 34:
            sub_46D960(0, 51);
            break;
          case 35:
            sub_46D960((_DWORD *)v2 - 6, 51);
            break;
          case 36:
            sub_46FA60(0, 0);
            break;
          case 37:
            sub_46FA60((_DWORD *)v2 - 6, 0);
            break;
          case 38:
            sub_46FA60((_DWORD *)v2 - 6, 1);
            break;
          case 42:
          case 147:
          case 148:
            sub_46EDA0(v2);
            break;
          case 43:
          case 151:
            sub_46E2C0((int)(v2 - 24));
            break;
          case 44:
            v35 = (char *)sub_473493((int)&unk_4888B0);
            zend_error(64, v35);
            zval_dtor((int)(v2 - 16));
            break;
          case 46:
            v121 = 1;
            goto LABEL_103;
          case 47:
          case 50:
            sub_46F220((_DWORD *)v2 - 12, (_DWORD *)v2 - 6, (_DWORD *)v2 - 24);
            break;
          case 48:
          case 51:
            sub_46F1B0((int)(v2 - 216), (_DWORD *)v2 - 48);
            break;
          case 49:
            v121 = 0;
LABEL_103:
            sub_46CE90((_DWORD *)v2 - 12, (int)(v2 - 72), (_DWORD *)v2 - 6, v2, v121);
            break;
          case 52:
            *((_DWORD *)v2 + 2) = *(_DWORD *)(dword_4AB36C + 20);
            sub_46C5F0();
            break;
          case 53:
            sub_46C030((int)(v2 - 120));
            break;
          case 57:
            sub_46E750(6, 0);
            sub_46C090();
            break;
          case 58:
          case 72:
          case 114:
          case 124:
          case 125:
          case 150:
          case 152:
          case 153:
            v36 = *((_DWORD *)v2 + 1);
            v37 = *((_DWORD *)v2 + 2);
            v145 = *(_DWORD *)v2;
            v38 = *((_DWORD *)v2 + 3);
            v146 = v36;
            v39 = *((_DWORD *)v2 + 4);
            v147 = v37;
            v40 = *((_DWORD *)v2 + 5);
            v148 = v38;
            v149 = v39;
            v150 = v40;
            break;
          case 59:
          case 81:
          case 82:
          case 126:
          case 210:
          case 262:
            v41 = *((_DWORD *)v2 - 5);
            v42 = *((_DWORD *)v2 - 4);
            v145 = *((_DWORD *)v2 - 6);
            v43 = *((_DWORD *)v2 - 3);
            v146 = v41;
            v44 = *((_DWORD *)v2 - 2);
            v147 = v42;
            v45 = *((_DWORD *)v2 - 1);
            v148 = v43;
            v149 = v44;
            v150 = v45;
            break;
          case 61:
          case 64:
          case 134:
          case 137:
            *((_DWORD *)v2 + 2) = dword_4AB35C;
            break;
          case 62:
          case 65:
            sub_46E140((int)v2, (int)(v2 - 72), 0, *((_DWORD *)v2 - 6));
            break;
          case 63:
          case 136:
            sub_46FE30((int)(v2 - 240));
            break;
          case 66:
          case 139:
            sub_46FE30((int)(v2 - 216));
            break;
          case 67:
            sub_46F760((int)v2, 0);
            break;
          case 68:
          case 70:
            sub_470090((void *)v143);
            break;
          case 69:
            sub_46F760((int)(v2 - 48), (int)v2);
            break;
          case 71:
          case 85:
          case 284:
            goto LABEL_228;
          case 79:
          case 80:
            sub_46CE10((int)(v2 - 48), v2);
            break;
          case 83:
          case 84:
            v46 = *((_DWORD *)v2 - 11);
            v47 = *((_DWORD *)v2 - 10);
            v145 = *((_DWORD *)v2 - 12);
            v48 = *((_DWORD *)v2 - 9);
            v146 = v46;
            v49 = *((_DWORD *)v2 - 8);
            v147 = v47;
            v50 = *((_DWORD *)v2 - 7);
            v148 = v48;
            v149 = v49;
            v150 = v50;
            break;
          case 86:
            sub_46CAF0();
            sub_46D660((_DWORD *)v2 - 6, (_DWORD *)v2 - 18, (int)(v2 - 48));
            break;
          case 87:
            sub_46D600((int)&v145, (int)(v2 - 96));
            goto LABEL_123;
          case 88:
            sub_46CAF0();
            sub_46D550((_DWORD *)v2 - 12, (int)(v2 - 24));
            break;
          case 89:
            sub_46D600((int)&v145, (int)(v2 - 72));
            v145 = 1;
            break;
          case 96:
            sub_46E850((int)(v2 - 48), 0);
            break;
          case 99:
            sub_46E850((int)(v2 - 72), 0);
            break;
          case 106:
          case 108:
            sub_46FE80(0, v134, (int)v2);
            v51 = 1;
            v145 = 1;
            v149 = 65537;
            v121 = 0;
            goto LABEL_129;
          case 107:
            sub_46FE80(0, v134, (int)v2);
            v51 = 1;
            v145 = 1;
            v149 = 65537;
            v121 = 1;
            goto LABEL_129;
          case 109:
            sub_46FE80(0, v134, (int)(v2 - 48));
            v145 = 1;
            v147 = 1;
            v149 = 65537;
            sub_46E000(v2, &v145, 64, v134, 0);
            break;
          case 110:
            sub_46FE80(0, v134, (int)v2);
            v52 = *((_DWORD *)v2 - 12);
            v53 = *((_DWORD *)v2 - 9);
            v146 = *((_DWORD *)v2 - 11);
            v54 = *((_DWORD *)v2 - 10);
            v145 = v52;
            v55 = *((_DWORD *)v2 - 8);
            v148 = v53;
            v56 = *((_DWORD *)v2 - 7);
            v149 = v55;
            v150 = v56;
            v51 = v54 + 1;
            v121 = 0;
            goto LABEL_129;
          case 111:
            sub_46FE80(0, v134, (int)v2);
            v57 = *((_DWORD *)v2 - 17);
            v58 = *((_DWORD *)v2 - 15);
            v145 = *((_DWORD *)v2 - 18);
            v59 = *((_DWORD *)v2 - 16);
            v146 = v57;
            v60 = *((_DWORD *)v2 - 14);
            v148 = v58;
            v61 = *((_DWORD *)v2 - 13);
            v149 = v60;
            v150 = v61;
            v51 = v59 + 1;
            v121 = 1;
LABEL_129:
            v147 = v51;
            sub_46E000(0, &v145, 63, v134, v121);
            break;
          case 112:
            sub_46FE80(0, v134, (int)v2);
            v62 = *((_DWORD *)v2 - 18);
            v63 = *((_DWORD *)v2 - 16);
            v146 = *((_DWORD *)v2 - 17);
            v64 = *((_DWORD *)v2 - 14);
            v145 = v62;
            v65 = *((_DWORD *)v2 - 15);
            v149 = v64;
            v121 = 0;
            v148 = v65;
            v150 = *((_DWORD *)v2 - 13);
            v147 = v63 + 1;
            sub_46E000(0, &v145, 63, v134, 0);
            break;
          case 113:
            sub_46FE80(0, v134, (int)(v2 - 48));
            v66 = *((_DWORD *)v2 - 23);
            v67 = *((_DWORD *)v2 - 21);
            v145 = *((_DWORD *)v2 - 24);
            v147 = *((_DWORD *)v2 - 22) + 1;
            v121 = 0;
            v146 = v66;
            v68 = *((_DWORD *)v2 - 20);
            v148 = v67;
            v69 = *((_DWORD *)v2 - 19);
            v149 = v68;
            v150 = v69;
            sub_46E000(v2, &v145, 64, v134, 0);
            break;
          case 115:
          case 241:
            v147 = 0;
            break;
          case 116:
            v147 = 1;
            sub_46FB20(65, (int)v2, 1);
            break;
          case 117:
            v147 = 1;
            sub_46FB20(66, (int)v2, 1);
            break;
          case 118:
            v147 = 1;
            sub_46FB20(67, (int)v2, 1);
            break;
          case 119:
            v147 = *((_DWORD *)v2 - 10) + 1;
            sub_46FB20(65, (int)v2, v147);
            break;
          case 120:
            v147 = *((_DWORD *)v2 - 10) + 1;
            sub_46FB20(66, (int)v2, v147);
            break;
          case 121:
            v147 = *((_DWORD *)v2 - 16) + 1;
            sub_46FB20(67, (int)v2, v147);
            break;
          case 122:
          case 123:
            sub_46FF00((int)v2, 0, 0);
            break;
          case 127:
          case 129:
            sub_46FF00((int)v2, 0, 2);
            break;
          case 128:
          case 130:
            sub_46FF00((int)(v2 - 48), v2, 2);
            break;
          case 135:
          case 138:
            sub_46E140((int)v2, (int)(v2 - 72), 1, *((_DWORD *)v2 - 6));
            break;
          case 140:
            v145 = 0;
            break;
          case 141:
LABEL_123:
            v145 = 1;
            break;
          case 142:
          case 144:
            sub_46C790(0, (int)v2);
            v2 = v144;
            break;
          case 143:
          case 145:
            sub_46C790(v144, (int)(v2 - 48));
            v2 = v144;
            break;
          case 149:
            v145 = 1;
            LOBYTE(v149) = 6;
            goto LABEL_152;
          case 154:
            sub_46C610();
            break;
          case 155:
            sub_46F480(&v145, (int)v2);
            break;
          case 156:
            sub_46E750(1, 0);
            sub_46ECF0(v2, &v145, (_DWORD *)v2 - 12);
            break;
          case 157:
          case 158:
            sub_46E750(1, 0);
            sub_46EC40(&v145, (_DWORD *)v2 - 18, v2);
            break;
          case 159:
          case 161:
            sub_46CAC0();
            sub_46D410(v2, (int)(v2 - 24));
            break;
          case 160:
            v70 = v144;
            sub_46F6D0((_DWORD *)v144 - 12, (int)(v2 - 72), (_DWORD *)v2 - 24, (int)v2);
            sub_46CA90();
            sub_46E750(1, 0);
            sub_46EC40(&v145, (_DWORD *)v70 - 36, (_DWORD *)v2 - 24);
            v2 = v144;
            break;
          case 162:
            sub_46F6D0((_DWORD *)v144 - 12, (int)(v2 - 72), &v145, (int)v2);
            sub_46CA90();
            v2 = v144;
            break;
          case 163:
            sub_46E750(2, 0);
            sub_46EFC0(v2, 23, &v145, (_DWORD *)v2 - 12);
            break;
          case 164:
            sub_46E750(2, 0);
            sub_46EFC0(v2, 24, &v145, (_DWORD *)v2 - 12);
            break;
          case 165:
            sub_46E750(2, 0);
            sub_46EFC0(v2, 25, &v145, (_DWORD *)v2 - 12);
            break;
          case 166:
            sub_46E750(2, 0);
            sub_46EFC0(v2, 26, &v145, (_DWORD *)v2 - 12);
            break;
          case 167:
            sub_46E750(2, 0);
            sub_46EFC0(v2, 30, &v145, (_DWORD *)v2 - 12);
            break;
          case 168:
            sub_46E750(2, 0);
            sub_46EFC0(v2, 27, &v145, (_DWORD *)v2 - 12);
            break;
          case 169:
            sub_46E750(2, 0);
            sub_46EFC0(v2, 32, &v145, (_DWORD *)v2 - 12);
            break;
          case 170:
            sub_46E750(2, 0);
            sub_46EFC0(v2, 31, &v145, (_DWORD *)v2 - 12);
            break;
          case 171:
            sub_46E750(2, 0);
            sub_46EFC0(v2, 33, &v145, (_DWORD *)v2 - 12);
            break;
          case 172:
            sub_46E750(2, 0);
            sub_46EFC0(v2, 28, &v145, (_DWORD *)v2 - 12);
            break;
          case 173:
            sub_46E750(2, 0);
            sub_46EFC0(v2, 29, &v145, (_DWORD *)v2 - 12);
            break;
          case 174:
            sub_46E950((_DWORD *)v2 - 6, &v145, 36);
            break;
          case 175:
            sub_46E9E0(v2, &v145, 34);
            break;
          case 176:
            sub_46E950((_DWORD *)v2 - 6, &v145, 37);
            break;
          case 177:
            sub_46E9E0(v2, &v145, 35);
            break;
          case 178:
          case 182:
            sub_46DC50((_DWORD *)v2 - 6, (int)v2);
            break;
          case 179:
          case 183:
            sub_46DBB0(v2, &v145, (_DWORD *)v2 - 18, (int)(v2 - 48));
            break;
          case 180:
          case 184:
          case 345:
            sub_46DB00((_DWORD *)v2 - 6, (int)v2);
            break;
          case 181:
          case 185:
            sub_46DA60(v2, &v145, (_DWORD *)v2 - 18, (int)(v2 - 48));
            break;
          case 186:
            sub_46F100(v2, 14, &v145, (_DWORD *)v2 - 12);
            break;
          case 187:
            sub_46F100(v2, 9, &v145, (_DWORD *)v2 - 12);
            break;
          case 188:
            sub_46F100(v2, 10, &v145, (_DWORD *)v2 - 12);
            break;
          case 189:
            sub_46F100(v2, 11, &v145, (_DWORD *)v2 - 12);
            break;
          case 190:
            sub_46F100(v2, 8, &v145, (_DWORD *)v2 - 12);
            break;
          case 191:
            sub_46F100(v2, 1, &v145, (_DWORD *)v2 - 12);
            break;
          case 192:
            sub_46F100(v2, 2, &v145, (_DWORD *)v2 - 12);
            break;
          case 193:
            sub_46F100(v2, 3, &v145, (_DWORD *)v2 - 12);
            break;
          case 194:
            sub_46F100(v2, 4, &v145, (_DWORD *)v2 - 12);
            break;
          case 195:
            sub_46F100(v2, 5, &v145, (_DWORD *)v2 - 12);
            break;
          case 196:
            sub_46F100(v2, 6, &v145, (_DWORD *)v2 - 12);
            break;
          case 197:
            sub_46F100(v2, 7, &v145, (_DWORD *)v2 - 12);
            break;
          case 198:
            v121 = (int)(v2 - 24);
            v120 = (int)&v145;
            LOBYTE(v119) = 1;
            *((_DWORD *)v2 - 4) = 0;
            *(v2 - 8) = 1;
            *((_DWORD *)v2 - 6) = 1;
            *((_WORD *)v2 - 3) = 1;
            *(v2 - 7) = 0;
            sub_46F100(v2, (char)v119, (_DWORD *)v120, (_DWORD *)v121);
            break;
          case 199:
            v121 = (int)(v2 - 24);
            v120 = (int)&v145;
            LOBYTE(v119) = 2;
            *((_DWORD *)v2 - 4) = 0;
            *(v2 - 8) = 1;
            *((_DWORD *)v2 - 6) = 1;
            *((_WORD *)v2 - 3) = 1;
            *(v2 - 7) = 0;
            sub_46F100(v2, (char)v119, (_DWORD *)v120, (_DWORD *)v121);
            break;
          case 200:
            sub_46F070(v2, 13, &v145);
            break;
          case 201:
            sub_46F070(v2, 12, &v145);
            break;
          case 202:
            sub_46F100(v2, 15, &v145, (_DWORD *)v2 - 12);
            break;
          case 203:
            sub_46F100(v2, 16, &v145, (_DWORD *)v2 - 12);
            break;
          case 204:
            sub_46F100(v2, 17, &v145, (_DWORD *)v2 - 12);
            break;
          case 205:
            sub_46F100(v2, 18, &v145, (_DWORD *)v2 - 12);
            break;
          case 206:
            sub_46F100(v2, 19, &v145, (_DWORD *)v2 - 12);
            break;
          case 207:
            sub_46F100(v2, 20, &v145, (_DWORD *)v2 - 12);
            break;
          case 208:
            sub_46F100((_DWORD *)v2 - 12, 19, &v145, v2);
            break;
          case 209:
            sub_46F100((_DWORD *)v2 - 12, 20, &v145, v2);
            break;
          case 211:
            sub_46CCA0((_DWORD *)v2 - 6, v2);
            break;
          case 212:
            sub_46CBE0((_DWORD *)v2 - 18, (_DWORD *)v2 - 6, (int)v2);
            break;
          case 213:
            sub_46CB20((_DWORD *)v2 - 30, v2, &v145, (int)(v2 - 48));
            break;
          case 214:
          case 215:
          case 236:
          case 237:
          case 243:
          case 244:
          case 245:
          case 246:
          case 247:
          case 248:
          case 249:
          case 250:
          case 252:
          case 269:
          case 270:
          case 274:
          case 276:
          case 277:
            goto LABEL_242;
          case 216:
            sub_46D050(v2, &v145, 1);
            break;
          case 217:
            sub_46D050(v2, &v145, 2);
            break;
          case 218:
            sub_46D050(v2, &v145, 3);
            break;
          case 219:
            sub_46D050(v2, &v145, 4);
            break;
          case 220:
            sub_46D050(v2, &v145, 5);
            break;
          case 221:
            sub_46D050(v2, &v145, 6);
            break;
          case 222:
            sub_46D050(v2, &v145, 0);
            break;
          case 223:
            sub_46CDC0((int)&v145, v2);
            break;
          case 224:
            sub_46CD60(v2);
            break;
          case 225:
            sub_46CD20((_DWORD *)v2 - 12);
            goto LABEL_216;
          case 226:
          case 256:
          case 257:
          case 282:
          case 285:
          case 286:
          case 288:
          case 289:
          case 295:
          case 334:
          case 335:
LABEL_216:
            v71 = *((_DWORD *)v2 + 1);
            v72 = *((_DWORD *)v2 + 2);
            v145 = *(_DWORD *)v2;
            v73 = *((_DWORD *)v2 + 3);
            v146 = v71;
            v74 = *((_DWORD *)v2 + 4);
            v147 = v72;
            v75 = *((_DWORD *)v2 + 5);
            v148 = v73;
            v149 = v74;
            v150 = v75;
            break;
          case 227:
          case 258:
          case 259:
          case 283:
          case 296:
          case 306:
          case 333:
          case 337:
            v76 = *((_DWORD *)v2 - 5);
            v77 = *((_DWORD *)v2 - 4);
            v145 = *((_DWORD *)v2 - 6);
            v78 = *((_DWORD *)v2 - 3);
            v146 = v76;
            v79 = *((_DWORD *)v2 - 2);
            v147 = v77;
            v80 = *((_DWORD *)v2 - 1);
            v148 = v78;
            v149 = v79;
            v150 = v80;
            break;
          case 228:
            sub_46D260((_DWORD *)v2 - 6, &v145);
            break;
          case 229:
            sub_46EDE0(v2, &v145);
            break;
          case 230:
            *((_DWORD *)v2 + 2) = sub_46FD50((int *)v2 - 6);
            break;
          case 231:
            v121 = *((_DWORD *)v2 - 16);
            v120 = 0;
            v119 = v2 - 24;
            v118 = &v145;
            goto LABEL_222;
          case 232:
            sub_46FCA0((_DWORD **)v143, (_DWORD *)v2 - 6);
            break;
          case 233:
            v121 = 1;
            v120 = 0;
            v119 = v2 - 24;
            v118 = &v145;
            goto LABEL_222;
          case 234:
            sub_46CAC0();
            sub_46DED0((_DWORD *)v2 - 18, (_DWORD *)v2 - 6);
            break;
          case 235:
            v121 = 1;
            v120 = 1;
            v119 = v2 - 24;
            v118 = &v145;
LABEL_222:
            sub_46DE10((_DWORD *)v2 - 24, v118, (int)v119, v120, v121);
            sub_46CA90();
            break;
          case 238:
          case 239:
            v145 = 0;
            v146 = 0;
            v147 = 0;
            v148 = 0;
            v149 = 0;
            v150 = 0;
LABEL_228:
            v145 = 8;
            break;
          case 240:
          case 242:
            v81 = *((_DWORD *)v2 - 5);
            v82 = *((_DWORD *)v2 - 4);
            v145 = *((_DWORD *)v2 - 6);
            v83 = *((_DWORD *)v2 - 3);
            v146 = v81;
            v84 = *((_DWORD *)v2 - 2);
            v147 = v82;
            v85 = *((_DWORD *)v2 - 1);
            v148 = v83;
            v149 = v84;
            v150 = v85;
            break;
          case 251:
            sub_46D350(1, &v145, v2);
            break;
          case 253:
            v125 = 1;
            v124 = -1;
            mul_function((int)(v2 + 8), (int)(v2 + 8), (int)&v124);
            v86 = *((_DWORD *)v2 + 1);
            v87 = *((_DWORD *)v2 + 2);
            v145 = *(_DWORD *)v2;
            v88 = *((_DWORD *)v2 + 3);
            v146 = v86;
            v89 = *((_DWORD *)v2 + 4);
            v147 = v87;
            v90 = *((_DWORD *)v2 + 5);
            v148 = v88;
            v149 = v89;
            v150 = v90;
            break;
          case 254:
            v91 = *((_DWORD *)v2 - 6);
            v92 = *((_DWORD *)v2 - 4);
            v146 = *((_DWORD *)v2 - 5);
            v93 = *((_DWORD *)v2 - 2);
            v145 = v91;
            v94 = *((_DWORD *)v2 - 3);
            v147 = v92;
            v95 = *((_DWORD *)v2 - 1);
            v149 = v93;
            v148 = v94;
            v150 = v95;
            LOBYTE(v149) = 9;
            break;
          case 255:
            sub_46D350(2, &v145, v2);
            break;
          case 260:
            v96 = *((_DWORD *)v2 - 5);
            v97 = *((_DWORD *)v2 - 4);
            v145 = *((_DWORD *)v2 - 6);
            v98 = *((_DWORD *)v2 - 3);
            v146 = v96;
            v99 = *((_DWORD *)v2 - 2);
            v147 = v97;
            v100 = *((_DWORD *)v2 - 1);
            v148 = v98;
            v149 = v99;
            v150 = v100;
            sub_46BFE0();
            break;
          case 261:
            v145 = 1;
            HIWORD(v149) = 1;
            BYTE1(v149) = 0;
            array_init((int)&v147);
            break;
          case 265:
            goto LABEL_237;
          case 266:
            goto LABEL_239;
          case 267:
            v145 = 1;
            HIWORD(v149) = 1;
            BYTE1(v149) = 0;
            array_init((int)&v147);
LABEL_237:
            sub_46C6C0(v2, (int)&v145, (int)(v2 - 48));
            break;
          case 268:
            v145 = 1;
            HIWORD(v149) = 1;
            BYTE1(v149) = 0;
            array_init((int)&v147);
LABEL_239:
            sub_46C6C0(v2, (int)&v145, 0);
            break;
          case 271:
            v121 = 0;
            v120 = 0;
            goto LABEL_241;
          case 272:
            v121 = 0;
            v120 = 1;
            goto LABEL_241;
          case 273:
            v121 = 0;
            v120 = 2;
LABEL_241:
            sub_46E750(v120, v121);
LABEL_242:
            v101 = *((_DWORD *)v2 + 1);
            v102 = *((_DWORD *)v2 + 2);
            v145 = *(_DWORD *)v2;
            v103 = *((_DWORD *)v2 + 3);
            v146 = v101;
            v104 = *((_DWORD *)v2 + 4);
            v147 = v102;
            v105 = *((_DWORD *)v2 + 5);
            v148 = v103;
            v149 = v104;
            v150 = v105;
            break;
          case 275:
          case 287:
            sub_46C770(v2 - 24);
            break;
          case 278:
            sub_46FE90(v2, &v145, (int)(v2 - 24));
            break;
          case 279:
          case 292:
            sub_46C390(&v145, (int *)v2 - 18, (int *)v2 - 6);
            v2 = v144;
            break;
          case 280:
          case 293:
            sub_46C880(&v145, (int *)v2 - 18, (int *)v2 - 6);
            v2 = v144;
            break;
          case 281:
          case 327:
            sub_46C1F0((int)v2);
            sub_46C800();
            goto LABEL_250;
          case 290:
            sub_46E750(0, 0);
            break;
          case 291:
            sub_46C0E0((_DWORD *)v143, v134);
            sub_46C270(&v145, v134, (int *)v2 - 6);
            v2 = v144;
            break;
          case 294:
            sub_46C0E0((_DWORD *)v143, v134);
            sub_46C270(&v145, v134, (int *)v2);
            v2 = v144;
            break;
          case 297:
LABEL_152:
            v147 = 1;
            break;
          case 298:
            ++v147;
            break;
          case 301:
            sub_46C660((int *)v2);
            break;
          case 302:
            sub_46C250();
            break;
          case 303:
            sub_46C0C0();
            break;
          case 304:
            sub_46C660(0);
            break;
          case 305:
            sub_46D180(&v145, 0, 0, 0);
            break;
          case 307:
            sub_46D0E0(&v145, v2, (_DWORD *)v2 - 12, 0);
            break;
          case 308:
            sub_46D0E0(&v145, v2, 0, 0);
            break;
          case 309:
            sub_46D180(&v145, v2, (_DWORD *)v2 - 12, 0);
            break;
          case 310:
            sub_46D180(&v145, v2, 0, 0);
            break;
          case 311:
            sub_46D0E0(&v145, v2, (_DWORD *)v2 - 18, 1);
            break;
          case 312:
            sub_46D0E0(&v145, v2, 0, 1);
            break;
          case 313:
            sub_46D180(&v145, v2, (_DWORD *)v2 - 18, 1);
            break;
          case 314:
            sub_46D180(&v145, v2, 0, 1);
            break;
          case 315:
            sub_46E750(0, 0);
            sub_46E3B0((_DWORD *)v2 - 6, &v145, v2);
            break;
          case 316:
          case 317:
          case 318:
          case 320:
            sub_46E590((_DWORD *)v2 - 6, v2, &v145);
            break;
          case 319:
            goto LABEL_271;
          case 321:
            *((_DWORD *)v2 + 2) = 91;
            goto LABEL_271;
          case 322:
            *((_DWORD *)v2 + 2) = 93;
            goto LABEL_271;
          case 323:
            v121 = (int)&v145;
            *((_DWORD *)v2 + 2) = 123;
            sub_46E640((_DWORD *)v2 - 6, v2, (_DWORD *)v121);
            break;
          case 324:
            *((_DWORD *)v2 + 2) = 125;
LABEL_271:
            sub_46E640((_DWORD *)v2 - 6, v2, &v145);
            break;
          case 325:
            v121 = (int)v134;
            *((_DWORD *)v2 + 2) = 45;
            sub_46E640((_DWORD *)v2 - 6, v2, (_DWORD *)v121);
            v121 = (int)&v145;
            *((_DWORD *)v2 + 2) = 62;
            sub_46E640(v134, v2, (_DWORD *)v121);
            break;
          case 326:
            sub_46E6F0(&v145);
            break;
          case 328:
            sub_46C800();
            break;
          case 329:
            sub_46C1F0((int)(v2 - 96));
            sub_470130(&v145, (int)(v2 - 96), (int *)v2 - 6);
            break;
          case 330:
            sub_46C800();
            v133 = (int *)(v2 - 24);
            sub_46FE80(1, (_DWORD *)v2 - 6, (int)(v2 - 48));
            sub_46C270(&v145, v133, (int *)v2);
            v2 = v144;
            break;
          case 331:
            sub_46C800();
            sub_46FE80(1, &v145, (int)(v2 - 24));
            break;
          case 332:
            sub_46C800();
            sub_470130(&v145, (int)(v2 - 96), (int *)v2 - 12);
            break;
          case 336:
LABEL_250:
            sub_46FE80(1, &v145, (int)v2);
            break;
          case 338:
            sub_46F3E0((_DWORD *)v2 - 6, 2, &v145);
            break;
          case 339:
            sub_46CFC0(v2, 2, &v145);
            break;
          case 340:
            sub_46CFC0(v2, 4, &v145);
            break;
          case 341:
            sub_46CFC0((_DWORD *)v2 - 6, 1, &v145);
            break;
          case 342:
            sub_46CFC0(v2, 8, &v145);
            break;
          case 343:
            sub_46CFC0(v2, 16, &v145);
            break;
          case 344:
            sub_46F3E0(v2, 1, &v145);
            break;
          case 346:
            sub_46F3E0(v2, 1, v134);
            sub_46DA60(v134, &v145, (_DWORD *)v2 - 18, (int)(v2 - 48));
            break;
          default:
            break;
        }
        v106 = &v140[-2 * (_DWORD)v141];
        v2 += 24 - 24 * (_DWORD)v141;
        v107 = v146;
        *(_DWORD *)v2 = v145;
        v108 = v147;
        *((_DWORD *)v2 + 1) = v107;
        v109 = v148;
        *((_DWORD *)v2 + 2) = v108;
        v110 = v149;
        *((_DWORD *)v2 + 3) = v109;
        v111 = v150;
        *((_DWORD *)v2 + 4) = v110;
        v112 = v143;
        *((_DWORD *)v2 + 5) = v111;
        v113 = word_4958F0[v112];
        v114 = *(_WORD *)v106;
        v140 = v106;
        v115 = v114 + word_4968BE[v113];
        v144 = v2;
        if ( v115 > 0xE16 || word_498700[v115] != v114 )
        {
          v0 = word_496286[v113];
          v1 = v140;
          goto LABEL_3;
        }
        v1 = v140;
      }
      v0 = word_496AD0[v15];
      if ( v0 < 0 )
      {
        if ( v0 == -32768 )
          break;
        v143 = -v0;
        goto LABEL_23;
      }
      if ( word_496AD0[v15] )
      {
        if ( v0 == 664 )
          return 0;
        if ( v13 )
          v139 = -2;
        v2 += 24;
        v21 = v142 == 0;
        *(_DWORD *)v2 = v126;
        *((_DWORD *)v2 + 1) = v127;
        *((_DWORD *)v2 + 2) = v128;
        *((_DWORD *)v2 + 3) = v129;
        *((_DWORD *)v2 + 4) = v130;
        v144 = v2;
        *((_DWORD *)v2 + 5) = v131;
        if ( !v21 )
          --v142;
        v1 = v140;
        continue;
      }
      break;
    }
LABEL_34:
    if ( v142 )
    {
      if ( v142 == 3 )
      {
        if ( !v13 )
          return 1;
        v139 = -2;
      }
    }
    else
    {
      v22 = word_496498[v11];
      ++v132;
      v143 = v22;
      if ( (unsigned int)(v22 + 0x7FFF) > 0x8E14 )
      {
        sub_468060((char *)byte_47627C);
      }
      else
      {
        v23 = 0;
        v24 = 0;
        v142 = 0;
        if ( v143 >= 0 || (v23 = -v143, (unsigned int)-v143 < 0x108) )
        {
          v141 = (char *)&word_498700[v23 + v143];
          do
          {
            if ( *(__int16 *)v141 == v23 )
            {
              v25 = strlen((const char *)sub_473493((int)*(&off_4954D0 + v23)));
              ++v142;
              v24 += v25 + 15;
            }
            v141 += 2;
            ++v23;
          }
          while ( v23 < 0x108 );
        }
        v26 = (char *)malloc(v24 + 15);
        v27 = v26;
        v28 = 0;
        if ( v26 )
        {
          v29 = v142 < 5;
          *v26 = 0;
          if ( v29 )
          {
            v30 = v143;
            v142 = 0;
            if ( v143 >= 0 )
            {
              v143 = 0;
              goto LABEL_46;
            }
            v28 = -v143;
            v143 = -v143;
            if ( (unsigned int)-v30 < 0x108 )
            {
LABEL_46:
              v141 = (char *)&word_498700[v28 + v30];
              do
              {
                if ( *(__int16 *)v141 == v28 )
                {
                  if ( v142 )
                    v121 = (int)&unk_488908;
                  else
                    v121 = (int)&unk_4888F8;
                  strcat(v27, (const char *)sub_473493(v121));
                  strcat(v27, (const char *)sub_473493((int)*(&off_4954D0 + v143)));
                  ++v142;
                  v28 = v143;
                  strcat(v27, "'");
                  v2 = v144;
                }
                v141 += 2;
                v143 = ++v28;
              }
              while ( v28 < 0x108 );
            }
          }
          sub_468060(v27);
          free(v27);
          v11 = i;
        }
        else
        {
          v31 = (char *)sub_473493((int)&unk_488910);
          sub_468060(v31);
          v11 = i;
        }
      }
    }
    v32 = v140;
    v142 = 3;
    while ( 2 )
    {
      v33 = word_496498[v11];
      if ( v33 == -32768 )
        goto LABEL_68;
      v34 = v33 + 1;
      if ( v34 > 0xE16 || word_498700[v34] != 1 )
        goto LABEL_68;
      v0 = word_496AD0[v34];
      if ( v0 < 0 )
      {
        if ( v0 != -32768 )
        {
          v143 = -v0;
          goto LABEL_23;
        }
        goto LABEL_68;
      }
      if ( !v0 )
      {
LABEL_68:
        if ( v32 == v135 )
          return 1;
        v11 = *((__int16 *)v32 - 1);
        v2 -= 24;
        v32 -= 2;
        v144 = v2;
        v140 = v32;
        continue;
      }
      break;
    }
    if ( v0 != 664 )
    {
      v1 = v140;
      *((_DWORD *)v2 + 6) = v126;
      v2 += 24;
      *((_DWORD *)v2 + 1) = v127;
      *((_DWORD *)v2 + 2) = v128;
      *((_DWORD *)v2 + 3) = v129;
      *((_DWORD *)v2 + 4) = v130;
      *((_DWORD *)v2 + 5) = v131;
      continue;
    }
    return 0;
  }
}
// 4951F8: using guessed type __int16 word_4951F8[362];
// 4958F0: using guessed type __int16 word_4958F0[348];
// 495BA8: using guessed type __int16 word_495BA8[348];
// 495E60: using guessed type __int16 word_495E60[531];
// 496286: using guessed type __int16 word_496286[263];
// 496498: using guessed type __int16 word_496498[531];
// 4968BE: using guessed type __int16 word_4968BE[263];
// 496AD0: using guessed type __int16 word_496AD0[3608];
// 498700: using guessed type __int16 word_498700[3608];
// 4AB35C: using guessed type int dword_4AB35C;
// 4AB36C: using guessed type int dword_4AB36C;
// 465210: using guessed type int var_1F0[6];

//----- (00467690) --------------------------------------------------------
int __cdecl zend_stack_apply(_DWORD *a1, int a2, int (__cdecl *a3)(_DWORD))
{
  int result; // eax
  int j; // esi
  int i; // esi

  result = a2 - 1;
  if ( a2 == 1 )
  {
    for ( i = *a1 - 1; i >= 0; --i )
    {
      result = a3(*(_DWORD *)(a1[2] + 4 * i));
      if ( result )
        break;
    }
  }
  else
  {
    result = a2 - 2;
    if ( a2 == 2 )
    {
      for ( j = 0; j < *a1; ++j )
      {
        result = a3(*(_DWORD *)(a1[2] + 4 * j));
        if ( result )
          break;
      }
    }
  }
  return result;
}

//----- (00467700) --------------------------------------------------------
int __cdecl zend_stack_count(int a1)
{
  return *(_DWORD *)a1;
}

//----- (00467710) --------------------------------------------------------
int __cdecl zend_stack_base(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (00467720) --------------------------------------------------------
BOOL __cdecl zend_stack_is_empty(_DWORD *a1)
{
  return *a1 == 0;
}

//----- (00467730) --------------------------------------------------------
int __cdecl zend_stack_top(int *a1, _DWORD *a2)
{
  if ( *a1 <= 0 )
  {
    *a2 = 0;
    return -1;
  }
  else
  {
    *a2 = *(_DWORD *)(a1[2] + 4 * *a1 - 4);
    return 0;
  }
}

//----- (00467760) --------------------------------------------------------
int __cdecl zend_stack_destroy(_DWORD *a1)
{
  int i; // esi
  int v2; // edi

  for ( i = 0; i < *a1; ++i )
    efree(*(_DWORD *)(a1[2] + 4 * i));
  v2 = a1[2];
  if ( v2 )
    efree(v2);
  return 0;
}

//----- (004677A0) --------------------------------------------------------
int __cdecl zend_stack_int_top(int *a1)
{
  int v1; // ecx
  int result; // eax
  int v3; // [esp+0h] [ebp-4h] BYREF

  v3 = v1;
  result = zend_stack_top(a1, &v3);
  if ( result != -1 )
    return *(_DWORD *)v3;
  return result;
}
// 4677A0: variable 'v1' is possibly undefined

//----- (004677D0) --------------------------------------------------------
int __cdecl zend_stack_del_top(int *a1)
{
  int v1; // eax

  if ( *a1 > 0 )
  {
    v1 = *a1 - 1;
    *a1 = v1;
    efree(*(_DWORD *)(a1[2] + 4 * v1));
  }
  return 0;
}

//----- (004677F0) --------------------------------------------------------
int __cdecl zend_stack_init(_DWORD *a1)
{
  _DWORD *v1; // eax

  *a1 = 0;
  v1 = emalloc(256);
  a1[2] = v1;
  if ( !v1 )
    return -1;
  a1[1] = 64;
  return 0;
}

//----- (00467820) --------------------------------------------------------
int __cdecl zend_stack_push(_DWORD *a1, void *Src, size_t Size)
{
  int v3; // eax
  int v4; // ecx
  int v5; // eax
  _DWORD *v6; // eax

  v3 = a1[1];
  if ( *a1 >= v3 )
  {
    v4 = a1[2];
    v5 = v3 + 64;
    a1[1] = v5;
    v6 = erealloc(v4, 4 * v5, 0);
    a1[2] = v6;
    if ( !v6 )
      return -1;
  }
  *(_DWORD *)(a1[2] + 4 * *a1) = emalloc(Size);
  memcpy(*(void **)(a1[2] + 4 * *a1), Src, Size);
  return (*a1)++;
}

//----- (00467890) --------------------------------------------------------
int __cdecl zval_add_ref(int *a1)
{
  int result; // eax

  result = *a1;
  ++*(_WORD *)(*a1 + 10);
  return result;
}

//----- (004678A0) --------------------------------------------------------
char __cdecl zval_dtor(int a1)
{
  char (*v1)[4]; // eax
  char (*v2)[4]; // esi

  LOBYTE(v1) = *(_BYTE *)(a1 + 8);
  if ( (_BYTE)v1 != 1 )
  {
    v1 = (char (*)[4])((unsigned __int8)v1 - 3);
    switch ( (unsigned int)v1 )
    {
      case 0u:
      case 5u:
        v2 = *(char (**)[4])a1;
        if ( *(_DWORD *)a1 && v2 != empty_string )
          LOBYTE(v1) = efree((int)v2);
        break;
      case 1u:
      case 6u:
        v1 = *(char (**)[4])a1;
        if ( *(_DWORD *)a1 && v1 != (char (*)[4])&unk_4AB09C )
        {
          zend_hash_destroy(*(void **)a1);
          LOBYTE(v1) = efree(*(_DWORD *)a1);
        }
        break;
      case 2u:
        zend_hash_destroy(*(void **)(a1 + 4));
        LOBYTE(v1) = efree(*(_DWORD *)(a1 + 4));
        break;
      case 4u:
        LOBYTE(v1) = zend_list_delete(*(_DWORD *)a1);
        break;
      default:
        return (char)v1;
    }
  }
  return (char)v1;
}
// 4954CC: using guessed type char (*empty_string)[4];

//----- (00467940) --------------------------------------------------------
int __cdecl zval_copy_ctor(int a1)
{
  int *v1; // esi
  int result; // eax
  void *v3; // edi
  _DWORD *v4; // eax
  int v5; // edi
  _DWORD *v6; // eax

  v1 = (int *)a1;
  switch ( *(_BYTE *)(a1 + 8) )
  {
    case 3:
    case 8:
      if ( !*(_DWORD *)a1 || *(_DWORD *)(a1 + 4) )
      {
        *v1 = (int)estrndup(*(void **)a1, *(_DWORD *)(a1 + 4));
        result = 0;
      }
      else
      {
        *(_DWORD *)a1 = empty_string;
        result = 0;
      }
      break;
    case 4:
    case 9:
      v3 = *(void **)a1;
      if ( *(_UNKNOWN **)a1 == &unk_4AB09C )
        goto LABEL_10;
      v4 = emalloc(40);
      *v1 = (int)v4;
      zend_hash_init((int)v4, 0, 0, (int)zval_ptr_dtor, 0);
      zend_hash_copy(*v1, (int)v3, (int (__cdecl *)(int))zval_add_ref, (int)&a1, 4u);
      result = 0;
      break;
    case 5:
      v5 = *(_DWORD *)(a1 + 4);
      v6 = emalloc(40);
      v1[1] = (int)v6;
      zend_hash_init((int)v6, 0, 0, (int)zval_ptr_dtor, 0);
      zend_hash_copy(v1[1], v5, (int (__cdecl *)(int))zval_add_ref, (int)&a1, 4u);
      goto LABEL_10;
    case 7:
      zend_list_addref(*(_DWORD *)a1);
      result = 0;
      break;
    default:
LABEL_10:
      result = 0;
      break;
  }
  return result;
}
// 4954CC: using guessed type char (*empty_string)[4];

//----- (00467A50) --------------------------------------------------------
int zend_get_configuration_directive()
{
  if ( dword_4A7BB8 )
    return dword_4A7BB8();
  else
    return -1;
}
// 4A7BB8: using guessed type int (*dword_4A7BB8)(void);

//----- (00467A60) --------------------------------------------------------
int (*zend_message_dispatcher())(void)
{
  int (*result)(void); // eax

  result = dword_4A7BB4;
  if ( dword_4A7BB4 )
    return (int (*)(void))dword_4A7BB4();
  return result;
}
// 4A7BB4: using guessed type int (*dword_4A7BB4)(void);

//----- (00467A70) --------------------------------------------------------
_DWORD *__usercall sub_467A70@<eax>(_DWORD *result@<eax>)
{
  result[5] = 0;
  result[6] = 1;
  result[7] = 0;
  result[4] = 0;
  *result = 0;
  result[1] = 0;
  result[13] = 0;
  result[14] = 0;
  return result;
}

//----- (00467A90) --------------------------------------------------------
char sub_467A90()
{
  char result; // al

  result = 1;
  byte_4AB3A6 = 0;
  byte_4AB3A5 = 1;
  byte_4AB3A7 = 1;
  byte_4AB3B8 = 0;
  return result;
}
// 4AB3A5: using guessed type char byte_4AB3A5;
// 4AB3A6: using guessed type char byte_4AB3A6;
// 4AB3A7: using guessed type char byte_4AB3A7;
// 4AB3B8: using guessed type char byte_4AB3B8;

//----- (00467AB0) --------------------------------------------------------
unsigned int __cdecl free_estring(int *a1)
{
  return efree(*a1);
}

//----- (00467AD0) --------------------------------------------------------
void __cdecl __noreturn zend_bailout(int a1, int a2)
{
  int v2; // eax

  if ( !byte_4AB151 )
  {
    v2 = sub_473493((int)&unk_4879C0);
    zend_output_debug_string(1, v2, a1, a2);
    exit(-1);
  }
  byte_4AB3BA = 1;
  byte_4AB150 = 0;
  byte_4AB3A4 = 0;
  longjmp(Buf, -1);
}
// 467A40: using guessed type int __cdecl zend_output_debug_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 4AB150: using guessed type char byte_4AB150;
// 4AB151: using guessed type char byte_4AB151;
// 4AB3A4: using guessed type char byte_4AB3A4;
// 4AB3BA: using guessed type char byte_4AB3BA;

//----- (00467B30) --------------------------------------------------------
int __cdecl zend_execute_scripts(int a1, int a2, int a3)
{
  int *v3; // ebp
  int v4; // esi
  int *v5; // esi
  int v6; // eax
  __int16 v7; // cx
  int v8; // esi
  int v10; // [esp+10h] [ebp-Ch] BYREF
  int v11; // [esp+14h] [ebp-8h]
  int v12; // [esp+18h] [ebp-4h]

  v12 = dword_4AB138;
  v10 = 0;
  v11 = 0;
  if ( a3 <= 0 )
  {
LABEL_19:
    dword_4AB138 = v12;
    return 0;
  }
  v3 = &a3;
  while ( 1 )
  {
    v4 = v3[1];
    ++v3;
    if ( v4 )
    {
      dword_4AB138 = zend_compile_file(v4, 2);
      zend_destroy_file_handle(v4);
      if ( dword_4AB138 )
      {
        if ( a2 )
          executor_globals = a2;
        else
          executor_globals = (int)&v10;
        zend_execute(dword_4AB138);
        if ( !a2 )
        {
          v5 = (int *)executor_globals;
          --*(_WORD *)(*(_DWORD *)executor_globals + 10);
          v6 = *v5;
          v7 = *(_WORD *)(*v5 + 10);
          if ( v7 )
          {
            if ( v7 == 1 && *(_BYTE *)(v6 + 8) != 5 )
              *(_BYTE *)(v6 + 9) = 0;
          }
          else
          {
            zval_dtor(*v5);
            v8 = *v5;
            if ( v8 != dword_4AAFD8 )
              efree(v8);
          }
          v10 = 0;
        }
        destroy_op_array(dword_4AB138);
        efree(dword_4AB138);
        goto LABEL_18;
      }
      if ( a1 == 8 )
        break;
    }
LABEL_18:
    if ( ++v11 >= a3 )
      goto LABEL_19;
  }
  dword_4AB138 = v12;
  return -1;
}
// 4AE0FC: invalid function type has been ignored
// 4AAFBC: using guessed type int (__cdecl *zend_compile_file)(_DWORD, _DWORD);
// 4AAFC0: using guessed type int executor_globals;
// 4AAFD8: using guessed type int dword_4AAFD8;
// 4AB138: using guessed type int dword_4AB138;
// 4AE0FC: using guessed type int (__cdecl *zend_execute)(_DWORD);

//----- (00467C70) --------------------------------------------------------
_DWORD *zend_error(int a1, char *Format, ...)
{
  int v2; // ebp
  int compiled_lineno; // edi
  bool v4; // zf
  char *compiled_filename; // esi
  _DWORD *result; // eax
  int v7; // eax
  int v8; // eax
  _DWORD *v9; // esi
  int v10; // edi
  _DWORD *v11; // [esp+Ch] [ebp-14h] BYREF
  _DWORD *v12; // [esp+10h] [ebp-10h] BYREF
  _DWORD *v13; // [esp+14h] [ebp-Ch] BYREF
  _DWORD *v14; // [esp+18h] [ebp-8h] BYREF
  int v15; // [esp+1Ch] [ebp-4h] BYREF
  va_list va; // [esp+2Ch] [ebp+Ch] BYREF

  va_start(va, Format);
  v2 = a1;
  if ( a1 > 64 )
  {
    if ( a1 > 512 )
    {
      v4 = a1 == 1024;
    }
    else
    {
      if ( a1 == 512 || a1 == 128 )
        goto LABEL_12;
      v4 = a1 == 256;
    }
    if ( !v4 )
    {
LABEL_11:
      compiled_lineno = 0;
      goto LABEL_14;
    }
  }
  else if ( a1 != 64 )
  {
    switch ( a1 )
    {
      case 1:
      case 2:
      case 4:
      case 8:
        break;
      case 16:
      case 32:
        goto LABEL_4;
      default:
        goto LABEL_11;
    }
  }
LABEL_12:
  if ( zend_is_compiling() )
  {
    compiled_filename = (char *)zend_get_compiled_filename();
    compiled_lineno = zend_get_compiled_lineno();
    if ( compiled_filename )
      goto LABEL_15;
  }
  else
  {
LABEL_4:
    compiled_lineno = 0;
  }
LABEL_14:
  compiled_filename = (char *)sub_473493((int)&unk_4879F4);
LABEL_15:
  if ( dword_4AB1D4 )
  {
    switch ( v2 )
    {
      case 1:
      case 4:
      case 16:
      case 32:
      case 64:
      case 128:
        goto LABEL_17;
      default:
        a1 = (int)emalloc(16);
        *(_DWORD *)a1 = zval_used_for_init;
        *(_DWORD *)(a1 + 4) = dword_4AAED4;
        *(_DWORD *)(a1 + 8) = dword_4AAED8;
        *(_DWORD *)(a1 + 12) = dword_4AAEDC;
        v13 = emalloc(16);
        *v13 = zval_used_for_init;
        v13[1] = dword_4AAED4;
        v13[2] = dword_4AAED8;
        v13[3] = dword_4AAEDC;
        v11 = emalloc(16);
        *v11 = zval_used_for_init;
        v11[1] = dword_4AAED4;
        v11[2] = dword_4AAED8;
        v11[3] = dword_4AAEDC;
        v14 = emalloc(16);
        *v14 = zval_used_for_init;
        v14[1] = dword_4AAED4;
        v14[2] = dword_4AAED8;
        v14[3] = dword_4AAEDC;
        v12 = emalloc(16);
        *v12 = zval_used_for_init;
        v12[1] = dword_4AAED4;
        v12[2] = dword_4AAED8;
        v12[3] = dword_4AAEDC;
        *(_DWORD *)a1 = emalloc(1024);
        v7 = _vsnprintf(*(char *const *)a1, 0x400u, Format, va);
        *(_DWORD *)(a1 + 4) = v7;
        v8 = a1;
        if ( *(int *)(a1 + 4) > 1023 )
        {
          *(_DWORD *)(a1 + 4) = 1023;
          v8 = a1;
        }
        *(_BYTE *)(v8 + 8) = 3;
        *v13 = v2;
        *((_BYTE *)v13 + 8) = 1;
        if ( compiled_filename )
        {
          v11[1] = strlen(compiled_filename);
          *v11 = estrndup(compiled_filename, v11[1]);
          *((_BYTE *)v11 + 8) = 3;
        }
        *v14 = compiled_lineno;
        *((_BYTE *)v14 + 8) = 1;
        *v12 = dword_4AB098;
        *((_BYTE *)v12 + 8) = 4;
        ++*((_WORD *)v12 + 5);
        v9 = emalloc(20);
        *v9 = &v13;
        v9[1] = &a1;
        v9[2] = &v11;
        v9[3] = &v14;
        v9[4] = &v12;
        v10 = dword_4AB1D4;
        dword_4AB1D4 = 0;
        zval_ptr_dtor(&v15);
        dword_4AB1D4 = v10;
        efree((int)v9);
        zval_ptr_dtor(&a1);
        zval_ptr_dtor((int *)&v13);
        zval_ptr_dtor((int *)&v11);
        zval_ptr_dtor((int *)&v14);
        result = v12;
        if ( *((_WORD *)v12 + 5) == 2 )
          result = (_DWORD *)efree((int)v12);
        break;
    }
  }
  else
  {
LABEL_17:
    result = (_DWORD *)zend_error_cb(v2, compiled_filename, compiled_lineno, Format, va);
  }
  if ( v2 == 4 )
    return (_DWORD *)sub_46C4B0();
  return result;
}
// 4AAEC0: using guessed type int (__cdecl *zend_error_cb)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4AAED0: using guessed type int zval_used_for_init;
// 4AAED4: using guessed type int dword_4AAED4;
// 4AAED8: using guessed type int dword_4AAED8;
// 4AAEDC: using guessed type int dword_4AAEDC;
// 4AB098: using guessed type int dword_4AB098;
// 4AB1D4: using guessed type int dword_4AB1D4;

//----- (00468060) --------------------------------------------------------
_DWORD *__usercall sub_468060@<eax>(char *a1@<eax>)
{
  return zend_error(4, a1);
}

//----- (00468070) --------------------------------------------------------
int sub_468070()
{
  void *v0; // eax
  char *v1; // eax

  zend_standard_class_def = 1;
  dword_4AAF08 = 8;
  v0 = (void *)sub_473493((int)&unk_4879A8);
  dword_4AAF04 = (int)zend_strndup(v0, 8u);
  dword_4AAF0C = 0;
  zend_hash_init_ex((int)&unk_4AAF40, 0, 0, (int)zval_ptr_dtor, 1, 0);
  zend_hash_init_ex((int)&unk_4AAF18, 0, 0, (int)destroy_zend_function, 1, 0);
  dword_4AAF6C = 0;
  dword_4AAF70 = 0;
  dword_4AAF74 = 0;
  dword_4AAF10 = (int)malloc(4u);
  *(_DWORD *)dword_4AAF10 = 1;
  v1 = (char *)sub_473493((int)&unk_4879B4);
  return zend_hash_add_or_update(dword_4AB374, v1, 9u, (size_t *)&zend_standard_class_def, 0x78u, 0, 2);
}
// 4AAF00: using guessed type char zend_standard_class_def;
// 4AAF04: using guessed type int dword_4AAF04;
// 4AAF08: using guessed type int dword_4AAF08;
// 4AAF0C: using guessed type int dword_4AAF0C;
// 4AAF10: using guessed type int dword_4AAF10;
// 4AAF6C: using guessed type int dword_4AAF6C;
// 4AAF70: using guessed type int dword_4AAF70;
// 4AAF74: using guessed type int dword_4AAF74;

//----- (00468150) --------------------------------------------------------
int __usercall sub_468150@<eax>(int a1@<esi>)
{
  int (__cdecl *v1)(_DWORD); // ecx
  int (__cdecl *v2)(_DWORD, _DWORD); // edx
  int (__cdecl *v3)(_DWORD, _DWORD); // eax
  int (__thiscall *v4)(_DWORD); // ecx
  int (*v5)(void); // edx
  int (*v6)(void); // eax
  int v7; // ecx

  j_start_memory_manager();
  zend_llist_init((int)&zend_extensions, 104, (int)zend_highlight, 1);
  v1 = *(int (__cdecl **)(_DWORD))(a1 + 4);
  v2 = *(int (__cdecl **)(_DWORD, _DWORD))(a1 + 8);
  zend_error_cb = *(int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a1;
  v3 = *(int (__cdecl **)(_DWORD, _DWORD))(a1 + 12);
  unk_4A7294 = 0;
  zend_printf = v1;
  zend_write = v2;
  zend_fopen = v3;
  if ( !v3 )
    zend_fopen = (int (__cdecl *)(_DWORD, _DWORD))sub_468120;
  v4 = *(int (__thiscall **)(_DWORD))(a1 + 20);
  v5 = *(int (**)(void))(a1 + 24);
  dword_4A7BB4 = *(int (**)(void))(a1 + 16);
  v6 = *(int (**)(void))(a1 + 28);
  zend_block_interruptions = v4;
  v7 = *(_DWORD *)(a1 + 32);
  zend_unblock_interruptions = v5;
  dword_4A7BB8 = v6;
  zend_ticks_function = v7;
  zend_compile_file = (int)compile_file;
  zend_execute = (int)zend_highlight;
  dword_4A79CC = (int)_strdup(byte_47627C);
  dword_4A7BB0 = 0;
  dword_4AB370 = (int)malloc(0x28u);
  dword_4AB374 = (int)malloc(0x28u);
  dword_4AB3A0 = (int)malloc(0x28u);
  zend_hash_init_ex(dword_4AB370, 0x64u, 0, (int)destroy_zend_function, 1, 0);
  zend_hash_init_ex(dword_4AB374, 0xAu, 0, (int)destroy_zend_class, 1, 0);
  zend_hash_init_ex(dword_4AB3A0, 8u, 0, 0, 1, 0);
  sub_468070();
  dword_4AAED8 = 0x10000;
  zend_hash_init_ex(dword_4AB3A0, 8u, 0, 0, 1, 0);
  sub_467A70(ini_scanner_globals);
  sub_467A70(&language_scanner_globals);
  sub_467A90();
  dword_4AB1D4 = 0;
  return 0;
}
// 40F640: using guessed type int __cdecl zend_highlight(_DWORD);
// 468120: using guessed type int sub_468120();
// 4A79CC: using guessed type int dword_4A79CC;
// 4A7BB0: using guessed type int dword_4A7BB0;
// 4A7BB4: using guessed type int (*dword_4A7BB4)(void);
// 4A7BB8: using guessed type int (*dword_4A7BB8)(void);
// 4AAEB4: using guessed type int (__cdecl *zend_printf)(_DWORD);
// 4AAEB8: using guessed type int zend_ticks_function;
// 4AAEBC: using guessed type int (*zend_unblock_interruptions)(void);
// 4AAEC0: using guessed type int (__cdecl *zend_error_cb)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4AAED8: using guessed type int dword_4AAED8;
// 4AAEE0: using guessed type int (__cdecl *zend_fopen)(_DWORD, _DWORD);
// 4AAEE4: using guessed type int (__cdecl *zend_write)(_DWORD, _DWORD);
// 4AAF78: using guessed type int (__thiscall *zend_block_interruptions)(_DWORD);
// 4AAFBC: using guessed type int zend_compile_file;
// 4AB1D4: using guessed type int dword_4AB1D4;
// 4AE0A0: using guessed type _DWORD ini_scanner_globals[16];
// 4AE0FC: using guessed type int zend_execute;

//----- (004682C0) --------------------------------------------------------
int __cdecl zend_llist_apply_with_argument(_DWORD **a1, int (__cdecl *a2)(_DWORD *, int), int a3)
{
  int result; // eax
  _DWORD *i; // esi

  result = (int)a1;
  for ( i = *a1; i; i = (_DWORD *)*i )
    result = a2(i + 2, a3);
  return result;
}

//----- (004682F0) --------------------------------------------------------
int __cdecl zend_llist_apply(_DWORD **a1, int (__cdecl *a2)(_DWORD *))
{
  int result; // eax
  _DWORD *i; // esi

  result = (int)a1;
  for ( i = *a1; i; i = (_DWORD *)*i )
    result = a2(i + 2);
  return result;
}

//----- (00468320) --------------------------------------------------------
int __cdecl zend_llist_init(int a1, int a2, int a3, char a4)
{
  int result; // eax

  result = a1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 16) = a3;
  *(_BYTE *)(a1 + 20) = a4;
  return result;
}

//----- (00468350) --------------------------------------------------------
void __cdecl zend_llist_apply_with_del(int a1, int (__cdecl *a2)(_DWORD *))
{
  _DWORD *v2; // esi
  _DWORD *v3; // ebp
  _DWORD *v4; // eax
  void (__cdecl *v5)(_DWORD *); // eax

  v2 = *(_DWORD **)a1;
  if ( *(_DWORD *)a1 )
  {
    do
    {
      v3 = (_DWORD *)*v2;
      if ( a2(v2 + 2) )
      {
        v4 = (_DWORD *)v2[1];
        if ( v4 )
          *v4 = *v2;
        else
          *(_DWORD *)a1 = *v2;
        if ( *v2 )
          *(_DWORD *)(*v2 + 4) = v2[1];
        else
          *(_DWORD *)(a1 + 4) = v2[1];
        v5 = *(void (__cdecl **)(_DWORD *))(a1 + 16);
        if ( v5 )
        {
          v5(v2 + 2);
          if ( *(_BYTE *)(a1 + 20) )
            free(v2);
          else
            efree((int)v2);
        }
        --*(_DWORD *)(a1 + 12);
      }
      v2 = v3;
    }
    while ( v3 );
  }
}

//----- (004683D0) --------------------------------------------------------
_DWORD *__cdecl zend_llist_remove_tail(int a1)
{
  _DWORD *v1; // edi
  _DWORD *v2; // eax
  void (__cdecl *v3)(_DWORD *); // eax

  v1 = *(_DWORD **)(a1 + 4);
  if ( !v1 )
    return 0;
  v2 = (_DWORD *)v1[1];
  if ( v2 )
    *v2 = 0;
  v3 = *(void (__cdecl **)(_DWORD *))(a1 + 16);
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4);
  if ( v3 )
    v3(v1 + 2);
  if ( *(_BYTE *)(a1 + 20) )
    free(v1);
  else
    efree((int)v1);
  --*(_DWORD *)(a1 + 12);
  return v1 + 2;
}

//----- (00468440) --------------------------------------------------------
void __cdecl zend_llist_destroy(int a1)
{
  _DWORD *v1; // esi
  void (__cdecl *v2)(_DWORD *); // eax
  _DWORD *v3; // edi

  v1 = *(_DWORD **)a1;
  if ( *(_DWORD *)a1 )
  {
    do
    {
      v2 = *(void (__cdecl **)(_DWORD *))(a1 + 16);
      v3 = (_DWORD *)*v1;
      if ( v2 )
        v2(v1 + 2);
      if ( *(_BYTE *)(a1 + 20) )
        free(v1);
      else
        efree((int)v1);
      v1 = v3;
    }
    while ( v3 );
  }
  *(_DWORD *)(a1 + 12) = 0;
}

//----- (00468490) --------------------------------------------------------
void __cdecl zend_llist_del_element(int a1, int a2, int (__cdecl *a3)(_DWORD *, int))
{
  _DWORD *v3; // esi
  _DWORD *v4; // edi
  _DWORD *v5; // eax
  void (__cdecl *v6)(_DWORD *); // eax

  v3 = *(_DWORD **)a1;
  if ( *(_DWORD *)a1 )
  {
    while ( 1 )
    {
      v4 = (_DWORD *)*v3;
      if ( a3(v3 + 2, a2) )
        break;
      v3 = v4;
      if ( !v4 )
        return;
    }
    v5 = (_DWORD *)v3[1];
    if ( v5 )
      *v5 = *v3;
    else
      *(_DWORD *)a1 = *v3;
    if ( *v3 )
      *(_DWORD *)(*v3 + 4) = v3[1];
    else
      *(_DWORD *)(a1 + 4) = v3[1];
    v6 = *(void (__cdecl **)(_DWORD *))(a1 + 16);
    if ( v6 )
    {
      v6(v3 + 2);
      if ( *(_BYTE *)(a1 + 20) )
      {
        free(v3);
        --*(_DWORD *)(a1 + 12);
        return;
      }
      efree((int)v3);
    }
    --*(_DWORD *)(a1 + 12);
  }
}

//----- (00468530) --------------------------------------------------------
void *__cdecl zend_llist_prepend_element(int a1, void *Src)
{
  _DWORD *v2; // eax
  void *result; // eax
  size_t v4; // [esp-4h] [ebp-8h]

  if ( *(_BYTE *)(a1 + 20) )
    v2 = malloc(*(_DWORD *)(a1 + 8) + 11);
  else
    v2 = emalloc(*(_DWORD *)(a1 + 8) + 11);
  *v2 = *(_DWORD *)a1;
  v2[1] = 0;
  if ( *(_DWORD *)a1 )
    *(_DWORD *)(*(_DWORD *)a1 + 4) = v2;
  else
    *(_DWORD *)(a1 + 4) = v2;
  v4 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)a1 = v2;
  result = memcpy(v2 + 2, Src, v4);
  ++*(_DWORD *)(a1 + 12);
  return result;
}

//----- (00468590) --------------------------------------------------------
void *__cdecl zend_llist_add_element(int a1, void *Src)
{
  _DWORD *v2; // eax
  _DWORD *v3; // ecx
  void *result; // eax
  size_t v5; // [esp-4h] [ebp-8h]

  if ( *(_BYTE *)(a1 + 20) )
    v2 = malloc(*(_DWORD *)(a1 + 8) + 11);
  else
    v2 = emalloc(*(_DWORD *)(a1 + 8) + 11);
  v2[1] = *(_DWORD *)(a1 + 4);
  *v2 = 0;
  v3 = *(_DWORD **)(a1 + 4);
  if ( v3 )
    *v3 = v2;
  else
    *(_DWORD *)a1 = v2;
  v5 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 4) = v2;
  result = memcpy(v2 + 2, Src, v5);
  ++*(_DWORD *)(a1 + 12);
  return result;
}

//----- (004685F0) --------------------------------------------------------
void *__cdecl zend_llist_copy(int a1, int a2)
{
  void *result; // eax
  _DWORD *v3; // esi

  result = (void *)zend_llist_init(a1, *(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 16), *(_BYTE *)(a2 + 20));
  v3 = *(_DWORD **)a2;
  if ( *(_DWORD *)a2 )
  {
    do
    {
      result = zend_llist_add_element(a1, v3 + 2);
      v3 = (_DWORD *)*v3;
    }
    while ( v3 );
  }
  return result;
}

//----- (00468640) --------------------------------------------------------
void __usercall sub_468640(void *a1@<eax>)
{
  free(a1);
}

//----- (00468650) --------------------------------------------------------
void *__usercall sub_468650@<eax>(void *Block@<ecx>, size_t a2@<eax>)
{
  return realloc(Block, a2);
}

//----- (00468660) --------------------------------------------------------
void *__usercall sub_468660@<eax>(size_t a1@<eax>)
{
  return malloc(a1);
}

//----- (00468670) --------------------------------------------------------
void __usercall sub_468670(int a1@<esi>)
{
  if ( a1 )
  {
    if ( a1 == dword_4AAF90 )
      dword_4AAF90 = 0;
    if ( *(_DWORD *)(a1 + 20) )
      sub_468640(*(void **)(a1 + 4));
    sub_468640((void *)a1);
  }
}
// 4AAF90: using guessed type int dword_4AAF90;

//----- (004686A0) --------------------------------------------------------
char sub_4686A0()
{
  char result; // al

  dword_4AAFA4 = *(_DWORD *)(dword_4AAF90 + 16);
  dword_4AAF94 = *(_DWORD *)(dword_4AAF90 + 8);
  String = (char *)dword_4AAF94;
  language_scanner_globals = *(FILE **)dword_4AAF90;
  result = *(_BYTE *)dword_4AAF94;
  byte_4AAFA0 = *(_BYTE *)dword_4AAF94;
  return result;
}
// 4AAF90: using guessed type int dword_4AAF90;
// 4AAF94: using guessed type int dword_4AAF94;
// 4AAFA0: using guessed type char byte_4AAFA0;
// 4AAFA4: using guessed type int dword_4AAFA4;

//----- (004686D0) --------------------------------------------------------
char __thiscall sub_4686D0(void *this)
{
  char result; // al

  result = dword_4AAF90;
  if ( (void *)dword_4AAF90 != this )
  {
    if ( dword_4AAF90 )
    {
      *(_BYTE *)dword_4AAF94 = byte_4AAFA0;
      *(_DWORD *)(dword_4AAF90 + 8) = dword_4AAF94;
      *(_DWORD *)(dword_4AAF90 + 16) = dword_4AAFA4;
    }
    dword_4AAF90 = (int)this;
    result = sub_4686A0();
    dword_4AAFA8 = 1;
  }
  return result;
}
// 4AAF90: using guessed type int dword_4AAF90;
// 4AAF94: using guessed type int dword_4AAF94;
// 4AAFA0: using guessed type char byte_4AAFA0;
// 4AAFA4: using guessed type int dword_4AAFA4;
// 4AAFA8: using guessed type int dword_4AAFA8;

//----- (00468720) --------------------------------------------------------
int __usercall sub_468720@<eax>(int a1@<eax>)
{
  int v1; // ecx
  unsigned __int8 v2; // dl

  v1 = a1;
  v2 = 1;
  if ( word_49A330[a1] )
  {
    dword_4AAFAC = a1;
    dword_4AAFB0 = dword_4AAF94;
  }
  if ( word_4A0CF2[word_49B2C0[a1]] != a1 )
  {
    do
    {
      a1 = word_49C098[v1];
      if ( a1 >= 1351 )
        v2 = byte_49B1C0[4 * v2];
      v1 = a1;
    }
    while ( word_4A0CF0[v2 + word_49B2C0[a1]] != a1 );
  }
  return word_49CE70[v2 + word_49B2C0[a1]] != 1350 ? word_49CE70[v2 + word_49B2C0[a1]] : 0;
}
// 49A330: using guessed type __int16 word_49A330[1352];
// 49B2C0: using guessed type __int16 word_49B2C0[1772];
// 49C098: using guessed type __int16 word_49C098[];
// 49CE70: using guessed type __int16 word_49CE70[8000];
// 4A0CF0: using guessed type __int16 word_4A0CF0[];
// 4A0CF2: using guessed type __int16 word_4A0CF2[7999];
// 4AAF94: using guessed type int dword_4AAF94;
// 4AAFAC: using guessed type int dword_4AAFAC;
// 4AAFB0: using guessed type int dword_4AAFB0;

//----- (004687C0) --------------------------------------------------------
int sub_4687C0()
{
  int result; // eax
  char *i; // esi
  unsigned __int8 v2; // bl
  int v3; // ecx
  int j; // edx

  result = dword_4AAF9C + *(_DWORD *)(dword_4AAF90 + 28);
  for ( i = &String[dword_4AAFB8]; (unsigned int)i < dword_4AAF94; ++i )
  {
    if ( *i )
      v2 = byte_49ADC0[4 * (unsigned __int8)*i];
    else
      v2 = 1;
    v3 = result;
    if ( word_49A330[result] )
    {
      dword_4AAFAC = result;
      dword_4AAFB0 = (int)i;
    }
    for ( j = v2; word_4A0CF0[v2 + word_49B2C0[result]] != result; j = v2 )
    {
      result = word_49C098[v3];
      if ( result >= 1351 )
        v2 = byte_49B1C0[4 * j];
      v3 = result;
    }
    result = word_49CE70[v2 + word_49B2C0[result]];
  }
  return result;
}
// 49A330: using guessed type __int16 word_49A330[1352];
// 49B2C0: using guessed type __int16 word_49B2C0[1772];
// 49C098: using guessed type __int16 word_49C098[];
// 49CE70: using guessed type __int16 word_49CE70[8000];
// 4A0CF0: using guessed type __int16 word_4A0CF0[];
// 4AAF90: using guessed type int dword_4AAF90;
// 4AAF94: using guessed type int dword_4AAF94;
// 4AAF9C: using guessed type int dword_4AAF9C;
// 4AAFAC: using guessed type int dword_4AAFAC;
// 4AAFB0: using guessed type int dword_4AAFB0;
// 4AAFB8: using guessed type int dword_4AAFB8;

//----- (004688A0) --------------------------------------------------------
BOOL __cdecl sub_4688A0(int a1, int a2)
{
  return *(_BYTE *)a1 == *(_BYTE *)a2 && *(_BYTE *)a1 == 2 && *(_DWORD *)(a1 + 12) == *(_DWORD *)(a2 + 12);
}

//----- (004688D0) --------------------------------------------------------
int sub_4688D0()
{
  int result; // eax

  result = 0;
  dword_4AB364 = 0;
  dword_4AB368 = 0;
  return result;
}
// 4AB364: using guessed type int dword_4AB364;
// 4AB368: using guessed type int dword_4AB368;

//----- (004688E0) --------------------------------------------------------
char __usercall sub_4688E0@<al>(_DWORD *a1@<eax>)
{
  _BYTE *v1; // edx

  if ( a1 )
  {
    v1 = (_BYTE *)a1[1];
    a1[4] = 0;
    *v1 = 0;
    *(_BYTE *)(a1[1] + 1) = 0;
    a1[2] = a1[1];
    a1[7] = 1;
    a1[9] = 0;
    if ( a1 == (_DWORD *)dword_4AAF90 )
      LOBYTE(a1) = sub_4686A0();
  }
  return (char)a1;
}
// 4AAF90: using guessed type int dword_4AAF90;

//----- (00468920) --------------------------------------------------------
BOOL __usercall sub_468920@<eax>(FILE *a1@<edi>, FILE **a2@<esi>)
{
  int v2; // eax
  BOOL result; // eax

  sub_4688E0(a2);
  *a2 = a1;
  a2[8] = (FILE *)1;
  if ( a1 )
  {
    v2 = _fileno(a1);
    result = _isatty(v2) > 0;
    a2[6] = (FILE *)result;
  }
  else
  {
    result = 0;
    a2[6] = 0;
  }
  return result;
}

//----- (00468960) --------------------------------------------------------
void __cdecl zend_destroy_file_handle(int a1)
{
  zend_llist_del_element((int)&unk_4AB3BC, a1, (int (__cdecl *)(_DWORD *, int))sub_4688A0);
}

//----- (00468980) --------------------------------------------------------
unsigned int __cdecl zend_file_handle_dtor(int a1)
{
  unsigned int result; // eax
  int v2; // esi

  if ( *(_BYTE *)a1 == 2 )
    fclose(*(FILE **)(a1 + 12));
  result = *(_DWORD *)(a1 + 8);
  if ( result )
    result = efree(*(_DWORD *)(a1 + 8));
  if ( *(_BYTE *)(a1 + 16) )
  {
    v2 = *(_DWORD *)(a1 + 4);
    if ( v2 )
      return efree(v2);
  }
  return result;
}

//----- (004689D0) --------------------------------------------------------
int __cdecl zend_restore_lexical_state(int a1)
{
  int v1; // esi

  v1 = dword_4AAF90;
  if ( *(_DWORD *)a1 )
    sub_4686D0(*(void **)a1);
  else
    dword_4AAF90 = 0;
  sub_468670(v1);
  language_scanner_globals = *(FILE **)(a1 + 8);
  dword_4AAF9C = 2 * *(_DWORD *)(a1 + 4) + 1;
  dword_4AB35C = *(_DWORD *)(a1 + 12);
  return zend_restore_compiled_filename(*(_DWORD *)(a1 + 16));
}
// 4AAF90: using guessed type int dword_4AAF90;
// 4AAF9C: using guessed type int dword_4AAF9C;
// 4AB35C: using guessed type int dword_4AB35C;

//----- (00468A30) --------------------------------------------------------
int __cdecl zend_save_lexical_state(_DWORD *a1)
{
  int compiled_filename; // eax
  int v2; // ecx
  int result; // eax

  *a1 = dword_4AAF90;
  a1[2] = language_scanner_globals;
  a1[1] = (dword_4AAF9C - 1) / 2;
  compiled_filename = zend_get_compiled_filename();
  *(_DWORD *)(v2 + 16) = compiled_filename;
  result = dword_4AB35C;
  *(_DWORD *)(v2 + 12) = dword_4AB35C;
  return result;
}
// 468A57: variable 'v2' is possibly undefined
// 4AAF90: using guessed type int dword_4AAF90;
// 4AAF9C: using guessed type int dword_4AAF9C;
// 4AB35C: using guessed type int dword_4AB35C;

//----- (00468A70) --------------------------------------------------------
unsigned int sub_468A70()
{
  unsigned int result; // eax

  result = dword_4AB364;
  if ( dword_4AB364 )
  {
    result = efree(dword_4AB364);
    dword_4AB368 = 0;
  }
  return result;
}
// 4AB364: using guessed type int dword_4AB364;
// 4AB368: using guessed type int dword_4AB368;

//----- (00468A90) --------------------------------------------------------
_DWORD *__usercall sub_468A90@<eax>(char *a1@<eax>)
{
  return zend_error(64, a1);
}

//----- (00468AA0) --------------------------------------------------------
int sub_468AA0()
{
  char *v0; // eax
  int result; // eax

  if ( --dword_4A9CF0 < 0 )
  {
    v0 = (char *)sub_473493((int)&unk_487984);
    sub_468A90(v0);
  }
  result = 2 * *((_DWORD *)dword_4A9CF8 + dword_4A9CF0) + 1;
  dword_4AAF9C = result;
  return result;
}
// 4A9CF0: using guessed type int dword_4A9CF0;
// 4AAF9C: using guessed type int dword_4AAF9C;

//----- (00468AE0) --------------------------------------------------------
int __cdecl sub_468AE0(int a1)
{
  int v1; // eax
  size_t v2; // eax
  void *v3; // eax
  char *v4; // eax
  int v5; // eax
  int result; // eax

  v1 = dword_4A9CF4;
  if ( dword_4A9CF0 >= dword_4A9CF4 )
  {
    dword_4A9CF4 += 25;
    v2 = 4 * (v1 + 25);
    if ( dword_4A9CF8 )
      v3 = sub_468650(dword_4A9CF8, v2);
    else
      v3 = sub_468660(v2);
    dword_4A9CF8 = v3;
    if ( !v3 )
    {
      v4 = (char *)sub_473493((int)&unk_487954);
      sub_468A90(v4);
    }
  }
  v5 = dword_4A9CF0;
  *((_DWORD *)dword_4A9CF8 + dword_4A9CF0) = (dword_4AAF9C - 1) / 2;
  dword_4A9CF0 = v5 + 1;
  result = a1;
  dword_4AAF9C = 2 * a1 + 1;
  return result;
}
// 4A9CF0: using guessed type int dword_4A9CF0;
// 4A9CF4: using guessed type int dword_4A9CF4;
// 4AAF9C: using guessed type int dword_4AAF9C;

//----- (00468B60) --------------------------------------------------------
_DWORD *__usercall sub_468B60@<eax>(int a1@<edi>, unsigned int a2)
{
  _DWORD *v2; // esi
  char *v3; // eax

  if ( a2 < 2 || *(_BYTE *)(a1 + a2 - 2) || *(_BYTE *)(a1 + a2 - 1) )
    return 0;
  v2 = sub_468660(0x28u);
  if ( !v2 )
  {
    v3 = (char *)sub_473493((int)&unk_487928);
    sub_468A90(v3);
  }
  v2[3] = a2 - 2;
  v2[1] = a1;
  v2[2] = a1;
  v2[5] = 0;
  *v2 = 0;
  v2[4] = a2 - 2;
  v2[6] = 0;
  v2[7] = 1;
  v2[8] = 0;
  v2[9] = 0;
  sub_4686D0(v2);
  return v2;
}

//----- (00468BD0) --------------------------------------------------------
FILE **__usercall sub_468BD0@<eax>(FILE *a1@<edi>)
{
  FILE **v1; // esi
  char *v2; // eax
  FILE *v3; // eax
  char *v4; // eax

  v1 = (FILE **)sub_468660(0x28u);
  if ( !v1 )
  {
    v2 = (char *)sub_473493((int)&unk_4878F8);
    sub_468A90(v2);
  }
  v1[3] = (FILE *)0x4000;
  v3 = (FILE *)sub_468660(0x4002u);
  v1[1] = v3;
  if ( !v3 )
  {
    v4 = (char *)sub_473493((int)&unk_4878F8);
    sub_468A90(v4);
  }
  v1[5] = (FILE *)1;
  sub_468920(a1, v1);
  return v1;
}

//----- (00468C30) --------------------------------------------------------
char __cdecl sub_468C30(FILE *a1)
{
  FILE **v1; // eax

  v1 = (FILE **)dword_4AAF90;
  if ( !dword_4AAF90 )
  {
    v1 = sub_468BD0(language_scanner_globals);
    dword_4AAF90 = (int)v1;
  }
  sub_468920(a1, v1);
  return sub_4686A0();
}
// 4AAF90: using guessed type int dword_4AAF90;

//----- (00468C60) --------------------------------------------------------
char __cdecl sub_468C60(char *a1)
{
  unsigned int v1; // eax
  char *v2; // ebp
  unsigned int v3; // esi
  int v4; // ecx
  unsigned int v5; // edi
  int v6; // edx
  unsigned int v7; // eax
  char v8; // cl
  unsigned int v9; // edx
  char *v10; // eax
  char *v11; // esi
  char v12; // cl

  LOBYTE(v1) = byte_4AAFA0;
  v2 = a1;
  v3 = dword_4AAF94;
  *(_BYTE *)dword_4AAF94 = byte_4AAFA0;
  v4 = dword_4AAF90;
  v5 = *(_DWORD *)(dword_4AAF90 + 4);
  if ( v3 < v5 + 2 )
  {
    v6 = *(_DWORD *)(dword_4AAF90 + 12) + v5 + 2;
    v7 = v5 + dword_4AAFA4 + 2;
    if ( v7 > v5 )
    {
      do
      {
        v8 = *(_BYTE *)--v7;
        *(_BYTE *)--v6 = v8;
        v4 = dword_4AAF90;
      }
      while ( v7 > *(_DWORD *)(dword_4AAF90 + 4) );
    }
    v9 = v6 - v7;
    dword_4AAFA4 = *(_DWORD *)(v4 + 12);
    *(_DWORD *)(v4 + 16) = dword_4AAFA4;
    v3 += v9;
    v2 = &a1[v9];
    v1 = *(_DWORD *)(dword_4AAF90 + 4) + 2;
    if ( v3 < v1 )
    {
      v10 = (char *)sub_473493((int)&unk_4878D4);
      LOBYTE(v1) = (unsigned __int8)sub_468A90(v10);
    }
  }
  v11 = (char *)(v3 - 1);
  *v11 = 59;
  String = v2;
  v12 = *v11;
  dword_4AAF94 = (int)v11;
  byte_4AAFA0 = v12;
  return v1;
}
// 4AAF90: using guessed type int dword_4AAF90;
// 4AAF94: using guessed type int dword_4AAF94;
// 4AAFA0: using guessed type char byte_4AAFA0;
// 4AAFA4: using guessed type int dword_4AAFA4;

//----- (00468D10) --------------------------------------------------------
int sub_468D10()
{
  _DWORD *v0; // edx
  char *v1; // ecx
  _BYTE *v2; // esi
  int v3; // eax
  char *v4; // edi
  char *v5; // eax
  int result; // eax
  int v7; // ebp
  int v8; // eax
  signed int i; // esi
  void *v10; // ecx
  void **v11; // esi
  int v12; // ebx
  int *v13; // eax
  unsigned int v14; // edx
  int v15; // edi
  char *v16; // eax
  int v17; // edi
  int v18; // eax
  int v19; // edx
  char *v20; // eax
  char *v21; // eax
  int v22; // esi

  v0 = (_DWORD *)dword_4AAF90;
  v1 = String;
  v2 = *(_BYTE **)(dword_4AAF90 + 4);
  v3 = dword_4AAF94;
  v4 = String;
  if ( dword_4AAF94 > (unsigned int)&v2[dword_4AAFA4 + 1] )
  {
    v5 = (char *)sub_473493((int)&unk_487848);
    sub_468A90(v5);
    v3 = dword_4AAF94;
    v0 = (_DWORD *)dword_4AAF90;
    v1 = String;
  }
  if ( !v0[8] )
    return (v3 - dword_4AAFB8 - (_DWORD)v1 != 1) + 1;
  v7 = v3 - (_DWORD)v1 - 1;
  if ( v7 > 0 )
  {
    v8 = v3 - (_DWORD)v1 - 1;
    do
    {
      *v2++ = *v4++;
      --v8;
    }
    while ( v8 );
    v3 = dword_4AAF94;
    v0 = (_DWORD *)dword_4AAF90;
  }
  if ( v0[9] == 2 )
  {
    dword_4AAFA4 = 0;
    v0[4] = 0;
  }
  else
  {
    for ( i = v0[3] - v7 - 1; i <= 0; i = *(_DWORD *)(dword_4AAF90 + 12) - v7 - 1 )
    {
      v10 = (void *)v0[1];
      v11 = (void **)(v0 + 1);
      v12 = v3 - (_DWORD)v10;
      if ( v0[5] )
      {
        v13 = v0 + 3;
        v14 = v0[3];
        v15 = 2 * v14;
        if ( (int)(2 * v14) <= 0 )
          v15 = v14 + (v14 >> 3);
        *v13 = v15;
        *v11 = sub_468650(v10, v15 + 2);
      }
      else
      {
        *v11 = 0;
      }
      if ( !*v11 )
      {
        v16 = (char *)sub_473493((int)&unk_487884);
        sub_468A90(v16);
      }
      v0 = (_DWORD *)dword_4AAF90;
      v3 = (int)*v11 + v12;
      dword_4AAF94 = v3;
    }
    if ( i > 0x2000 )
      i = 0x2000;
    if ( v0[6] )
    {
      v17 = 0;
      if ( i > 0 )
      {
        do
        {
          v18 = fgetc(language_scanner_globals);
          if ( v18 == -1 )
            break;
          if ( v18 == 10 )
          {
            *(_BYTE *)(v17 + *(_DWORD *)(dword_4AAF90 + 4) + v7) = 10;
            ++v17;
            break;
          }
          v19 = v17 + *(_DWORD *)(dword_4AAF90 + 4);
          ++v17;
          *(_BYTE *)(v19 + v7) = v18;
        }
        while ( v17 < i );
        if ( v18 == -1 && ferror(language_scanner_globals) )
        {
          v20 = (char *)sub_473493((int)&unk_4878B4);
          sub_468A90(v20);
        }
        v0 = (_DWORD *)dword_4AAF90;
      }
      dword_4AAFA4 = v17;
    }
    else
    {
      dword_4AAFA4 = fread((void *)(v7 + v0[1]), 1u, i, language_scanner_globals);
      if ( !dword_4AAFA4 && ferror(language_scanner_globals) )
      {
        v21 = (char *)sub_473493((int)&unk_4878B4);
        sub_468A90(v21);
      }
      v0 = (_DWORD *)dword_4AAF90;
    }
    v0[4] = dword_4AAFA4;
  }
  if ( dword_4AAFA4 )
  {
    v22 = 0;
  }
  else if ( v7 == dword_4AAFB8 )
  {
    v22 = 1;
    sub_468C30(language_scanner_globals);
  }
  else
  {
    v22 = 2;
    *(_DWORD *)(dword_4AAF90 + 36) = 2;
  }
  dword_4AAFA4 += v7;
  *(_BYTE *)(dword_4AAFA4 + *(_DWORD *)(dword_4AAF90 + 4)) = 0;
  *(_BYTE *)(*(_DWORD *)(dword_4AAF90 + 4) + dword_4AAFA4 + 1) = 0;
  result = v22;
  String = *(char **)(dword_4AAF90 + 4);
  return result;
}
// 468E7F: conditional instruction was optimized away because eax.4!=A
// 4AAF90: using guessed type int dword_4AAF90;
// 4AAF94: using guessed type int dword_4AAF94;
// 4AAFA4: using guessed type int dword_4AAFA4;
// 4AAFB8: using guessed type int dword_4AAFB8;

//----- (00468FA0) --------------------------------------------------------
int __cdecl lex_scan(int a1)
{
  char *v1; // ecx
  char *v2; // esi
  int v3; // edi
  char *v4; // ebp
  unsigned __int8 v5; // dl
  int v6; // eax
  int i; // ecx
  int v8; // edx
  int v9; // ecx
  int v10; // eax
  int v11; // eax
  int v12; // edi
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // eax
  char *v18; // eax
  char *v19; // eax
  size_t v20; // eax
  char *v21; // eax
  size_t v22; // eax
  char *v23; // eax
  int result; // eax
  _DWORD *v25; // eax
  int v26; // ecx
  size_t v27; // eax
  int v28; // esi
  char *v29; // eax
  unsigned int v30; // eax
  size_t v31; // eax
  char *v32; // edx
  size_t v33; // eax
  char *v34; // edx
  size_t v35; // eax
  char *compiled_filename; // eax
  size_t v37; // ecx
  size_t v38; // eax
  char *v39; // eax
  char *v40; // edx
  char *v41; // esi
  signed int v42; // ebp
  char *v43; // eax
  char *v44; // edi
  char *v45; // esi
  _DWORD *v46; // eax
  size_t v47; // edx
  char v48; // al
  size_t v49; // eax
  char v50; // al
  char *v51; // eax
  char v52; // al
  size_t v53; // eax
  size_t v54; // eax
  _DWORD *v55; // eax
  char *v56; // eax
  char *v57; // edx
  char *v58; // esi
  char *v59; // eax
  size_t v60; // eax
  char *v61; // esi
  char *v62; // edx
  size_t v63; // edx
  char *v64; // eax
  size_t v65; // eax
  char *v66; // eax
  char *v67; // edx
  char *v68; // edi
  char *v69; // edi
  unsigned int v70; // eax
  char *v71; // ebp
  char *v72; // ebx
  unsigned int v73; // edx
  char v74; // al
  char v75; // al
  int v76; // eax
  char v77; // cl
  int v78; // eax
  char v79; // dl
  char v80; // al
  char v81; // al
  char v82; // cl
  char *v83; // ebp
  int v84; // eax
  char v85; // cl
  char v86; // dl
  char v87; // al
  char *v88; // edi
  size_t v89; // eax
  char *v90; // eax
  char *v91; // edx
  char *v92; // esi
  _BYTE *v93; // eax
  unsigned int v94; // esi
  char *v95; // ecx
  char v96; // dl
  char v97; // dl
  size_t v98; // eax
  size_t v99; // eax
  _BYTE *j; // ecx
  size_t v101; // ebp
  unsigned int v102; // eax
  char v103; // bl
  _BYTE *v104; // esi
  char *v105; // edi
  _DWORD *v106; // eax
  size_t v107; // ebp
  char *v108; // eax
  char *v109; // edi
  char *v110; // esi
  _DWORD *v111; // eax
  char *v112; // eax
  char *v113; // edi
  char *v114; // esi
  size_t v115; // eax
  char *v116; // eax
  char *v117; // eax
  int v118; // eax
  size_t v119; // esi
  char *v120; // eax
  int v121; // [esp-8h] [ebp-24h]
  int v122; // [esp-4h] [ebp-20h]
  char *v123; // [esp-4h] [ebp-20h]
  int v124; // [esp-4h] [ebp-20h]
  char v125; // [esp+10h] [ebp-Ch] BYREF
  char v126; // [esp+11h] [ebp-Bh]
  char v127; // [esp+12h] [ebp-Ah]
  char String; // [esp+14h] [ebp-8h] BYREF
  char v129; // [esp+15h] [ebp-7h]
  char v130; // [esp+16h] [ebp-6h]
  char v131; // [esp+17h] [ebp-5h]
  unsigned int v132; // [esp+18h] [ebp-4h]

  if ( dword_4AAF98 )
  {
    dword_4AAF98 = 0;
    if ( !dword_4AAF9C )
      dword_4AAF9C = 1;
    if ( !language_scanner_globals )
      language_scanner_globals = (FILE *)sub_44F01A();
    if ( !dword_4AAF84 )
      dword_4AAF84 = (int)(sub_44F01A() + 8);
    if ( !dword_4AAF90 )
      dword_4AAF90 = (int)sub_468BD0(language_scanner_globals);
    sub_4686A0();
  }
LABEL_11:
  v1 = ::String;
LABEL_12:
  dword_4AAFB8 = 0;
  if ( dword_4AAFB4 )
  {
    dword_4AAFB8 = dword_4AAF94 - (_DWORD)v1;
    dword_4AAFB4 = 0;
  }
  v2 = (char *)dword_4AAF94;
  *(_BYTE *)dword_4AAF94 = byte_4AAFA0;
  v3 = dword_4AAF9C + *(_DWORD *)(dword_4AAF90 + 28);
  v4 = v2;
  do
  {
LABEL_15:
    v5 = byte_49ADC0[4 * (unsigned __int8)*v2];
    v6 = v3;
    if ( word_49A330[v3] )
    {
      dword_4AAFAC = v3;
      dword_4AAFB0 = (int)v2;
    }
    for ( i = v5; word_4A0CF0[v5 + word_49B2C0[v3]] != v3; i = v5 )
    {
      v3 = word_49C098[v6];
      if ( v3 >= 1351 )
        v5 = byte_49B1C0[4 * i];
      v6 = v3;
    }
    v3 = word_49CE70[v5 + word_49B2C0[v3]];
    ++v2;
  }
  while ( word_49B2C0[v3] != 7936 );
LABEL_22:
  v8 = dword_4AAFAC;
  v9 = dword_4AAFB0;
  while ( 2 )
  {
    v10 = word_49A330[v3];
    if ( !word_49A330[v3] )
    {
      v10 = word_49A330[v8];
      v2 = (char *)v9;
    }
    ::String = &v4[-dword_4AAFB8];
    dword_4AAF88 = v2 - &v4[-dword_4AAFB8];
    byte_4AAFA0 = *v2;
    *v2 = 0;
    v1 = ::String;
    dword_4AAF94 = (int)v2;
LABEL_26:
    switch ( v10 )
    {
      case 0:
        *v2 = byte_4AAFA0;
        v9 = dword_4AAFB0;
        v8 = dword_4AAFAC;
        v2 = (char *)dword_4AAFB0;
        v3 = dword_4AAFAC;
        continue;
      case 1:
      case 2:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 297;
      case 3:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 330;
      case 4:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 331;
      case 5:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 332;
      case 6:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 333;
      case 7:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 298;
      case 8:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 299;
      case 9:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 301;
      case 10:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 300;
      case 11:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 315;
      case 12:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 316;
      case 13:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 314;
      case 14:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 317;
      case 15:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 318;
      case 16:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 319;
      case 17:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 320;
      case 18:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 321;
      case 19:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 322;
      case 20:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 323;
      case 21:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 324;
      case 22:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 325;
      case 23:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 326;
      case 24:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 327;
      case 25:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 328;
      case 26:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 329;
      case 27:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 313;
      case 28:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 265;
      case 29:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 341;
      case 30:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 342;
      case 31:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        sub_468AE0(6);
        return 343;
      case 32:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        sub_468AA0();
        v25 = estrndup(::String, dword_4AAF88);
        v26 = a1;
        *(_DWORD *)a1 = v25;
        *(_DWORD *)(a1 + 4) = dword_4AAF88;
        goto LABEL_159;
      case 33:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        *v2 = byte_4AAFA0;
        v18 = &v4[-dword_4AAFB8];
        dword_4AAF94 = (int)&v4[-dword_4AAFB8];
        ::String = v18;
        dword_4AAF88 = 0;
        byte_4AAFA0 = v4[-dword_4AAFB8];
        *v18 = 0;
        dword_4AAF94 = (int)v18;
        sub_468AA0();
        goto LABEL_11;
      case 34:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 361;
      case 35:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 296;
      case 36:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 337;
      case 37:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 289;
      case 38:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 290;
      case 39:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 291;
      case 40:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 292;
      case 41:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 293;
      case 42:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 294;
      case 43:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 295;
      case 44:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 259;
      case 45:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 257;
      case 46:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 258;
      case 47:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 260;
      case 48:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 261;
      case 49:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 334;
      case 50:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 335;
      case 51:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 339;
      case 52:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 340;
      case 53:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 336;
      case 54:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 338;
      case 55:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 344;
      case 56:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 345;
      case 57:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 346;
      case 58:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 287;
      case 59:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 288;
      case 60:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 281;
      case 61:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 282;
      case 62:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 279;
      case 63:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 280;
      case 64:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 283;
      case 65:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 284;
      case 66:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 266;
      case 67:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 267;
      case 68:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 268;
      case 69:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 269;
      case 70:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 270;
      case 71:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 271;
      case 72:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 275;
      case 73:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 276;
      case 74:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 272;
      case 75:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 273;
      case 76:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 274;
      case 77:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 277;
      case 78:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 278;
      case 79:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 262;
      case 80:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 264;
      case 81:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 263;
      case 82:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 285;
      case 83:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        return 286;
      case 84:
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
        }
        return *v1;
      case 85:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        sub_468AE0(1);
        return 123;
      case 86:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        sub_468AE0(7);
        return 359;
      case 87:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        if ( dword_4A9CF0 )
          sub_468AA0();
        return 125;
      case 88:
        v27 = dword_4AAF88;
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
          v27 = dword_4AAF88;
        }
        *(_DWORD *)a1 = estrndup(v1, v27);
        *(_DWORD *)(a1 + 4) = dword_4AAF88;
        *(_BYTE *)(a1 + 8) = 3;
        sub_468AA0();
        sub_468AE0(1);
        return 305;
      case 89:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        *v2 = byte_4AAFA0;
        v19 = &v4[-dword_4AAFB8];
        dword_4AAF94 = (int)&v4[-dword_4AAFB8];
        ::String = v19;
        dword_4AAF88 = 0;
        byte_4AAFA0 = v4[-dword_4AAFB8];
        *v19 = 0;
        dword_4AAF94 = (int)v19;
        sub_468AA0();
        sub_468AE0(1);
        goto LABEL_11;
      case 90:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        *_errno() = 0;
        v28 = a1;
        *(_DWORD *)a1 = strtol(::String, 0, 0);
        if ( *_errno() != 34 )
          goto LABEL_338;
        *(double *)a1 = strtod(::String, 0);
        *(_BYTE *)(a1 + 8) = 2;
        return 303;
      case 91:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        *_errno() = 0;
        v28 = a1;
        *(_DWORD *)a1 = strtoul(::String, 0, 16);
        if ( *_errno() == 34 )
        {
          *(_DWORD *)a1 = 0x7FFFFFFF;
          v123 = ::String;
          v29 = (char *)sub_473493((int)&unk_487728);
          zend_error(8, v29, v123);
          *(_BYTE *)(a1 + 8) = 1;
          return 302;
        }
        else
        {
          v30 = *(_DWORD *)a1;
          if ( *(int *)a1 >= 0 )
          {
            *(_BYTE *)(a1 + 8) = 1;
LABEL_338:
            *(_BYTE *)(v28 + 8) = 1;
            return 302;
          }
          else
          {
            v132 = *(_DWORD *)a1;
            *(double *)a1 = (double)v30;
            *(_BYTE *)(a1 + 8) = 2;
            return 303;
          }
        }
      case 92:
        v31 = dword_4AAF88;
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
          v31 = dword_4AAF88;
        }
        *(_DWORD *)a1 = estrndup(v1, v31);
        *(_DWORD *)(a1 + 4) = dword_4AAF88;
        *(_BYTE *)(a1 + 8) = 3;
        return 307;
      case 93:
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
        }
        *(double *)a1 = strtod(v1, 0);
        *(_BYTE *)(a1 + 8) = 2;
        return 303;
      case 94:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        if ( !dword_4AB2F4 || (v32 = *(char **)(dword_4AB2F4 + 4)) == 0 )
          v32 = (char *)byte_47627C;
        v33 = strlen(v32);
        *(_DWORD *)(a1 + 4) = v33;
        *(_DWORD *)a1 = estrndup(v32, v33);
        *(_BYTE *)(a1 + 8) = 3;
        return 347;
      case 95:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        v34 = *(char **)(dword_4AB36C + 8);
        if ( !v34 )
          v34 = (char *)byte_47627C;
        v35 = strlen(v34);
        *(_DWORD *)(a1 + 4) = v35;
        *(_DWORD *)a1 = estrndup(v34, v35);
        *(_BYTE *)(a1 + 8) = 3;
        return 348;
      case 96:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        *(_DWORD *)a1 = dword_4AB35C;
        *(_BYTE *)(a1 + 8) = 1;
        return 349;
      case 97:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        compiled_filename = (char *)zend_get_compiled_filename();
        if ( !compiled_filename )
          compiled_filename = (char *)byte_47627C;
        v37 = strlen(compiled_filename);
        *(_DWORD *)(a1 + 4) = v37;
        *(_DWORD *)a1 = estrndup(compiled_filename, v37);
        *(_BYTE *)(a1 + 8) = 3;
        return 350;
      case 98:
        v38 = dword_4AAF88;
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
          v38 = dword_4AAF88;
        }
        *(_DWORD *)a1 = estrndup(v1, v38);
        *(_DWORD *)(a1 + 4) = dword_4AAF88;
        *(_BYTE *)(a1 + 8) = 3;
        v39 = ::String;
        v40 = &::String[dword_4AAF88];
        if ( ::String < &::String[dword_4AAF88] )
        {
          v41 = ::String + 1;
          do
          {
            if ( *v39 == 10 || *v39 == 13 && v41 < v40 && *v41 != 10 )
              ++dword_4AB35C;
            ++v39;
            ++v41;
          }
          while ( v39 < v40 );
        }
        return 308;
      case 99:
        v42 = dword_4AAF88;
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
          v42 = dword_4AAF88;
        }
        v43 = v1;
        v44 = &v1[v42];
        if ( v1 < &v1[v42] )
        {
          v45 = v1 + 1;
          do
          {
            if ( *v43 == 10 || *v43 == 13 && v45 < v44 && *v45 != 10 )
              ++dword_4AB35C;
            ++v43;
            ++v45;
          }
          while ( v43 < v44 );
        }
        if ( byte_4AB3A5 || v42 > 2 )
          goto LABEL_389;
        v46 = estrndup(v1, v42);
        goto LABEL_388;
      case 100:
        v47 = dword_4AAF88;
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
          v47 = dword_4AAF88;
        }
        v48 = v1[1];
        if ( v48 == 37 && byte_4AB3A6 || v48 == 63 && byte_4AB3A5 )
        {
          *(_DWORD *)a1 = v1;
          *(_DWORD *)(a1 + 4) = dword_4AAF88;
          *(_BYTE *)(a1 + 8) = 3;
          dword_4AAF9C = 3;
          return 354;
        }
        else
        {
          *(_DWORD *)a1 = estrndup(v1, v47);
          *(_DWORD *)(a1 + 4) = dword_4AAF88;
          *(_BYTE *)(a1 + 8) = 3;
          return 308;
        }
      case 101:
        v49 = dword_4AAF88;
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
          v49 = dword_4AAF88;
        }
        if ( byte_4AB3A6 )
        {
LABEL_389:
          *(_DWORD *)a1 = v1;
          *(_DWORD *)(a1 + 4) = dword_4AAF88;
          *(_BYTE *)(a1 + 8) = 3;
          dword_4AAF9C = 3;
          return 353;
        }
        else
        {
          *(_DWORD *)a1 = estrndup(v1, v49);
          *(_DWORD *)(a1 + 4) = dword_4AAF88;
          *(_BYTE *)(a1 + 8) = 3;
          return 308;
        }
      case 102:
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
        }
        *(_DWORD *)a1 = v1;
        *(_DWORD *)(a1 + 4) = dword_4AAF88;
        *(_BYTE *)(a1 + 8) = 3;
        v50 = ::String[dword_4AAF88 - 1];
        if ( v50 == 10 || v50 == 13 )
          ++dword_4AB35C;
        dword_4AAF9C = 3;
        return 353;
      case 103:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        v51 = (char *)sub_473493((int)&unk_487748);
        zend_error(2, v51);
        v52 = ::String[dword_4AAF88 - 1];
        if ( v52 == 10 || v52 == 13 )
          ++dword_4AB35C;
        v46 = estrndup(::String, dword_4AAF88);
LABEL_388:
        *(_DWORD *)a1 = v46;
        *(_DWORD *)(a1 + 4) = dword_4AAF88;
        *(_BYTE *)(a1 + 8) = 3;
        return 308;
      case 104:
        v53 = dword_4AAF88;
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
          v53 = dword_4AAF88;
        }
        *(_DWORD *)a1 = estrndup(v1 + 1, v53 - 1);
        *(_DWORD *)(a1 + 4) = dword_4AAF88 - 1;
        *(_BYTE *)(a1 + 8) = 3;
        return 306;
      case 105:
      case 106:
        v54 = dword_4AAF88;
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
          v54 = dword_4AAF88;
        }
        v55 = estrndup(v1, v54);
        v26 = a1;
        *(_DWORD *)a1 = v55;
        goto LABEL_159;
      case 107:
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
        }
        *(_DWORD *)a1 = v1;
        *(_DWORD *)(a1 + 4) = dword_4AAF88;
        *(_BYTE *)(a1 + 8) = 3;
        v56 = ::String;
        v57 = &::String[dword_4AAF88];
        if ( ::String < &::String[dword_4AAF88] )
        {
          v58 = ::String + 1;
          do
          {
            if ( *v56 == 10 || *v56 == 13 && v58 < v57 && *v58 != 10 )
              ++dword_4AB35C;
            ++v56;
            ++v58;
          }
          while ( v56 < v57 );
        }
        return 356;
      case 108:
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
        }
        dword_4AAF9C = 19;
        dword_4AAFB4 = 1;
        goto LABEL_12;
      case 109:
      case 110:
      case 114:
      case 116:
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
        }
        dword_4AAFB4 = 1;
        goto LABEL_12;
      case 111:
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
        }
        *(_DWORD *)a1 = v1;
        *(_DWORD *)(a1 + 4) = dword_4AAF88;
        *(_BYTE *)(a1 + 8) = 3;
        ++dword_4AB35C;
        dword_4AAF9C = 3;
        return 351;
      case 112:
        v20 = dword_4AAF88;
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
          v20 = dword_4AAF88;
        }
        if ( byte_4AB3A6 || v1[v20 - 2] != 37 )
        {
          *(_DWORD *)a1 = v1;
          *(_DWORD *)(a1 + 4) = dword_4AAF88;
          *(_BYTE *)(a1 + 8) = 3;
          *v2 = byte_4AAFA0;
          v59 = &v4[dword_4AAF88 - dword_4AAFB8 - 2];
          dword_4AAF94 = (int)v59;
          dword_4AAF88 = dword_4AAF88 - dword_4AAFB8 - 2 + dword_4AAFB8;
          ::String = &v4[-dword_4AAFB8];
          byte_4AAFA0 = *v59;
          *v59 = 0;
          dword_4AAF94 = (int)v59;
          dword_4AAF9C = 3;
          return 351;
        }
        dword_4AAFB4 = 1;
        goto LABEL_12;
      case 113:
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
        }
        *(_DWORD *)dword_4AB360 = dword_4AB35C;
        dword_4AAF9C = 17;
        dword_4AAFB4 = 1;
        goto LABEL_12;
      case 115:
        v60 = dword_4AAF88;
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
          v60 = dword_4AAF88;
        }
        v61 = &v1[v60];
        if ( v1 < &v1[v60] )
        {
          v62 = v1 + 1;
          do
          {
            if ( *v1 == 10 || *v1 == 13 && v62 < v61 && *v62 != 10 )
              ++dword_4AB35C;
            ++v1;
            ++v62;
          }
          while ( v1 < v61 );
        }
        dword_4AAF9C = 3;
        return 351;
      case 117:
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
        }
        *(_DWORD *)a1 = v1;
        *(_DWORD *)(a1 + 4) = dword_4AAF88;
        *(_BYTE *)(a1 + 8) = 3;
        dword_4AAF9C = 1;
        return 355;
      case 118:
        v63 = dword_4AAF88;
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v63 = dword_4AAF88;
        }
        if ( byte_4AB3A6 )
        {
          dword_4AAF9C = 1;
          *(_DWORD *)(a1 + 4) = v63;
          *(_BYTE *)(a1 + 8) = 3;
          *(_DWORD *)a1 = ::String;
          return 355;
        }
        else
        {
          *v2 = byte_4AAFA0;
          v64 = &v4[-dword_4AAFB8 + 1];
          dword_4AAF94 = (int)v64;
          ::String = &v4[-dword_4AAFB8];
          dword_4AAF88 = 1;
          byte_4AAFA0 = *v64;
          *v64 = 0;
          dword_4AAF94 = (int)v64;
          return *::String;
        }
      case 119:
        v65 = dword_4AAF88;
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
          v65 = dword_4AAF88;
        }
        *(_DWORD *)a1 = estrndup(v1 + 1, v65 - 2);
        *(_DWORD *)(a1 + 4) = dword_4AAF88 - 2;
        *(_BYTE *)(a1 + 8) = 3;
        v66 = ::String;
        v67 = &::String[dword_4AAF88];
        if ( ::String < &::String[dword_4AAF88] )
        {
          v68 = ::String + 1;
          do
          {
            if ( *v66 == 10 || *v66 == 13 && v68 < v67 && *v68 != 10 )
              ++dword_4AB35C;
            ++v66;
            ++v68;
          }
          while ( v66 < v67 );
        }
        v69 = *(char **)a1;
        v70 = *(_DWORD *)a1 + *(_DWORD *)(a1 + 4);
        v71 = v69;
        v132 = v70;
        if ( (unsigned int)v69 >= v70 )
          goto LABEL_503;
        v72 = v69 + 1;
        v73 = v70;
        do
        {
          v74 = *v71++;
          if ( v74 == 92 )
          {
            ++v72;
            if ( (unsigned int)v71 >= v73 )
              break;
            v75 = *v71;
            switch ( *v71 )
            {
              case '"':
              case '$':
              case '\\':
                *v69 = v75;
                --*(_DWORD *)(a1 + 4);
                ++v69;
                ++v71;
                break;
              case 'n':
                *v69 = 10;
                --*(_DWORD *)(a1 + 4);
                ++v69;
                ++v71;
                break;
              case 'r':
                *v69 = 13;
                --*(_DWORD *)(a1 + 4);
                ++v69;
                ++v71;
                break;
              case 't':
                *v69 = 9;
                --*(_DWORD *)(a1 + 4);
                ++v69;
                ++v71;
                break;
              default:
                if ( v75 < 48 || v75 > 55 )
                {
                  if ( v75 == 120
                    && (unsigned int)v72 < v73
                    && ((v81 = *v72, *v72 >= 48) && v81 <= 57 || v81 >= 97 && v81 <= 102 || v81 >= 65 && v81 <= 70) )
                  {
                    --*(_DWORD *)(a1 + 4);
                    v82 = v71[1];
                    v83 = v71 + 1;
                    ++v72;
                    v84 = *(_DWORD *)(a1 + 4) - 1;
                    v126 = 0;
                    v127 = 0;
                    v125 = v82;
                    *(_DWORD *)(a1 + 4) = v84;
                    if ( (unsigned int)v72 < v73 )
                    {
                      if ( (v85 = *v72, *v72 >= 48) && v85 <= 57 || v85 >= 97 && v85 <= 102 || v85 >= 65 && v85 <= 70 )
                      {
                        v86 = *++v83;
                        ++v72;
                        v126 = v86;
                        *(_DWORD *)(a1 + 4) = v84 - 1;
                      }
                    }
                    v87 = strtol(&v125, 0, 16);
                    v73 = v132;
                    *v69++ = v87;
                    v71 = v83 + 1;
                  }
                  else
                  {
                    *v69 = 92;
                    v88 = v69 + 1;
                    *v88 = *v71;
                    v69 = v88 + 1;
                    ++v71;
                  }
                }
                else
                {
                  --*(_DWORD *)(a1 + 4);
                  String = v75;
                  v76 = *(_DWORD *)(a1 + 4);
                  v129 = 0;
                  v130 = 0;
                  v131 = 0;
                  if ( (unsigned int)v72 < v73 && *v72 >= 48 && *v72 <= 55 )
                  {
                    v77 = *++v71;
                    ++v72;
                    v78 = v76 - 1;
                    v129 = v77;
                    *(_DWORD *)(a1 + 4) = v78;
                    if ( (unsigned int)v72 < v73 && *v72 >= 48 && *v72 <= 55 )
                    {
                      v79 = *++v71;
                      ++v72;
                      v130 = v79;
                      *(_DWORD *)(a1 + 4) = v78 - 1;
                    }
                  }
                  v80 = strtol(&String, 0, 8);
                  v73 = v132;
                  *v69++ = v80;
                  ++v71;
                }
                break;
            }
          }
          else
          {
            *v69++ = v74;
          }
          ++v72;
        }
        while ( (unsigned int)v71 < v73 );
LABEL_503:
        *v69 = 0;
        return 312;
      case 120:
        v89 = dword_4AAF88;
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
          v89 = dword_4AAF88;
        }
        *(_DWORD *)a1 = estrndup(v1 + 1, v89 - 2);
        *(_DWORD *)(a1 + 4) = dword_4AAF88 - 2;
        *(_BYTE *)(a1 + 8) = 3;
        v90 = ::String;
        v91 = &::String[dword_4AAF88];
        if ( ::String < &::String[dword_4AAF88] )
        {
          v92 = ::String + 1;
          do
          {
            if ( *v90 == 10 || *v90 == 13 && v92 < v91 && *v92 != 10 )
              ++dword_4AB35C;
            ++v90;
            ++v92;
          }
          while ( v90 < v91 );
        }
        v93 = *(_BYTE **)a1;
        v94 = *(_DWORD *)a1 + *(_DWORD *)(a1 + 4);
        v95 = *(char **)a1;
        if ( *(_DWORD *)a1 >= v94 )
          goto LABEL_522;
        break;
      case 121:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        dword_4AAF9C = 5;
        return 34;
      case 122:
        v98 = dword_4AAF88;
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
          v98 = dword_4AAF88;
        }
        ++dword_4AB35C;
        v99 = v98 - (v1[v98 - 2] == 13) - 4;
        for ( j = v1 + 3; ; ++j )
        {
          dword_4AB368 = v99;
          if ( *j != 32 && *j != 9 )
            break;
          --v99;
        }
        dword_4AB364 = (int)estrndup(j, v99);
        dword_4AAF9C = 11;
        return 357;
      case 123:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        dword_4AAF9C = 9;
        return 96;
      case 124:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        dword_4AAF9C = 7;
        return 39;
      case 125:
        v101 = dword_4AAF88;
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
          v101 = dword_4AAF88;
        }
        ++dword_4AB35C;
        v102 = v101 - 2;
        if ( v1[v101 - 2] != 13 )
          v102 = v101 - 1;
        if ( v1[v102 - 1] == 59 )
        {
          --v102;
          v103 = 1;
        }
        else
        {
          v103 = 0;
        }
        if ( v102 != dword_4AB368 )
          goto LABEL_560;
        v104 = (_BYTE *)dword_4AB364;
        v105 = v1;
        if ( v102 < 4 )
          goto LABEL_551;
        while ( *(_DWORD *)v105 == *(_DWORD *)v104 )
        {
          v102 -= 4;
          v104 += 4;
          v105 += 4;
          if ( v102 < 4 )
          {
LABEL_551:
            if ( !v102 || *v104 == *v105 && (v102 <= 1 || v104[1] == v105[1] && (v102 <= 2 || v104[2] == v105[2])) )
            {
              *(_DWORD *)a1 = estrndup(v1, v101);
              *(_DWORD *)(a1 + 4) = dword_4AAF88;
              if ( v103 )
                sub_468C60(::String);
              efree(dword_4AB364);
              dword_4AB364 = 0;
              dword_4AB368 = 0;
              dword_4AAF9C = 3;
              return 358;
            }
            break;
          }
        }
LABEL_560:
        v106 = estrndup(v1, v101);
        v26 = a1;
        *(_DWORD *)a1 = v106;
LABEL_159:
        *(_DWORD *)(v26 + 4) = dword_4AAF88;
        *(_BYTE *)(v26 + 8) = 3;
        return 304;
      case 126:
        v107 = dword_4AAF88;
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
          v107 = dword_4AAF88;
        }
        v108 = v1;
        v109 = &v1[v107];
        if ( v1 < &v1[v107] )
        {
          v110 = v1 + 1;
          do
          {
            if ( *v108 == 10 || *v108 == 13 && v110 < v109 && *v110 != 10 )
              ++dword_4AB35C;
            ++v108;
            ++v110;
          }
          while ( v108 < v109 );
        }
        goto LABEL_571;
      case 127:
        v107 = dword_4AAF88;
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
          v107 = dword_4AAF88;
        }
        v112 = v1;
        v113 = &v1[v107];
        if ( v1 < &v1[v107] )
        {
          v114 = v1 + 1;
          do
          {
            if ( *v112 == 10 || *v112 == 13 && v114 < v113 && *v114 != 10 )
              ++dword_4AB35C;
            ++v112;
            ++v114;
          }
          while ( v112 < v113 );
        }
LABEL_571:
        v111 = estrndup(v1, v107);
        goto LABEL_572;
      case 128:
      case 129:
      case 140:
        v115 = dword_4AAF88;
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
          v115 = dword_4AAF88;
        }
        v111 = estrndup(v1, v115);
LABEL_572:
        *(_DWORD *)a1 = v111;
        *(_DWORD *)(a1 + 4) = dword_4AAF88;
        *(_BYTE *)(a1 + 8) = 3;
        return 311;
      case 130:
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
        }
        *(_DWORD *)a1 = *v1;
        if ( dword_4AAF88 == 2 )
        {
          *v2 = byte_4AAFA0;
          v116 = &v4[-dword_4AAFB8 + 1];
          dword_4AAF94 = (int)v116;
          ::String = &v4[-dword_4AAFB8];
          dword_4AAF88 = 1;
          byte_4AAFA0 = *v116;
          *v116 = 0;
          dword_4AAF94 = (int)v116;
        }
        return 309;
      case 131:
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
        }
        *(_DWORD *)a1 = *v1;
        return *::String;
      case 132:
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
        }
        *(_DWORD *)a1 = *v1;
        sub_468AE0(1);
        *v2 = byte_4AAFA0;
        v117 = &v4[-dword_4AAFB8 + 1];
        dword_4AAF94 = (int)v117;
        ::String = &v4[-dword_4AAFB8];
        dword_4AAF88 = 1;
        byte_4AAFA0 = *v117;
        *v117 = 0;
        dword_4AAF94 = (int)v117;
        return 360;
      case 133:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        *(_DWORD *)a1 = 39;
        return 309;
      case 134:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        *(_DWORD *)a1 = 92;
        return 309;
      case 135:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        *(_DWORD *)a1 = 34;
        return 309;
      case 136:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        *(_DWORD *)a1 = 96;
        return 309;
      case 137:
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
        }
        v118 = strtol(v1 + 1, 0, 8);
        goto LABEL_613;
      case 138:
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
        }
        v118 = strtol(v1 + 2, 0, 16);
LABEL_613:
        *(_DWORD *)a1 = v118;
        return 309;
      case 139:
        v119 = dword_4AAF88;
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
          v119 = dword_4AAF88;
        }
        v118 = v1[1];
        switch ( v1[1] )
        {
          case '$':
            goto LABEL_613;
          case '\\':
            *(_DWORD *)a1 = 92;
            result = 309;
            break;
          case 'n':
            *(_DWORD *)a1 = 10;
            result = 309;
            break;
          case 'r':
            *(_DWORD *)a1 = 13;
            result = 309;
            break;
          case 't':
            *(_DWORD *)a1 = 9;
            result = 309;
            break;
          case '{':
            *(_DWORD *)a1 = v118;
            result = 309;
            break;
          default:
            *(_DWORD *)a1 = estrndup(v1, v119);
            *(_DWORD *)(a1 + 4) = dword_4AAF88;
            *(_BYTE *)(a1 + 8) = 3;
            result = 310;
            break;
        }
        return result;
      case 141:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        dword_4AAF9C = 3;
        return 34;
      case 142:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        dword_4AAF9C = 3;
        return 96;
      case 143:
        if ( (int)dword_4AAF88 > 0 )
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
        dword_4AAF9C = 3;
        return 39;
      case 144:
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
        }
        v122 = (dword_4AAF9C - 1) / 2;
        v121 = *v1;
        v21 = (char *)sub_473493((int)&unk_4877D4);
        zend_error(128, v21, v121, v121, v122);
        goto LABEL_11;
      case 145:
        v22 = dword_4AAF88;
        if ( (int)dword_4AAF88 > 0 )
        {
          *(_DWORD *)(dword_4AAF90 + 28) = v1[dword_4AAF88 - 1] == 10;
          v1 = ::String;
          v22 = dword_4AAF88;
        }
        zend_write(v1, v22);
        goto LABEL_11;
      case 146:
        *v2 = byte_4AAFA0;
        v11 = dword_4AAF90;
        v12 = v2 - v1 - 1;
        if ( !*(_DWORD *)(dword_4AAF90 + 36) )
        {
          dword_4AAFA4 = *(_DWORD *)(dword_4AAF90 + 16);
          *(_DWORD *)dword_4AAF90 = language_scanner_globals;
          *(_DWORD *)(dword_4AAF90 + 36) = 1;
          v11 = dword_4AAF90;
        }
        if ( dword_4AAF94 <= (unsigned int)(dword_4AAFA4 + *(_DWORD *)(v11 + 4)) )
        {
          dword_4AAF94 = (int)&::String[v12];
          v3 = sub_4687C0();
          v16 = sub_468720(v3);
          v2 = (char *)dword_4AAF94;
          v4 = &::String[dword_4AAFB8];
          if ( !v16 )
            goto LABEL_22;
          v2 = (char *)++dword_4AAF94;
          v3 = v16;
          goto LABEL_15;
        }
        v13 = sub_468D10();
        if ( !v13 )
        {
          dword_4AAF94 = (int)&::String[v12];
          v17 = sub_4687C0();
          v2 = (char *)dword_4AAF94;
          v3 = v17;
          v4 = &::String[dword_4AAFB8];
          goto LABEL_15;
        }
        v14 = v13 - 1;
        if ( !v14 )
        {
          v1 = ::String;
          dword_4AAF94 = (int)&::String[dword_4AAFB8];
          dword_4AAFA8 = 0;
          v10 = (dword_4AAF9C - 1) / 2 + 147;
          goto LABEL_26;
        }
        if ( v14 == 1 )
        {
          dword_4AAF94 = dword_4AAFA4 + *(_DWORD *)(dword_4AAF90 + 4);
          v15 = sub_4687C0();
          v2 = (char *)dword_4AAF94;
          v3 = v15;
          v4 = &::String[dword_4AAFB8];
          goto LABEL_22;
        }
        goto LABEL_11;
      case 147:
      case 148:
      case 149:
      case 150:
      case 151:
      case 152:
      case 153:
      case 154:
      case 156:
        return 0;
      case 155:
        v124 = *(_DWORD *)dword_4AB360;
        v120 = (char *)sub_473493((int)&unk_4877AC);
        zend_error(128, v120, v124);
        return 0;
      default:
        v23 = (char *)sub_473493((int)&unk_487810);
        sub_468A90(v23);
        goto LABEL_11;
    }
    break;
  }
  while ( 1 )
  {
    v96 = *v95;
    if ( *v95 == 92 )
    {
      if ( (unsigned int)++v95 >= v94 )
        goto LABEL_522;
      v97 = *v95;
      if ( *v95 == 39 || v97 == 92 )
      {
        *v93++ = v97;
        --*(_DWORD *)(a1 + 4);
        goto LABEL_521;
      }
      *v93 = 92;
      v96 = *v95;
      ++v93;
    }
    *v93++ = v96;
LABEL_521:
    if ( (unsigned int)++v95 >= v94 )
    {
LABEL_522:
      *v93 = 0;
      return 312;
    }
  }
}
// 49A330: using guessed type __int16 word_49A330[1352];
// 49B2C0: using guessed type __int16 word_49B2C0[1772];
// 49C098: using guessed type __int16 word_49C098[];
// 49CE70: using guessed type __int16 word_49CE70[8000];
// 4A0CF0: using guessed type __int16 word_4A0CF0[];
// 4A9CF0: using guessed type int dword_4A9CF0;
// 4AAEE4: using guessed type int (__cdecl *zend_write)(_DWORD, _DWORD);
// 4AAF84: using guessed type int dword_4AAF84;
// 4AAF90: using guessed type int dword_4AAF90;
// 4AAF94: using guessed type int dword_4AAF94;
// 4AAF98: using guessed type int dword_4AAF98;
// 4AAF9C: using guessed type int dword_4AAF9C;
// 4AAFA0: using guessed type char byte_4AAFA0;
// 4AAFA4: using guessed type int dword_4AAFA4;
// 4AAFA8: using guessed type int dword_4AAFA8;
// 4AAFAC: using guessed type int dword_4AAFAC;
// 4AAFB0: using guessed type int dword_4AAFB0;
// 4AAFB4: using guessed type int dword_4AAFB4;
// 4AAFB8: using guessed type int dword_4AAFB8;
// 4AB2F4: using guessed type int dword_4AB2F4;
// 4AB35C: using guessed type int dword_4AB35C;
// 4AB364: using guessed type int dword_4AB364;
// 4AB368: using guessed type int dword_4AB368;
// 4AB36C: using guessed type int dword_4AB36C;
// 4AB3A5: using guessed type char byte_4AB3A5;
// 4AB3A6: using guessed type char byte_4AB3A6;

//----- (0046B9C0) --------------------------------------------------------
int __cdecl zend_prepare_string_for_scanning(int *a1, char *String)
{
  _DWORD *v2; // eax
  size_t v4; // [esp-8h] [ebp-10h]

  if ( (char (*)[4])*a1 == empty_string )
  {
    v2 = emalloc(a1[1] + 2);
    v4 = a1[1] + 2;
    *a1 = (int)v2;
    memset(v2, 0, v4);
  }
  else
  {
    *a1 = (int)erealloc(*a1, a1[1] + 2, 0);
  }
  *(_BYTE *)(a1[1] + *a1 + 1) = 0;
  language_scanner_globals = 0;
  sub_468B60(*a1, a1[1] + 2);
  zend_set_compiled_filename(String);
  dword_4AB35C = 1;
  byte_4AB3E0 = 0;
  return 0;
}
// 4954CC: using guessed type char (*empty_string)[4];
// 4AB35C: using guessed type int dword_4AB35C;
// 4AB3E0: using guessed type char byte_4AB3E0;

//----- (0046BA50) --------------------------------------------------------
int __cdecl compile_filename(int a1, int *a2)
{
  int *v2; // edi
  int v3; // eax
  int v4; // edx
  int v5; // eax
  int v6; // esi
  size_t Src; // [esp+8h] [ebp-30h] BYREF
  int v9; // [esp+Ch] [ebp-2Ch]
  int v10[5]; // [esp+10h] [ebp-28h] BYREF
  char v11[4]; // [esp+24h] [ebp-14h] BYREF
  int v12; // [esp+28h] [ebp-10h]
  char *String; // [esp+2Ch] [ebp-Ch]
  char v14; // [esp+34h] [ebp-4h]

  v2 = a2;
  if ( *((_BYTE *)a2 + 8) != 3 )
  {
    v3 = *a2;
    v4 = a2[2];
    v10[1] = a2[1];
    v10[0] = v3;
    v5 = a2[3];
    v10[2] = v4;
    v10[3] = v5;
    zval_copy_ctor((int)v10);
    convert_to_string((int)v10);
    v2 = v10;
  }
  v12 = *v2;
  v14 = 0;
  v11[0] = 0;
  String = 0;
  v6 = zend_compile_file(v11, a1);
  v9 = v6;
  if ( v6 && String )
  {
    Src = 1;
    zend_hash_add_or_update((int)&unk_4AB0C4, String, strlen(String) + 1, &Src, 4u, 0, 2);
    v6 = v9;
  }
  zend_destroy_file_handle((int)v11);
  if ( v2 == v10 )
    zval_dtor((int)v10);
  return v6;
}
// 4AAFBC: using guessed type int (__cdecl *zend_compile_file)(_DWORD, _DWORD);
// 46BA50: using guessed type char var_14[4];

//----- (0046BB40) --------------------------------------------------------
int __cdecl open_file_for_scanning(_DWORD *Src)
{
  FILE *v1; // eax
  FILE **v3; // eax
  char *v4; // eax

  if ( *(_BYTE *)Src )
  {
    if ( *(_BYTE *)Src != 1 )
      goto LABEL_6;
    v1 = _fdopen(Src[3], "r");
  }
  else
  {
    v1 = (FILE *)zend_fopen(Src[1], Src + 2);
  }
  Src[3] = v1;
LABEL_6:
  if ( !Src[3] )
    return -1;
  *(_BYTE *)Src = 2;
  if ( (void **)Src[3] != sub_44F01A() )
    zend_llist_add_element((int)&unk_4AB3BC, Src);
  language_scanner_globals = (FILE *)Src[3];
  v3 = sub_468BD0(language_scanner_globals);
  sub_4686D0(v3);
  dword_4AAF9C = 1;
  v4 = (char *)Src[2];
  if ( !v4 )
    v4 = (char *)Src[1];
  zend_set_compiled_filename(v4);
  byte_4AB3E0 = 0;
  return 0;
}
// 4AAEE0: using guessed type int (__cdecl *zend_fopen)(_DWORD, _DWORD);
// 4AAF9C: using guessed type int dword_4AAF9C;
// 4AB3E0: using guessed type char byte_4AB3E0;

//----- (0046BBE0) --------------------------------------------------------
int __cdecl highlight_string(int *a1, int a2, char *String)
{
  int v3; // edx
  int v4; // ecx
  int v5; // edx
  int result; // eax
  int v7[4]; // [esp+0h] [ebp-24h] BYREF
  _DWORD v8[5]; // [esp+10h] [ebp-14h] BYREF

  v3 = a1[1];
  v7[0] = *a1;
  v4 = a1[2];
  v7[1] = v3;
  v5 = a1[3];
  v7[2] = v4;
  v7[3] = v5;
  zval_copy_ctor((int)v7);
  zend_save_lexical_state(v8);
  result = zend_prepare_string_for_scanning(v7, String);
  if ( result != -1 )
  {
    zend_restore_lexical_state((int)v8);
    zval_dtor((int)v7);
    return 0;
  }
  return result;
}
// 46BBE0: using guessed type _DWORD var_14[5];

//----- (0046BC50) --------------------------------------------------------
int __cdecl highlight_file(int a1)
{
  _DWORD Src[4]; // [esp+4h] [ebp-28h] BYREF
  char v3; // [esp+14h] [ebp-18h]
  _DWORD v4[5]; // [esp+18h] [ebp-14h] BYREF

  LOBYTE(Src[0]) = 0;
  v3 = 0;
  Src[2] = 0;
  Src[1] = a1;
  zend_save_lexical_state(v4);
  if ( open_file_for_scanning(Src) == -1 )
  {
    zend_message_dispatcher();
    return -1;
  }
  else
  {
    zend_destroy_file_handle((int)Src);
    zend_restore_lexical_state((int)v4);
    return 0;
  }
}
// 46BC50: using guessed type _DWORD var_14[5];

//----- (0046BCC0) --------------------------------------------------------
int __cdecl compile_string(int *a1, char *String)
{
  _DWORD *v2; // eax
  int v3; // ebx
  int v4; // edi
  int result; // eax
  int v6; // edx
  int v7; // ecx
  int v8; // edx
  char v9; // [esp+Fh] [ebp-29h]
  int v10[5]; // [esp+10h] [ebp-28h] BYREF
  _DWORD v11[5]; // [esp+24h] [ebp-14h] BYREF

  v2 = emalloc(84);
  v3 = dword_4AB36C;
  v4 = (int)v2;
  v9 = byte_4AB3A4;
  if ( a1[1] )
  {
    byte_4AB3A4 = 1;
    v6 = a1[1];
    v10[0] = *a1;
    v7 = a1[2];
    v10[1] = v6;
    v8 = a1[3];
    v10[2] = v7;
    v10[3] = v8;
    zval_copy_ctor((int)v10);
    convert_to_string((int)v10);
    zend_save_lexical_state(v11);
    if ( zend_prepare_string_for_scanning(v10, String) == -1 )
    {
      efree(v4);
      v4 = 0;
    }
    else
    {
      init_op_array(v4, 4, 64);
      dword_4AB36C = v4;
      dword_4AAF9C = 3;
      if ( sub_465210() == 1 )
      {
        dword_4AB36C = v3;
        byte_4AB3BA = 1;
        v4 = 0;
      }
      else
      {
        sub_46FA60(0, 0);
        dword_4AB36C = v3;
        sub_40FA00(v4);
      }
      zend_restore_lexical_state((int)v11);
    }
    zval_dtor((int)v10);
    result = v4;
    byte_4AB3A4 = v9;
  }
  else
  {
    efree((int)v2);
    return 0;
  }
  return result;
}
// 4AAF9C: using guessed type int dword_4AAF9C;
// 4AB36C: using guessed type int dword_4AB36C;
// 4AB3A4: using guessed type char byte_4AB3A4;
// 4AB3BA: using guessed type char byte_4AB3BA;
// 46BCC0: using guessed type _DWORD var_14[5];

//----- (0046BDF0) --------------------------------------------------------
_DWORD *__cdecl compile_file(_DWORD *Src, int a2)
{
  _DWORD *v2; // edi
  char v3; // bl
  char v5; // [esp+Fh] [ebp-39h]
  _DWORD *v6; // [esp+10h] [ebp-38h]
  int v7; // [esp+14h] [ebp-34h]
  int v8; // [esp+18h] [ebp-30h]
  _DWORD v9[5]; // [esp+1Ch] [ebp-2Ch] BYREF
  int v10[4]; // [esp+30h] [ebp-18h] BYREF
  char v11; // [esp+40h] [ebp-8h]
  char v12; // [esp+41h] [ebp-7h]
  __int16 v13; // [esp+42h] [ebp-6h]

  v2 = emalloc(84);
  v3 = 1;
  v8 = dword_4AB36C;
  v5 = byte_4AB3A4;
  v10[0] = 1;
  v11 = 1;
  v10[2] = 1;
  v12 = 0;
  v13 = 1;
  zend_save_lexical_state(v9);
  v6 = v2;
  if ( open_file_for_scanning(Src) == -1 )
  {
    if ( a2 == 8 )
    {
      zend_message_dispatcher();
      zend_bailout((int)byte_47627C, 0);
    }
    zend_message_dispatcher();
    v3 = 0;
  }
  else
  {
    init_op_array((int)v2, 2, 64);
    byte_4AB3A4 = 1;
    dword_4AB36C = (int)v2;
    v7 = sub_465210();
    sub_46FA60(v10, 0);
    byte_4AB3A4 = v5;
    if ( v7 == 1 )
    {
      byte_4AB3BA = 1;
      v6 = 0;
    }
  }
  if ( v6 )
  {
    dword_4AB36C = v8;
    if ( !v3 )
    {
      efree((int)v2);
      return 0;
    }
    sub_40FA00((int)v2);
  }
  if ( v3 )
    zend_restore_lexical_state((int)v9);
  return v6;
}
// 4AB36C: using guessed type int dword_4AB36C;
// 4AB3A4: using guessed type char byte_4AB3A4;
// 4AB3BA: using guessed type char byte_4AB3BA;
// 46BDF0: using guessed type _DWORD var_2C[5];

//----- (0046BF30) --------------------------------------------------------
bool __thiscall sub_46BF30(_DWORD **this)
{
  _DWORD **v1; // ecx
  _DWORD *i; // eax
  _DWORD **v4; // [esp+0h] [ebp-4h] BYREF

  v4 = this;
  zend_stack_top(compiler_globals, &v4);
  v1 = (_DWORD **)*v4;
  for ( i = (_DWORD *)**v4; i; i = (_DWORD *)*i )
    v1 = (_DWORD **)i;
  return *((_BYTE *)v1 + 8) == 85;
}
// 4AB240: using guessed type _DWORD compiler_globals[3];

//----- (0046BF70) --------------------------------------------------------
int __thiscall sub_46BF70(_DWORD *this)
{
  int result; // eax

  result = this[7];
  this[7] = result + 1;
  return result;
}

//----- (0046BF80) --------------------------------------------------------
char zend_is_compiling()
{
  return byte_4AB3A4;
}
// 4AB3A4: using guessed type char byte_4AB3A4;

//----- (0046BF90) --------------------------------------------------------
int zend_get_compiled_lineno()
{
  return dword_4AB35C;
}
// 4AB35C: using guessed type int dword_4AB35C;

//----- (0046BFA0) --------------------------------------------------------
int zend_get_compiled_filename()
{
  return dword_4AB358;
}
// 4AB358: using guessed type int dword_4AB358;

//----- (0046BFB0) --------------------------------------------------------
int __cdecl zend_restore_compiled_filename(int a1)
{
  int result; // eax

  result = a1;
  dword_4AB358 = a1;
  return result;
}
// 4AB358: using guessed type int dword_4AB358;

//----- (0046BFE0) --------------------------------------------------------
int sub_46BFE0()
{
  int result; // eax
  int v1; // ecx
  int v2; // esi
  bool v3; // zf
  _BYTE *v4; // ecx

  result = 88 * *(_DWORD *)(dword_4AB36C + 20) + *(_DWORD *)(dword_4AB36C + 16) - 88;
  if ( *(_BYTE *)result == 55 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 64) + (*(_DWORD *)(result + 68))-- - 1) = 0;
    v1 = *(_DWORD *)(result + 68);
    if ( v1 > 0 )
    {
      v2 = *(_DWORD *)(result + 64);
      v3 = *(_BYTE *)(v2 + v1 - 1) == 13;
      v4 = (_BYTE *)(v2 + v1 - 1);
      if ( v3 )
      {
        *v4 = 0;
        --*(_DWORD *)(result + 68);
      }
    }
  }
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046C030) --------------------------------------------------------
int __cdecl sub_46C030(int a1)
{
  int *v1; // ecx
  int result; // eax
  int *v3; // [esp+0h] [ebp-4h] BYREF

  v3 = v1;
  zend_stack_top(dword_4AB270, &v3);
  result = *(_DWORD *)(dword_4AB36C + 20) - (dword_4AB3A8 != 0) - *(_DWORD *)(a1 + 8);
  if ( result )
  {
    dword_4AB3A8 = *v3;
    dword_4AB3AC = v3[1];
    dword_4AB3B0 = v3[2];
    result = v3[3];
    dword_4AB3B4 = result;
  }
  return result;
}
// 46C030: variable 'v1' is possibly undefined
// 4AB270: using guessed type _DWORD dword_4AB270[3];
// 4AB36C: using guessed type int dword_4AB36C;
// 4AB3A8: using guessed type int dword_4AB3A8;
// 4AB3AC: using guessed type int dword_4AB3AC;
// 4AB3B0: using guessed type int dword_4AB3B0;
// 4AB3B4: using guessed type int dword_4AB3B4;

//----- (0046C090) --------------------------------------------------------
char sub_46C090()
{
  int v0; // edx
  int v1; // ecx
  char result; // al
  _BYTE *v3; // ecx
  bool v4; // cf

  v0 = *(_DWORD *)(dword_4AB36C + 16);
  v1 = 88 * *(_DWORD *)(dword_4AB36C + 20);
  result = *(_BYTE *)(v1 + v0 - 88);
  v3 = (_BYTE *)(v1 + v0 - 88);
  if ( result == 95 )
  {
    *v3 = 74;
  }
  else
  {
    v4 = result == 96;
    result -= 96;
    if ( v4 || result == 1 )
      *v3 = 75;
  }
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046C0C0) --------------------------------------------------------
int sub_46C0C0()
{
  int result; // eax

  zend_llist_remove_tail((int)&unk_4AB324);
  result = dword_4AB328;
  ++*(_DWORD *)(dword_4AB328 + 8);
  return result;
}
// 4AB328: using guessed type int dword_4AB328;

//----- (0046C0E0) --------------------------------------------------------
int __usercall sub_46C0E0@<eax>(_DWORD *a1@<ecx>, _DWORD *a2@<esi>)
{
  _DWORD *v2; // eax
  int v3; // edx
  int v4; // ecx
  int v5; // edx
  int v6; // ecx
  int v7; // edx
  _DWORD *v9; // [esp+0h] [ebp-4h] BYREF

  v9 = a1;
  zend_stack_top(dword_4AB264, &v9);
  v2 = v9;
  v3 = v9[1];
  *a2 = *v9;
  v4 = v2[2];
  a2[1] = v3;
  v5 = v2[3];
  a2[2] = v4;
  v6 = v2[4];
  a2[3] = v5;
  v7 = v2[5];
  a2[4] = v6;
  a2[5] = v7;
  return zend_stack_del_top(dword_4AB264);
}
// 4AB264: using guessed type _DWORD dword_4AB264[3];

//----- (0046C130) --------------------------------------------------------
int sub_46C130()
{
  int v0; // esi
  int v1; // ecx
  _DWORD *v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+4h] [ebp-4h] BYREF

  v0 = *(_DWORD *)(dword_4AB36C + 20);
  zend_stack_top(compiler_globals, &v4);
  v1 = (int)v4;
  v2 = (_DWORD *)*v4;
  if ( *v4 )
  {
    do
    {
      *(_DWORD *)(88 * v2[2] + *(_DWORD *)(dword_4AB36C + 16) + 40) = v0;
      v2 = (_DWORD *)*v2;
    }
    while ( v2 );
  }
  zend_llist_destroy(v1);
  result = zend_stack_del_top(compiler_globals);
  if ( dword_4AB3DC )
  {
    result = dword_4AB36C;
    --*(_DWORD *)(dword_4AB36C + 56);
  }
  return result;
}
// 4AB240: using guessed type _DWORD compiler_globals[3];
// 4AB36C: using guessed type int dword_4AB36C;
// 4AB3DC: using guessed type int dword_4AB3DC;

//----- (0046C1B0) --------------------------------------------------------
int __fastcall sub_46C1B0(int a1, int a2)
{
  int result; // eax

  *(_DWORD *)(*(_DWORD *)(dword_4AB36C + 32) + 12 * *(_DWORD *)(dword_4AB36C + 40)) = a2;
  *(_DWORD *)(*(_DWORD *)(dword_4AB36C + 32) + 12 * *(_DWORD *)(dword_4AB36C + 40) + 4) = *(_DWORD *)(dword_4AB36C + 20);
  result = dword_4AB36C;
  *(_DWORD *)(dword_4AB36C + 40) = *(_DWORD *)(*(_DWORD *)(dword_4AB36C + 32) + 12 * *(_DWORD *)(dword_4AB36C + 40) + 8);
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046C1F0) --------------------------------------------------------
char __usercall sub_46C1F0@<al>(int a1@<esi>)
{
  int v1; // eax
  _DWORD *v2; // ecx
  char v3; // dl
  _BYTE *v4; // ecx

  LOBYTE(v1) = dword_4AB36C;
  if ( !*(_BYTE *)(dword_4AB36C + 44) && *(_DWORD *)a1 == 1 && *(_BYTE *)(a1 + 16) == 3 && *(_DWORD *)(a1 + 12) == 7 )
  {
    v1 = sub_473493((int)&unk_4873C8);
    v2 = *(_DWORD **)(a1 + 8);
    if ( *v2 == *(_DWORD *)v1 )
    {
      v3 = *(_BYTE *)(v1 + 4);
      v1 += 4;
      v4 = v2 + 1;
      if ( v3 == *v4 && *(_BYTE *)(v1 + 1) == v4[1] )
      {
        LOBYTE(v1) = *(_BYTE *)(v1 + 2);
        if ( (_BYTE)v1 == v4[2] )
          *(_BYTE *)(dword_4AB36C + 44) = 1;
      }
    }
  }
  return v1;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046C250) --------------------------------------------------------
void *sub_46C250()
{
  int Src; // [esp+0h] [ebp-4h] BYREF

  Src = 0;
  return zend_llist_add_element((int)&unk_4AB324, &Src);
}

//----- (0046C270) --------------------------------------------------------
void *__usercall sub_46C270@<eax>(_DWORD *a1@<ebx>, int *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // ecx
  int v5; // edx
  int v6; // ecx
  int v7; // edx
  int v8; // ecx
  int v9; // edx
  int v10; // ecx
  int v11; // ecx
  int v12; // ecx
  int v14; // [esp+4h] [ebp-60h] BYREF
  char Src[8]; // [esp+8h] [ebp-5Ch] BYREF
  int v16; // [esp+10h] [ebp-54h]
  int v17; // [esp+14h] [ebp-50h]
  int v18; // [esp+18h] [ebp-4Ch]
  int v19; // [esp+1Ch] [ebp-48h]
  int v20; // [esp+20h] [ebp-44h]
  int v21; // [esp+24h] [ebp-40h]
  int v22; // [esp+28h] [ebp-3Ch]
  int v23; // [esp+2Ch] [ebp-38h]
  int v24; // [esp+30h] [ebp-34h]
  int v25; // [esp+34h] [ebp-30h]
  int v26; // [esp+38h] [ebp-2Ch]
  int v27; // [esp+3Ch] [ebp-28h]
  int v28; // [esp+40h] [ebp-24h]
  int v29; // [esp+44h] [ebp-20h]
  int v30; // [esp+48h] [ebp-1Ch]
  int v31; // [esp+4Ch] [ebp-18h]
  int v32; // [esp+50h] [ebp-14h]
  int v33; // [esp+54h] [ebp-10h]
  int v34; // [esp+58h] [ebp-Ch]
  int v35; // [esp+5Ch] [ebp-8h]

  v35 = dword_4AB35C;
  v17 = 0;
  v18 = 0;
  v20 = 0;
  v21 = 0;
  v34 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  Src[0] = 85;
  v16 = 4;
  v19 = 0;
  v3 = sub_46BF70((_DWORD *)dword_4AB36C);
  v4 = a2[1];
  v22 = *a2;
  v24 = a2[2];
  v26 = a2[4];
  v5 = *a3;
  v23 = v4;
  v6 = a2[3];
  v28 = v5;
  v7 = a3[2];
  v25 = v6;
  v8 = a2[5];
  v30 = v7;
  v9 = a3[4];
  v27 = v8;
  v10 = a3[1];
  v32 = v9;
  *a1 = 4;
  a1[1] = 0;
  a1[2] = v3;
  v29 = v10;
  v11 = a3[3];
  v18 = v3;
  v31 = v11;
  v12 = a3[5];
  a1[3] = 0;
  v33 = v12;
  a1[4] = 0;
  a1[5] = 0;
  zend_stack_top(compiler_globals, &v14);
  return zend_llist_add_element(v14, Src);
}
// 4AB240: using guessed type _DWORD compiler_globals[3];
// 4AB35C: using guessed type int dword_4AB35C;
// 4AB36C: using guessed type int dword_4AB36C;
// 46C270: using guessed type char Src[8];

//----- (0046C390) --------------------------------------------------------
void *__usercall sub_46C390@<eax>(_DWORD *a1@<ebx>, int *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // ecx
  int v5; // edx
  int v6; // ecx
  int v7; // edx
  int v8; // ecx
  int v9; // edx
  int v10; // ecx
  int v11; // edx
  int v12; // ecx
  int v13; // ecx
  int v15; // [esp+4h] [ebp-60h] BYREF
  char Src[8]; // [esp+8h] [ebp-5Ch] BYREF
  int v17; // [esp+10h] [ebp-54h]
  int v18; // [esp+14h] [ebp-50h]
  int v19; // [esp+18h] [ebp-4Ch]
  int v20; // [esp+1Ch] [ebp-48h]
  int v21; // [esp+20h] [ebp-44h]
  int v22; // [esp+24h] [ebp-40h]
  int v23; // [esp+28h] [ebp-3Ch]
  int v24; // [esp+2Ch] [ebp-38h]
  int v25; // [esp+30h] [ebp-34h]
  int v26; // [esp+34h] [ebp-30h]
  int v27; // [esp+38h] [ebp-2Ch]
  int v28; // [esp+3Ch] [ebp-28h]
  int v29; // [esp+40h] [ebp-24h]
  int v30; // [esp+44h] [ebp-20h]
  int v31; // [esp+48h] [ebp-1Ch]
  int v32; // [esp+4Ch] [ebp-18h]
  int v33; // [esp+50h] [ebp-14h]
  int v34; // [esp+54h] [ebp-10h]
  int v35; // [esp+58h] [ebp-Ch]
  int v36; // [esp+5Ch] [ebp-8h]

  v36 = dword_4AB35C;
  v18 = 0;
  v19 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  Src[0] = 84;
  v17 = 4;
  v20 = 0;
  v3 = sub_46BF70((_DWORD *)dword_4AB36C);
  v4 = a2[1];
  v23 = *a2;
  v25 = a2[2];
  v5 = a2[4];
  v24 = v4;
  v6 = a2[3];
  v27 = v5;
  v7 = *a3;
  v26 = v6;
  v8 = a2[5];
  v29 = v7;
  v9 = a3[2];
  v28 = v8;
  v10 = a3[1];
  v31 = v9;
  v11 = a3[4];
  v30 = v10;
  v12 = a3[3];
  v33 = v11;
  v32 = v12;
  v13 = a3[5];
  *a1 = 4;
  a1[1] = 0;
  a1[2] = v3;
  v19 = v3;
  a1[3] = 0;
  v34 = v13;
  a1[4] = 0;
  v35 = 0;
  a1[5] = 0;
  zend_stack_top(compiler_globals, &v15);
  return zend_llist_add_element(v15, Src);
}
// 4AB240: using guessed type _DWORD compiler_globals[3];
// 4AB35C: using guessed type int dword_4AB35C;
// 4AB36C: using guessed type int dword_4AB36C;
// 46C390: using guessed type char Src[8];

//----- (0046C4B0) --------------------------------------------------------
int sub_46C4B0()
{
  int result; // eax

  zend_stack_init(compiler_globals);
  zend_stack_init(dword_4AB34C);
  zend_stack_init(dword_4AB24C);
  zend_stack_init(dword_4AB258);
  zend_stack_init(dword_4AB264);
  zend_stack_init(dword_4AB270);
  dword_4AB2F4 = 0;
  dword_4AB2F8 = 0;
  zend_llist_init((int)&dword_4AB308, 80, 0, 0);
  zend_llist_init((int)&unk_4AB324, 4, 0, 0);
  result = zend_stack_init(dword_4AB340);
  byte_4AB3B9 = 1;
  byte_4AB3A4 = 0;
  LOBYTE(dword_4AB3B0) = 1;
  dword_4AB3A8 = 0;
  return result;
}
// 4AB240: using guessed type _DWORD compiler_globals[3];
// 4AB24C: using guessed type _DWORD dword_4AB24C[3];
// 4AB258: using guessed type _DWORD dword_4AB258[3];
// 4AB264: using guessed type _DWORD dword_4AB264[3];
// 4AB270: using guessed type _DWORD dword_4AB270[3];
// 4AB2F4: using guessed type int dword_4AB2F4;
// 4AB308: using guessed type int dword_4AB308;
// 4AB340: using guessed type _DWORD dword_4AB340[3];
// 4AB34C: using guessed type _DWORD dword_4AB34C[3];
// 4AB3A4: using guessed type char byte_4AB3A4;
// 4AB3A8: using guessed type int dword_4AB3A8;
// 4AB3B0: using guessed type int dword_4AB3B0;
// 4AB3B9: using guessed type char byte_4AB3B9;

//----- (0046C540) --------------------------------------------------------
int __usercall sub_46C540@<eax>(int *a1@<edi>, int a2@<esi>, int a3)
{
  int v3; // eax
  const char *v4; // ebx
  unsigned int v5; // eax
  const char *v6; // eax
  int result; // eax
  int v8; // [esp-Ch] [ebp-38h]
  char Buffer[32]; // [esp+8h] [ebp-24h] BYREF

  v3 = sprintf(Buffer, "%d", *(_DWORD *)(a3 + 84));
  v4 = *(const char **)(dword_4AB36C + 64);
  if ( !v4 )
    v4 = (const char *)&unk_4790E4;
  v5 = strlen(v4) + a1[1] + v3 + 1;
  *(_DWORD *)(a2 + 4) = v5;
  *(_DWORD *)a2 = emalloc(v5 + 1);
  v8 = *a1;
  v6 = (const char *)sub_473493((int)&unk_4873BC);
  sprintf(*(char *const *)a2, v6, 0, v8, v4, Buffer);
  result = 1;
  *(_BYTE *)(a2 + 8) = 3;
  *(_WORD *)(a2 + 10) = 1;
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046C5F0) --------------------------------------------------------
int sub_46C5F0()
{
  return zend_stack_push(dword_4AB270, &dword_4AB3A8, 0x10u);
}
// 4AB270: using guessed type _DWORD dword_4AB270[3];
// 4AB3A8: using guessed type int dword_4AB3A8;

//----- (0046C610) --------------------------------------------------------
void *sub_46C610()
{
  zend_stack_push(dword_4AB340, &dword_4AB308, 0x1Cu);
  zend_stack_push(dword_4AB340, &unk_4AB324, 0x1Cu);
  zend_llist_init((int)&dword_4AB308, 80, 0, 0);
  zend_llist_init((int)&unk_4AB324, 4, 0, 0);
  return sub_46C250();
}
// 4AB308: using guessed type int dword_4AB308;
// 4AB340: using guessed type _DWORD dword_4AB340[3];

//----- (0046C660) --------------------------------------------------------
int __usercall sub_46C660@<eax>(int *a1@<eax>)
{
  int v1; // edx
  int v2; // ecx
  int v3; // edx
  int v4; // ecx
  int v5; // edx
  int result; // eax
  int Src[6]; // [esp+0h] [ebp-54h] BYREF
  char v8[60]; // [esp+18h] [ebp-3Ch] BYREF

  if ( a1 )
  {
    v1 = a1[1];
    Src[0] = *a1;
    v2 = a1[2];
    Src[1] = v1;
    v3 = a1[3];
    Src[2] = v2;
    v4 = a1[4];
    Src[3] = v3;
    v5 = a1[5];
    Src[4] = v4;
    Src[5] = v5;
    zend_llist_copy((int)v8, (int)&unk_4AB324);
    zend_llist_prepend_element((int)&dword_4AB308, Src);
  }
  result = dword_4AB328;
  ++*(_DWORD *)(dword_4AB328 + 8);
  return result;
}
// 4AB308: using guessed type int dword_4AB308;
// 4AB328: using guessed type int dword_4AB328;
// 46C660: using guessed type char var_3C[60];

//----- (0046C6C0) --------------------------------------------------------
char __usercall sub_46C6C0@<al>(_DWORD *a1@<eax>, int a2@<ebx>, int a3@<esi>)
{
  _DWORD *v4; // eax
  int v5; // edx
  _DWORD *Src; // [esp+4h] [ebp-4h] BYREF

  v4 = emalloc(16);
  *v4 = a1[2];
  v4[1] = a1[3];
  v4[2] = a1[4];
  v5 = a1[5];
  Src = v4;
  v4[3] = v5;
  if ( !a3 )
  {
    LOBYTE(v4) = zend_hash_index_update_or_next_insert(*(_DWORD *)(a2 + 8), 0, &Src, 4u, 0, 4);
    return (char)v4;
  }
  switch ( *(_BYTE *)(a3 + 16) )
  {
    case 1:
      LOBYTE(v4) = zend_hash_index_update_or_next_insert(*(_DWORD *)(a2 + 8), *(_DWORD *)(a3 + 8), &Src, 4u, 0, 1);
      return (char)v4;
    case 3:
      goto LABEL_6;
    case 8:
      *((_BYTE *)v4 + 8) |= 0x80u;
LABEL_6:
      zend_hash_add_or_update(
        *(_DWORD *)(a2 + 8),
        *(char **)(a3 + 8),
        *(_DWORD *)(a3 + 12) + 1,
        (size_t *)&Src,
        4u,
        0,
        1);
      LOBYTE(v4) = zval_dtor(a3 + 8);
      break;
  }
  return (char)v4;
}

//----- (0046C770) --------------------------------------------------------
int __usercall sub_46C770@<eax>(void *a1@<eax>)
{
  return zend_stack_push(dword_4AB264, a1, 0x18u);
}
// 4AB264: using guessed type _DWORD dword_4AB264[3];

//----- (0046C790) --------------------------------------------------------
char __usercall sub_46C790@<al>(_DWORD *a1@<eax>, int a2@<edi>)
{
  _DWORD *v3; // eax
  _DWORD *Src; // [esp+4h] [ebp-4h] BYREF

  v3 = emalloc(16);
  Src = v3;
  if ( a1 )
  {
    *v3 = a1[2];
    v3[1] = a1[3];
    v3[2] = a1[4];
    v3[3] = a1[5];
  }
  else
  {
    *((_WORD *)v3 + 5) = 1;
    *((_BYTE *)v3 + 9) = 0;
    *((_BYTE *)v3 + 8) = 0;
  }
  zend_hash_add_or_update(dword_4AB2F4 + 64, *(char **)(a2 + 8), *(_DWORD *)(a2 + 12) + 1, (size_t *)&Src, 4u, 0, 1);
  return zval_dtor(a2 + 8);
}
// 4AB2F4: using guessed type int dword_4AB2F4;

//----- (0046C800) --------------------------------------------------------
int sub_46C800()
{
  char Src[28]; // [esp+0h] [ebp-1Ch] BYREF

  zend_llist_init((int)Src, 88, 0, 0);
  return zend_stack_push(compiler_globals, Src, 0x1Cu);
}
// 4AB240: using guessed type _DWORD compiler_globals[3];

//----- (0046C830) --------------------------------------------------------
_DWORD *sub_46C830()
{
  int v0; // ebx
  int v1; // edi
  _DWORD *result; // eax
  int v3; // esi

  v0 = *(_DWORD *)(dword_4AB36C + 40);
  *(_DWORD *)(dword_4AB36C + 40) = *(_DWORD *)(dword_4AB36C + 36);
  v1 = dword_4AB36C;
  ++*(_DWORD *)(dword_4AB36C + 36);
  result = erealloc(*(_DWORD *)(v1 + 32), 12 * *(_DWORD *)(v1 + 36), 0);
  v3 = *(_DWORD *)(v1 + 36);
  *(_DWORD *)(v1 + 32) = result;
  result[3 * v3 - 1] = v0;
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046C880) --------------------------------------------------------
void *__usercall sub_46C880@<eax>(_DWORD *a1@<ebx>, int *a2@<edi>, int *a3@<esi>)
{
  return sub_46C390(a1, a2, a3);
}

//----- (0046C890) --------------------------------------------------------
_DWORD *__cdecl zend_set_compiled_filename(char *String)
{
  size_t v1; // esi
  _DWORD *result; // eax
  int v3; // [esp+Ch] [ebp-8h] BYREF
  _DWORD *Src; // [esp+10h] [ebp-4h] BYREF

  v1 = strlen(String);
  if ( zend_hash_find((int)&unk_4AB378, String, v1 + 1, &v3) )
  {
    Src = estrndup(String, v1);
    zend_hash_add_or_update((int)&unk_4AB378, String, v1 + 1, (size_t *)&Src, 4u, &v3, 1);
    result = Src;
    dword_4AB358 = (int)Src;
  }
  else
  {
    dword_4AB358 = *(_DWORD *)v3;
    return *(_DWORD **)v3;
  }
  return result;
}
// 4AB358: using guessed type int dword_4AB358;

//----- (0046C920) --------------------------------------------------------
int sub_46C920()
{
  int result; // eax

  sub_46C4B0();
  zend_hash_init((int)&unk_4AB378, 5u, 0, (int)free_estring, 0);
  result = zend_llist_init((int)&unk_4AB3BC, 20, (int)zend_file_handle_dtor, 0);
  byte_4AB3BA = 0;
  return result;
}
// 4AB3BA: using guessed type char byte_4AB3BA;

//----- (0046C960) --------------------------------------------------------
int __cdecl sub_46C960(int a1)
{
  int v1; // edi
  char v2; // al
  int result; // eax

  if ( byte_4AB3E0 )
  {
    ++dword_4AB35C;
    byte_4AB3E0 = 0;
  }
  *(_BYTE *)(a1 + 16) = 1;
  v1 = lex_scan(a1 + 8);
  switch ( v1 )
  {
    case 351:
    case 353:
    case 356:
      v1 = sub_46C960(a1);
      break;
    case 354:
      v1 = 313;
      break;
    case 355:
      v2 = String[dword_4AAF88 - 1];
      if ( v2 == 10 || String[dword_4AAF88 - 2] == 13 && v2 )
        byte_4AB3E0 = 1;
      v1 = 59;
      break;
    case 358:
      efree(*(_DWORD *)(a1 + 8));
      break;
    default:
      break;
  }
  result = v1;
  *(_WORD *)(a1 + 18) = 1;
  *(_BYTE *)(a1 + 17) = 0;
  *(_DWORD *)a1 = 1;
  return result;
}
// 4AB35C: using guessed type int dword_4AB35C;
// 4AB3E0: using guessed type char byte_4AB3E0;

//----- (0046CA20) --------------------------------------------------------
int __usercall sub_46CA20@<eax>(char *String@<ecx>, int a2@<eax>)
{
  return zend_hash_add_empty_element(dword_4AB3A0, String, a2 + 1);
}

//----- (0046CA40) --------------------------------------------------------
void sub_46CA40()
{
  _DWORD *v0; // eax

  if ( dword_4AB3A8 )
  {
    v0 = sub_40F8F0((_DWORD *)dword_4AB36C);
    *(_BYTE *)v0 = 105;
    v0[10] = dword_4AB3A8;
    v0[11] = dword_4AB3AC;
    v0[12] = dword_4AB3B0;
    v0[13] = dword_4AB3B4;
    v0[8] = 1;
    v0[14] = 8;
  }
}
// 4AB36C: using guessed type int dword_4AB36C;
// 4AB3A8: using guessed type int dword_4AB3A8;
// 4AB3AC: using guessed type int dword_4AB3AC;
// 4AB3B0: using guessed type int dword_4AB3B0;
// 4AB3B4: using guessed type int dword_4AB3B4;

//----- (0046CA90) --------------------------------------------------------
void sub_46CA90()
{
  _DWORD *v0; // eax

  if ( byte_4AB3B8 )
  {
    v0 = sub_40F8F0((_DWORD *)dword_4AB36C);
    *(_BYTE *)v0 = 103;
    v0[8] = 8;
    v0[14] = 8;
  }
}
// 4AB36C: using guessed type int dword_4AB36C;
// 4AB3B8: using guessed type char byte_4AB3B8;

//----- (0046CAC0) --------------------------------------------------------
void sub_46CAC0()
{
  _DWORD *v0; // eax

  if ( byte_4AB3B8 )
  {
    v0 = sub_40F8F0((_DWORD *)dword_4AB36C);
    *(_BYTE *)v0 = 102;
    v0[8] = 8;
    v0[14] = 8;
  }
}
// 4AB36C: using guessed type int dword_4AB36C;
// 4AB3B8: using guessed type char byte_4AB3B8;

//----- (0046CAF0) --------------------------------------------------------
void sub_46CAF0()
{
  _DWORD *v0; // eax

  if ( byte_4AB3B8 )
  {
    v0 = sub_40F8F0((_DWORD *)dword_4AB36C);
    *(_BYTE *)v0 = 101;
    v0[8] = 8;
    v0[14] = 8;
  }
}
// 4AB36C: using guessed type int dword_4AB36C;
// 4AB3B8: using guessed type char byte_4AB3B8;

//----- (0046CB20) --------------------------------------------------------
int __usercall sub_46CB20@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<ebx>, _DWORD *a3, int a4)
{
  _DWORD *v5; // eax
  bool v6; // zf
  int v7; // ecx
  int v8; // edx
  int v9; // ecx
  int v10; // edx
  int result; // eax

  v5 = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)v5 = 22;
  v5[2] = *a1;
  v5[3] = a1[1];
  v5[4] = a1[2];
  v5[5] = a1[3];
  v5[6] = a1[4];
  v5[7] = a1[5];
  v5[8] = *a2;
  v5[9] = a2[1];
  v5[10] = a2[2];
  v5[11] = a2[3];
  v5[12] = a2[4];
  v5[13] = a2[5];
  v5[14] = 8;
  *(_DWORD *)(88 * *(_DWORD *)(a4 + 8) + *(_DWORD *)(dword_4AB36C + 16) + 40) = *(_DWORD *)(dword_4AB36C + 20);
  v6 = dword_4AB3DC == 0;
  v7 = v5[3];
  *a3 = v5[2];
  v8 = v5[4];
  a3[1] = v7;
  v9 = v5[5];
  a3[2] = v8;
  v10 = v5[6];
  result = v5[7];
  a3[3] = v9;
  a3[4] = v10;
  a3[5] = result;
  if ( !v6 )
  {
    result = dword_4AB36C;
    --*(_DWORD *)(dword_4AB36C + 56);
  }
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;
// 4AB3DC: using guessed type int dword_4AB3DC;

//----- (0046CBE0) --------------------------------------------------------
_DWORD *__usercall sub_46CBE0@<eax>(_DWORD *a1@<ebx>, _DWORD *a2, int a3)
{
  _DWORD *v3; // esi
  int v4; // ecx
  _DWORD *result; // eax

  v3 = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_DWORD *)(88 * a1[2] + *(_DWORD *)(dword_4AB36C + 16) + 64) = *(_DWORD *)(dword_4AB36C + 20) + 1;
  *(_BYTE *)v3 = 22;
  v3[2] = 2;
  v3[4] = sub_46BF70((_DWORD *)dword_4AB36C);
  v3[8] = *a2;
  v3[9] = a2[1];
  v3[10] = a2[2];
  v3[11] = a2[3];
  v4 = v3[2];
  v3[12] = a2[4];
  v3[13] = a2[5];
  v3[14] = 8;
  *a1 = v4;
  a1[1] = v3[3];
  a1[2] = v3[4];
  a1[3] = v3[5];
  a1[4] = v3[6];
  a1[5] = v3[7];
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(dword_4AB36C + 20);
  result = sub_40F8F0((_DWORD *)dword_4AB36C);
  result[8] = 8;
  result[14] = 8;
  *(_BYTE *)result = 42;
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046CCA0) --------------------------------------------------------
_DWORD *__usercall sub_46CCA0@<eax>(_DWORD *a1@<ebx>, _DWORD *a2@<esi>)
{
  int v2; // ebp
  _DWORD *result; // eax
  int v4; // edx
  int v5; // ecx

  v2 = *(_DWORD *)(dword_4AB36C + 20);
  result = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)result = 43;
  result[8] = *a1;
  result[9] = a1[1];
  result[10] = a1[2];
  result[11] = a1[3];
  result[12] = a1[4];
  v4 = a1[5];
  result[16] = v2;
  result[14] = 8;
  v5 = result[14];
  result[13] = v4;
  *a2 = v5;
  a2[1] = result[15];
  a2[2] = result[16];
  a2[3] = result[17];
  a2[4] = result[18];
  a2[5] = result[19];
  if ( dword_4AB3DC )
  {
    result = (_DWORD *)dword_4AB36C;
    ++*(_DWORD *)(dword_4AB36C + 56);
  }
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;
// 4AB3DC: using guessed type int dword_4AB3DC;

//----- (0046CD20) --------------------------------------------------------
_DWORD *__usercall sub_46CD20@<eax>(_DWORD *a1@<esi>)
{
  _DWORD *result; // eax

  result = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)result = 58;
  result[8] = *a1;
  result[9] = a1[1];
  result[10] = a1[2];
  result[11] = a1[3];
  result[12] = a1[4];
  result[13] = a1[5];
  result[14] = 8;
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046CD60) --------------------------------------------------------
int __usercall sub_46CD60@<eax>(_DWORD *a1@<ebx>)
{
  _DWORD *v1; // esi
  int result; // eax

  v1 = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)v1 = 57;
  v1[2] = 2;
  v1[4] = sub_46BF70((_DWORD *)dword_4AB36C);
  v1[8] = 8;
  v1[14] = 8;
  *a1 = v1[2];
  a1[1] = v1[3];
  a1[2] = v1[4];
  result = v1[5];
  a1[3] = result;
  a1[4] = v1[6];
  a1[5] = v1[7];
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046CDC0) --------------------------------------------------------
_DWORD *__usercall sub_46CDC0@<eax>(int a1@<ebx>, _DWORD *a2@<esi>)
{
  _DWORD *result; // eax

  result = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)result = 79;
  result[8] = *a2;
  result[9] = a2[1];
  result[10] = a2[2];
  result[11] = a2[3];
  result[12] = a2[4];
  result[13] = a2[5];
  result[14] = 8;
  *(_DWORD *)a1 = 1;
  *(_BYTE *)(a1 + 16) = 6;
  *(_DWORD *)(a1 + 8) = 1;
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046CE10) --------------------------------------------------------
char __usercall sub_46CE10@<al>(int a1@<eax>, _DWORD *a2)
{
  unsigned __int8 **v3; // edi
  unsigned __int8 *v4; // eax

  v3 = (unsigned __int8 **)(a1 + 8);
  convert_to_string(a1 + 8);
  v4 = (unsigned __int8 *)sub_473493((int)&unk_487720);
  if ( !zend_binary_strcasecmp(*v3, *(_DWORD *)(a1 + 12), v4, 5u) )
  {
    convert_to_long_base((int)(a2 + 2), 10);
    dword_4AB3A8 = a2[2];
    dword_4AB3AC = a2[3];
    dword_4AB3B0 = a2[4];
    dword_4AB3B4 = a2[5];
  }
  return zval_dtor((int)v3);
}
// 4AB3A8: using guessed type int dword_4AB3A8;
// 4AB3AC: using guessed type int dword_4AB3AC;
// 4AB3B0: using guessed type int dword_4AB3B0;
// 4AB3B4: using guessed type int dword_4AB3B4;

//----- (0046CE90) --------------------------------------------------------
int __usercall sub_46CE90@<eax>(_DWORD *a1@<ebx>, int a2, _DWORD *a3, _DWORD *a4, int a5)
{
  _DWORD *v5; // esi
  int v6; // ecx
  _DWORD *v7; // esi
  int v8; // ecx
  int result; // eax

  v5 = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)v5 = 77;
  v5[2] = 4;
  v5[4] = sub_46BF70((_DWORD *)dword_4AB36C);
  v5[8] = *a3;
  v5[9] = a3[1];
  v5[10] = a3[2];
  v5[11] = a3[3];
  v5[12] = a3[4];
  v6 = v5[2];
  v5[13] = a3[5];
  v5[14] = 8;
  v5[20] = a5 != 0;
  *a1 = v6;
  a1[1] = v5[3];
  a1[2] = v5[4];
  a1[3] = v5[5];
  a1[4] = v5[6];
  a1[5] = v5[7];
  zend_stack_push(dword_4AB258, v5 + 2, 0x18u);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(dword_4AB36C + 20);
  v7 = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)v7 = 78;
  v7[2] = 2;
  v7[4] = sub_46BF70((_DWORD *)dword_4AB36C);
  v7[8] = *a1;
  v7[9] = a1[1];
  v7[10] = a1[2];
  v7[11] = a1[3];
  v8 = v7[2];
  v7[12] = a1[4];
  v7[13] = a1[5];
  v7[14] = 8;
  *a4 = v8;
  a4[1] = v7[3];
  a4[2] = v7[4];
  a4[3] = v7[5];
  a4[4] = v7[6];
  result = v7[7];
  a4[5] = result;
  return result;
}
// 4AB258: using guessed type _DWORD dword_4AB258[3];
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046CFC0) --------------------------------------------------------
void __usercall sub_46CFC0(_DWORD *a1@<ebx>, int a2, _DWORD *a3)
{
  _DWORD *v3; // esi
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  int v7; // eax

  sub_46CAC0();
  v3 = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)v3 = 73;
  v3[2] = 4;
  v3[4] = sub_46BF70((_DWORD *)dword_4AB36C);
  v3[8] = *a1;
  v3[9] = a1[1];
  v3[10] = a1[2];
  v3[11] = a1[3];
  v3[12] = a1[4];
  v4 = a1[5];
  *a3 = v3[2];
  v5 = v3[5];
  v3[13] = v4;
  a3[1] = v3[3];
  v6 = v3[6];
  v3[16] = a2;
  a3[2] = v3[4];
  v7 = v3[7];
  a3[3] = v5;
  v3[14] = 8;
  a3[4] = v6;
  a3[5] = v7;
  sub_46CA90();
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046D050) --------------------------------------------------------
int __usercall sub_46D050@<eax>(_DWORD *a1@<ebx>, _DWORD *a2, int a3)
{
  _DWORD *v3; // esi
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  int result; // eax

  v3 = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)v3 = 21;
  v3[2] = 2;
  v3[4] = sub_46BF70((_DWORD *)dword_4AB36C);
  v3[8] = *a1;
  v3[9] = a1[1];
  v3[10] = a1[2];
  v3[11] = a1[3];
  v3[12] = a1[4];
  v4 = a1[5];
  *a2 = v3[2];
  v5 = v3[5];
  v3[13] = v4;
  a2[1] = v3[3];
  v6 = v3[6];
  v3[20] = a3;
  a2[2] = v3[4];
  result = v3[7];
  a2[3] = v5;
  v3[14] = 8;
  a2[4] = v6;
  a2[5] = result;
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046D0E0) --------------------------------------------------------
_DWORD *__usercall sub_46D0E0@<eax>(_DWORD *a1@<ebx>, _DWORD *a2@<esi>, _DWORD *a3, int a4)
{
  _DWORD *result; // eax
  int v5; // edx
  int v6; // ecx
  int v7; // edx
  int v8; // ecx
  int v9; // edx

  result = sub_40F8F0((_DWORD *)dword_4AB36C);
  v5 = a1[1];
  result[2] = *a1;
  v6 = a1[2];
  result[3] = v5;
  v7 = a1[3];
  result[4] = v6;
  v8 = a1[4];
  result[5] = v7;
  v9 = a1[5];
  result[6] = v8;
  *(_BYTE *)result = 72;
  result[7] = v9;
  result[8] = *a2;
  result[9] = a2[1];
  result[10] = a2[2];
  result[11] = a2[3];
  result[12] = a2[4];
  result[13] = a2[5];
  if ( a3 )
  {
    result[14] = *a3;
    result[15] = a3[1];
    result[16] = a3[2];
    result[17] = a3[3];
    result[18] = a3[4];
    result[19] = a3[5];
  }
  else
  {
    result[14] = 8;
  }
  result[20] = a4;
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046D180) --------------------------------------------------------
int __usercall sub_46D180@<eax>(_DWORD *a1@<ebx>, _DWORD *a2, _DWORD *a3, int a4)
{
  _DWORD *v4; // esi
  int v5; // ecx
  int v6; // edx
  int v7; // eax
  int v8; // ecx
  int v9; // edx
  int result; // eax

  v4 = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)v4 = 71;
  v4[4] = sub_46BF70((_DWORD *)dword_4AB36C);
  v4[2] = 2;
  v5 = v4[3];
  v6 = v4[4];
  *a1 = v4[2];
  v7 = v4[5];
  a1[1] = v5;
  v8 = v4[6];
  a1[2] = v6;
  v9 = v4[7];
  a1[3] = v7;
  a1[4] = v8;
  a1[5] = v9;
  if ( a2 )
  {
    v4[8] = *a2;
    v4[9] = a2[1];
    v4[10] = a2[2];
    v4[11] = a2[3];
    result = (int)a3;
    v4[12] = a2[4];
    v4[13] = a2[5];
    if ( a3 )
    {
      v4[14] = *a3;
      v4[15] = a3[1];
      v4[16] = a3[2];
      v4[17] = a3[3];
      v4[18] = a3[4];
      result = a4;
      v4[19] = a3[5];
    }
    else
    {
      v4[14] = 8;
    }
    v4[20] = a4;
  }
  else
  {
    result = 8;
    v4[8] = 8;
    v4[14] = 8;
    v4[20] = a4;
  }
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046D260) --------------------------------------------------------
int __usercall sub_46D260@<eax>(_DWORD *a1@<eax>, _DWORD *a2)
{
  _DWORD *v3; // eax
  _DWORD *v4; // esi
  void *v5; // eax
  _DWORD *v6; // eax
  int v7; // edx
  int v8; // edx
  int result; // eax
  int v10; // ecx

  v3 = sub_40F8F0((_DWORD *)dword_4AB36C);
  if ( *a1 == 2 )
    *(_BYTE *)v3 = 65;
  else
    *(_BYTE *)v3 = 66;
  v3[8] = *a1;
  v3[9] = a1[1];
  v3[10] = a1[2];
  v3[11] = a1[3];
  v3[12] = a1[4];
  v3[13] = a1[5];
  v3[16] = 0;
  v3[20] = 60;
  v3[14] = 8;
  v4 = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)v4 = 60;
  v4[4] = sub_46BF70((_DWORD *)dword_4AB36C);
  v4[2] = 4;
  v5 = (void *)sub_473493((int)&unk_487710);
  v6 = estrndup(v5, 0xAu);
  v7 = v4[2];
  v4[10] = v6;
  *a2 = v7;
  v8 = v4[5];
  v4[8] = 1;
  v4[20] = 1;
  a2[1] = v4[3];
  result = v4[6];
  *((_WORD *)v4 + 25) = 1;
  a2[2] = v4[4];
  v10 = v4[7];
  a2[3] = v8;
  v4[11] = 10;
  *((_BYTE *)v4 + 49) = 0;
  *((_BYTE *)v4 + 48) = 3;
  v4[14] = 8;
  a2[4] = result;
  a2[5] = v10;
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046D350) --------------------------------------------------------
int __usercall sub_46D350@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, _DWORD *a3)
{
  int v3; // eax
  int result; // eax
  _DWORD *v5; // esi
  int v6; // eax
  int v7; // edx
  int v8; // ecx
  int v9; // edx
  int v10; // ecx
  int v11; // edx
  int v12; // ecx
  int v13; // edx
  int v14; // ecx
  int v15; // edx

  v3 = a1 - 1;
  if ( v3 )
  {
    result = v3 - 1;
    if ( !result )
    {
      v5 = sub_40F8F0((_DWORD *)dword_4AB36C);
      *(_BYTE *)v5 = 99;
      v5[2] = 2;
      v5[4] = sub_46BF70((_DWORD *)dword_4AB36C);
      v5[8] = *a3;
      v5[9] = a3[1];
      v5[10] = a3[2];
      v5[11] = a3[3];
      v6 = v5[2];
      v5[12] = a3[4];
      v7 = a3[5];
      v8 = v5[3];
      *a2 = v6;
      result = v5[5];
      v5[13] = v7;
      v9 = v5[4];
      a2[1] = v8;
      v10 = v5[6];
      a2[2] = v9;
      v11 = v5[7];
      a2[3] = result;
      v5[14] = 8;
      a2[4] = v10;
      a2[5] = v11;
    }
  }
  else
  {
    v12 = a3[1];
    v13 = a3[2];
    *a2 = *a3;
    result = a3[3];
    a2[1] = v12;
    v14 = a3[4];
    a2[2] = v13;
    v15 = a3[5];
    a2[3] = result;
    a2[4] = v14;
    a2[5] = v15;
    *((_BYTE *)a2 + 16) = 8;
  }
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046D410) --------------------------------------------------------
int __usercall sub_46D410@<eax>(_DWORD *a1@<ebx>, int a2)
{
  _DWORD *v2; // esi
  _DWORD *v3; // eax
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  int v7; // ecx
  int v8; // edx
  _DWORD *v9; // eax
  int v10; // edx
  int v11; // ecx
  int v12; // edx
  int v13; // ecx
  int v14; // edx
  int Src; // [esp+8h] [ebp-4h] BYREF

  v2 = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)v2 = 68;
  v2[2] = 4;
  Src = 0;
  v2[4] = sub_46BF70((_DWORD *)dword_4AB36C);
  v2[8] = *a1;
  v2[9] = a1[1];
  v2[10] = a1[2];
  v2[11] = a1[3];
  v2[12] = a1[4];
  v2[13] = a1[5];
  v2[14] = 8;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(dword_4AB36C + 20);
  v3 = sub_40F8F0((_DWORD *)dword_4AB36C);
  v4 = *(v3 - 19);
  v3[8] = *(v3 - 20);
  v5 = *(v3 - 18);
  v3[9] = v4;
  v6 = *(v3 - 17);
  v3[10] = v5;
  v7 = *(v3 - 16);
  v3[11] = v6;
  v8 = *(v3 - 15);
  v3[12] = v7;
  *(_BYTE *)v3 = 69;
  v3[13] = v8;
  v3[14] = 8;
  if ( *a1 == 1 )
    zval_copy_ctor((int)(a1 + 2));
  v9 = sub_40F8F0((_DWORD *)dword_4AB36C);
  v10 = *(v9 - 41);
  v9[8] = *(v9 - 42);
  v11 = *(v9 - 40);
  v9[9] = v10;
  v12 = *(v9 - 39);
  v9[10] = v11;
  v13 = *(v9 - 38);
  v9[11] = v12;
  v14 = *(v9 - 37);
  v9[12] = v13;
  *(_BYTE *)v9 = 59;
  v9[13] = v14;
  v9[14] = *a1;
  v9[15] = a1[1];
  v9[16] = a1[2];
  v9[17] = a1[3];
  v9[18] = a1[4];
  v9[19] = a1[5];
  v9[20] = 3;
  return zend_stack_push(dword_4AB34C, &Src, 4u);
}
// 4AB34C: using guessed type _DWORD dword_4AB34C[3];
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046D550) --------------------------------------------------------
_DWORD *__cdecl sub_46D550(_DWORD *a1, int a2)
{
  int v2; // ebx
  _DWORD *v3; // esi
  int v4; // esi
  _DWORD *v5; // eax
  int v6; // ecx
  _DWORD *result; // eax
  int v8; // [esp+Ch] [ebp-4h] BYREF

  v2 = *(_DWORD *)(dword_4AB36C + 20);
  v3 = sub_40F8F0((_DWORD *)dword_4AB36C);
  zend_stack_top(dword_4AB24C, &v8);
  *(_BYTE *)v3 = 42;
  v3[8] = 8;
  v3[14] = 8;
  *(_DWORD *)(a2 + 8) = v2;
  v4 = *(_DWORD *)(dword_4AB36C + 20);
  v5 = sub_40F8F0((_DWORD *)dword_4AB36C);
  v6 = v8;
  *(_BYTE *)v5 = 52;
  v5[4] = *(_DWORD *)(v6 + 28);
  v5[2] = 2;
  v5[8] = 1;
  *((_BYTE *)v5 + 48) = 6;
  v5[10] = 1;
  *((_WORD *)v5 + 25) = 1;
  *((_BYTE *)v5 + 49) = 0;
  v5[14] = 8;
  result = a1;
  *(_DWORD *)(v6 + 24) = v4;
  if ( *a1 != 8 )
  {
    result = *(_DWORD **)(dword_4AB36C + 20);
    *(_DWORD *)(88 * a1[2] + *(_DWORD *)(dword_4AB36C + 16) + 40) = result;
  }
  return result;
}
// 4AB24C: using guessed type _DWORD dword_4AB24C[3];
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046D600) --------------------------------------------------------
int __cdecl sub_46D600(int a1, int a2)
{
  int v2; // esi
  _DWORD *v3; // eax
  int v4; // edx
  int result; // eax

  v2 = *(_DWORD *)(dword_4AB36C + 20);
  v3 = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)v3 = 42;
  v3[8] = 8;
  v3[14] = 8;
  v4 = dword_4AB36C;
  *(_DWORD *)(a1 + 8) = v2;
  result = *(_DWORD *)(v4 + 16) + 88 * *(_DWORD *)(a2 + 8);
  if ( *(_BYTE *)result == 42 )
  {
    *(_DWORD *)(result + 40) = *(_DWORD *)(v4 + 20);
  }
  else if ( *(_BYTE *)result == 43 )
  {
    *(_DWORD *)(result + 64) = *(_DWORD *)(v4 + 20);
  }
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046D660) --------------------------------------------------------
_DWORD *__usercall sub_46D660@<eax>(_DWORD *a1@<eax>, _DWORD *a2, int a3)
{
  _DWORD *v4; // esi
  _DWORD *v5; // eax
  bool v6; // zf
  int v7; // edx
  int v8; // eax
  int v9; // ecx
  int v10; // ebx
  int v11; // ebp
  int v12; // esi
  int v13; // edx
  _DWORD *v14; // eax
  int v15; // ecx
  int v16; // edx
  int v17; // ecx
  _DWORD *result; // eax
  int v19[3]; // [esp+10h] [ebp-1Ch] BYREF
  int v20; // [esp+1Ch] [ebp-10h]
  int v21; // [esp+20h] [ebp-Ch]
  int v22; // [esp+24h] [ebp-8h]

  v4 = sub_40F8F0((_DWORD *)dword_4AB36C);
  zend_stack_top(dword_4AB24C, v19);
  v5 = (_DWORD *)v19[0];
  *(_BYTE *)v4 = 48;
  v4[4] = v5[7];
  v4[2] = 2;
  v4[8] = *v5;
  v4[9] = v5[1];
  v4[10] = v5[2];
  v4[11] = v5[3];
  v4[12] = v5[4];
  v4[13] = v5[5];
  v4[14] = *a1;
  v4[15] = a1[1];
  v4[16] = a1[2];
  v4[17] = a1[3];
  v4[18] = a1[4];
  v6 = v4[8] == 1;
  v4[19] = a1[5];
  if ( v6 )
    zval_copy_ctor((int)(v4 + 10));
  v7 = v4[4];
  v8 = v4[5];
  v9 = v4[6];
  v10 = v4[2];
  v11 = v4[3];
  v12 = v4[7];
  v20 = v7;
  v13 = *(_DWORD *)(dword_4AB36C + 20);
  v21 = v8;
  v22 = v9;
  v19[0] = v13;
  v14 = sub_40F8F0((_DWORD *)dword_4AB36C);
  v15 = v20;
  v16 = v21;
  v14[8] = v10;
  v14[9] = v11;
  v14[10] = v15;
  v17 = v22;
  v14[11] = v16;
  v14[12] = v17;
  v14[13] = v12;
  *(_BYTE *)v14 = 43;
  v14[14] = 8;
  *(_DWORD *)(a3 + 8) = v19[0];
  result = a2;
  if ( *a2 != 8 )
  {
    result = *(_DWORD **)(dword_4AB36C + 20);
    *(_DWORD *)(88 * a2[2] + *(_DWORD *)(dword_4AB36C + 16) + 40) = result;
  }
  return result;
}
// 4AB24C: using guessed type _DWORD dword_4AB24C[3];
// 4AB36C: using guessed type int dword_4AB36C;
// 46D660: using guessed type int var_1C[3];

//----- (0046D780) --------------------------------------------------------
int __usercall sub_46D780@<eax>(_DWORD *a1@<eax>)
{
  _DWORD *v2; // esi
  _DWORD *v3; // eax
  _DWORD *v4; // eax
  int result; // eax
  _DWORD *v6; // [esp+4h] [ebp-4h] BYREF

  zend_stack_top(dword_4AB24C, &v6);
  if ( *a1 != 8 )
    *(_DWORD *)(88 * a1[2] + *(_DWORD *)(dword_4AB36C + 16) + 40) = *(_DWORD *)(dword_4AB36C + 20);
  v2 = v6;
  if ( v6[6] != -1 )
  {
    v3 = sub_40F8F0((_DWORD *)dword_4AB36C);
    *(_BYTE *)v3 = 43;
    v3[8] = 2;
    v3[10] = v2[7];
    v3[16] = v2[6];
    v3[14] = 8;
  }
  *(_DWORD *)(*(_DWORD *)(dword_4AB36C + 32) + 12 * *(_DWORD *)(dword_4AB36C + 40) + 4) = *(_DWORD *)(dword_4AB36C + 20);
  *(_DWORD *)(*(_DWORD *)(dword_4AB36C + 32) + 12 * *(_DWORD *)(dword_4AB36C + 40)) = *(_DWORD *)(*(_DWORD *)(dword_4AB36C + 32)
                                                                                                + 12
                                                                                                * *(_DWORD *)(dword_4AB36C + 40)
                                                                                                + 4);
  *(_DWORD *)(dword_4AB36C + 40) = *(_DWORD *)(*(_DWORD *)(dword_4AB36C + 32) + 12 * *(_DWORD *)(dword_4AB36C + 40) + 8);
  if ( *v2 == 4 || *v2 == 2 )
  {
    v4 = sub_40F8F0((_DWORD *)dword_4AB36C);
    *(_BYTE *)v4 = 49;
    v4[8] = *v2;
    v4[9] = v2[1];
    v4[10] = v2[2];
    v4[11] = v2[3];
    v4[12] = v2[4];
    v4[13] = v2[5];
    v4[14] = 8;
  }
  if ( *v2 == 1 )
    zval_dtor((int)(v2 + 2));
  result = zend_stack_del_top(dword_4AB24C);
  if ( dword_4AB3DC )
  {
    result = dword_4AB36C;
    --*(_DWORD *)(dword_4AB36C + 56);
  }
  return result;
}
// 4AB24C: using guessed type _DWORD dword_4AB24C[3];
// 4AB36C: using guessed type int dword_4AB36C;
// 4AB3DC: using guessed type int dword_4AB3DC;

//----- (0046D8A0) --------------------------------------------------------
_DWORD *__cdecl sub_46D8A0(int *a1)
{
  _DWORD *v1; // esi
  int v2; // eax
  int v3; // ecx
  int v4; // edx
  int v5; // ecx
  _DWORD *result; // eax
  int Src[8]; // [esp+10h] [ebp-20h] BYREF

  v1 = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)v1 = 52;
  v2 = sub_46BF70((_DWORD *)dword_4AB36C);
  v1[4] = v2;
  v1[2] = 2;
  *((_BYTE *)v1 + 48) = 6;
  v1[10] = 0;
  *((_BYTE *)v1 + 49) = 0;
  v1[14] = 8;
  v1[8] = 1;
  *((_WORD *)v1 + 25) = 1;
  v3 = a1[1];
  Src[0] = *a1;
  Src[2] = a1[2];
  v4 = a1[4];
  Src[1] = v3;
  v5 = a1[3];
  Src[4] = v4;
  Src[3] = v5;
  Src[5] = a1[5];
  Src[6] = -1;
  Src[7] = v2;
  zend_stack_push(dword_4AB24C, Src, 0x20u);
  result = sub_46C830();
  if ( dword_4AB3DC )
  {
    result = (_DWORD *)dword_4AB36C;
    ++*(_DWORD *)(dword_4AB36C + 56);
  }
  return result;
}
// 4AB24C: using guessed type _DWORD dword_4AB24C[3];
// 4AB36C: using guessed type int dword_4AB36C;
// 4AB3DC: using guessed type int dword_4AB3DC;

//----- (0046D960) --------------------------------------------------------
_DWORD *__usercall sub_46D960@<eax>(_DWORD *a1@<esi>, char a2)
{
  _DWORD *result; // eax

  result = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)result = a2;
  result[10] = *(_DWORD *)(dword_4AB36C + 40);
  result[8] = 8;
  if ( a1 )
  {
    result[14] = *a1;
    result[15] = a1[1];
    result[16] = a1[2];
    result[17] = a1[3];
    result[18] = a1[4];
    result[19] = a1[5];
  }
  else
  {
    *((_BYTE *)result + 72) = 1;
    result[16] = 1;
    *((_WORD *)result + 37) = 1;
    *((_BYTE *)result + 73) = 0;
    result[14] = 1;
  }
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046D9D0) --------------------------------------------------------
int __usercall sub_46D9D0@<eax>(_DWORD *a1@<esi>, int a2, int a3)
{
  _DWORD *v3; // eax
  int result; // eax

  v3 = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)v3 = 44;
  v3[8] = *a1;
  v3[9] = a1[1];
  v3[10] = a1[2];
  v3[11] = a1[3];
  v3[12] = a1[4];
  v3[13] = a1[5];
  v3[16] = *(_DWORD *)(a2 + 8);
  v3[14] = 8;
  result = sub_46C1B0(a2, *(_DWORD *)(a3 + 8));
  if ( dword_4AB3DC )
  {
    result = dword_4AB36C;
    --*(_DWORD *)(dword_4AB36C + 56);
  }
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;
// 4AB3DC: using guessed type int dword_4AB3DC;

//----- (0046DA40) --------------------------------------------------------
_DWORD *sub_46DA40()
{
  _DWORD *result; // eax

  result = sub_46C830();
  if ( dword_4AB3DC )
  {
    result = (_DWORD *)dword_4AB36C;
    ++*(_DWORD *)(dword_4AB36C + 56);
  }
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;
// 4AB3DC: using guessed type int dword_4AB3DC;

//----- (0046DA60) --------------------------------------------------------
int __usercall sub_46DA60@<eax>(_DWORD *a1@<ebx>, _DWORD *a2@<esi>, _DWORD *a3, int a4)
{
  _DWORD *v4; // eax
  int v5; // edx
  int v6; // ecx
  int v7; // edx
  int v8; // ecx
  int v9; // edx
  int v10; // edx
  int v11; // ecx
  int v12; // edx
  int v13; // ecx
  int v14; // edx
  int result; // eax

  v4 = sub_40F8F0((_DWORD *)dword_4AB36C);
  v5 = a3[1];
  *a2 = *a3;
  v6 = a3[2];
  a2[1] = v5;
  v7 = a3[3];
  a2[2] = v6;
  v8 = a3[4];
  a2[3] = v7;
  v9 = a3[5];
  a2[4] = v8;
  a2[5] = v9;
  v10 = a2[1];
  v4[2] = *a2;
  v11 = a2[2];
  v4[3] = v10;
  v12 = a2[3];
  v4[4] = v11;
  v13 = a2[4];
  v4[5] = v12;
  v14 = a2[5];
  v4[6] = v13;
  *(_BYTE *)v4 = 52;
  v4[7] = v14;
  v4[8] = *a1;
  v4[9] = a1[1];
  v4[10] = a1[2];
  v4[11] = a1[3];
  v4[12] = a1[4];
  v4[13] = a1[5];
  v4[14] = 8;
  result = *(_DWORD *)(dword_4AB36C + 20);
  *(_DWORD *)(88 * *(_DWORD *)(a4 + 8) + *(_DWORD *)(dword_4AB36C + 16) + 64) = result;
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046DB00) --------------------------------------------------------
int __usercall sub_46DB00@<eax>(_DWORD *a1@<ebx>, int a2)
{
  int v2; // ebp
  _DWORD *v3; // eax
  _DWORD *v4; // esi
  int result; // eax

  v2 = *(_DWORD *)(dword_4AB36C + 20);
  v3 = sub_40F8F0((_DWORD *)dword_4AB36C);
  v4 = v3;
  *(_BYTE *)v3 = 46;
  if ( *a1 == 2 )
  {
    v3[2] = *a1;
    v3[3] = a1[1];
    v3[4] = a1[2];
    v3[5] = a1[3];
    v3[6] = a1[4];
    v3[7] = a1[5];
  }
  else
  {
    v3[4] = sub_46BF70((_DWORD *)dword_4AB36C);
    v4[2] = 2;
  }
  v4[8] = *a1;
  v4[9] = a1[1];
  v4[10] = a1[2];
  v4[11] = a1[3];
  v4[12] = a1[4];
  v4[13] = a1[5];
  v4[14] = 8;
  *(_DWORD *)(a2 + 8) = v2;
  *a1 = v4[2];
  a1[1] = v4[3];
  a1[2] = v4[4];
  a1[3] = v4[5];
  a1[4] = v4[6];
  result = v4[7];
  a1[5] = result;
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046DBB0) --------------------------------------------------------
int __usercall sub_46DBB0@<eax>(_DWORD *a1@<ebx>, _DWORD *a2@<esi>, _DWORD *a3, int a4)
{
  _DWORD *v4; // eax
  int v5; // edx
  int v6; // ecx
  int v7; // edx
  int v8; // ecx
  int v9; // edx
  int v10; // edx
  int v11; // ecx
  int v12; // edx
  int v13; // ecx
  int v14; // edx
  int result; // eax

  v4 = sub_40F8F0((_DWORD *)dword_4AB36C);
  v5 = a3[1];
  *a2 = *a3;
  v6 = a3[2];
  a2[1] = v5;
  v7 = a3[3];
  a2[2] = v6;
  v8 = a3[4];
  a2[3] = v7;
  v9 = a3[5];
  a2[4] = v8;
  a2[5] = v9;
  v10 = a2[1];
  v4[2] = *a2;
  v11 = a2[2];
  v4[3] = v10;
  v12 = a2[3];
  v4[4] = v11;
  v13 = a2[4];
  v4[5] = v12;
  v14 = a2[5];
  v4[6] = v13;
  *(_BYTE *)v4 = 52;
  v4[7] = v14;
  v4[8] = *a1;
  v4[9] = a1[1];
  v4[10] = a1[2];
  v4[11] = a1[3];
  v4[12] = a1[4];
  v4[13] = a1[5];
  v4[14] = 8;
  result = *(_DWORD *)(dword_4AB36C + 20);
  *(_DWORD *)(88 * *(_DWORD *)(a4 + 8) + *(_DWORD *)(dword_4AB36C + 16) + 64) = result;
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046DC50) --------------------------------------------------------
int __usercall sub_46DC50@<eax>(_DWORD *a1@<ebx>, int a2)
{
  int v2; // ebp
  _DWORD *v3; // eax
  _DWORD *v4; // esi
  int result; // eax

  v2 = *(_DWORD *)(dword_4AB36C + 20);
  v3 = sub_40F8F0((_DWORD *)dword_4AB36C);
  v4 = v3;
  *(_BYTE *)v3 = 47;
  if ( *a1 == 2 )
  {
    v3[2] = *a1;
    v3[3] = a1[1];
    v3[4] = a1[2];
    v3[5] = a1[3];
    v3[6] = a1[4];
    v3[7] = a1[5];
  }
  else
  {
    v3[4] = sub_46BF70((_DWORD *)dword_4AB36C);
    v4[2] = 2;
  }
  v4[8] = *a1;
  v4[9] = a1[1];
  v4[10] = a1[2];
  v4[11] = a1[3];
  v4[12] = a1[4];
  v4[13] = a1[5];
  v4[14] = 8;
  *(_DWORD *)(a2 + 8) = v2;
  *a1 = v4[2];
  a1[1] = v4[3];
  a1[2] = v4[4];
  a1[3] = v4[5];
  a1[4] = v4[6];
  result = v4[7];
  a1[5] = result;
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046DD00) --------------------------------------------------------
void __cdecl function_add_ref(int a1)
{
  int v1; // esi
  int v2; // edi
  _DWORD *v3; // eax

  v1 = a1;
  if ( *(_BYTE *)a1 == 2 )
  {
    ++**(_DWORD **)(a1 + 12);
    v2 = *(_DWORD *)(v1 + 48);
    if ( v2 )
    {
      v3 = emalloc(40);
      *(_DWORD *)(v1 + 48) = v3;
      zend_hash_init((int)v3, 2u, 0, (int)zval_ptr_dtor, 0);
      zend_hash_copy(*(_DWORD *)(v1 + 48), v2, (int (__cdecl *)(int))zval_add_ref, (int)&a1, 4u);
    }
  }
}

//----- (0046DD50) --------------------------------------------------------
int __cdecl sub_46DD50(_DWORD *a1)
{
  _DWORD *v2; // eax

  if ( *a1 != 4 && *a1 != 2 )
    return 1;
  v2 = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)v2 = 49;
  v2[8] = *a1;
  v2[9] = a1[1];
  v2[10] = a1[2];
  v2[11] = a1[3];
  v2[12] = a1[4];
  v2[13] = a1[5];
  v2[14] = 8;
  v2[20] = 1;
  return 0;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046DE10) --------------------------------------------------------
int __usercall sub_46DE10@<eax>(_DWORD *a1@<ebx>, _DWORD *a2, int a3, int a4, int a5)
{
  _DWORD *v5; // eax
  _DWORD *v6; // esi
  int v7; // ecx
  int v8; // edx
  int v9; // eax
  int v10; // ecx
  int v11; // edx
  int result; // eax

  v5 = sub_40F8F0((_DWORD *)dword_4AB36C);
  v6 = v5;
  if ( *a1 != 1 || a4 || a5 )
    *(_BYTE *)v5 = 61;
  else
    *(_BYTE *)v5 = 60;
  v5[8] = *a1;
  v5[9] = a1[1];
  v5[10] = a1[2];
  v5[11] = a1[3];
  v5[12] = a1[4];
  v5[13] = a1[5];
  v5[4] = sub_46BF70((_DWORD *)dword_4AB36C);
  v6[2] = 4;
  v7 = v6[3];
  v8 = v6[4];
  *a2 = v6[2];
  v9 = v6[5];
  a2[1] = v7;
  v10 = v6[6];
  a2[2] = v8;
  v11 = v6[7];
  a2[3] = v9;
  a2[4] = v10;
  a2[5] = v11;
  v6[14] = 8;
  v6[16] = a4;
  result = zend_stack_del_top(dword_4AB34C);
  v6[20] = *(_DWORD *)(a3 + 8);
  return result;
}
// 4AB34C: using guessed type _DWORD dword_4AB34C[3];
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046DED0) --------------------------------------------------------
int __usercall sub_46DED0@<eax>(_DWORD *a1@<ebx>, _DWORD *a2)
{
  _DWORD *v2; // esi
  _BYTE *v3; // edi
  _BYTE *i; // ebp
  int v5; // eax
  _DWORD *v6; // edi
  char v7; // dl
  int v8; // eax
  _BYTE *v9; // edi
  char *v10; // eax
  size_t v11; // edx
  int Src; // [esp+Ch] [ebp-4h] BYREF

  Src = 0;
  v2 = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)v2 = 59;
  v3 = (_BYTE *)a1[2];
  for ( i = &v3[a1[3]]; v3 < i; ++v3 )
    *v3 = tolower((char)*v3);
  if ( a1[3] == 6 )
  {
    v5 = sub_473493((int)&unk_487410);
    v6 = (_DWORD *)a1[2];
    if ( *v6 == *(_DWORD *)v5 )
    {
      v7 = *(_BYTE *)(v5 + 4);
      v8 = v5 + 4;
      v9 = v6 + 1;
      if ( v7 == *v9 && *(_BYTE *)(v8 + 1) == v9[1] )
      {
        if ( dword_4AB2F8 )
        {
          efree(a1[2]);
          v11 = dword_4AB2FC;
          a1[3] = dword_4AB2FC;
          a1[2] = estrndup(dword_4AB2F8, v11);
        }
        else
        {
          v10 = (char *)sub_473493((int)&unk_48741C);
          zend_error(64, v10);
        }
      }
    }
  }
  v2[8] = *a1;
  v2[9] = a1[1];
  v2[10] = a1[2];
  v2[11] = a1[3];
  v2[12] = a1[4];
  v2[13] = a1[5];
  v2[14] = *a2;
  v2[15] = a2[1];
  v2[16] = a2[2];
  v2[17] = a2[3];
  v2[18] = a2[4];
  v2[19] = a2[5];
  v2[20] = 1;
  zval_copy_ctor((int)(v2 + 16));
  return zend_stack_push(dword_4AB34C, &Src, 4u);
}
// 4AB34C: using guessed type _DWORD dword_4AB34C[3];
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046E000) --------------------------------------------------------
char __usercall sub_46E000@<al>(_DWORD *a1@<ebx>, _DWORD *a2@<esi>, int a3, _DWORD *a4, char a5)
{
  _DWORD *v5; // eax
  int v6; // edx
  int v7; // eax
  _DWORD *v8; // eax
  int v9; // ecx
  int i; // eax

  v5 = sub_40F8F0((_DWORD *)dword_4AB36C);
  v5[2] = *a4;
  v5[3] = a4[1];
  v5[4] = a4[2];
  v5[5] = a4[3];
  v5[6] = a4[4];
  v5[7] = a4[5];
  v5[8] = *a2;
  v5[9] = a2[1];
  v5[10] = a2[2];
  v5[11] = a2[3];
  v5[12] = a2[4];
  v6 = a2[5];
  *(_BYTE *)v5 = a3;
  v5[13] = v6;
  if ( a3 == 64 )
  {
    v5[14] = *a1;
    v5[15] = a1[1];
    v5[16] = a1[2];
    v5[17] = a1[3];
    v5[18] = a1[4];
    v5[19] = a1[5];
  }
  else
  {
    v5[14] = 8;
  }
  v7 = *(_DWORD *)(dword_4AB36C + 4);
  if ( v7 )
  {
    *(_DWORD *)(dword_4AB36C + 4) = erealloc(v7, a2[2] + 1, 0);
    **(_BYTE **)(dword_4AB36C + 4) = *((_BYTE *)a2 + 8);
    LOBYTE(v7) = a5;
    *(_BYTE *)(*(_DWORD *)(dword_4AB36C + 4) + a2[2]) = a5;
  }
  else if ( a5 == 1 )
  {
    v8 = emalloc(a2[2] + 1);
    v9 = a2[2];
    *(_DWORD *)(dword_4AB36C + 4) = v8;
    for ( i = 1; i < v9; ++i )
      *(_BYTE *)(i + *(_DWORD *)(dword_4AB36C + 4)) = 0;
    **(_BYTE **)(dword_4AB36C + 4) = v9;
    v7 = *(_DWORD *)(dword_4AB36C + 4);
    *(_BYTE *)(v9 + v7) = 1;
  }
  return v7;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046E140) --------------------------------------------------------
int __usercall sub_46E140@<eax>(int a1@<eax>, int a2@<ecx>, int a3, char a4)
{
  char *v4; // ebx
  int *v5; // esi
  size_t v6; // eax
  char *v7; // ebp
  char *i; // edi
  _DWORD *v9; // ebp
  _DWORD *v10; // eax
  size_t v11; // edx
  char *v12; // ecx
  _DWORD *v13; // eax
  size_t Size; // [esp+14h] [ebp-88h]
  int v16; // [esp+1Ch] [ebp-80h]
  int v17[8]; // [esp+20h] [ebp-7Ch] BYREF
  size_t Src[15]; // [esp+40h] [ebp-5Ch] BYREF
  char v19; // [esp+7Ch] [ebp-20h]

  v4 = *(char **)(a1 + 8);
  v5 = (int *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 12);
  v16 = *(_DWORD *)(a2 + 8);
  v7 = &v4[v6];
  Size = v6;
  *(_DWORD *)(a2 + 8) = dword_4AB36C;
  for ( i = v4; i < v7; ++i )
    *i = tolower(*i);
  init_op_array((int)Src, 2, 64);
  Src[2] = (size_t)v4;
  Src[1] = 0;
  v19 = a4;
  if ( a3 )
  {
    zend_hash_add_or_update(dword_4AB2F4 + 24, v4, Size + 1, Src, 0x54u, &dword_4AB36C, 1);
  }
  else
  {
    v9 = sub_40F8F0((_DWORD *)dword_4AB36C);
    *(_BYTE *)v9 = 100;
    v9[8] = 1;
    sub_46C540(v5, (int)(v9 + 10), (int)v9);
    v9[14] = 1;
    *((_BYTE *)v9 + 72) = 3;
    v10 = estrndup(v4, Size);
    v11 = v9[11];
    v9[16] = v10;
    *((_WORD *)v9 + 37) = 1;
    v12 = (char *)v9[10];
    v9[17] = Size;
    v9[20] = 2;
    zend_hash_add_or_update(dword_4AB370, v12, v11, Src, 0x54u, &dword_4AB36C, 1);
  }
  if ( byte_4AB3B8 )
  {
    v13 = sub_40F8F0((_DWORD *)dword_4AB36C);
    *(_BYTE *)v13 = 104;
    v13[21] = v16;
    v13[8] = 8;
    v13[14] = 8;
  }
  v17[0] = 8;
  v17[6] = 0;
  v17[7] = 0;
  zend_stack_push(dword_4AB24C, v17, 0x20u);
  return zend_stack_push(dword_4AB258, v17, 0x18u);
}
// 4AB24C: using guessed type _DWORD dword_4AB24C[3];
// 4AB258: using guessed type _DWORD dword_4AB258[3];
// 4AB2F4: using guessed type int dword_4AB2F4;
// 4AB36C: using guessed type int dword_4AB36C;
// 4AB3B8: using guessed type char byte_4AB3B8;

//----- (0046E2C0) --------------------------------------------------------
char __usercall sub_46E2C0@<al>(int a1@<eax>)
{
  _DWORD *i; // eax
  unsigned int v3; // edx

  i = *(_DWORD **)a1;
  if ( i == (_DWORD *)2 )
  {
    i = sub_40F8F0((_DWORD *)dword_4AB36C);
    *(_BYTE *)i = 70;
    i[8] = *(_DWORD *)a1;
    i[9] = *(_DWORD *)(a1 + 4);
    i[10] = *(_DWORD *)(a1 + 8);
    i[11] = *(_DWORD *)(a1 + 12);
    i[12] = *(_DWORD *)(a1 + 16);
    i[13] = *(_DWORD *)(a1 + 20);
    i[14] = 8;
  }
  else if ( i == (_DWORD *)4 )
  {
    v3 = *(_DWORD *)(dword_4AB36C + 16);
    for ( i = (_DWORD *)(88 * *(_DWORD *)(dword_4AB36C + 20) + v3 - 88); *(_BYTE *)i == 58 || *(_BYTE *)i == 103; i -= 22 )
      ;
    if ( i[2] == 4 && i[4] == *(_DWORD *)(a1 + 8) )
    {
      i[5] |= 1u;
    }
    else if ( (unsigned int)i > v3 )
    {
      while ( 1 )
      {
        if ( *(_BYTE *)i == 69 )
        {
          *(i - 17) |= 1u;
          i[33] |= 1u;
          return (char)i;
        }
        if ( *(_BYTE *)i == 81 && i[8] == 4 && i[10] == *(_DWORD *)(a1 + 8) )
          break;
        if ( i[2] != 4 || i[4] != *(_DWORD *)(a1 + 8) )
        {
          i -= 22;
          if ( (unsigned int)i > v3 )
            continue;
        }
        return (char)i;
      }
      i[20] = 0;
    }
  }
  else if ( i == (_DWORD *)1 )
  {
    LOBYTE(i) = zval_dtor(a1 + 8);
  }
  return (char)i;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046E3B0) --------------------------------------------------------
_DWORD *__usercall sub_46E3B0@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<esi>, _DWORD *a3)
{
  _DWORD *v4; // edi
  int v5; // ecx
  int v6; // edx
  int v7; // eax
  int v8; // ecx
  int v9; // edx
  bool v10; // cc
  _DWORD *v11; // eax
  int v12; // edx
  int v13; // ecx
  int v14; // edx
  int v15; // ecx
  int v16; // edx
  int v17; // ecx
  int v18; // edx
  int v19; // ecx
  int v20; // edx
  int v21; // ecx
  int v22; // edx
  int v23; // edx
  int v24; // ecx
  int v25; // edx
  int v26; // ecx
  int v27; // edx
  int v28; // ecx
  int v29; // edx
  int v30; // eax
  int v31; // ecx
  int v32; // edx
  _DWORD *result; // eax
  int v34; // edx
  int v35; // ecx
  int v36; // edx
  int v37; // ecx
  int v38; // edx
  int v39; // ecx
  int v40; // edx
  int v41; // ecx
  int v42; // edx
  int v43; // ecx
  int v44; // edx
  int v45; // edx
  int v46; // ecx
  int v47; // edx
  int v48; // ecx
  int v49; // edx

  if ( *a1 == 1 )
  {
    v4 = sub_40F8F0((_DWORD *)dword_4AB36C);
    *(_BYTE *)v4 = 53;
    v4[2] = 2;
    v4[4] = sub_46BF70((_DWORD *)dword_4AB36C);
    v5 = v4[3];
    v6 = v4[4];
    *a2 = v4[2];
    v7 = v4[5];
    a2[1] = v5;
    v8 = v4[6];
    a2[2] = v6;
    v9 = v4[7];
    a2[3] = v7;
    v4[8] = 8;
    v4[14] = 8;
    v10 = a1[3] <= 0;
    a2[4] = v8;
    a2[5] = v9;
    if ( v10 )
    {
      zval_dtor((int)(a1 + 2));
    }
    else
    {
      v11 = sub_40F8F0((_DWORD *)dword_4AB36C);
      v12 = a2[1];
      v11[2] = *a2;
      v13 = a2[2];
      v11[3] = v12;
      v14 = a2[3];
      v11[4] = v13;
      v15 = a2[4];
      v11[5] = v14;
      v16 = a2[5];
      v11[6] = v15;
      v17 = *a2;
      v11[7] = v16;
      v18 = a2[1];
      v11[8] = v17;
      v19 = a2[2];
      v11[9] = v18;
      v20 = a2[3];
      v11[10] = v19;
      v21 = a2[4];
      v11[11] = v20;
      v22 = a2[5];
      v11[12] = v21;
      v11[13] = v22;
      *(_BYTE *)v11 = 55;
      v11[14] = *a1;
      v11[15] = a1[1];
      v11[16] = a1[2];
      v11[17] = a1[3];
      v11[18] = a1[4];
      v23 = a1[5];
      v11[2] = *a2;
      v24 = a2[2];
      v11[19] = v23;
      v11[3] = a2[1];
      v25 = a2[3];
      v11[4] = v24;
      v26 = a2[4];
      v11[5] = v25;
      v27 = a2[5];
      v11[6] = v26;
      v11[7] = v27;
    }
  }
  else
  {
    v28 = a1[1];
    v29 = a1[2];
    *a2 = *a1;
    v30 = a1[3];
    a2[1] = v28;
    v31 = a1[4];
    a2[2] = v29;
    v32 = a1[5];
    a2[3] = v30;
    a2[4] = v31;
    a2[5] = v32;
  }
  result = sub_40F8F0((_DWORD *)dword_4AB36C);
  v34 = a2[1];
  result[2] = *a2;
  v35 = a2[2];
  result[3] = v34;
  v36 = a2[3];
  result[4] = v35;
  v37 = a2[4];
  result[5] = v36;
  v38 = a2[5];
  result[6] = v37;
  v39 = *a2;
  result[7] = v38;
  v40 = a2[1];
  result[8] = v39;
  v41 = a2[2];
  result[9] = v40;
  v42 = a2[3];
  result[10] = v41;
  v43 = a2[4];
  result[11] = v42;
  v44 = a2[5];
  result[12] = v43;
  result[13] = v44;
  *(_BYTE *)result = 56;
  result[14] = *a3;
  result[15] = a3[1];
  result[16] = a3[2];
  result[17] = a3[3];
  result[18] = a3[4];
  v45 = a3[5];
  *a2 = result[2];
  v46 = result[4];
  result[19] = v45;
  a2[1] = result[3];
  v47 = result[5];
  a2[2] = v46;
  v48 = result[6];
  a2[3] = v47;
  v49 = result[7];
  a2[4] = v48;
  a2[5] = v49;
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046E590) --------------------------------------------------------
_DWORD *__usercall sub_46E590@<eax>(_DWORD *a1@<ebx>, _DWORD *a2@<esi>, _DWORD *a3)
{
  _DWORD *result; // eax
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  int v7; // ecx
  int v8; // edx
  int v9; // ecx
  int v10; // edx
  int v11; // ecx
  int v12; // edx

  result = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)result = 55;
  result[8] = *a1;
  result[9] = a1[1];
  result[10] = a1[2];
  result[11] = a1[3];
  result[12] = a1[4];
  result[13] = a1[5];
  result[14] = *a2;
  result[15] = a2[1];
  result[16] = a2[2];
  result[17] = a2[3];
  result[18] = a2[4];
  v4 = a2[5];
  result[2] = result[8];
  v5 = result[10];
  result[19] = v4;
  result[3] = result[9];
  v6 = result[11];
  result[4] = v5;
  v7 = result[12];
  result[5] = v6;
  v8 = result[13];
  result[6] = v7;
  *a3 = result[8];
  v9 = result[10];
  result[7] = v8;
  a3[1] = result[9];
  v10 = result[11];
  a3[2] = v9;
  v11 = result[12];
  a3[3] = v10;
  v12 = result[13];
  a3[4] = v11;
  a3[5] = v12;
  result[14] = 1;
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046E640) --------------------------------------------------------
_DWORD *__usercall sub_46E640@<eax>(_DWORD *a1@<ebx>, _DWORD *a2@<esi>, _DWORD *a3)
{
  _DWORD *result; // eax
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  int v7; // ecx
  int v8; // edx
  int v9; // ecx
  int v10; // edx
  int v11; // ecx
  int v12; // edx

  result = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)result = 54;
  result[8] = *a1;
  result[9] = a1[1];
  result[10] = a1[2];
  result[11] = a1[3];
  result[12] = a1[4];
  result[13] = a1[5];
  result[14] = *a2;
  result[15] = a2[1];
  result[16] = a2[2];
  result[17] = a2[3];
  result[18] = a2[4];
  v4 = a2[5];
  result[2] = result[8];
  v5 = result[10];
  result[19] = v4;
  result[3] = result[9];
  v6 = result[11];
  result[4] = v5;
  v7 = result[12];
  result[5] = v6;
  v8 = result[13];
  result[6] = v7;
  *a3 = result[8];
  v9 = result[10];
  result[7] = v8;
  a3[1] = result[9];
  v10 = result[11];
  a3[2] = v9;
  v11 = result[12];
  a3[3] = v10;
  v12 = result[13];
  a3[4] = v11;
  a3[5] = v12;
  result[14] = 1;
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046E6F0) --------------------------------------------------------
int __usercall sub_46E6F0@<eax>(_DWORD *a1@<ebx>)
{
  _DWORD *v1; // esi
  int v2; // ecx
  int v3; // edx
  int v4; // eax
  int v5; // ecx
  int v6; // edx
  int result; // eax

  v1 = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)v1 = 53;
  v1[2] = 2;
  v1[4] = sub_46BF70((_DWORD *)dword_4AB36C);
  v2 = v1[3];
  v3 = v1[4];
  *a1 = v1[2];
  v4 = v1[5];
  a1[1] = v2;
  v5 = v1[6];
  a1[2] = v3;
  v6 = v1[7];
  a1[3] = v4;
  result = 8;
  a1[4] = v5;
  v1[8] = 8;
  v1[14] = 8;
  a1[5] = v6;
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046E750) --------------------------------------------------------
int __cdecl sub_46E750(int a1, int a2)
{
  _DWORD *v2; // ebp
  _DWORD *v3; // ebx
  char *v4; // eax
  char *v5; // eax
  _DWORD *v7; // [esp+4h] [ebp-4h] BYREF

  zend_stack_top(compiler_globals, &v7);
  v2 = (_DWORD *)*v7;
  if ( *v7 )
  {
    do
    {
      v3 = sub_40F8F0((_DWORD *)dword_4AB36C);
      qmemcpy(v3, v2 + 2, 0x58u);
      switch ( a1 )
      {
        case 0:
          if ( *(_BYTE *)v3 == 84 && v3[14] == 8 )
          {
            v4 = (char *)sub_473493((int)&unk_4873D4);
            zend_error(64, v4);
          }
          *(_BYTE *)v3 -= 3;
          break;
        case 2:
          *(_BYTE *)v3 += 3;
          break;
        case 3:
          *(_BYTE *)v3 += 6;
          break;
        case 5:
          *(_BYTE *)v3 += 9;
          v3[20] = a2;
          break;
        case 6:
          if ( *(_BYTE *)v3 == 84 && v3[14] == 8 )
          {
            v5 = (char *)sub_473493((int)&unk_4873F0);
            zend_error(64, v5);
          }
          *(_BYTE *)v3 += 12;
          break;
        default:
          break;
      }
      v2 = (_DWORD *)*v2;
    }
    while ( v2 );
  }
  zend_llist_destroy((int)v7);
  return zend_stack_del_top(compiler_globals);
}
// 4AB240: using guessed type _DWORD compiler_globals[3];
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046E850) --------------------------------------------------------
int __cdecl sub_46E850(int a1, int a2)
{
  _DWORD *v2; // eax
  bool v3; // zf
  _DWORD *v4; // esi
  int result; // eax
  int v6; // [esp+8h] [ebp-20h] BYREF
  char Src[28]; // [esp+Ch] [ebp-1Ch] BYREF

  v6 = *(_DWORD *)(dword_4AB36C + 20);
  v2 = sub_40F8F0((_DWORD *)dword_4AB36C);
  v3 = (_BYTE)a2 == 0;
  v4 = v2;
  *(_BYTE *)v2 = 42;
  if ( !v3 )
  {
    zend_llist_init((int)Src, 4, 0, 0);
    zend_stack_push(compiler_globals, Src, 0x1Cu);
  }
  zend_stack_top(compiler_globals, &a2);
  zend_llist_add_element(a2, &v6);
  *(_DWORD *)(88 * *(_DWORD *)(a1 + 8) + *(_DWORD *)(dword_4AB36C + 16) + 64) = v6 + 1;
  result = 8;
  v4[8] = 8;
  v4[14] = 8;
  return result;
}
// 4AB240: using guessed type _DWORD compiler_globals[3];
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046E8F0) --------------------------------------------------------
_DWORD *__usercall sub_46E8F0@<eax>(_DWORD *a1@<esi>, int a2)
{
  int v2; // ebx
  _DWORD *result; // eax

  v2 = *(_DWORD *)(dword_4AB36C + 20);
  result = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)result = 43;
  result[8] = *a1;
  result[9] = a1[1];
  result[10] = a1[2];
  result[11] = a1[3];
  result[12] = a1[4];
  result[13] = a1[5];
  *(_DWORD *)(a2 + 8) = v2;
  result[14] = 8;
  if ( dword_4AB3DC )
  {
    result = (_DWORD *)dword_4AB36C;
    ++*(_DWORD *)(dword_4AB36C + 56);
  }
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;
// 4AB3DC: using guessed type int dword_4AB3DC;

//----- (0046E950) --------------------------------------------------------
int __usercall sub_46E950@<eax>(_DWORD *a1@<ebx>, _DWORD *a2, char a3)
{
  _DWORD *v3; // esi
  int v4; // ecx
  int v5; // eax
  int v6; // edx
  int v7; // ecx
  int v8; // edx
  int result; // eax

  v3 = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)v3 = a3;
  v3[2] = 2;
  v3[4] = sub_46BF70((_DWORD *)dword_4AB36C);
  v3[8] = *a1;
  v3[9] = a1[1];
  v3[10] = a1[2];
  v3[11] = a1[3];
  v4 = v3[2];
  v3[12] = a1[4];
  v5 = a1[5];
  v6 = v3[3];
  *a2 = v4;
  v7 = v3[5];
  a2[1] = v6;
  v8 = v3[6];
  v3[13] = v5;
  a2[2] = v3[4];
  result = v3[7];
  a2[3] = v7;
  a2[4] = v8;
  v3[14] = 8;
  a2[5] = result;
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046E9E0) --------------------------------------------------------
int __usercall sub_46E9E0@<eax>(_DWORD *a1@<ebx>, _DWORD *a2, char a3)
{
  _DWORD *v3; // esi
  int v4; // ecx
  int v5; // eax
  int v6; // edx
  int v7; // ecx
  int v8; // edx
  int result; // eax

  v3 = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)v3 = a3;
  v3[2] = 4;
  v3[5] = 0;
  v3[4] = sub_46BF70((_DWORD *)dword_4AB36C);
  v3[8] = *a1;
  v3[9] = a1[1];
  v3[10] = a1[2];
  v3[11] = a1[3];
  v4 = v3[2];
  v3[12] = a1[4];
  v5 = a1[5];
  v6 = v3[3];
  *a2 = v4;
  v7 = v3[5];
  a2[1] = v6;
  v8 = v3[6];
  v3[13] = v5;
  a2[2] = v3[4];
  result = v3[7];
  a2[3] = v7;
  a2[4] = v8;
  v3[14] = 8;
  a2[5] = result;
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046EA70) --------------------------------------------------------
int __usercall sub_46EA70@<eax>(int a1@<esi>)
{
  _DWORD *v1; // eax
  int result; // eax

  v1 = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)v1 = 42;
  v1[10] = *(_DWORD *)(a1 + 8) + 1;
  *(_DWORD *)(88 * *(_DWORD *)(a1 + 8) + *(_DWORD *)(dword_4AB36C + 16) + 64) = *(_DWORD *)(dword_4AB36C + 20);
  v1[8] = 8;
  v1[14] = 8;
  result = sub_46C1B0(8, *(_DWORD *)(a1 + 8) + 1);
  if ( dword_4AB3DC )
  {
    result = dword_4AB36C;
    --*(_DWORD *)(dword_4AB36C + 56);
  }
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;
// 4AB3DC: using guessed type int dword_4AB3DC;

//----- (0046EAD0) --------------------------------------------------------
_DWORD *__cdecl sub_46EAD0(int a1, int a2)
{
  _DWORD *v2; // eax
  _DWORD *result; // eax

  v2 = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)v2 = 42;
  v2[10] = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(88 * *(_DWORD *)(a2 + 8) + *(_DWORD *)(dword_4AB36C + 16) + 80) = *(_DWORD *)(dword_4AB36C + 20);
  v2[8] = 8;
  v2[14] = 8;
  result = sub_46C830();
  if ( dword_4AB3DC )
  {
    result = (_DWORD *)dword_4AB36C;
    ++*(_DWORD *)(dword_4AB36C + 56);
  }
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;
// 4AB3DC: using guessed type int dword_4AB3DC;

//----- (0046EB30) --------------------------------------------------------
_DWORD *__usercall sub_46EB30@<eax>(_DWORD *a1@<esi>, int a2)
{
  int v2; // ebx
  _DWORD *result; // eax

  v2 = *(_DWORD *)(dword_4AB36C + 20);
  result = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)result = 45;
  result[8] = *a1;
  result[9] = a1[1];
  result[10] = a1[2];
  result[11] = a1[3];
  result[12] = a1[4];
  result[13] = a1[5];
  *(_DWORD *)(a2 + 8) = v2;
  result[14] = 8;
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046EB80) --------------------------------------------------------
int __usercall sub_46EB80@<eax>(int a1@<esi>, int a2)
{
  _DWORD *v2; // eax
  int v3; // ecx
  int result; // eax

  v2 = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)v2 = 42;
  v2[10] = *(_DWORD *)(a1 + 8);
  v2[8] = 8;
  v2[14] = 8;
  v3 = 88 * *(_DWORD *)(a2 + 8);
  *(_DWORD *)(v3 + *(_DWORD *)(dword_4AB36C + 16) + 64) = *(_DWORD *)(dword_4AB36C + 20);
  result = sub_46C1B0(v3, *(_DWORD *)(a1 + 8));
  if ( dword_4AB3DC )
  {
    result = dword_4AB36C;
    --*(_DWORD *)(dword_4AB36C + 56);
  }
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;
// 4AB3DC: using guessed type int dword_4AB3DC;

//----- (0046EBE0) --------------------------------------------------------
_DWORD *__usercall sub_46EBE0@<eax>(_DWORD *a1@<esi>, int a2)
{
  int v2; // ebx
  _DWORD *v3; // eax
  _DWORD *result; // eax

  v2 = *(_DWORD *)(dword_4AB36C + 20);
  v3 = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)v3 = 43;
  v3[8] = *a1;
  v3[9] = a1[1];
  v3[10] = a1[2];
  v3[11] = a1[3];
  v3[12] = a1[4];
  v3[13] = a1[5];
  *(_DWORD *)(a2 + 8) = v2;
  v3[14] = 8;
  result = sub_46C830();
  if ( dword_4AB3DC )
  {
    result = (_DWORD *)dword_4AB36C;
    ++*(_DWORD *)(dword_4AB36C + 56);
  }
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;
// 4AB3DC: using guessed type int dword_4AB3DC;

//----- (0046EC40) --------------------------------------------------------
int __usercall sub_46EC40@<eax>(_DWORD *a1@<ebx>, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // eax
  _DWORD *v4; // esi
  int result; // eax

  v3 = sub_40F8F0((_DWORD *)dword_4AB36C);
  v4 = v3;
  *(_BYTE *)v3 = 39;
  if ( a1 )
  {
    v3[2] = 4;
    v3[5] = 0;
    v3[4] = sub_46BF70((_DWORD *)dword_4AB36C);
    *a1 = v4[2];
    a1[1] = v4[3];
    a1[2] = v4[4];
    a1[3] = v4[5];
    a1[4] = v4[6];
    a1[5] = v4[7];
  }
  else
  {
    v3[5] |= 1u;
  }
  v4[8] = *a2;
  v4[9] = a2[1];
  v4[10] = a2[2];
  v4[11] = a2[3];
  v4[12] = a2[4];
  v4[13] = a2[5];
  v4[14] = *a3;
  v4[15] = a3[1];
  v4[16] = a3[2];
  result = a3[3];
  v4[17] = result;
  v4[18] = a3[4];
  v4[19] = a3[5];
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046ECF0) --------------------------------------------------------
_DWORD *__usercall sub_46ECF0@<eax>(_DWORD *a1@<ebx>, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // esi
  _DWORD *result; // eax
  int v5; // edx
  int v6; // ecx
  int v7; // edx
  int v8; // ecx
  int v9; // edx

  v3 = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)v3 = 38;
  v3[2] = 4;
  v3[5] = 0;
  v3[4] = sub_46BF70((_DWORD *)dword_4AB36C);
  v3[8] = *a3;
  v3[9] = a3[1];
  v3[10] = a3[2];
  v3[11] = a3[3];
  v3[12] = a3[4];
  v3[13] = a3[5];
  v3[14] = *a1;
  v3[15] = a1[1];
  v3[16] = a1[2];
  v3[17] = a1[3];
  result = a2;
  v3[18] = a1[4];
  v5 = a1[5];
  *a2 = v3[2];
  v6 = v3[4];
  v3[19] = v5;
  a2[1] = v3[3];
  v7 = v3[5];
  a2[2] = v6;
  v8 = v3[6];
  a2[3] = v7;
  v9 = v3[7];
  a2[4] = v8;
  a2[5] = v9;
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046EDA0) --------------------------------------------------------
_DWORD *__usercall sub_46EDA0@<eax>(_DWORD *a1@<esi>)
{
  _DWORD *result; // eax

  result = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)result = 40;
  result[8] = *a1;
  result[9] = a1[1];
  result[10] = a1[2];
  result[11] = a1[3];
  result[12] = a1[4];
  result[13] = a1[5];
  result[14] = 8;
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046EDE0) --------------------------------------------------------
int __usercall sub_46EDE0@<eax>(_DWORD *a1@<ebx>, _DWORD *a2)
{
  _DWORD *v2; // esi
  int v3; // eax
  int v4; // edx
  int v5; // ecx
  int result; // eax
  int v7; // ecx
  int v8; // edx

  v2 = sub_40F8F0((_DWORD *)dword_4AB36C);
  v2[2] = 2;
  v2[4] = sub_46BF70((_DWORD *)dword_4AB36C);
  *(_BYTE *)v2 = 41;
  v2[8] = *a1;
  v2[9] = a1[1];
  v2[10] = a1[2];
  v2[11] = a1[3];
  v3 = v2[2];
  v2[12] = a1[4];
  v4 = a1[5];
  v5 = v2[3];
  *a2 = v3;
  result = v2[5];
  a2[1] = v5;
  v7 = v2[6];
  v2[13] = v4;
  a2[2] = v2[4];
  v8 = v2[7];
  a2[3] = result;
  v2[14] = 8;
  a2[4] = v7;
  a2[5] = v8;
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046EE60) --------------------------------------------------------
void *__usercall sub_46EE60@<eax>(int a1@<ebx>, _DWORD *a2, int a3, char a4)
{
  char *p_Src; // esi
  int v5; // edx
  void *result; // eax
  char Src; // [esp+10h] [ebp-58h] BYREF
  int v8; // [esp+18h] [ebp-50h]
  int v9; // [esp+1Ch] [ebp-4Ch]
  int v10; // [esp+20h] [ebp-48h]
  int v11; // [esp+24h] [ebp-44h]
  int v12; // [esp+28h] [ebp-40h]
  int v13; // [esp+2Ch] [ebp-3Ch]
  int v14; // [esp+30h] [ebp-38h]
  int v15; // [esp+34h] [ebp-34h]
  int v16; // [esp+38h] [ebp-30h]
  int v17; // [esp+3Ch] [ebp-2Ch]
  int v18; // [esp+40h] [ebp-28h]
  int v19; // [esp+44h] [ebp-24h]
  int v20; // [esp+48h] [ebp-20h]
  int v21; // [esp+4Ch] [ebp-1Ch]
  int v22; // [esp+50h] [ebp-18h]
  int v23; // [esp+54h] [ebp-14h]
  int v24; // [esp+58h] [ebp-10h]
  int v25; // [esp+5Ch] [ebp-Ch]
  int v26; // [esp+60h] [ebp-8h]
  int v27; // [esp+64h] [ebp-4h]

  if ( a3 )
  {
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v27 = dword_4AB35C;
    p_Src = &Src;
    v8 = 8;
    v26 = 0;
    v14 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v20 = 0;
    v21 = 0;
    v22 = 0;
    v23 = 0;
    v24 = 0;
    v25 = 0;
  }
  else
  {
    p_Src = (char *)sub_40F8F0((_DWORD *)dword_4AB36C);
  }
  *p_Src = a4;
  *((_DWORD *)p_Src + 2) = 4;
  *((_DWORD *)p_Src + 5) = 0;
  *((_DWORD *)p_Src + 4) = sub_46BF70((_DWORD *)dword_4AB36C);
  *((_DWORD *)p_Src + 8) = *(_DWORD *)a1;
  *((_DWORD *)p_Src + 9) = *(_DWORD *)(a1 + 4);
  *((_DWORD *)p_Src + 10) = *(_DWORD *)(a1 + 8);
  *((_DWORD *)p_Src + 11) = *(_DWORD *)(a1 + 12);
  v5 = *((_DWORD *)p_Src + 2);
  *((_DWORD *)p_Src + 12) = *(_DWORD *)(a1 + 16);
  *((_DWORD *)p_Src + 13) = *(_DWORD *)(a1 + 20);
  *a2 = v5;
  a2[1] = *((_DWORD *)p_Src + 3);
  a2[2] = *((_DWORD *)p_Src + 4);
  a2[3] = *((_DWORD *)p_Src + 5);
  result = (void *)*((_DWORD *)p_Src + 6);
  a2[4] = result;
  a2[5] = *((_DWORD *)p_Src + 7);
  *((_DWORD *)p_Src + 14) = 8;
  *((_DWORD *)p_Src + 16) = *(_DWORD *)a1 != 1
                         || *(_BYTE *)(a1 + 16) != 3
                         || (result = (void *)zend_hash_exists(
                                                dword_4AB3A0,
                                                *(char **)(a1 + 8),
                                                *(_DWORD *)(a1 + 12) + 1)) == 0;
  if ( a3 )
  {
    zend_stack_top(compiler_globals, &a3);
    return zend_llist_add_element(a3, p_Src);
  }
  return result;
}
// 4AB240: using guessed type _DWORD compiler_globals[3];
// 4AB35C: using guessed type int dword_4AB35C;
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046EFC0) --------------------------------------------------------
_DWORD *__usercall sub_46EFC0@<eax>(_DWORD *a1@<ebx>, char a2, _DWORD *a3, _DWORD *a4)
{
  _DWORD *v4; // esi
  int v5; // ecx
  int v6; // edx
  _DWORD *result; // eax
  int v8; // ecx
  int v9; // edx
  int v10; // ecx
  int v11; // edx

  v4 = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)v4 = a2;
  v4[2] = 4;
  v4[5] = 0;
  v4[4] = sub_46BF70((_DWORD *)dword_4AB36C);
  v4[8] = *a4;
  v4[9] = a4[1];
  v4[10] = a4[2];
  v4[11] = a4[3];
  v4[12] = a4[4];
  v4[13] = a4[5];
  v4[14] = *a1;
  v4[15] = a1[1];
  v4[16] = a1[2];
  v4[17] = a1[3];
  v5 = v4[2];
  v4[18] = a1[4];
  v6 = v4[3];
  v4[19] = a1[5];
  result = a3;
  *a3 = v5;
  v8 = v4[4];
  a3[1] = v6;
  v9 = v4[5];
  a3[2] = v8;
  v10 = v4[6];
  a3[3] = v9;
  v11 = v4[7];
  a3[4] = v10;
  a3[5] = v11;
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046F070) --------------------------------------------------------
int __usercall sub_46F070@<eax>(_DWORD *a1@<ebx>, char a2, _DWORD *a3)
{
  _DWORD *v3; // esi
  int v4; // ecx
  int v5; // eax
  int v6; // edx
  int v7; // ecx
  int v8; // edx
  int result; // eax

  v3 = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)v3 = a2;
  v3[2] = 2;
  v3[4] = sub_46BF70((_DWORD *)dword_4AB36C);
  v3[8] = *a1;
  v3[9] = a1[1];
  v3[10] = a1[2];
  v3[11] = a1[3];
  v4 = v3[2];
  v3[12] = a1[4];
  v5 = a1[5];
  v6 = v3[3];
  *a3 = v4;
  v7 = v3[5];
  a3[1] = v6;
  v8 = v3[6];
  v3[13] = v5;
  a3[2] = v3[4];
  result = v3[7];
  a3[3] = v7;
  a3[4] = v8;
  v3[14] = 8;
  a3[5] = result;
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046F100) --------------------------------------------------------
_DWORD *__usercall sub_46F100@<eax>(_DWORD *a1@<ebx>, char a2, _DWORD *a3, _DWORD *a4)
{
  _DWORD *v4; // esi
  int v5; // ecx
  int v6; // edx
  _DWORD *result; // eax
  int v8; // ecx
  int v9; // edx
  int v10; // ecx
  int v11; // edx

  v4 = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)v4 = a2;
  v4[2] = 2;
  v4[4] = sub_46BF70((_DWORD *)dword_4AB36C);
  v4[8] = *a4;
  v4[9] = a4[1];
  v4[10] = a4[2];
  v4[11] = a4[3];
  v4[12] = a4[4];
  v4[13] = a4[5];
  v4[14] = *a1;
  v4[15] = a1[1];
  v4[16] = a1[2];
  v4[17] = a1[3];
  v5 = v4[2];
  v4[18] = a1[4];
  v6 = v4[3];
  v4[19] = a1[5];
  result = a3;
  *a3 = v5;
  v8 = v4[4];
  a3[1] = v6;
  v9 = v4[5];
  a3[2] = v8;
  v10 = v4[6];
  a3[3] = v9;
  v11 = v4[7];
  a3[4] = v10;
  a3[5] = v11;
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046F1B0) --------------------------------------------------------
int __usercall sub_46F1B0@<eax>(int a1@<esi>, _DWORD *a2)
{
  _DWORD *v2; // eax
  int v3; // ecx
  int result; // eax

  v2 = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)v2 = 42;
  v2[10] = *(_DWORD *)(a1 + 8);
  v2[8] = 8;
  v2[14] = 8;
  v3 = *(_DWORD *)(dword_4AB36C + 16);
  *(_DWORD *)(88 * *(_DWORD *)(a1 + 8) + v3 + 64) = *(_DWORD *)(dword_4AB36C + 20);
  sub_46C1B0(v3, *(_DWORD *)(a1 + 8));
  sub_46DD50(a2);
  result = zend_stack_del_top(dword_4AB258);
  if ( dword_4AB3DC )
  {
    result = dword_4AB36C;
    --*(_DWORD *)(dword_4AB36C + 56);
  }
  return result;
}
// 4AB258: using guessed type _DWORD dword_4AB258[3];
// 4AB36C: using guessed type int dword_4AB36C;
// 4AB3DC: using guessed type int dword_4AB3DC;

//----- (0046F220) --------------------------------------------------------
_DWORD *__cdecl sub_46F220(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // edi
  _DWORD *v4; // esi
  _DWORD *v5; // eax
  int v6; // ecx
  int v7; // edx
  int v8; // eax
  int v9; // ecx
  int v10; // edx
  int v11; // eax
  bool v12; // zf
  _DWORD *v13; // esi
  int v14; // ecx
  int v15; // edx
  int v16; // eax
  int v17; // ecx
  int v18; // edx
  int v19; // eax
  _DWORD *v20; // eax
  _DWORD *result; // eax
  int v22[6]; // [esp+10h] [ebp-48h] BYREF
  int v23[6]; // [esp+28h] [ebp-30h] BYREF
  _DWORD v24[6]; // [esp+40h] [ebp-18h] BYREF

  v3 = a2;
  v4 = sub_40F8F0((_DWORD *)dword_4AB36C);
  if ( *a2 != 8 )
  {
    v5 = a1;
    a1 = a2;
    a2 = v5;
    v3 = v5;
  }
  *(_BYTE *)v4 = 98;
  v4[2] = 4;
  v4[5] = 0;
  v4[4] = sub_46BF70((_DWORD *)dword_4AB36C);
  v4[8] = *a3;
  v4[9] = a3[1];
  v4[10] = a3[2];
  v4[11] = a3[3];
  v6 = v4[2];
  v4[12] = a3[4];
  v7 = v4[3];
  v4[13] = a3[5];
  v8 = v4[4];
  v22[0] = v6;
  v9 = v4[5];
  v22[1] = v7;
  v10 = v4[6];
  v22[2] = v8;
  v11 = v4[7];
  v4[14] = 1;
  *((_BYTE *)v4 + 72) = 1;
  v4[16] = 0;
  v4[20] = 0;
  v12 = *v3 == 8;
  v22[3] = v9;
  v22[4] = v10;
  v22[5] = v11;
  if ( !v12 )
  {
    v13 = sub_40F8F0((_DWORD *)dword_4AB36C);
    *(_BYTE *)v13 = 98;
    v13[2] = 4;
    v13[5] = 0;
    v13[4] = sub_46BF70((_DWORD *)dword_4AB36C);
    v13[8] = *a3;
    v13[9] = a3[1];
    v13[10] = a3[2];
    v13[11] = a3[3];
    v14 = v13[2];
    v13[12] = a3[4];
    v15 = v13[3];
    v13[13] = a3[5];
    v13[14] = 1;
    *((_BYTE *)v13 + 72) = 1;
    v13[16] = 1;
    v16 = v13[4];
    v23[0] = v14;
    v17 = v13[5];
    v23[1] = v15;
    v18 = v13[6];
    v23[2] = v16;
    v19 = v13[7];
    v13[20] = 0;
    v23[3] = v17;
    v23[4] = v18;
    v23[5] = v19;
  }
  sub_46ECF0(v22, v24, a1);
  *(_DWORD *)(88 * *(_DWORD *)(dword_4AB36C + 20) + *(_DWORD *)(dword_4AB36C + 16) - 68) |= 1u;
  if ( *a2 != 8 )
  {
    sub_46ECF0(v23, v24, a2);
    v20 = (_DWORD *)(88 * *(_DWORD *)(dword_4AB36C + 20) + *(_DWORD *)(dword_4AB36C + 16) - 68);
    *v20 |= 1u;
  }
  sub_46E2C0((int)a3);
  result = sub_46C830();
  if ( dword_4AB3DC )
  {
    result = (_DWORD *)dword_4AB36C;
    ++*(_DWORD *)(dword_4AB36C + 56);
  }
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;
// 4AB3DC: using guessed type int dword_4AB3DC;
// 46F220: using guessed type _DWORD var_18[6];

//----- (0046F3E0) --------------------------------------------------------
int __usercall sub_46F3E0@<eax>(_DWORD *a1@<ebx>, int a2, _DWORD *a3)
{
  _DWORD *v3; // esi
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  int result; // eax

  sub_46E750(3, 0);
  v3 = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)v3 = 76;
  v3[2] = 2;
  v3[4] = sub_46BF70((_DWORD *)dword_4AB36C);
  v3[8] = *a1;
  v3[9] = a1[1];
  v3[10] = a1[2];
  v3[11] = a1[3];
  v3[12] = a1[4];
  v4 = a1[5];
  *a3 = v3[2];
  v5 = v3[5];
  v3[13] = v4;
  a3[1] = v3[3];
  v6 = v3[6];
  v3[16] = a2;
  a3[2] = v3[4];
  result = v3[7];
  a3[3] = v5;
  v3[14] = 8;
  a3[4] = v6;
  a3[5] = result;
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046F480) --------------------------------------------------------
int __cdecl sub_46F480(int *a1, int a2)
{
  int *v2; // ebp
  int *v3; // edi
  _DWORD *v4; // ebx
  int v5; // eax
  _DWORD *v6; // esi
  int v7; // edi
  int v8; // ecx
  int v9; // edx
  int v10; // eax
  int *v11; // eax
  int v12; // edx
  int v13; // ecx
  int v14; // edx
  int v15; // ecx
  int v16; // edx
  _DWORD *v18; // [esp+Ch] [ebp-1Ch]
  int v19; // [esp+10h] [ebp-18h]
  int v20; // [esp+14h] [ebp-14h]
  int v21; // [esp+18h] [ebp-10h]
  int v22; // [esp+1Ch] [ebp-Ch]
  int v23; // [esp+20h] [ebp-8h]
  int v24; // [esp+24h] [ebp-4h]

  v2 = (int *)a2;
  v3 = (int *)dword_4AB308;
  a2 = dword_4AB308;
  if ( !dword_4AB308 )
    goto LABEL_17;
  while ( 2 )
  {
    v4 = (_DWORD *)v3[8];
    v5 = (int)(v3 + 8);
    v18 = v3 + 8;
    if ( !v4 )
      goto LABEL_16;
    do
    {
      v6 = sub_40F8F0((_DWORD *)dword_4AB36C);
      if ( v4 == (_DWORD *)*v18 )
      {
        v7 = *v2;
        v22 = v2[3];
        v20 = v2[1];
        v21 = v2[2];
        v23 = v2[4];
        v24 = v2[5];
        if ( *v2 == 1 )
        {
          zval_copy_ctor((int)(v2 + 2));
LABEL_11:
          *(_BYTE *)v6 = 98;
          goto LABEL_14;
        }
        if ( v7 == 2 )
          goto LABEL_11;
        if ( v7 != 4 )
          goto LABEL_14;
      }
      else
      {
        v7 = v19;
      }
      *(_BYTE *)v6 = 81;
LABEL_14:
      v6[2] = 4;
      v6[5] = 0;
      v6[4] = sub_46BF70((_DWORD *)dword_4AB36C);
      v6[8] = v7;
      v6[9] = v20;
      v6[10] = v21;
      v6[11] = v22;
      v6[12] = v23;
      v6[13] = v24;
      v6[14] = 1;
      *((_BYTE *)v6 + 72) = 1;
      v6[16] = v4[2];
      v8 = v6[3];
      *((_WORD *)v6 + 37) = 1;
      v9 = v6[4];
      v6[20] = 1;
      v10 = v6[2];
      *((_BYTE *)v6 + 73) = 0;
      v4 = (_DWORD *)*v4;
      v19 = v10;
      v20 = v8;
      v21 = v9;
      v22 = v6[5];
      v23 = v6[6];
      v24 = v6[7];
    }
    while ( v4 );
    v3 = (int *)a2;
    v5 = (int)v18;
LABEL_16:
    v3[16] = v19;
    v3[17] = v20;
    v3[18] = v21;
    v3[19] = v22;
    v3[20] = v23;
    v3[21] = v24;
    zend_llist_destroy(v5);
    sub_46E750(1, 0);
    sub_46ECF0(v3 + 16, a1, v3 + 2);
    *(_DWORD *)(88 * *(_DWORD *)(dword_4AB36C + 20) + *(_DWORD *)(dword_4AB36C + 16) - 68) |= 1u;
    a2 = *v3;
    if ( a2 )
    {
      v3 = (int *)a2;
      continue;
    }
    break;
  }
LABEL_17:
  zend_llist_destroy((int)&unk_4AB324);
  zend_llist_destroy((int)&dword_4AB308);
  v11 = a1;
  v12 = v2[1];
  *a1 = *v2;
  v13 = v2[2];
  v11[1] = v12;
  v14 = v2[3];
  v11[2] = v13;
  v15 = v2[4];
  v11[3] = v14;
  v16 = v2[5];
  v11[4] = v15;
  v11[5] = v16;
  zend_stack_top(dword_4AB340, &a1);
  qmemcpy(&unk_4AB324, a1, 0x1Cu);
  zend_stack_del_top(dword_4AB340);
  zend_stack_top(dword_4AB340, &a1);
  qmemcpy(&dword_4AB308, a1, 0x1Cu);
  return zend_stack_del_top(dword_4AB340);
}
// 46F51F: variable 'v19' is possibly undefined
// 46F551: variable 'v20' is possibly undefined
// 46F558: variable 'v21' is possibly undefined
// 46F55F: variable 'v22' is possibly undefined
// 46F567: variable 'v23' is possibly undefined
// 46F56A: variable 'v24' is possibly undefined
// 4AB308: using guessed type int dword_4AB308;
// 4AB340: using guessed type _DWORD dword_4AB340[3];
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046F6D0) --------------------------------------------------------
_DWORD *__usercall sub_46F6D0@<eax>(_DWORD *a1@<eax>, int a2@<edi>, _DWORD *a3@<esi>, int a4)
{
  _DWORD *result; // eax
  _DWORD v6[6]; // [esp+8h] [ebp-18h] BYREF

  if ( *a1 == 1 )
    zval_copy_ctor((int)(a1 + 2));
  sub_46DE10(a1, v6, a4, 1, 0);
  sub_46E2C0((int)v6);
  *(_DWORD *)(88 * *(_DWORD *)(a2 + 8) + *(_DWORD *)(dword_4AB36C + 16) + 64) = *(_DWORD *)(dword_4AB36C + 20);
  result = (_DWORD *)(88 * *(_DWORD *)(a2 + 8) + *(_DWORD *)(dword_4AB36C + 16) + 32);
  *a3 = *result;
  a3[1] = result[1];
  a3[2] = result[2];
  a3[3] = result[3];
  a3[4] = result[4];
  a3[5] = result[5];
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;
// 46F6D0: using guessed type _DWORD var_18[6];

//----- (0046F760) --------------------------------------------------------
_DWORD *__usercall sub_46F760@<eax>(int a1@<eax>, int a2@<ebx>)
{
  _DWORD *v3; // ebp
  char *v4; // eax
  char *v6; // esi
  char *v7; // edi
  _DWORD *v8; // esi
  int *v9; // edi
  size_t v10; // eax
  _DWORD *v11; // eax
  _DWORD *v12; // edi
  _BYTE *v13; // edi
  int v14; // [esp+Ch] [ebp-60h]
  int v15; // [esp+10h] [ebp-5Ch] BYREF
  int v16; // [esp+14h] [ebp-58h] BYREF
  int v17[21]; // [esp+18h] [ebp-54h] BYREF

  v3 = sub_40F8F0((_DWORD *)dword_4AB36C);
  v14 = 0;
  if ( dword_4AB2F4 )
  {
    v4 = (char *)sub_473493((int)&unk_4876E8);
    return zend_error(64, v4);
  }
  byte_4AB27C = 2;
  v16 = a1 + 8;
  Src = *(void **)(a1 + 8);
  Size = *(_DWORD *)(a1 + 12);
  dword_4AB28C = (int)emalloc(4);
  *(_DWORD *)dword_4AB28C = 1;
  v6 = (char *)Src;
  v7 = (char *)Src + Size;
  byte_4AB290 = 0;
  if ( Src < (char *)Src + Size )
  {
    do
    {
      *v6 = tolower(*v6);
      ++v6;
    }
    while ( v6 < v7 );
  }
  zend_hash_init((int)&unk_4AB294, 0xAu, 0, (int)destroy_zend_function, 0);
  zend_hash_init((int)&unk_4AB2BC, 0xAu, 0, (int)zval_ptr_dtor, 0);
  dword_4AB2E8 = 0;
  dword_4AB2F0 = 0;
  dword_4AB2EC = 0;
  if ( !a2 )
    goto LABEL_9;
  zend_str_tolower(*(_BYTE **)(a2 + 8), *(_DWORD *)(a2 + 12));
  dword_4AB2F8 = estrndup(*(void **)(a2 + 8), *(_DWORD *)(a2 + 12));
  dword_4AB2FC = *(_DWORD *)(a2 + 12);
  if ( zend_hash_find(dword_4AB374, *(char **)(a2 + 8), *(_DWORD *)(a2 + 12) + 1, &v15) )
  {
    v14 = 1;
LABEL_9:
    dword_4AB288 = 0;
    goto LABEL_10;
  }
  v8 = (_DWORD *)v15;
  zend_hash_copy((int)&unk_4AB294, v15 + 24, (int (__cdecl *)(int))function_add_ref, (int)v17, 0x54u);
  zend_hash_copy((int)&unk_4AB2BC, (int)(v8 + 16), (int (__cdecl *)(int))zval_add_ref, (int)&v16, 4u);
  dword_4AB2E8 = v8[27];
  dword_4AB2EC = v8[28];
  dword_4AB2F0 = v8[29];
  dword_4AB288 = (int)v8;
  zval_dtor(a2 + 8);
LABEL_10:
  v9 = (int *)v16;
  *(_BYTE *)v3 = 100;
  v3[8] = 1;
  v15 = (int)(v3 + 10);
  sub_46C540(v9, (int)(v3 + 10), (int)v3);
  v3[14] = 1;
  *((_BYTE *)v3 + 72) = 3;
  *((_WORD *)v3 + 37) = 1;
  if ( v14 )
  {
    v10 = Size + *(_DWORD *)(a2 + 12) + 1;
    v3[17] = v10;
    v11 = emalloc(v10 + 1);
    v3[16] = v11;
    v12 = v11;
    memcpy(v11, *(const void **)(a2 + 8), *(_DWORD *)(a2 + 12));
    v13 = (char *)v12 + *(_DWORD *)(a2 + 12);
    *v13++ = 58;
    memcpy(v13, Src, Size);
    zval_dtor(a2 + 8);
    v13[Size] = 0;
    v3[20] = 3;
  }
  else
  {
    v3[16] = estrndup(Src, Size);
    v3[17] = Size;
    v3[20] = 1;
  }
  return (_DWORD *)zend_hash_add_or_update(
                     dword_4AB374,
                     *(char **)v15,
                     v3[11],
                     (size_t *)&byte_4AB27C,
                     0x78u,
                     &dword_4AB2F4,
                     1);
}
// 4AB27C: using guessed type char byte_4AB27C;
// 4AB288: using guessed type int dword_4AB288;
// 4AB28C: using guessed type int dword_4AB28C;
// 4AB290: using guessed type char byte_4AB290;
// 4AB2E8: using guessed type int dword_4AB2E8;
// 4AB2EC: using guessed type int dword_4AB2EC;
// 4AB2F0: using guessed type int dword_4AB2F0;
// 4AB2F4: using guessed type int dword_4AB2F4;
// 4AB36C: using guessed type int dword_4AB36C;
// 46F760: using guessed type int var_54[21];

//----- (0046F9F0) --------------------------------------------------------
void __usercall sub_46F9F0(void *a1@<ecx>, int a2@<esi>)
{
  void *v2; // edi
  void *Src; // [esp+0h] [ebp-4h] BYREF

  Src = a1;
  if ( *(_DWORD *)(a2 + 12)
    && !zend_hash_exists(a2 + 24, *(char **)(a2 + 4), *(_DWORD *)(a2 + 8) + 1)
    && !zend_hash_find(
          *(_DWORD *)(a2 + 12) + 24,
          *(char **)(*(_DWORD *)(a2 + 12) + 4),
          *(_DWORD *)(*(_DWORD *)(a2 + 12) + 8) + 1,
          &Src) )
  {
    v2 = Src;
    zend_hash_add_or_update(a2 + 24, *(char **)(a2 + 4), *(_DWORD *)(a2 + 8) + 1, (size_t *)Src, 0x54u, 0, 1);
    function_add_ref((int)v2);
  }
}

//----- (0046FA60) --------------------------------------------------------
_DWORD *__usercall sub_46FA60@<eax>(_DWORD *a1@<esi>, int a2)
{
  _DWORD *result; // eax
  int v3; // edx

  if ( a2 )
  {
    if ( *(_BYTE *)(dword_4AB36C + 60) )
      sub_46E750(1, 0);
    else
      sub_46E750(0, 0);
  }
  zend_stack_apply(dword_4AB24C, 1, (int (__cdecl *)(_DWORD))sub_46DDB0);
  zend_stack_apply(dword_4AB258, 1, (int (__cdecl *)(_DWORD))sub_46DD50);
  result = sub_40F8F0((_DWORD *)dword_4AB36C);
  *(_BYTE *)result = 62;
  if ( a1 )
  {
    result[8] = *a1;
    result[9] = a1[1];
    result[10] = a1[2];
    result[11] = a1[3];
    result[12] = a1[4];
    v3 = a1[5];
  }
  else
  {
    result[8] = 1;
    result[10] = zval_used_for_init;
    result[11] = dword_4AAED4;
    result[12] = dword_4AAED8;
    v3 = dword_4AAEDC;
  }
  result[14] = 8;
  result[13] = v3;
  return result;
}
// 46DDB0: using guessed type int sub_46DDB0();
// 4AAED0: using guessed type int zval_used_for_init;
// 4AAED4: using guessed type int dword_4AAED4;
// 4AAED8: using guessed type int dword_4AAED8;
// 4AAEDC: using guessed type int dword_4AAEDC;
// 4AB24C: using guessed type _DWORD dword_4AB24C[3];
// 4AB258: using guessed type _DWORD dword_4AB258[3];
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046FB20) --------------------------------------------------------
_DWORD *__usercall sub_46FB20@<eax>(int a1@<eax>, int a2, int a3)
{
  _DWORD *v3; // ebp
  int v4; // ebx
  int v5; // esi
  char *v6; // eax
  unsigned __int8 *v7; // eax
  int v8; // ecx
  int v9; // edi
  char *v10; // eax
  _DWORD *result; // eax
  int v12; // edx

  v3 = (_DWORD *)a2;
  v4 = a1;
  zend_stack_top(dword_4AB34C, &a2);
  v5 = *(_DWORD *)a2;
  if ( v4 == 67 && !byte_4AB3A7 )
  {
    if ( dword_4AE2A4 )
      v6 = (char *)sub_473493((int)&unk_487438);
    else
      v6 = (char *)sub_473493((int)&unk_4874F8);
    zend_error(128, v6);
  }
  if ( v5 && (v7 = *(unsigned __int8 **)(v5 + 4)) != 0 )
  {
    v8 = *v7;
    v9 = a3;
    if ( a3 > v8 )
      goto LABEL_12;
    if ( v7[a3] == 1 )
    {
LABEL_13:
      a2 = 1;
      goto LABEL_16;
    }
    if ( a3 >= v8 )
    {
LABEL_12:
      if ( v7[v8] == 3 )
        goto LABEL_13;
    }
  }
  else
  {
    v9 = a3;
  }
  a2 = 0;
LABEL_16:
  if ( v4 == 65 )
  {
    if ( *v3 == 4 )
    {
      v4 = 106;
      goto LABEL_24;
    }
  }
  else if ( v4 == 106 )
  {
    goto LABEL_24;
  }
  if ( a2 == 1 )
  {
    if ( *v3 == 4 )
    {
      v4 = 67;
    }
    else
    {
      v10 = (char *)sub_473493((int)&unk_4875A8);
      zend_error(64, v10);
    }
  }
LABEL_24:
  if ( a1 != 66 )
    goto LABEL_32;
  switch ( v4 )
  {
    case 'B':
      if ( v5 )
      {
LABEL_28:
        sub_46E750(0, 0);
        break;
      }
      sub_46E750(5, v9);
      break;
    case 'C':
      sub_46E750(1, 0);
      break;
    case 'j':
      goto LABEL_28;
    default:
      break;
  }
LABEL_32:
  result = sub_40F8F0((_DWORD *)dword_4AB36C);
  if ( v4 == 106 )
  {
    if ( v5 )
      result[20] = a2 | 2;
    else
      result[20] = 0;
  }
  else
  {
    result[20] = 61 - (v5 != 0);
  }
  *(_BYTE *)result = v4;
  result[8] = *v3;
  result[9] = v3[1];
  result[10] = v3[2];
  result[11] = v3[3];
  result[12] = v3[4];
  v12 = a3;
  result[13] = v3[5];
  result[16] = v12;
  result[14] = 8;
  return result;
}
// 4AB34C: using guessed type _DWORD dword_4AB34C[3];
// 4AB36C: using guessed type int dword_4AB36C;
// 4AB3A7: using guessed type char byte_4AB3A7;
// 4AE2A4: using guessed type int dword_4AE2A4;

//----- (0046FCA0) --------------------------------------------------------
void __usercall sub_46FCA0(_DWORD **a1@<ecx>, _DWORD *a2@<esi>)
{
  bool v2; // zf
  int v3; // eax
  _DWORD *v4; // eax
  _DWORD **Src; // [esp+0h] [ebp-4h] BYREF

  Src = a1;
  v2 = *a2 == 1;
  Src = 0;
  if ( v2 )
    goto LABEL_5;
  if ( !sub_46BF30(a1) )
  {
    sub_46E750(0, 0);
LABEL_5:
    v4 = sub_40F8F0((_DWORD *)dword_4AB36C);
    *(_BYTE *)v4 = 59;
    v4[14] = *a2;
    v4[15] = a2[1];
    v4[16] = a2[2];
    v4[17] = a2[3];
    v4[18] = a2[4];
    v4[19] = a2[5];
    v4[20] = 0;
    v4[8] = 8;
    goto LABEL_6;
  }
  sub_46E750(1, 0);
  v3 = 88 * *(_DWORD *)(dword_4AB36C + 20) + *(_DWORD *)(dword_4AB36C + 16) - 88;
  *(_BYTE *)v3 = 59;
  *(_DWORD *)(v3 + 80) = 1;
LABEL_6:
  zend_stack_push(dword_4AB34C, &Src, 4u);
  sub_46CAC0();
}
// 4AB34C: using guessed type _DWORD dword_4AB34C[3];
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046FD50) --------------------------------------------------------
int __usercall sub_46FD50@<eax>(int *a1@<ebx>)
{
  _BYTE *v1; // esi
  _BYTE *i; // edi
  int v3; // eax
  int v4; // ecx
  int v5; // eax
  int v6; // ecx
  _DWORD **v7; // ecx
  int Src; // [esp+Ch] [ebp-20h] BYREF
  int v10[2]; // [esp+10h] [ebp-1Ch] BYREF
  int v11[5]; // [esp+18h] [ebp-14h] BYREF

  v1 = (_BYTE *)a1[2];
  for ( i = &v1[a1[3]]; v1 < i; ++v1 )
    *v1 = tolower((char)*v1);
  if ( zend_hash_find(dword_4AB370, (char *)a1[2], a1[3] + 1, &Src) == -1 )
  {
    v3 = a1[1];
    v4 = a1[2];
    v10[0] = *a1;
    v11[1] = a1[3];
    v10[1] = v3;
    v5 = a1[4];
    v11[0] = v4;
    v6 = a1[5];
    v11[2] = v5;
    v11[3] = v6;
    zval_copy_ctor((int)v11);
    sub_46FCA0(v7, v10);
    return 1;
  }
  else
  {
    if ( *(_BYTE *)Src == 1 || *(_BYTE *)Src == 2 )
      zend_stack_push(dword_4AB34C, &Src, 4u);
    sub_46CAC0();
    return 0;
  }
}
// 46FDD0: variable 'v7' is possibly undefined
// 4AB34C: using guessed type _DWORD dword_4AB34C[3];

//----- (0046FE30) --------------------------------------------------------
int __cdecl sub_46FE30(int a1)
{
  sub_46CAF0();
  sub_46FA60(0, 0);
  sub_40FA00(dword_4AB36C);
  dword_4AB36C = *(_DWORD *)(a1 + 8);
  zend_stack_del_top(dword_4AB24C);
  return zend_stack_del_top(dword_4AB258);
}
// 4AB24C: using guessed type _DWORD dword_4AB24C[3];
// 4AB258: using guessed type _DWORD dword_4AB258[3];
// 4AB36C: using guessed type int dword_4AB36C;

//----- (0046FE80) --------------------------------------------------------
void *__usercall sub_46FE80@<eax>(int a1@<eax>, _DWORD *a2@<ecx>, int a3@<ebx>)
{
  return sub_46EE60(a3, a2, a1, 83);
}

//----- (0046FE90) --------------------------------------------------------
void *__usercall sub_46FE90@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<esi>, int a3)
{
  int i; // edi
  int v5; // ecx
  int v6; // edx
  int v7; // eax
  int v8; // ecx
  int v9; // edx

  sub_46E750(0, 0);
  for ( i = 1; i < *(_DWORD *)(a3 + 8); a1[5] = v9 )
  {
    sub_46EE60((int)a1, a2, 0, 80);
    v5 = a2[1];
    v6 = a2[2];
    *a1 = *a2;
    v7 = a2[3];
    a1[1] = v5;
    v8 = a2[4];
    a1[2] = v6;
    v9 = a2[5];
    a1[3] = v7;
    a1[4] = v8;
    ++i;
  }
  sub_46C800();
  return sub_46FE80(1, a2, (int)a1);
}

//----- (0046FF00) --------------------------------------------------------
int __usercall sub_46FF00@<eax>(int a1@<eax>, _DWORD *a2, int a3)
{
  _DWORD *v4; // esi
  _DWORD *v5; // edi
  int v6; // edx
  int v7; // eax
  int v8; // ecx
  int v9; // edx
  int v10; // eax
  int v11; // ecx
  bool v12; // zf
  int v13; // eax
  int v14; // edx
  _DWORD *Src; // [esp+14h] [ebp-38h] BYREF
  int v17[6]; // [esp+18h] [ebp-34h] BYREF
  _DWORD v18[7]; // [esp+30h] [ebp-1Ch] BYREF

  v4 = sub_40F8F0((_DWORD *)dword_4AB36C);
  if ( a3 == 2 && a2 )
  {
    v5 = emalloc(16);
    Src = v5;
    convert_to_string(a1 + 8);
    *v5 = a2[2];
    v5[1] = a2[3];
    v5[2] = a2[4];
    v5[3] = a2[5];
    if ( !*(_DWORD *)(dword_4AB36C + 48) )
    {
      *(_DWORD *)(dword_4AB36C + 48) = emalloc(40);
      zend_hash_init(*(_DWORD *)(dword_4AB36C + 48), 2u, 0, (int)zval_ptr_dtor, 0);
    }
    zend_hash_add_or_update(
      *(_DWORD *)(dword_4AB36C + 48),
      *(char **)(a1 + 8),
      *(_DWORD *)(a1 + 12) + 1,
      (size_t *)&Src,
      4u,
      0,
      1);
  }
  *(_BYTE *)v4 = 83;
  v4[2] = 4;
  v4[5] = 0;
  v4[4] = sub_46BF70((_DWORD *)dword_4AB36C);
  v4[8] = *(_DWORD *)a1;
  v4[9] = *(_DWORD *)(a1 + 4);
  v4[10] = *(_DWORD *)(a1 + 8);
  v4[11] = *(_DWORD *)(a1 + 12);
  v4[12] = *(_DWORD *)(a1 + 16);
  v6 = v4[2];
  v4[13] = *(_DWORD *)(a1 + 20);
  v7 = v4[3];
  v4[16] = a3;
  v8 = v4[4];
  v17[0] = v6;
  v9 = v4[5];
  v17[1] = v7;
  v10 = v4[6];
  v17[2] = v8;
  v11 = v4[7];
  v4[14] = 8;
  v12 = *(_DWORD *)a1 == 1;
  v17[3] = v9;
  v17[4] = v10;
  v17[5] = v11;
  if ( v12 )
    zval_copy_ctor(a1 + 8);
  sub_46FE80(0, v18, a1);
  sub_46EC40(0, v18, v17);
  v13 = *(_DWORD *)(dword_4AB36C + 16);
  v14 = 88 * *(_DWORD *)(dword_4AB36C + 20);
  *(_DWORD *)(v14 + v13 - 68) |= 1u;
  return v14 + v13 - 68;
}
// 4AB36C: using guessed type int dword_4AB36C;
// 46FF00: using guessed type _DWORD var_1C[7];

//----- (00470090) --------------------------------------------------------
void *__thiscall sub_470090(void *this)
{
  void *result; // eax

  sub_46F9F0(this, dword_4AB2F4);
  result = dword_4AB2F8;
  dword_4AB2F4 = 0;
  if ( dword_4AB2F8 )
  {
    result = (void *)efree((int)dword_4AB2F8);
    dword_4AB2F8 = 0;
  }
  return result;
}
// 4AB2F4: using guessed type int dword_4AB2F4;

//----- (004700C0) --------------------------------------------------------
void __usercall sub_4700C0(_DWORD *a1@<eax>, _DWORD *a2@<edi>)
{
  void *v3; // ecx
  bool v4; // zf
  int v5; // [esp+4h] [ebp-58h] BYREF
  int v6[21]; // [esp+8h] [ebp-54h] BYREF

  zend_hash_merge((int)(a1 + 16), (int)(a2 + 16), (int (__cdecl *)(_DWORD))zval_add_ref, (int)&v5, 4u, 0);
  zend_hash_merge((int)(a1 + 6), (int)(a2 + 6), (int (__cdecl *)(_DWORD))function_add_ref, (int)v6, 0x54u, 0);
  v4 = a1[28] == 0;
  a1[3] = a2;
  if ( v4 )
    a1[28] = a2[28];
  if ( !a1[29] )
  {
    v3 = (void *)a2[29];
    a1[29] = v3;
  }
  if ( !a1[27] )
    a1[27] = a2[27];
  sub_46F9F0(v3, (int)a1);
}
// 470126: variable 'v3' is possibly undefined
// 4700C0: using guessed type int var_54[21];

//----- (00470130) --------------------------------------------------------
void *__usercall sub_470130@<eax>(int *a1@<eax>, int a2@<ecx>, int *a3@<esi>)
{
  sub_46FE80(1, a1, a2);
  return sub_46C390(a1, a1, a3);
}

//----- (00470150) --------------------------------------------------------
int __cdecl do_bind_function_or_class(_DWORD *Src, int a2, int a3, int a4)
{
  _DWORD *v4; // esi
  int v5; // edi
  char *v6; // ebx
  char *v7; // eax
  char *v8; // ebx
  char *v9; // eax
  _BYTE *v10; // eax
  size_t v11; // edi
  char *v12; // ebp
  char *v13; // eax
  size_t *v15; // ebp
  char *v16; // eax
  int v17; // edi
  _DWORD *v18; // ebx
  char *v19; // eax
  char *v20; // eax
  int v21; // ebx
  char *v22; // eax
  size_t *v23; // edi
  char *v24; // eax
  int v25; // [esp-Ch] [ebp-1Ch]
  int v26; // [esp-8h] [ebp-18h]
  int v27; // [esp-8h] [ebp-18h]
  int v28; // [esp-4h] [ebp-14h]
  int v29; // [esp-4h] [ebp-14h]
  int v30; // [esp-4h] [ebp-14h]
  int v31; // [esp-4h] [ebp-14h]
  int v32; // [esp+Ch] [ebp-4h] BYREF

  v4 = Src;
  if ( Src[20] == 1 )
  {
    v21 = a3;
    if ( zend_hash_find(a3, (char *)Src[10], Src[11], &Src) == -1 )
    {
      v30 = v4[10];
      v22 = (char *)sub_473493((int)&unk_487624);
      zend_error(1, v22, v30);
      return -1;
    }
    v23 = Src;
    ++*(_DWORD *)Src[4];
    if ( zend_hash_add_or_update(v21, (char *)v4[16], v4[17] + 1, v23, 0x78u, 0, 2) == -1 )
    {
      --*(_DWORD *)v23[4];
      if ( !a4 )
      {
        v31 = v4[16];
        v24 = (char *)sub_473493((int)&unk_487660);
        zend_error(1, v24, v31);
      }
      return -1;
    }
    return 0;
  }
  if ( Src[20] == 2 )
  {
    v17 = a2;
    zend_hash_find(a2, (char *)Src[10], Src[11], &Src);
    v18 = Src;
    if ( zend_hash_add_or_update(v17, (char *)v4[16], v4[17] + 1, Src, 0x54u, 0, 2) == -1 )
    {
      if ( !a4 )
      {
        if ( !zend_hash_find(v17, (char *)v4[16], v4[17] + 1, &Src) && *(_BYTE *)Src == 2 && Src[5] )
        {
          v28 = *(_DWORD *)(Src[4] + 84);
          v27 = Src[16];
          v25 = v4[16];
          v19 = (char *)sub_473493((int)&unk_4875D4);
          zend_error(1, v19, v25, v27, v28);
          return -1;
        }
        v29 = v4[16];
        v20 = (char *)sub_473493((int)&unk_48760C);
        zend_error(1, v20, v29);
      }
      return -1;
    }
    ++*(_DWORD *)v18[3];
    v18[12] = 0;
    return 0;
  }
  if ( Src[20] != 3 )
    return -1;
  v5 = zend_hash_find(a3, (char *)Src[10], Src[11], &Src);
  v6 = strchr((const char *)v4[16], 58);
  if ( !v6 )
  {
    v7 = (char *)sub_473493((int)&unk_48767C);
    zend_error(16, v7);
  }
  v8 = v6 + 1;
  if ( v5 == -1 )
  {
    v9 = (char *)sub_473493((int)&unk_487660);
    zend_error(1, v9, v8);
    return -1;
  }
  ++*(_DWORD *)Src[4];
  v10 = (_BYTE *)v4[16];
  v11 = v8 - v10 - 1;
  v12 = (char *)estrndup(v10, v11);
  if ( zend_hash_find(a3, v12, v11 + 1, &v32) == -1 )
  {
    if ( !a4 )
    {
      v13 = (char *)sub_473493((int)&unk_48769C);
      zend_error(1, v13, v8, v12);
    }
    --*(_DWORD *)Src[4];
    efree((int)v12);
    return -1;
  }
  else
  {
    efree((int)v12);
    v15 = Src;
    sub_4700C0(Src, (_DWORD *)v32);
    if ( zend_hash_add_or_update(a3, v8, strlen(v8) + 1, v15, 0x78u, 0, 2) == -1 )
    {
      if ( !a4 )
      {
        v26 = v4[16];
        v16 = (char *)sub_473493((int)&unk_487660);
        zend_error(1, v16, v26);
      }
      --*(_DWORD *)v15[4];
      zend_hash_destroy(v15 + 6);
      zend_hash_destroy(v15 + 16);
      return -1;
    }
    else
    {
      return 0;
    }
  }
}

//----- (00470410) --------------------------------------------------------
int sub_470410()
{
  int v0; // esi
  int result; // eax
  char *v2; // eax
  _DWORD *v3; // eax

  v0 = 88 * *(_DWORD *)(dword_4AB36C + 20) + *(_DWORD *)(dword_4AB36C + 16) - 88;
  result = do_bind_function_or_class((_DWORD *)v0, dword_4AB370, dword_4AB374, 1);
  if ( result != -1 )
  {
    if ( *(_DWORD *)(v0 + 80) == 1 )
    {
      v3 = (_DWORD *)dword_4AB374;
    }
    else
    {
      if ( *(_DWORD *)(v0 + 80) != 2 )
      {
        v2 = (char *)sub_473493((int)&unk_4876D0);
        return (int)zend_error(64, v2);
      }
      v3 = (_DWORD *)dword_4AB370;
    }
    zend_hash_del_key_or_index(v3, *(char **)(v0 + 40), *(_DWORD *)(v0 + 44), 0, 0);
    zval_dtor(v0 + 40);
    zval_dtor(v0 + 64);
    *(_BYTE *)v0 = 0;
    *(_DWORD *)(v0 + 36) = 0;
    *(_DWORD *)(v0 + 40) = 0;
    *(_DWORD *)(v0 + 44) = 0;
    *(_DWORD *)(v0 + 48) = 0;
    *(_DWORD *)(v0 + 52) = 0;
    *(_DWORD *)(v0 + 60) = 0;
    *(_DWORD *)(v0 + 64) = 0;
    *(_DWORD *)(v0 + 68) = 0;
    *(_DWORD *)(v0 + 72) = 0;
    *(_DWORD *)(v0 + 76) = 0;
    result = 8;
    *(_DWORD *)(v0 + 32) = 8;
    *(_DWORD *)(v0 + 56) = 8;
  }
  return result;
}
// 4AB36C: using guessed type int dword_4AB36C;

//----- (004704D0) --------------------------------------------------------
_DWORD *__cdecl shutdown_memory_manager(int a1, int a2)
{
  _DWORD *result; // eax
  unsigned int *v3; // esi
  LPVOID **v4; // ebp
  unsigned int v5; // edi
  LPVOID **v6; // ebx
  LPVOID *v7; // eax
  _DWORD *v8; // esi
  int v9; // [esp+8h] [ebp+8h]

  if ( a2 && dword_4AE040 )
    return (_DWORD *)HeapDestroy(dword_4AE040);
  v3 = (unsigned int *)&unk_4AE008;
  v4 = (LPVOID **)&unk_4AB804;
  v9 = 10;
  do
  {
    v5 = 0;
    if ( *v3 )
    {
      v6 = v4;
      do
      {
        v7 = *v6;
        if ( *v6 == alloc_globals )
          alloc_globals = **v6;
        else
          *(_DWORD *)v7[1] = **v6;
        if ( *v7 )
          *((_DWORD *)*v7 + 1) = v7[1];
        if ( dword_4AE040 )
          HeapFree(dword_4AE040, 1u, v7);
        else
          free(v7);
        ++v5;
        ++v6;
      }
      while ( v5 < *v3 );
    }
    *v3 = 0;
    v4 += 256;
    ++v3;
    --v9;
  }
  while ( v9 );
  result = alloc_globals;
  if ( alloc_globals )
  {
    do
    {
      if ( (result[2] & 0x80000000) != 0 )
      {
        result = (_DWORD *)*result;
      }
      else
      {
        v8 = (_DWORD *)*result;
        if ( result == alloc_globals )
          alloc_globals = (LPVOID)*result;
        else
          *(_DWORD *)result[1] = *result;
        if ( *result )
          *(_DWORD *)(*result + 4) = result[1];
        if ( dword_4AE040 )
          HeapFree(dword_4AE040, 1u, result);
        else
          free(result);
        result = v8;
      }
    }
    while ( result );
  }
  return result;
}

//----- (004705E0) --------------------------------------------------------
HANDLE start_memory_manager()
{
  HANDLE result; // eax

  alloc_globals = 0;
  memset(&dword_4AE004, 0, 0x2Cu);
  result = HeapCreate(1u, 0x40000u, 0);
  dword_4AE040 = result;
  return result;
}
// 4AE004: using guessed type int dword_4AE004;

//----- (00470610) --------------------------------------------------------
int zend_set_memory_limit()
{
  return -1;
}

//----- (00470620) --------------------------------------------------------
_BYTE *__cdecl zend_strndup(void *Src, size_t Size)
{
  _BYTE *result; // eax
  _BYTE *v3; // esi

  result = malloc(Size + 1);
  v3 = result;
  if ( result )
  {
    if ( Size )
      memcpy(result, Src, Size);
    v3[Size] = 0;
    return v3;
  }
  return result;
}

//----- (00470660) --------------------------------------------------------
unsigned int __cdecl efree(int a1)
{
  _DWORD *v1; // esi
  unsigned int result; // eax
  unsigned int v3; // ecx

  v1 = (_DWORD *)(a1 - 16);
  result = ((*(_DWORD *)(a1 - 8) & 0x7FFFFFFFu) + 7) >> 3;
  if ( result >= 0xB || (v3 = dword_4AE004[result], v3 >= 0x100) )
  {
    if ( zend_block_interruptions )
      zend_block_interruptions();
    if ( v1 == alloc_globals )
      alloc_globals = (LPVOID)*v1;
    else
      *(_DWORD *)v1[1] = *v1;
    if ( *v1 )
      *(_DWORD *)(*v1 + 4) = v1[1];
    if ( dword_4AE040 )
      HeapFree(dword_4AE040, 1u, v1);
    else
      free(v1);
    result = (unsigned int)zend_unblock_interruptions;
    if ( zend_unblock_interruptions )
      return zend_unblock_interruptions();
  }
  else
  {
    dword_4AB404[256 * result + v3] = (int)v1;
    ++dword_4AE004[result];
    v1[2] |= 0x80000000;
  }
  return result;
}
// 4AAEBC: using guessed type int (*zend_unblock_interruptions)(void);
// 4AAF78: using guessed type int (*zend_block_interruptions)(void);
// 4AB404: using guessed type int dword_4AB404[256];
// 4AE004: using guessed type int dword_4AE004[];

//----- (00470700) --------------------------------------------------------
_DWORD *__cdecl emalloc(int a1)
{
  unsigned int v1; // eax
  int v2; // edx
  int v3; // eax
  _DWORD *v5; // eax
  _DWORD *v6; // esi
  FILE *v7; // eax
  const char *v8; // [esp-Ch] [ebp-10h]
  SIZE_T v9; // [esp-8h] [ebp-Ch]

  v1 = ((a1 + 7) & 0xFFFFFFF8) >> 3;
  if ( v1 < 0xB && (v2 = dword_4AE004[v1]) != 0 )
  {
    dword_4AE004[v1] = v2 - 1;
    v3 = dword_4AB404[256 * v1 - 1 + v2];
    *(_DWORD *)(v3 + 8) = a1 & 0x7FFFFFFF;
    return (_DWORD *)(v3 + 16);
  }
  else
  {
    v9 = ((a1 + 7) & 0xFFFFFFF8) + 16;
    if ( dword_4AE040 )
      v5 = HeapAlloc(dword_4AE040, 1u, v9);
    else
      v5 = malloc(v9);
    v6 = v5;
    if ( zend_block_interruptions )
      zend_block_interruptions();
    if ( !v6 )
    {
      v8 = (const char *)sub_473493((int)&unk_487314);
      v7 = (FILE *)sub_44F01A();
      fprintf(v7 + 2, v8, a1);
      exit(1);
    }
    v6[2] &= ~0x80000000;
    *v6 = alloc_globals;
    if ( alloc_globals )
      *((_DWORD *)alloc_globals + 1) = v6;
    alloc_globals = v6;
    v6[2] ^= (a1 ^ v6[2]) & 0x7FFFFFFF;
    v6[1] = 0;
    if ( zend_unblock_interruptions )
      zend_unblock_interruptions();
    return v6 + 4;
  }
}
// 4AAEBC: using guessed type int (*zend_unblock_interruptions)(void);
// 4AAF78: using guessed type int (*zend_block_interruptions)(void);
// 4AB404: using guessed type int dword_4AB404[256];
// 4AE004: using guessed type int dword_4AE004[];

//----- (004707F0) --------------------------------------------------------
_DWORD *__cdecl estrndup(void *Src, size_t Size)
{
  _DWORD *v2; // esi

  if ( zend_block_interruptions )
    zend_block_interruptions();
  v2 = emalloc(Size + 1);
  if ( v2 )
  {
    if ( zend_unblock_interruptions )
      zend_unblock_interruptions();
    memcpy(v2, Src, Size);
    *((_BYTE *)v2 + Size) = 0;
    return v2;
  }
  else
  {
    if ( zend_unblock_interruptions )
      zend_unblock_interruptions();
    return 0;
  }
}
// 4AAEBC: using guessed type int (*zend_unblock_interruptions)(void);
// 4AAF78: using guessed type int (*zend_block_interruptions)(void);

//----- (00470850) --------------------------------------------------------
_DWORD *__cdecl estrdup(const char *Src)
{
  char v1; // cl
  unsigned int v2; // edi
  _DWORD *v3; // esi

  v2 = strlen(Src) + 1;
  if ( zend_block_interruptions )
    zend_block_interruptions(v1);
  v3 = emalloc(v2);
  if ( v3 )
  {
    if ( zend_unblock_interruptions )
      zend_unblock_interruptions();
    memcpy(v3, Src, v2);
    return v3;
  }
  else
  {
    if ( zend_unblock_interruptions )
      zend_unblock_interruptions();
    return 0;
  }
}
// 470875: variable 'v1' is possibly undefined
// 4AAEBC: using guessed type int (*zend_unblock_interruptions)(void);
// 4AAF78: using guessed type int (__thiscall *zend_block_interruptions)(_DWORD);

//----- (004708B0) --------------------------------------------------------
_DWORD *__cdecl erealloc(int a1, int a2, int a3)
{
  _DWORD *v4; // edi
  _DWORD *v5; // eax
  _DWORD *v6; // esi
  FILE *v7; // eax
  const char *v8; // [esp-14h] [ebp-14h]
  SIZE_T v9; // [esp-10h] [ebp-10h]

  if ( !a1 )
    return emalloc(a2);
  v4 = (_DWORD *)(a1 - 16);
  if ( zend_block_interruptions )
    zend_block_interruptions();
  if ( v4 == alloc_globals )
    alloc_globals = (LPVOID)*v4;
  else
    *(_DWORD *)v4[1] = *v4;
  if ( *v4 )
    *(_DWORD *)(*v4 + 4) = v4[1];
  v9 = ((a2 + 7) & 0xFFFFFFF8) + 16;
  if ( dword_4AE040 )
    v5 = HeapReAlloc(dword_4AE040, 1u, v4, v9);
  else
    v5 = realloc(v4, v9);
  v6 = v5;
  if ( v5 )
  {
    *v5 = alloc_globals;
    if ( alloc_globals )
      *((_DWORD *)alloc_globals + 1) = v5;
    alloc_globals = v5;
    v5[2] ^= (a2 ^ v5[2]) & 0x7FFFFFFF;
    v5[1] = 0;
    if ( zend_unblock_interruptions )
      zend_unblock_interruptions();
    return v6 + 4;
  }
  else
  {
    if ( !a3 )
    {
      v8 = (const char *)sub_473493((int)&unk_487384);
      v7 = (FILE *)sub_44F01A();
      fprintf(v7 + 2, v8, a2);
      exit(1);
    }
    *v4 = alloc_globals;
    if ( alloc_globals )
      *((_DWORD *)alloc_globals + 1) = v4;
    alloc_globals = (LPVOID)(a1 - 16);
    v4[1] = 0;
    if ( zend_unblock_interruptions )
      zend_unblock_interruptions();
    return 0;
  }
}
// 4AAEBC: using guessed type int (*zend_unblock_interruptions)(void);
// 4AAF78: using guessed type int (*zend_block_interruptions)(void);

//----- (004709D0) --------------------------------------------------------
_DWORD *__cdecl ecalloc(unsigned int a1, int a2)
{
  size_t v2; // esi
  FILE *v3; // eax
  _DWORD *v4; // eax
  _DWORD *v5; // edi
  const char *v7; // [esp-Ch] [ebp-14h]

  v2 = a2 * a1;
  if ( a1 && v2 / a1 != a2 )
  {
    v7 = (const char *)sub_473493((int)&unk_487348);
    v3 = (FILE *)sub_44F01A();
    fprintf(v3 + 2, v7, a1, a2);
    exit(1);
  }
  v4 = emalloc(a2 * a1);
  v5 = v4;
  if ( v4 )
    memset(v4, 0, v2);
  return v5;
}

//----- (00470A40) --------------------------------------------------------
int __cdecl zend_hash_next_free_element(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (00470A50) --------------------------------------------------------
int __cdecl zend_hash_minmax(_DWORD *a1, int (__cdecl *a2)(_DWORD **, _DWORD **), int a3, _DWORD *a4)
{
  int v4; // ecx
  int v6; // esi
  int (__cdecl *v7)(_DWORD **, _DWORD **); // edi
  int v8; // eax
  _DWORD *v9; // [esp+0h] [ebp-4h] BYREF

  v9 = (_DWORD *)v4;
  if ( !a1[2] )
  {
    *a4 = 0;
    return -1;
  }
  v9 = (_DWORD *)a1[5];
  a1 = (_DWORD *)v9[4];
  if ( a1 )
  {
    v6 = a3;
    v7 = a2;
    do
    {
      v8 = v7(&v9, &a1);
      if ( v6 )
      {
        if ( v8 < 0 )
          goto LABEL_9;
      }
      else if ( v8 > 0 )
      {
LABEL_9:
        v9 = a1;
      }
      a1 = (_DWORD *)a1[4];
    }
    while ( a1 );
  }
  *a4 = v9[2];
  return 0;
}
// 470A50: variable 'v4' is possibly undefined

//----- (00470AE0) --------------------------------------------------------
int __cdecl zend_hash_get_current_data_ex(int a1, _DWORD *a2, int *a3)
{
  int v3; // eax

  if ( a3 )
    v3 = *a3;
  else
    v3 = *(_DWORD *)(a1 + 16);
  if ( !v3 )
    return -1;
  *a2 = *(_DWORD *)(v3 + 8);
  return 0;
}

//----- (00470B10) --------------------------------------------------------
int __cdecl zend_hash_get_current_key_type_ex(int a1, int *a2)
{
  int v2; // eax

  if ( a2 )
    v2 = *a2;
  else
    v2 = *(_DWORD *)(a1 + 16);
  if ( v2 )
    return 2 - (*(_DWORD *)(v2 + 4) != 0);
  else
    return 3;
}

//----- (00470B40) --------------------------------------------------------
int __cdecl zend_hash_move_backwards_ex(int a1, int a2)
{
  int v2; // eax

  v2 = a2;
  if ( !a2 )
    v2 = a1 + 16;
  if ( !*(_DWORD *)v2 )
    return -1;
  *(_DWORD *)v2 = *(_DWORD *)(*(_DWORD *)v2 + 20);
  return 0;
}

//----- (00470B70) --------------------------------------------------------
int __cdecl zend_hash_move_forward_ex(int a1, int a2)
{
  int v2; // eax

  v2 = a2;
  if ( !a2 )
    v2 = a1 + 16;
  if ( !*(_DWORD *)v2 )
    return -1;
  *(_DWORD *)v2 = *(_DWORD *)(*(_DWORD *)v2 + 16);
  return 0;
}

//----- (00470BA0) --------------------------------------------------------
_DWORD *__cdecl zend_hash_internal_pointer_end_ex(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a2;
  if ( a2 )
  {
    *a2 = a1[6];
  }
  else
  {
    result = a1;
    a1[4] = a1[6];
  }
  return result;
}

//----- (00470BC0) --------------------------------------------------------
_DWORD *__cdecl zend_hash_internal_pointer_reset_ex(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a2;
  if ( a2 )
  {
    *a2 = a1[5];
  }
  else
  {
    result = a1;
    a1[4] = a1[5];
  }
  return result;
}

//----- (00470BE0) --------------------------------------------------------
int __cdecl zend_hash_num_elements(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (00470BF0) --------------------------------------------------------
int __cdecl zend_hash_index_exists(int a1, int a2)
{
  _DWORD *v2; // eax

  v2 = *(_DWORD **)(*(_DWORD *)(a1 + 28) + 4 * (a2 & *(_DWORD *)(a1 + 4)));
  if ( !v2 )
    return 0;
  while ( *v2 != a2 || v2[1] )
  {
    v2 = (_DWORD *)v2[6];
    if ( !v2 )
      return 0;
  }
  return 1;
}

//----- (00470C30) --------------------------------------------------------
int __cdecl zend_hash_index_find(int a1, int a2, _DWORD *a3)
{
  _DWORD *v3; // eax

  v3 = *(_DWORD **)(*(_DWORD *)(a1 + 28) + 4 * (a2 & *(_DWORD *)(a1 + 4)));
  if ( !v3 )
    return -1;
  while ( *v3 != a2 || v3[1] )
  {
    v3 = (_DWORD *)v3[6];
    if ( !v3 )
      return -1;
  }
  *a3 = v3[2];
  return 0;
}

//----- (00470C70) --------------------------------------------------------
int __cdecl zend_hash_quick_find(int a1, int a2, unsigned int a3, int a4, _DWORD *a5)
{
  _DWORD *v5; // edi
  unsigned int v6; // eax
  int v7; // ecx
  _DWORD *v8; // esi

  v5 = *(_DWORD **)(*(_DWORD *)(a1 + 28) + 4 * (a4 & *(_DWORD *)(a1 + 4)));
  if ( !v5 )
    return -1;
  while ( 1 )
  {
    if ( *v5 == a4 && v5[1] == a3 )
    {
      v6 = a3;
      v7 = a2;
      v8 = v5 + 8;
      if ( a3 >= 4 )
      {
        while ( *v8 == *(_DWORD *)v7 )
        {
          v6 -= 4;
          v7 += 4;
          ++v8;
          if ( v6 < 4 )
            goto LABEL_7;
        }
        goto LABEL_13;
      }
LABEL_7:
      if ( !v6
        || *(_BYTE *)v7 == *(_BYTE *)v8
        && (v6 <= 1 || *(_BYTE *)(v7 + 1) == *((_BYTE *)v8 + 1) && (v6 <= 2 || *(_BYTE *)(v7 + 2) == *((_BYTE *)v8 + 2))) )
      {
        break;
      }
    }
LABEL_13:
    v5 = (_DWORD *)v5[6];
    if ( !v5 )
      return -1;
  }
  *a5 = v5[2];
  return 0;
}

//----- (00470D10) --------------------------------------------------------
int __usercall sub_470D10@<eax>(int a1@<ecx>, int a2@<edi>, void *a3@<esi>)
{
  void (__cdecl *v3)(_DWORD); // eax
  int v4; // eax
  int v5; // ecx
  int v6; // ebx
  int v7; // eax
  int v8; // eax
  int v9; // eax

  if ( zend_block_interruptions )
    zend_block_interruptions(a1);
  v3 = *(void (__cdecl **)(_DWORD))(a2 + 32);
  if ( v3 )
    v3(*((_DWORD *)a3 + 2));
  if ( !*((_DWORD *)a3 + 3) )
  {
    if ( *(_BYTE *)(a2 + 36) )
      free(*((void **)a3 + 2));
    else
      efree(*((_DWORD *)a3 + 2));
  }
  v4 = *((_DWORD *)a3 + 7);
  v5 = *((_DWORD *)a3 + 6);
  v6 = *((_DWORD *)a3 + 4);
  if ( v4 )
    *(_DWORD *)(v4 + 24) = v5;
  else
    *(_DWORD *)(*(_DWORD *)(a2 + 28) + 4 * (*(_DWORD *)a3 & *(_DWORD *)(a2 + 4))) = v5;
  v7 = *((_DWORD *)a3 + 6);
  if ( v7 )
    *(_DWORD *)(v7 + 28) = *((_DWORD *)a3 + 7);
  v8 = *((_DWORD *)a3 + 5);
  if ( v8 )
    *(_DWORD *)(v8 + 16) = *((_DWORD *)a3 + 4);
  else
    *(_DWORD *)(a2 + 20) = *((_DWORD *)a3 + 4);
  v9 = *((_DWORD *)a3 + 4);
  if ( v9 )
    *(_DWORD *)(v9 + 20) = *((_DWORD *)a3 + 5);
  else
    *(_DWORD *)(a2 + 24) = *((_DWORD *)a3 + 5);
  if ( *(void **)(a2 + 16) == a3 )
    *(_DWORD *)(a2 + 16) = *((_DWORD *)a3 + 4);
  if ( *(_BYTE *)(a2 + 36) )
    free(a3);
  else
    efree((int)a3);
  if ( zend_unblock_interruptions )
    zend_unblock_interruptions();
  --*(_DWORD *)(a2 + 8);
  return v6;
}
// 4AAEBC: using guessed type int (*zend_unblock_interruptions)(void);
// 4AAF78: using guessed type int (__thiscall *zend_block_interruptions)(_DWORD);

//----- (00470DE0) --------------------------------------------------------
void *__cdecl zend_hash_clean(int a1)
{
  _DWORD *v1; // esi
  void (__cdecl *v2)(_DWORD); // eax
  _DWORD *v3; // edi
  void *result; // eax
  void *v5; // [esp-8h] [ebp-14h]

  v1 = *(_DWORD **)(a1 + 20);
  while ( v1 )
  {
    v2 = *(void (__cdecl **)(_DWORD))(a1 + 32);
    v3 = v1;
    v1 = (_DWORD *)v1[4];
    if ( v2 )
      v2(v3[2]);
    if ( !v3[3] && v3[2] )
    {
      v5 = (void *)v3[2];
      if ( *(_BYTE *)(a1 + 36) )
        free(v5);
      else
        efree((int)v5);
    }
    if ( *(_BYTE *)(a1 + 36) )
      free(v3);
    else
      efree((int)v3);
  }
  result = memset(*(void **)(a1 + 28), 0, 4 * *(_DWORD *)a1);
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}

//----- (00470E70) --------------------------------------------------------
void __cdecl zend_hash_destroy(void *Block)
{
  _DWORD *v1; // esi
  void (__cdecl *v2)(_DWORD); // eax
  _DWORD *v3; // edi
  void *v4; // [esp-8h] [ebp-10h]

  v1 = (_DWORD *)*((_DWORD *)Block + 5);
  while ( v1 )
  {
    v2 = (void (__cdecl *)(_DWORD))*((_DWORD *)Block + 8);
    v3 = v1;
    v1 = (_DWORD *)v1[4];
    if ( v2 )
      v2(v3[2]);
    if ( !v3[3] && v3[2] )
    {
      v4 = (void *)v3[2];
      if ( *((_BYTE *)Block + 36) )
        free(v4);
      else
        efree((int)v4);
    }
    if ( *((_BYTE *)Block + 36) )
      free(v3);
    else
      efree((int)v3);
  }
  if ( *((_BYTE *)Block + 36) )
    free(*((void **)Block + 7));
  else
    efree(*((_DWORD *)Block + 7));
}

//----- (00470F00) --------------------------------------------------------
int __cdecl zend_hash_rehash(int a1)
{
  _DWORD *i; // eax
  int v2; // ecx
  int v3; // edx

  memset(*(void **)(a1 + 28), 0, 4 * *(_DWORD *)a1);
  for ( i = *(_DWORD **)(a1 + 20); i; i = (_DWORD *)i[4] )
  {
    v2 = *i & *(_DWORD *)(a1 + 4);
    v3 = *(_DWORD *)(*(_DWORD *)(a1 + 28) + 4 * v2);
    i[6] = v3;
    i[7] = 0;
    if ( v3 )
      *(_DWORD *)(v3 + 28) = i;
    *(_DWORD *)(*(_DWORD *)(a1 + 28) + 4 * v2) = i;
  }
  return 0;
}

//----- (00470F50) --------------------------------------------------------
char __cdecl zend_hash_set_apply_protection(int a1, char a2)
{
  char result; // al

  result = a2;
  *(_BYTE *)(a1 + 38) = a2;
  return result;
}

//----- (00470F60) --------------------------------------------------------
int __fastcall sub_470F60(char *a1, int a2)
{
  char *v2; // edx
  int result; // eax
  int v4; // esi

  v2 = &a1[a2];
  for ( result = 5381; a1 < v2; result = v4 ^ (33 * result) )
    v4 = *a1++;
  return result;
}

//----- (00470F90) --------------------------------------------------------
int __cdecl zend_hash_exists(int a1, char *String, unsigned int a3)
{
  char v4; // cl
  char *v5; // edx
  char *v6; // eax
  bool v7; // zf
  int v8; // eax
  int v10; // eax
  _DWORD *v11; // edi
  unsigned int v12; // ecx
  char *v13; // edx
  _DWORD *v14; // esi
  char *Stringa; // [esp+10h] [ebp+8h]

  v4 = *String;
  if ( *String >= 48 && v4 <= 57 )
  {
    v5 = &String[a3 - 1];
    v6 = String + 1;
    if ( v4 != 48 || a3 <= 2 )
    {
      v7 = v6 == v5;
      if ( v6 < v5 )
      {
        do
        {
          if ( *v6 < 48 )
            break;
          if ( *v6 > 57 )
            break;
          ++v6;
        }
        while ( v6 < v5 );
        v7 = v6 == v5;
      }
      if ( v7 && !*v6 )
      {
        v8 = strtol(String, 0, 10);
        if ( v8 != 0x7FFFFFFF )
          return zend_hash_index_exists(a1, v8);
      }
    }
  }
  v10 = sub_470F60(String, a3);
  v11 = *(_DWORD **)(*(_DWORD *)(a1 + 28) + 4 * (v10 & *(_DWORD *)(a1 + 4)));
  Stringa = (char *)v10;
  if ( !v11 )
    return 0;
  while ( 1 )
  {
    if ( *v11 != v10 || v11[1] != a3 )
      goto LABEL_27;
    v12 = a3;
    v13 = String;
    v14 = v11 + 8;
    if ( a3 >= 4 )
    {
      while ( *v14 == *(_DWORD *)v13 )
      {
        v12 -= 4;
        v13 += 4;
        ++v14;
        if ( v12 < 4 )
          goto LABEL_20;
      }
      goto LABEL_26;
    }
LABEL_20:
    if ( !v12
      || *v13 == *(_BYTE *)v14
      && (v12 <= 1 || v13[1] == *((_BYTE *)v14 + 1) && (v12 <= 2 || v13[2] == *((_BYTE *)v14 + 2))) )
    {
      return 1;
    }
LABEL_26:
    v10 = (int)Stringa;
LABEL_27:
    v11 = (_DWORD *)v11[6];
    if ( !v11 )
      return 0;
  }
}

//----- (00471090) --------------------------------------------------------
int __cdecl zend_hash_find(int a1, char *String, unsigned int a3, _DWORD *a4)
{
  char v5; // cl
  char *v6; // edx
  char *v7; // eax
  bool v8; // zf
  int v9; // eax
  int v11; // eax
  _DWORD *v12; // edi
  unsigned int v13; // ecx
  char *v14; // edx
  _DWORD *v15; // esi
  char *Stringa; // [esp+10h] [ebp+8h]

  v5 = *String;
  if ( *String >= 48 && v5 <= 57 )
  {
    v6 = &String[a3 - 1];
    v7 = String + 1;
    if ( v5 != 48 || a3 <= 2 )
    {
      v8 = v7 == v6;
      if ( v7 < v6 )
      {
        do
        {
          if ( *v7 < 48 )
            break;
          if ( *v7 > 57 )
            break;
          ++v7;
        }
        while ( v7 < v6 );
        v8 = v7 == v6;
      }
      if ( v8 && !*v7 )
      {
        v9 = strtol(String, 0, 10);
        if ( v9 != 0x7FFFFFFF )
          return zend_hash_index_find(a1, v9, a4);
      }
    }
  }
  v11 = sub_470F60(String, a3);
  v12 = *(_DWORD **)(*(_DWORD *)(a1 + 28) + 4 * (v11 & *(_DWORD *)(a1 + 4)));
  Stringa = (char *)v11;
  if ( !v12 )
    return -1;
  while ( 1 )
  {
    if ( *v12 != v11 || v12[1] != a3 )
      goto LABEL_27;
    v13 = a3;
    v14 = String;
    v15 = v12 + 8;
    if ( a3 >= 4 )
    {
      while ( *v15 == *(_DWORD *)v14 )
      {
        v13 -= 4;
        v14 += 4;
        ++v15;
        if ( v13 < 4 )
          goto LABEL_20;
      }
      goto LABEL_26;
    }
LABEL_20:
    if ( !v13
      || *v14 == *(_BYTE *)v15
      && (v13 <= 1 || v14[1] == *((_BYTE *)v15 + 1) && (v13 <= 2 || v14[2] == *((_BYTE *)v15 + 2))) )
    {
      break;
    }
LABEL_26:
    v11 = (int)Stringa;
LABEL_27:
    v12 = (_DWORD *)v12[6];
    if ( !v12 )
      return -1;
  }
  *a4 = v12[2];
  return 0;
}

//----- (004711A0) --------------------------------------------------------
int __cdecl zend_get_hash_value(int a1, char *a2, int a3)
{
  return sub_470F60(a2, a3);
}

//----- (004711B0) --------------------------------------------------------
void __cdecl zend_hash_graceful_reverse_destroy(void *Block)
{
  int v1; // ecx
  void *i; // esi

  for ( i = (void *)*((_DWORD *)Block + 6); i; i = (void *)*((_DWORD *)Block + 6) )
    sub_470D10(v1, (int)Block, i);
  if ( *((_BYTE *)Block + 36) )
    free(*((void **)Block + 7));
  else
    efree(*((_DWORD *)Block + 7));
}
// 4711C0: variable 'v1' is possibly undefined

//----- (004711F0) --------------------------------------------------------
void __cdecl zend_hash_graceful_destroy(void *Block)
{
  int v1; // ecx
  void *i; // eax

  for ( i = (void *)*((_DWORD *)Block + 5); i; i = (void *)sub_470D10(v1, (int)Block, i) )
    ;
  if ( *((_BYTE *)Block + 36) )
    free(*((void **)Block + 7));
  else
    efree(*((_DWORD *)Block + 7));
}
// 471202: variable 'v1' is possibly undefined

//----- (00471230) --------------------------------------------------------
int __cdecl zend_hash_del_key_or_index(_DWORD *a1, char *String, unsigned int a3, int a4, int a5)
{
  char v5; // cl
  char *v6; // edx
  char *v7; // eax
  bool v8; // zf
  int v9; // eax
  _DWORD *v10; // edx
  int v11; // edi
  char *v12; // esi
  int v13; // ecx
  unsigned int v14; // ecx
  char *v15; // edx
  char *v16; // edi
  int v18; // eax
  int v19; // ecx
  _DWORD *v20; // eax
  int v21; // eax
  int v22; // eax
  int v23; // eax
  void (__cdecl *v24)(_DWORD); // eax

  if ( !a5 )
  {
    v5 = *String;
    if ( *String < 48 )
      goto LABEL_14;
    if ( v5 > 57 )
      goto LABEL_14;
    v6 = &String[a3 - 1];
    v7 = String + 1;
    if ( v5 == 48 && a3 > 2 )
      goto LABEL_14;
    v8 = v7 == v6;
    if ( v7 < v6 )
    {
      do
      {
        if ( *v7 < 48 )
          break;
        if ( *v7 > 57 )
          break;
        ++v7;
      }
      while ( v7 < v6 );
      v8 = v7 == v6;
    }
    if ( !v8 || *v7 || (v9 = strtol(String, 0, 10), v9 == 0x7FFFFFFF) )
LABEL_14:
      v9 = sub_470F60(String, a3);
    a4 = v9;
  }
  v10 = a1;
  v11 = a4 & a1[1];
  v12 = *(char **)(a1[7] + 4 * v11);
  if ( !v12 )
    return -1;
  while ( 1 )
  {
    if ( *(_DWORD *)v12 == a4 )
    {
      v13 = *((_DWORD *)v12 + 1);
      if ( !v13 )
        goto LABEL_33;
      if ( v13 == a3 )
        break;
    }
LABEL_30:
    v12 = (char *)*((_DWORD *)v12 + 6);
    if ( !v12 )
      return -1;
  }
  v14 = a3;
  v15 = String;
  v16 = v12 + 32;
  if ( a3 >= 4 )
  {
    while ( *(_DWORD *)v16 == *(_DWORD *)v15 )
    {
      v14 -= 4;
      v15 += 4;
      v16 += 4;
      if ( v14 < 4 )
        goto LABEL_23;
    }
    goto LABEL_29;
  }
LABEL_23:
  if ( v14 && (*v15 != *v16 || v14 > 1 && (v15[1] != v16[1] || v14 > 2 && v15[2] != v16[2])) )
  {
LABEL_29:
    v11 = a4 & a1[1];
    v10 = a1;
    goto LABEL_30;
  }
  v11 = a4 & a1[1];
  v10 = a1;
LABEL_33:
  if ( zend_block_interruptions )
  {
    zend_block_interruptions();
    v10 = a1;
  }
  v18 = v10[7];
  v19 = *((_DWORD *)v12 + 6);
  v8 = v12 == *(char **)(v18 + 4 * v11);
  v20 = (_DWORD *)(v18 + 4 * v11);
  if ( v8 )
    *v20 = v19;
  else
    *(_DWORD *)(*((_DWORD *)v12 + 7) + 24) = v19;
  v21 = *((_DWORD *)v12 + 6);
  if ( v21 )
    *(_DWORD *)(v21 + 28) = *((_DWORD *)v12 + 7);
  v22 = *((_DWORD *)v12 + 5);
  if ( v22 )
    *(_DWORD *)(v22 + 16) = *((_DWORD *)v12 + 4);
  else
    v10[5] = *((_DWORD *)v12 + 4);
  v23 = *((_DWORD *)v12 + 4);
  if ( v23 )
    *(_DWORD *)(v23 + 20) = *((_DWORD *)v12 + 5);
  else
    v10[6] = *((_DWORD *)v12 + 5);
  if ( (char *)v10[4] == v12 )
    v10[4] = *((_DWORD *)v12 + 4);
  v24 = (void (__cdecl *)(_DWORD))v10[8];
  if ( v24 )
  {
    v24(*((_DWORD *)v12 + 2));
    v10 = a1;
  }
  if ( !*((_DWORD *)v12 + 3) )
  {
    if ( *((_BYTE *)v10 + 36) )
      free(*((void **)v12 + 2));
    else
      efree(*((_DWORD *)v12 + 2));
    v10 = a1;
  }
  if ( *((_BYTE *)v10 + 36) )
    free(v12);
  else
    efree((int)v12);
  if ( zend_unblock_interruptions )
    zend_unblock_interruptions();
  --a1[2];
  return 0;
}
// 4AAEBC: using guessed type int (*zend_unblock_interruptions)(void);
// 4AAF78: using guessed type int (*zend_block_interruptions)(void);

//----- (00471410) --------------------------------------------------------
int __cdecl zend_hash_func(char *a1, int a2)
{
  return sub_470F60(a1, a2);
}

//----- (00471420) --------------------------------------------------------
int __cdecl zend_hash_sort(int a1, void (__cdecl *a2)(int *, int, int, int), int a3, int a4)
{
  unsigned int v4; // eax
  int *v6; // eax
  int *v7; // esi
  int v8; // eax
  int i; // ebp
  int v10; // ecx
  int v11; // ecx
  int v12; // eax
  int v13; // ecx
  int v14; // edx
  _DWORD *v15; // eax
  int j; // ecx

  v4 = *(_DWORD *)(a1 + 8);
  if ( v4 <= 1 )
    return 0;
  if ( *(_BYTE *)(a1 + 36) )
    v6 = (int *)malloc(4 * v4);
  else
    v6 = emalloc(4 * v4);
  v7 = v6;
  if ( !v6 )
    return -1;
  v8 = *(_DWORD *)(a1 + 20);
  for ( i = 0; v8; ++i )
  {
    v7[i] = v8;
    v8 = *(_DWORD *)(v8 + 16);
  }
  a2(v7, i, 4, a3);
  if ( zend_block_interruptions )
    zend_block_interruptions(v10);
  v11 = *v7;
  *(_DWORD *)(a1 + 20) = *v7;
  v12 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  for ( *(_DWORD *)(a1 + 16) = v11; v12 < i; *(_DWORD *)(a1 + 24) = v14 )
  {
    v13 = *(_DWORD *)(a1 + 24);
    if ( v13 )
      *(_DWORD *)(v13 + 16) = v7[v12];
    *(_DWORD *)(v7[v12] + 20) = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(v7[v12] + 16) = 0;
    v14 = v7[v12++];
  }
  if ( *(_BYTE *)(a1 + 36) )
    free(v7);
  else
    efree((int)v7);
  if ( zend_unblock_interruptions )
    zend_unblock_interruptions();
  if ( a4 )
  {
    v15 = *(_DWORD **)(a1 + 20);
    for ( j = 0; v15; ++j )
    {
      *v15 = j;
      v15[1] = 0;
      v15 = (_DWORD *)v15[4];
    }
    *(_DWORD *)(a1 + 12) = j;
    zend_hash_rehash(a1);
  }
  return 0;
}
// 471494: variable 'v10' is possibly undefined
// 4AAEBC: using guessed type int (*zend_unblock_interruptions)(void);
// 4AAF78: using guessed type int (__thiscall *zend_block_interruptions)(_DWORD);

//----- (00471530) --------------------------------------------------------
int __cdecl zend_hash_init(int a1, unsigned int a2, int a3, int a4, int a5)
{
  unsigned int v5; // eax
  char i; // cl
  size_t v7; // eax
  void *v8; // eax
  _DWORD *v9; // eax
  size_t v11; // [esp-Ch] [ebp-Ch]

  v5 = 8;
  for ( i = 3; v5 < a2; v5 = __ROL4__(v5, 1) )
    ++i;
  v7 = 1 << i;
  *(_DWORD *)a1 = 1 << i;
  *(_DWORD *)(a1 + 4) = (1 << i) - 1;
  if ( a5 )
  {
    v8 = calloc(v7, 4u);
  }
  else
  {
    v11 = 4 * v7;
    v9 = emalloc(4 * v7);
    v8 = memset(v9, 0, v11);
  }
  *(_DWORD *)(a1 + 28) = v8;
  if ( !v8 )
    return -1;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 36) = a5;
  *(_BYTE *)(a1 + 37) = 0;
  *(_DWORD *)(a1 + 32) = a4;
  *(_BYTE *)(a1 + 38) = 1;
  return 0;
}

//----- (004715D0) --------------------------------------------------------
int __cdecl zend_hash_get_current_key_ex(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, char a5, _DWORD **a6)
{
  _DWORD *v6; // esi

  if ( a6 )
    v6 = *a6;
  else
    v6 = *(_DWORD **)(a1 + 16);
  if ( !v6 )
    return 3;
  if ( v6[1] )
  {
    if ( a5 )
      *a2 = estrndup(v6 + 8, v6[1]);
    else
      *a2 = v6 + 8;
    if ( a3 )
      *a3 = v6[1];
    return 1;
  }
  else
  {
    *a4 = *v6;
    return 2;
  }
}

//----- (00471640) --------------------------------------------------------
int __usercall sub_471640@<eax>(int a1@<esi>)
{
  int v1; // eax
  void *v2; // eax
  void *v3; // edi
  int v4; // eax

  v1 = *(_DWORD *)a1;
  if ( (*(_DWORD *)a1 & 0x7FFFFFFF) == 0 )
    return 0;
  if ( *(_BYTE *)(a1 + 36) )
    v2 = realloc(*(void **)(a1 + 28), 8 * v1);
  else
    v2 = erealloc(*(_DWORD *)(a1 + 28), 8 * v1, 1);
  v3 = v2;
  if ( !v2 )
    return -1;
  if ( zend_block_interruptions )
    zend_block_interruptions();
  *(_DWORD *)a1 *= 2;
  v4 = *(_DWORD *)a1 - 1;
  *(_DWORD *)(a1 + 28) = v3;
  *(_DWORD *)(a1 + 4) = v4;
  zend_hash_rehash(a1);
  if ( zend_unblock_interruptions )
    zend_unblock_interruptions();
  return 0;
}
// 4AAEBC: using guessed type int (*zend_unblock_interruptions)(void);
// 4AAF78: using guessed type int (*zend_block_interruptions)(void);

//----- (004716C0) --------------------------------------------------------
int __cdecl zend_hash_index_update_or_next_insert(int a1, int a2, _DWORD *Src, size_t Size, _DWORD *a5, char a6)
{
  int v6; // ebp
  int v7; // ebx
  int v8; // edi
  _DWORD *v9; // eax
  void (__cdecl *v10)(_DWORD); // eax
  _DWORD *v11; // ebp
  void *v12; // eax
  _DWORD *v14; // edi
  void *v15; // eax
  int v16; // ecx
  int v17; // eax

  if ( (a6 & 4) != 0 )
  {
    v6 = *(_DWORD *)(a1 + 12);
    a2 = v6;
  }
  else
  {
    v6 = a2;
  }
  v7 = v6 & *(_DWORD *)(a1 + 4);
  v8 = *(_DWORD *)(*(_DWORD *)(a1 + 28) + 4 * v7);
  if ( v8 )
  {
    while ( *(_DWORD *)(v8 + 4) || *(_DWORD *)v8 != v6 )
    {
      v8 = *(_DWORD *)(v8 + 24);
      if ( !v8 )
        goto LABEL_8;
    }
    if ( (a6 & 4) == 0 && (a6 & 2) == 0 )
    {
      if ( zend_block_interruptions )
        zend_block_interruptions();
      v10 = *(void (__cdecl **)(_DWORD))(a1 + 32);
      if ( v10 )
        v10(*(_DWORD *)(v8 + 8));
      if ( Size == 4 )
      {
        v11 = (_DWORD *)(v8 + 12);
        if ( !*(_DWORD *)(v8 + 12) )
        {
          if ( *(_BYTE *)(a1 + 36) )
            free(*(void **)(v8 + 8));
          else
            efree(*(_DWORD *)(v8 + 8));
        }
        *v11 = *Src;
        *(_DWORD *)(v8 + 8) = v11;
        v6 = a2;
      }
      else
      {
        if ( *(_DWORD *)(v8 + 12) )
        {
          if ( *(_BYTE *)(a1 + 36) )
            v12 = malloc(Size);
          else
            v12 = emalloc(Size);
          *(_DWORD *)(v8 + 8) = v12;
          *(_DWORD *)(v8 + 12) = 0;
        }
        memcpy(*(void **)(v8 + 8), Src, Size);
      }
      if ( zend_unblock_interruptions )
        zend_unblock_interruptions();
      if ( v6 >= *(_DWORD *)(a1 + 12) )
        *(_DWORD *)(a1 + 12) = v6 + 1;
      if ( a5 )
      {
        *a5 = *(_DWORD *)(v8 + 8);
        return 0;
      }
      return 0;
    }
    return -1;
  }
LABEL_8:
  if ( *(_BYTE *)(a1 + 36) )
    v9 = malloc(0x23u);
  else
    v9 = emalloc(35);
  v14 = v9;
  if ( !v9 )
    return -1;
  *v9 = v6;
  v9[1] = 0;
  if ( Size == 4 )
  {
    v9[3] = *Src;
    v9[2] = v9 + 3;
  }
  else
  {
    if ( *(_BYTE *)(a1 + 36) )
      v15 = malloc(Size);
    else
      v15 = emalloc(Size);
    v14[2] = v15;
    if ( !v15 )
    {
      if ( *(_BYTE *)(a1 + 36) )
      {
        free(v14);
        return -1;
      }
      efree((int)v14);
      return -1;
    }
    memcpy(v15, Src, Size);
    v14[3] = 0;
  }
  if ( a5 )
    *a5 = v14[2];
  v16 = *(_DWORD *)(*(_DWORD *)(a1 + 28) + 4 * v7);
  v14[6] = v16;
  v14[7] = 0;
  if ( v16 )
    *(_DWORD *)(v16 + 28) = v14;
  if ( zend_block_interruptions )
    zend_block_interruptions();
  *(_DWORD *)(*(_DWORD *)(a1 + 28) + 4 * v7) = v14;
  v14[5] = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(a1 + 24) = v14;
  v17 = v14[5];
  v14[4] = 0;
  if ( v17 )
    *(_DWORD *)(v17 + 16) = v14;
  if ( !*(_DWORD *)(a1 + 20) )
    *(_DWORD *)(a1 + 20) = v14;
  if ( !*(_DWORD *)(a1 + 16) )
    *(_DWORD *)(a1 + 16) = v14;
  if ( zend_unblock_interruptions )
    zend_unblock_interruptions();
  if ( a2 >= *(_DWORD *)(a1 + 12) )
    *(_DWORD *)(a1 + 12) = a2 + 1;
  if ( ++*(_DWORD *)(a1 + 8) > *(_DWORD *)a1 )
    sub_471640(a1);
  return 0;
}
// 4AAEBC: using guessed type int (*zend_unblock_interruptions)(void);
// 4AAF78: using guessed type int (*zend_block_interruptions)(void);

//----- (00471900) --------------------------------------------------------
int __cdecl zend_hash_quick_add_or_update(
        int a1,
        char *a2,
        size_t a3,
        int a4,
        _DWORD *Src,
        size_t Size,
        _DWORD *a7,
        char a8)
{
  int v10; // ebp
  char *v11; // ecx
  size_t v12; // eax
  int v13; // edi
  _DWORD *v14; // eax
  void (__cdecl *v15)(_DWORD); // eax
  _DWORD *v16; // esi
  void *v17; // eax
  _DWORD *v18; // edi
  void *v19; // eax
  int v20; // ecx
  int v21; // eax
  int v22; // [esp+10h] [ebp+Ch]

  if ( !a3 )
    return -1;
  v10 = *(_DWORD *)(*(_DWORD *)(a1 + 28) + 4 * (a4 & *(_DWORD *)(a1 + 4)));
  v22 = a4 & *(_DWORD *)(a1 + 4);
  if ( !v10 )
  {
LABEL_16:
    if ( *(_BYTE *)(a1 + 36) )
      v14 = malloc(a3 + 35);
    else
      v14 = emalloc(a3 + 35);
    v18 = v14;
    if ( v14 )
    {
      memcpy(v14 + 8, a2, a3);
      v18[1] = a3;
      if ( Size == 4 )
      {
        v18[3] = *Src;
        v18[2] = v18 + 3;
      }
      else
      {
        if ( *(_BYTE *)(a1 + 36) )
          v19 = malloc(Size);
        else
          v19 = emalloc(Size);
        v18[2] = v19;
        if ( !v19 )
        {
          if ( *(_BYTE *)(a1 + 36) )
          {
            free(v18);
            return -1;
          }
          efree((int)v18);
          return -1;
        }
        memcpy(v19, Src, Size);
        v18[3] = 0;
      }
      *v18 = a4;
      v20 = *(_DWORD *)(*(_DWORD *)(a1 + 28) + 4 * v22);
      v18[6] = v20;
      v18[7] = 0;
      if ( v20 )
        *(_DWORD *)(v20 + 28) = v18;
      if ( a7 )
        *a7 = v18[2];
      if ( zend_block_interruptions )
        zend_block_interruptions(v20);
      *(_DWORD *)(*(_DWORD *)(a1 + 28) + 4 * v22) = v18;
      v18[5] = *(_DWORD *)(a1 + 24);
      *(_DWORD *)(a1 + 24) = v18;
      v21 = v18[5];
      v18[4] = 0;
      if ( v21 )
        *(_DWORD *)(v21 + 16) = v18;
      if ( !*(_DWORD *)(a1 + 20) )
        *(_DWORD *)(a1 + 20) = v18;
      if ( !*(_DWORD *)(a1 + 16) )
        *(_DWORD *)(a1 + 16) = v18;
      if ( zend_unblock_interruptions )
        zend_unblock_interruptions();
      if ( ++*(_DWORD *)(a1 + 8) > *(_DWORD *)a1 )
        sub_471640(a1);
      return 0;
    }
    return -1;
  }
  while ( 1 )
  {
    if ( *(_DWORD *)v10 == a4 && *(_DWORD *)(v10 + 4) == a3 )
    {
      v11 = a2;
      v12 = a3;
      v13 = v10 + 32;
      if ( a3 >= 4 )
      {
        while ( *(_DWORD *)v13 == *(_DWORD *)v11 )
        {
          v12 -= 4;
          v11 += 4;
          v13 += 4;
          if ( v12 < 4 )
            goto LABEL_9;
        }
        goto LABEL_15;
      }
LABEL_9:
      if ( !v12
        || *v11 == *(_BYTE *)v13
        && (v12 <= 1 || v11[1] == *(_BYTE *)(v13 + 1) && (v12 <= 2 || v11[2] == *(_BYTE *)(v13 + 2))) )
      {
        break;
      }
    }
LABEL_15:
    v10 = *(_DWORD *)(v10 + 24);
    if ( !v10 )
      goto LABEL_16;
  }
  if ( (a8 & 2) != 0 )
    return -1;
  if ( zend_block_interruptions )
    zend_block_interruptions(v11);
  v15 = *(void (__cdecl **)(_DWORD))(a1 + 32);
  if ( v15 )
    v15(*(_DWORD *)(v10 + 8));
  if ( Size == 4 )
  {
    v16 = (_DWORD *)(v10 + 12);
    if ( !*(_DWORD *)(v10 + 12) )
    {
      if ( *(_BYTE *)(a1 + 36) )
      {
        free(*(void **)(v10 + 8));
        *v16 = *Src;
        *(_DWORD *)(v10 + 8) = v16;
        goto LABEL_35;
      }
      efree(*(_DWORD *)(v10 + 8));
    }
    *v16 = *Src;
    *(_DWORD *)(v10 + 8) = v16;
  }
  else
  {
    if ( *(_DWORD *)(v10 + 12) )
    {
      if ( *(_BYTE *)(a1 + 36) )
        v17 = malloc(Size);
      else
        v17 = emalloc(Size);
      *(_DWORD *)(v10 + 8) = v17;
      *(_DWORD *)(v10 + 12) = 0;
    }
    memcpy(*(void **)(v10 + 8), Src, Size);
  }
LABEL_35:
  if ( a7 )
    *a7 = *(_DWORD *)(v10 + 8);
  if ( zend_unblock_interruptions )
  {
    zend_unblock_interruptions();
    return 0;
  }
  return 0;
}
// 4AAEBC: using guessed type int (*zend_unblock_interruptions)(void);
// 4AAF78: using guessed type int (__thiscall *zend_block_interruptions)(_DWORD);

//----- (00471B90) --------------------------------------------------------
int __cdecl zend_hash_add_or_update(int a1, char *String, size_t a3, size_t *Src, size_t Size, _DWORD *a6, char a7)
{
  char *v9; // edi
  char v10; // cl
  char *v11; // edx
  char *v12; // eax
  bool v13; // zf
  int v14; // eax
  int v15; // eax
  int v16; // ebp
  char *v17; // ecx
  size_t v18; // eax
  int v19; // edi
  size_t *v20; // eax
  void (__cdecl *v21)(_DWORD); // eax
  size_t *v22; // esi
  void *v23; // eax
  size_t *v24; // edi
  void *v25; // eax
  size_t v26; // ecx
  size_t v27; // eax
  int v28; // [esp+4h] [ebp-4h]
  size_t v29; // [esp+14h] [ebp+Ch]

  if ( !a3 )
    return -1;
  v9 = String;
  v10 = *String;
  if ( *String >= 48 && v10 <= 57 )
  {
    v11 = &String[a3 - 1];
    v12 = String + 1;
    if ( v10 != 48 || a3 <= 2 )
    {
      v13 = v12 == v11;
      if ( v12 < v11 )
      {
        do
        {
          if ( *v12 < 48 )
            break;
          if ( *v12 > 57 )
            break;
          ++v12;
        }
        while ( v12 < v11 );
        v13 = v12 == v11;
      }
      if ( v13 && !*v12 )
      {
        v14 = strtol(String, 0, 10);
        if ( v14 != 0x7FFFFFFF )
          return zend_hash_index_update_or_next_insert(a1, v14, Src, Size, a6, a7);
      }
    }
  }
  v15 = sub_470F60(String, a3);
  v16 = *(_DWORD *)(*(_DWORD *)(a1 + 28) + 4 * (v15 & *(_DWORD *)(a1 + 4)));
  v29 = v15;
  v28 = v15 & *(_DWORD *)(a1 + 4);
  if ( !v16 )
  {
LABEL_30:
    if ( *(_BYTE *)(a1 + 36) )
      v20 = (size_t *)malloc(a3 + 35);
    else
      v20 = emalloc(a3 + 35);
    v24 = v20;
    if ( v20 )
    {
      memcpy(v20 + 8, String, a3);
      v24[1] = a3;
      if ( Size == 4 )
      {
        v24[3] = *Src;
        v24[2] = (size_t)(v24 + 3);
      }
      else
      {
        if ( *(_BYTE *)(a1 + 36) )
          v25 = malloc(Size);
        else
          v25 = emalloc(Size);
        v24[2] = (size_t)v25;
        if ( !v25 )
        {
          if ( *(_BYTE *)(a1 + 36) )
          {
            free(v24);
            return -1;
          }
          efree((int)v24);
          return -1;
        }
        memcpy(v25, Src, Size);
        v24[3] = 0;
      }
      *v24 = v29;
      v26 = *(_DWORD *)(*(_DWORD *)(a1 + 28) + 4 * v28);
      v24[6] = v26;
      v24[7] = 0;
      if ( v26 )
        *(_DWORD *)(v26 + 28) = v24;
      if ( a6 )
        *a6 = v24[2];
      if ( zend_block_interruptions )
        zend_block_interruptions(v26);
      v24[5] = *(_DWORD *)(a1 + 24);
      *(_DWORD *)(a1 + 24) = v24;
      v27 = v24[5];
      v24[4] = 0;
      if ( v27 )
        *(_DWORD *)(v27 + 16) = v24;
      if ( !*(_DWORD *)(a1 + 20) )
        *(_DWORD *)(a1 + 20) = v24;
      if ( !*(_DWORD *)(a1 + 16) )
        *(_DWORD *)(a1 + 16) = v24;
      *(_DWORD *)(*(_DWORD *)(a1 + 28) + 4 * v28) = v24;
      if ( zend_unblock_interruptions )
        zend_unblock_interruptions();
      if ( ++*(_DWORD *)(a1 + 8) > *(_DWORD *)a1 )
        sub_471640(a1);
      return 0;
    }
    return -1;
  }
  while ( 1 )
  {
    if ( *(_DWORD *)v16 != v15 || *(_DWORD *)(v16 + 4) != a3 )
      goto LABEL_29;
    v17 = v9;
    v18 = a3;
    v19 = v16 + 32;
    if ( a3 >= 4 )
    {
      while ( *(_DWORD *)v19 == *(_DWORD *)v17 )
      {
        v18 -= 4;
        v17 += 4;
        v19 += 4;
        if ( v18 < 4 )
          goto LABEL_22;
      }
      goto LABEL_28;
    }
LABEL_22:
    if ( !v18
      || *v17 == *(_BYTE *)v19
      && (v18 <= 1 || v17[1] == *(_BYTE *)(v19 + 1) && (v18 <= 2 || v17[2] == *(_BYTE *)(v19 + 2))) )
    {
      break;
    }
LABEL_28:
    v15 = v29;
    v9 = String;
LABEL_29:
    v16 = *(_DWORD *)(v16 + 24);
    if ( !v16 )
      goto LABEL_30;
  }
  if ( (a7 & 2) != 0 )
    return -1;
  if ( zend_block_interruptions )
    zend_block_interruptions(v17);
  v21 = *(void (__cdecl **)(_DWORD))(a1 + 32);
  if ( v21 )
    v21(*(_DWORD *)(v16 + 8));
  if ( Size == 4 )
  {
    v22 = (size_t *)(v16 + 12);
    if ( !*(_DWORD *)(v16 + 12) )
    {
      if ( *(_BYTE *)(a1 + 36) )
      {
        free(*(void **)(v16 + 8));
        *v22 = *Src;
        *(_DWORD *)(v16 + 8) = v22;
        goto LABEL_49;
      }
      efree(*(_DWORD *)(v16 + 8));
    }
    *v22 = *Src;
    *(_DWORD *)(v16 + 8) = v22;
  }
  else
  {
    if ( *(_DWORD *)(v16 + 12) )
    {
      if ( *(_BYTE *)(a1 + 36) )
        v23 = malloc(Size);
      else
        v23 = emalloc(Size);
      *(_DWORD *)(v16 + 8) = v23;
      *(_DWORD *)(v16 + 12) = 0;
    }
    memcpy(*(void **)(v16 + 8), Src, Size);
  }
LABEL_49:
  if ( a6 )
    *a6 = *(_DWORD *)(v16 + 8);
  if ( zend_unblock_interruptions )
  {
    zend_unblock_interruptions();
    return 0;
  }
  return 0;
}
// 4AAEBC: using guessed type int (*zend_unblock_interruptions)(void);
// 4AAF78: using guessed type int (__thiscall *zend_block_interruptions)(_DWORD);

//----- (00471EB0) --------------------------------------------------------
int __cdecl zend_hash_init_ex(int a1, unsigned int a2, int a3, int a4, int a5, char a6)
{
  int result; // eax

  result = zend_hash_init(a1, a2, a3, a4, a5);
  *(_BYTE *)(a1 + 38) = a6;
  return result;
}

//----- (00471EE0) --------------------------------------------------------
int __cdecl zend_hash_compare(_DWORD *a1, int a2, int (__cdecl *a3)(_DWORD, int), char a4)
{
  _DWORD *v4; // ebp
  unsigned __int8 v5; // al
  char *v6; // eax
  int v7; // esi
  unsigned __int8 v8; // al
  char *v9; // eax
  int result; // eax
  int v11; // edi
  _DWORD *v12; // ebx
  unsigned int v13; // ecx
  unsigned __int8 *v14; // edx
  unsigned __int8 *v15; // esi
  int v16; // eax
  unsigned int v17; // eax
  int v18; // eax
  int v19; // [esp+8h] [ebp-4h] BYREF

  v4 = a1;
  if ( *((_BYTE *)a1 + 38) )
  {
    v5 = *((_BYTE *)a1 + 37);
    *((_BYTE *)a1 + 37) = v5 + 1;
    if ( v5 >= 3u )
    {
      v6 = (char *)sub_473493((int)&unk_4872E0);
      zend_error(1, v6);
    }
  }
  v7 = a2;
  if ( *(_BYTE *)(a2 + 38) )
  {
    v8 = *(_BYTE *)(a2 + 37);
    *(_BYTE *)(a2 + 37) = v8 + 1;
    if ( v8 >= 3u )
    {
      v9 = (char *)sub_473493((int)&unk_4872E0);
      zend_error(1, v9);
    }
  }
  result = a1[2] - *(_DWORD *)(a2 + 8);
  if ( result )
  {
    if ( *((_BYTE *)a1 + 38) )
      --*((_BYTE *)a1 + 37);
    if ( *(_BYTE *)(a2 + 38) )
      --*(_BYTE *)(a2 + 37);
    return result;
  }
  v11 = a1[5];
  if ( a4 )
  {
    v12 = *(_DWORD **)(a2 + 20);
    a1 = v12;
  }
  else
  {
    v12 = a1;
  }
  if ( !v11 )
  {
LABEL_51:
    if ( *((_BYTE *)v4 + 38) )
      --*((_BYTE *)v4 + 37);
    if ( *(_BYTE *)(v7 + 38) )
      --*(_BYTE *)(v7 + 37);
    return 0;
  }
  while ( 1 )
  {
    if ( a4 )
    {
      if ( !v12 )
        break;
      v13 = *(_DWORD *)(v11 + 4);
      if ( !v13 && !v12[1] )
      {
        result = *(_DWORD *)v11 - *v12;
        if ( *(_DWORD *)v11 != *v12 )
          goto LABEL_21;
LABEL_42:
        v19 = v12[2];
        goto LABEL_47;
      }
      result = v13 - v12[1];
      if ( v13 != v12[1] )
        goto LABEL_21;
      v14 = (unsigned __int8 *)(v12 + 8);
      v15 = (unsigned __int8 *)(v11 + 32);
      if ( v13 < 4 )
      {
LABEL_29:
        if ( !v13 )
        {
LABEL_39:
          result = 0;
          goto LABEL_40;
        }
      }
      else
      {
        while ( *(_DWORD *)v15 == *(_DWORD *)v14 )
        {
          v13 -= 4;
          v14 += 4;
          v15 += 4;
          if ( v13 < 4 )
            goto LABEL_29;
        }
      }
      v16 = *v15 - *v14;
      if ( !v16 )
      {
        if ( v13 <= 1 )
          goto LABEL_38;
        v16 = v15[1] - v14[1];
        if ( v16 )
          goto LABEL_37;
        if ( v13 <= 2 )
        {
LABEL_38:
          v12 = a1;
          goto LABEL_39;
        }
        v16 = v15[2] - v14[2];
        if ( !v16 )
        {
          if ( v13 > 3 )
          {
            v16 = v15[3] - v14[3];
            goto LABEL_37;
          }
          goto LABEL_38;
        }
      }
LABEL_37:
      v12 = a1;
      result = (v16 >> 31) | 1;
LABEL_40:
      if ( result )
      {
        if ( *((_BYTE *)v4 + 38) )
          --*((_BYTE *)v4 + 37);
        if ( *(_BYTE *)(a2 + 38) )
          --*(_BYTE *)(a2 + 37);
        return result;
      }
      v7 = a2;
      goto LABEL_42;
    }
    v17 = *(_DWORD *)(v11 + 4);
    v18 = v17 ? zend_hash_find(v7, (char *)(v11 + 32), v17, &v19) : zend_hash_index_find(v7, *(_DWORD *)v11, &v19);
    if ( v18 == -1 )
      break;
LABEL_47:
    result = a3(*(_DWORD *)(v11 + 8), v19);
    if ( result )
    {
LABEL_21:
      if ( *((_BYTE *)v4 + 38) )
        --*((_BYTE *)v4 + 37);
      if ( *(_BYTE *)(v7 + 38) )
        --*(_BYTE *)(v7 + 37);
      return result;
    }
    v11 = *(_DWORD *)(v11 + 16);
    if ( a4 )
    {
      v12 = (_DWORD *)v12[4];
      a1 = v12;
    }
    if ( !v11 )
      goto LABEL_51;
  }
  if ( *((_BYTE *)v4 + 38) )
    --*((_BYTE *)v4 + 37);
  if ( *(_BYTE *)(v7 + 38) )
    --*(_BYTE *)(v7 + 37);
  return 1;
}

//----- (00472120) --------------------------------------------------------
int (__cdecl *__cdecl zend_hash_merge_ex(
        int a1,
        int a2,
        int (__cdecl *a3)(_DWORD),
        size_t Size,
        int (__cdecl *a5)(int, _DWORD)))(_DWORD)
{
  int v5; // esi
  int v6; // ebx
  size_t v7; // ebp
  unsigned int v8; // eax
  int (__cdecl *result)(_DWORD); // eax

  v5 = *(_DWORD *)(a2 + 20);
  if ( v5 )
  {
    v6 = a1;
    v7 = Size;
    while ( 1 )
    {
      v8 = *(_DWORD *)(v5 + 4);
      if ( v8 )
      {
        if ( zend_hash_find(v6, (char *)(v5 + 32), v8, &a1) != -1 )
        {
          result = (int (__cdecl *)(_DWORD))a5(a1, *(_DWORD *)(v5 + 8));
          if ( !(_BYTE)result )
            goto LABEL_14;
        }
        result = (int (__cdecl *)(_DWORD))zend_hash_add_or_update(
                                            v6,
                                            (char *)(v5 + 32),
                                            *(_DWORD *)(v5 + 4),
                                            *(size_t **)(v5 + 8),
                                            v7,
                                            &a2,
                                            1);
        if ( result )
          goto LABEL_14;
        result = a3;
        if ( !a3 )
          goto LABEL_14;
      }
      else
      {
        if ( zend_hash_index_find(v6, *(_DWORD *)v5, &a1) != -1 )
        {
          result = (int (__cdecl *)(_DWORD))a5(a1, *(_DWORD *)(v5 + 8));
          if ( !(_BYTE)result )
            goto LABEL_14;
        }
        result = (int (__cdecl *)(_DWORD))zend_hash_index_update_or_next_insert(
                                            v6,
                                            *(_DWORD *)v5,
                                            *(_DWORD **)(v5 + 8),
                                            v7,
                                            &a2,
                                            1);
        if ( result || !a3 )
          goto LABEL_14;
      }
      result = (int (__cdecl *)(_DWORD))a3(a2);
LABEL_14:
      v5 = *(_DWORD *)(v5 + 16);
      if ( !v5 )
      {
        *(_DWORD *)(v6 + 16) = *(_DWORD *)(v6 + 20);
        return result;
      }
    }
  }
  result = (int (__cdecl *)(_DWORD))a1;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 20);
  return result;
}

//----- (00472220) --------------------------------------------------------
int (__cdecl *__cdecl zend_hash_merge(int a1, int a2, int (__cdecl *a3)(_DWORD), int a4, size_t Size, int a6))(_DWORD)
{
  int v6; // esi
  int v7; // edi
  int v8; // ebx
  size_t v9; // ebp
  size_t v10; // eax
  int (__cdecl *result)(_DWORD); // eax

  v6 = *(_DWORD *)(a2 + 20);
  v7 = 2 - (a6 != 0);
  if ( v6 )
  {
    v8 = a1;
    v9 = Size;
    while ( 1 )
    {
      v10 = *(_DWORD *)(v6 + 4);
      if ( v10 )
      {
        result = (int (__cdecl *)(_DWORD))zend_hash_add_or_update(
                                            v8,
                                            (char *)(v6 + 32),
                                            v10,
                                            *(size_t **)(v6 + 8),
                                            v9,
                                            &a1,
                                            v7);
        if ( result )
          goto LABEL_12;
        result = a3;
        if ( !a3 )
          goto LABEL_12;
      }
      else
      {
        if ( v7 != 1 )
        {
          result = (int (__cdecl *)(_DWORD))zend_hash_index_exists(v8, *(_DWORD *)v6);
          if ( result )
            goto LABEL_12;
        }
        result = (int (__cdecl *)(_DWORD))zend_hash_index_update_or_next_insert(
                                            v8,
                                            *(_DWORD *)v6,
                                            *(_DWORD **)(v6 + 8),
                                            v9,
                                            &a1,
                                            1);
        if ( result || !a3 )
          goto LABEL_12;
      }
      result = (int (__cdecl *)(_DWORD))a3(a1);
LABEL_12:
      v6 = *(_DWORD *)(v6 + 16);
      if ( !v6 )
      {
        *(_DWORD *)(v8 + 16) = *(_DWORD *)(v8 + 20);
        return result;
      }
    }
  }
  result = (int (__cdecl *)(_DWORD))a1;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 20);
  return result;
}

//----- (004722E0) --------------------------------------------------------
int __cdecl zend_hash_copy(int a1, int a2, int (__cdecl *a3)(int), int a4, size_t Size)
{
  int v5; // esi
  size_t v6; // ebx
  int (__cdecl *v7)(int); // ebp
  int v8; // edi
  size_t v9; // eax
  int result; // eax
  size_t *v11; // [esp-1Ch] [ebp-20h]

  v5 = *(_DWORD *)(a2 + 20);
  if ( v5 )
  {
    v6 = Size;
    v7 = a3;
    v8 = a1;
    do
    {
      v9 = *(_DWORD *)(v5 + 4);
      v11 = *(size_t **)(v5 + 8);
      if ( v9 )
        result = zend_hash_add_or_update(v8, (char *)(v5 + 32), v9, v11, v6, &a1, 1);
      else
        result = zend_hash_index_update_or_next_insert(v8, *(_DWORD *)v5, v11, v6, &a1, 1);
      if ( v7 )
        result = v7(a1);
      v5 = *(_DWORD *)(v5 + 16);
    }
    while ( v5 );
    *(_DWORD *)(v8 + 16) = *(_DWORD *)(v8 + 20);
  }
  else
  {
    result = a1;
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 20);
  }
  return result;
}

//----- (00472360) --------------------------------------------------------
void __cdecl zend_hash_reverse_apply(int a1, int (__cdecl *a2)(_DWORD))
{
  unsigned __int8 v2; // al
  char *v3; // eax
  int v4; // esi
  char v5; // bl
  int v6; // eax
  unsigned int v7; // ecx

  if ( *(_BYTE *)(a1 + 38) )
  {
    v2 = *(_BYTE *)(a1 + 37);
    *(_BYTE *)(a1 + 37) = v2 + 1;
    if ( v2 >= 3u )
    {
      v3 = (char *)sub_473493((int)&unk_4872E0);
      zend_error(1, v3);
    }
  }
  v4 = *(_DWORD *)(a1 + 24);
  if ( v4 )
  {
    do
    {
      v5 = a2(*(_DWORD *)(v4 + 8));
      v6 = v4;
      v4 = *(_DWORD *)(v4 + 20);
      if ( (v5 & 1) != 0 )
      {
        v7 = *(_DWORD *)(v6 + 4);
        if ( v7 )
          zend_hash_del_key_or_index((_DWORD *)a1, (char *)(v6 + 32), v7, 0, 0);
        else
          zend_hash_del_key_or_index((_DWORD *)a1, 0, 0, *(_DWORD *)v6, 1);
      }
    }
    while ( (v5 & 2) == 0 && v4 );
  }
  if ( *(_BYTE *)(a1 + 38) )
    --*(_BYTE *)(a1 + 37);
}

//----- (004723F0) --------------------------------------------------------
void zend_hash_apply_with_arguments(int a1, int (__cdecl *a2)(int, int, char *, int *), int a3, ...)
{
  unsigned __int8 v3; // al
  char *v4; // eax
  int *v5; // esi
  int v6; // ecx
  int v7[3]; // [esp+4h] [ebp-Ch] BYREF
  va_list va; // [esp+20h] [ebp+10h] BYREF

  va_start(va, a3);
  if ( *(_BYTE *)(a1 + 38) )
  {
    v3 = *(_BYTE *)(a1 + 37);
    *(_BYTE *)(a1 + 37) = v3 + 1;
    if ( v3 >= 3u )
    {
      v4 = (char *)sub_473493((int)&unk_4872E0);
      zend_error(1, v4);
    }
  }
  v5 = *(int **)(a1 + 20);
  while ( v5 )
  {
    v7[0] = (int)(v5 + 8);
    v7[1] = v5[1];
    v7[2] = *v5;
    if ( a2(v5[2], a3, va, v7) )
      v5 = (int *)sub_470D10(v6, a1, v5);
    else
      v5 = (int *)v5[4];
  }
  if ( *(_BYTE *)(a1 + 38) )
    --*(_BYTE *)(a1 + 37);
}
// 472460: variable 'v6' is possibly undefined

//----- (00472480) --------------------------------------------------------
void __cdecl zend_hash_apply_with_argument(int a1, int (__cdecl *a2)(_DWORD, int), int a3)
{
  unsigned __int8 v3; // al
  char *v4; // eax
  _DWORD *v5; // esi
  int v6; // ecx

  if ( *(_BYTE *)(a1 + 38) )
  {
    v3 = *(_BYTE *)(a1 + 37);
    *(_BYTE *)(a1 + 37) = v3 + 1;
    if ( v3 >= 3u )
    {
      v4 = (char *)sub_473493((int)&unk_4872E0);
      zend_error(1, v4);
    }
  }
  v5 = *(_DWORD **)(a1 + 20);
  while ( v5 )
  {
    if ( a2(v5[2], a3) )
      v5 = (_DWORD *)sub_470D10(v6, a1, v5);
    else
      v5 = (_DWORD *)v5[4];
  }
  if ( *(_BYTE *)(a1 + 38) )
    --*(_BYTE *)(a1 + 37);
}
// 4724CE: variable 'v6' is possibly undefined

//----- (004724F0) --------------------------------------------------------
void __cdecl zend_hash_apply(int a1, int (__cdecl *a2)(_DWORD))
{
  unsigned __int8 v2; // al
  char *v3; // eax
  _DWORD *v4; // esi
  int v5; // ecx

  if ( *(_BYTE *)(a1 + 38) )
  {
    v2 = *(_BYTE *)(a1 + 37);
    *(_BYTE *)(a1 + 37) = v2 + 1;
    if ( v2 >= 3u )
    {
      v3 = (char *)sub_473493((int)&unk_4872E0);
      zend_error(1, v3);
    }
  }
  v4 = *(_DWORD **)(a1 + 20);
  while ( v4 )
  {
    if ( a2(v4[2]) )
      v4 = (_DWORD *)sub_470D10(v5, a1, v4);
    else
      v4 = (_DWORD *)v4[4];
  }
  if ( *(_BYTE *)(a1 + 38) )
    --*(_BYTE *)(a1 + 37);
}
// 47253D: variable 'v5' is possibly undefined

//----- (00472560) --------------------------------------------------------
int __cdecl zend_hash_add_empty_element(int a1, char *String, size_t a3)
{
  size_t Src; // [esp+0h] [ebp-4h] BYREF

  Src = 1;
  return zend_hash_add_or_update(a1, String, a3, &Src, 4u, 0, 2);
}

//----- (004725CD) --------------------------------------------------------
int __usercall sub_4725CD@<eax>(SOCKET a1@<eax>, int a2@<ecx>, char a3)
{
  int v3; // esi
  fd_set readfds; // [esp+4h] [ebp-210h] BYREF
  fd_set writefds; // [esp+108h] [ebp-10Ch] BYREF
  struct timeval timeout; // [esp+20Ch] [ebp-8h] BYREF

  v3 = 0;
  if ( (a3 & 3) != 0 )
  {
    readfds.fd_count = 0;
    writefds.fd_count = 0;
    if ( (a3 & 1) != 0 )
    {
      readfds.fd_array[0] = a1;
      readfds.fd_count = 1;
    }
    if ( (a3 & 2) != 0 )
    {
      writefds.fd_array[0] = a1;
      writefds.fd_count = 1;
    }
    timeout.tv_sec = a2;
    timeout.tv_usec = 0;
    if ( select(a1 + 1, &readfds, &writefds, 0, &timeout) > 0 )
      return 1;
  }
  return v3;
}

//----- (0047263F) --------------------------------------------------------
int __cdecl sub_47263F(SOCKET s, BOOL argp)
{
  argp = argp;
  return ioctlsocket(s, -2147195266, (u_long *)&argp);
}

//----- (00472661) --------------------------------------------------------
int sub_472661()
{
  struct protoent *v0; // eax

  v0 = getprotobyname(aTcp);
  if ( v0 )
    return v0->p_proto;
  else
    return -1;
}

//----- (0047270A) --------------------------------------------------------
char *__cdecl sub_47270A(SOCKET s)
{
  int v1; // esi
  signed int v2; // ebp
  char *v3; // edi
  int i; // eax

  v1 = 0;
  v2 = 1024;
  v3 = (char *)malloc(0x400u);
  if ( sub_4725CD(s, 10, 1) )
  {
    for ( i = recv(s, v3, 1024, 0); i > 0; i = recv(s, &v3[v1], v2 - v1, 0) )
    {
      v1 += i;
      if ( v1 + 1024 > v2 )
      {
        v2 += (((v1 - v2 + 1024) / 1024) << 10) + 1024;
        v3 = (char *)realloc(v3, v2);
      }
      sub_4725CD(s, 5, 1);
    }
  }
  v3[v1] = 0;
  return v3;
}

//----- (0047279E) --------------------------------------------------------
int __usercall sub_47279E@<eax>(const char *a1@<ebx>)
{
  SOCKET v1; // esi
  struct hostent *v2; // eax
  SOCKET v3; // eax
  int Error; // eax
  int protocol; // [esp+8h] [ebp-18h]
  struct sockaddr name; // [esp+Ch] [ebp-14h] BYREF

  v1 = -1;
  protocol = sub_472661();
  name.sa_family = 2;
  *(_DWORD *)&name.sa_data[6] = 0;
  *(_DWORD *)&name.sa_data[10] = 0;
  *(_WORD *)name.sa_data = htons(0x50u);
  *(_DWORD *)&name.sa_data[2] = inet_addr(a1);
  if ( *(_DWORD *)&name.sa_data[2] == -1 )
  {
    v2 = gethostbyname(a1);
    if ( v2 )
    {
      memcpy(&name.sa_data[2], *(const void **)v2->h_addr_list, v2->h_length);
      if ( protocol >= 0 )
      {
        v3 = socket(2, 1, protocol);
        v1 = v3;
        if ( v3 != -1 )
        {
          sub_47263F(v3, 1);
          if ( connect(v1, &name, 16) )
          {
            if ( (Error = WSAGetLastError(), Error != 10036) && Error != 10035 || !sub_4725CD(v1, 10, 2) )
            {
              closesocket(v1);
              return -1;
            }
          }
        }
      }
    }
  }
  return v1;
}

//----- (00472882) --------------------------------------------------------
_DWORD *__cdecl sub_472882(const char *a1)
{
  _DWORD *v1; // ebx
  const char *v2; // esi
  const char *v3; // edx
  char *v4; // eax
  char *v5; // eax
  char *Format; // [esp+14h] [ebp-10h]
  char SubStr[8]; // [esp+18h] [ebp-Ch] BYREF

  strcpy(SubStr, "\r\n\r\n");
  v1 = malloc(0x18u);
  v2 = (const char *)sub_473493((int)&unk_4A4F08);
  Format = (char *)sub_473493((int)&unk_4A4F1C);
  v3 = (const char *)sub_473493((int)&unk_4A4F34);
  memset(v1, 0, 0x18u);
  v1[4] = a1;
  sscanf(a1, v3, v1, v1 + 1, v1 + 2);
  v4 = strstr(a1, v2);
  sscanf(v4, Format, v1 + 3);
  v5 = strstr(a1, SubStr);
  v1[5] = v5;
  if ( v5 )
    v1[5] = v5 + 4;
  return v1;
}

//----- (00472937) --------------------------------------------------------
int __cdecl sub_472937(const char *a1, const char *a2)
{
  const char *v2; // ebx
  unsigned int v3; // esi
  char *v4; // edi
  int v5; // esi
  int v6; // ebx
  int v7; // eax
  int s; // [esp+4h] [ebp-4h]

  s = sub_47279E(a1);
  if ( s != -1 )
  {
    v2 = (const char *)sub_473493((int)&unk_4A4ECC);
    sub_47263F(s, 0);
    v3 = strlen(a2) + strlen(a1) + strlen(v2) + 1;
    v4 = (char *)malloc(v3);
    v5 = _snprintf(v4, v3, v2, a2, a1);
    v6 = 0;
    while ( v5 )
    {
      v7 = send(s, &v4[v6], v5, 0);
      if ( v7 >= 0 )
      {
        v6 += v7;
        v5 -= v7;
      }
      else if ( WSAGetLastError() != 10004 )
      {
        break;
      }
    }
    sub_47263F(s, 1);
    if ( v5 )
    {
      closesocket(s);
      s = -1;
    }
    free(v4);
  }
  return s;
}

//----- (00472A5D) --------------------------------------------------------
int __cdecl sub_472A5D(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 12) = 1;
  return result;
}

//----- (00472A69) --------------------------------------------------------
int __cdecl sub_472A69(int *a1)
{
  int result; // eax
  int v2; // eax
  int v3; // edx

  if ( a1[3] )
  {
    result = a1[2];
    a1[3] = 0;
  }
  else
  {
    v2 = 30345 * (unsigned __int16)a1[1] + HIWORD(a1[1]);
    v3 = 18000 * (unsigned __int16)*a1 + HIWORD(*a1);
    a1[1] = v2;
    result = v3 + __ROL4__(v2, 16);
    *a1 = v3;
    a1[2] = result;
  }
  return result;
}

//----- (00472ACC) --------------------------------------------------------
unsigned int __fastcall sub_472ACC(unsigned int a1)
{
  unsigned int v1; // eax
  unsigned int v2; // ecx

  if ( !__OFSUB__(a1 % 9 + 1, 1) && a1 % 9 != 0 )
  {
    v1 = a1 % 9;
    do
    {
      v2 = (((a1 << 10) ^ a1) >> 15) ^ (a1 << 10) ^ a1;
      a1 = (((16 * v2) ^ v2) >> 13) ^ (16 * v2) ^ v2;
      --v1;
    }
    while ( v1 );
  }
  return a1;
}

//----- (00472B02) --------------------------------------------------------
unsigned int __cdecl sub_472B02(unsigned int a1)
{
  return (2 * (a1 ^ (a1 >> 9))) ^ a1 ^ (a1 >> 9) ^ (((2 * (a1 ^ (a1 >> 9))) ^ a1 ^ (a1 >> 9)) >> 7);
}

//----- (00472B1A) --------------------------------------------------------
unsigned int __cdecl sub_472B1A(int a1)
{
  return ((a1 ^ (unsigned int)(a1 << 13)) >> 17) ^ a1 ^ (a1 << 13) ^ (32
                                                                    * (((a1 ^ (unsigned int)(a1 << 13)) >> 17) ^ a1 ^ (a1 << 13)));
}

//----- (00472B66) --------------------------------------------------------
int __cdecl sub_472B66(int a1, int *a2)
{
  int v2; // eax
  int v3; // ecx
  int result; // eax

  v2 = *a2;
  a2[1] = *a2 + 1;
  a2[2] = 0;
  a2[3] = -1727483681;
  if ( !a2[4] )
    a2[4] = (int)malloc(4 * v2 + 16) + 16;
  v3 = -4;
  do
    *(_DWORD *)(a2[4] + 4 * v3++) = 0;
  while ( v3 < 0 );
  while ( v3 < *a2 )
  {
    *(_DWORD *)(a2[4] + 4 * v3) = a1 & 0xFFFF0000;
    *(_DWORD *)(a2[4] + 4 * v3) |= (unsigned int)(69069 * a1 + 1) >> 16;
    a1 = 69069 * (69069 * a1 + 1) + 1;
    ++v3;
  }
  result = *a2;
  a2[1] = *a2;
  return result;
}

//----- (00472BE5) --------------------------------------------------------
void __usercall sub_472BE5(void **a1@<esi>)
{
  ((void (__cdecl *)(void *))a1[5])(*a1);
  free(*a1);
  free(a1);
}

//----- (00472C1C) --------------------------------------------------------
char __thiscall sub_472C1C(_DWORD *this)
{
  int v1; // edx
  char result; // al

  v1 = this[8];
  result = *(_BYTE *)(v1 + this[6]);
  if ( v1 == this[7] - 1 )
    this[8] = 0;
  else
    this[8] = v1 + 1;
  return result;
}

//----- (00472C42) --------------------------------------------------------
int __cdecl sub_472C42(int *a1)
{
  return dword_4A4F44 ^ sub_472A69(a1);
}
// 4A4F44: using guessed type int dword_4A4F44;

//----- (00472C66) --------------------------------------------------------
int __usercall sub_472C66@<eax>(int result@<eax>, char a2)
{
  if ( (a2 & 1) != 0 )
    *(_DWORD *)(result + 20) = sub_472B1A;
  else
    *(_DWORD *)(result + 20) = sub_472B02;
  return result;
}

//----- (00472C7D) --------------------------------------------------------
int __thiscall sub_472C7D(_DWORD *this)
{
  int v1; // eax
  _DWORD *v2; // esi
  __int64 v3; // rax

  v1 = (this[1] + 1) & (*this - 1);
  v2 = (_DWORD *)(this[6] + 4 * v1);
  this[1] = v1;
  v3 = (unsigned int)this[4] + 18782i64 * (unsigned int)*v2;
  LODWORD(v3) = HIDWORD(v3) + v3;
  this[4] = HIDWORD(v3);
  if ( (unsigned int)v3 < HIDWORD(v3) )
  {
    LODWORD(v3) = v3 + 1;
    this[4] = HIDWORD(v3) + 1;
  }
  if ( (_DWORD)v3 == -1 )
  {
    ++this[4];
    LODWORD(v3) = 0;
  }
  *v2 = -2 - v3;
  return *(_DWORD *)(this[6] + 4 * this[1]);
}

//----- (00472CD2) --------------------------------------------------------
int __usercall sub_472CD2@<eax>(int *a1@<esi>)
{
  __time32_t v1; // edi
  DWORD CurrentProcessId; // eax

  v1 = _time32(0);
  CurrentProcessId = GetCurrentProcessId();
  *a1 = 624;
  return sub_472B66(v1 + CurrentProcessId, a1);
}

//----- (00472D0B) --------------------------------------------------------
int __cdecl sub_472D0B(int a1)
{
  _DWORD *v1; // ecx

  if ( v1[6] )
    return a1 ^ (unsigned __int8)sub_472C1C(v1);
  else
    return a1;
}
// 472D0B: variable 'v1' is possibly undefined

//----- (00472D23) --------------------------------------------------------
_DWORD *sub_472D23()
{
  _DWORD *v0; // esi
  _DWORD *v1; // eax

  v0 = malloc(0x24u);
  v1 = malloc(0x10u);
  *v0 = v1;
  *v1 = 0;
  v1[1] = 0;
  v1[2] = 0;
  v1[3] = 0;
  v0[1] = nullsub_2;
  v0[2] = sub_472A69;
  v0[3] = sub_472C42;
  v0[4] = sub_472A5D;
  v0[5] = nullsub_1;
  return v0;
}
// 472AAC: using guessed type int nullsub_1();
// 472AAD: using guessed type int nullsub_2();

//----- (00472D69) --------------------------------------------------------
int __cdecl sub_472D69(unsigned int a1, int a2)
{
  int v2; // edi
  int v3; // eax
  int v4; // eax
  int v5; // ecx
  int result; // eax
  int v7; // [esp-4h] [ebp-10h]

  *(_DWORD *)(a2 + 4) = *(_DWORD *)a2 + 1;
  *(_DWORD *)(a2 + 8) = 69069 * a1 + 1234567;
  v2 = 0;
  *(_DWORD *)(a2 + 12) = sub_472ACC(a1);
  *(_DWORD *)(a2 + 16) = a1 % 0x495E;
  sub_472C66(a2, a1);
  if ( !*(_DWORD *)(a2 + 24) )
    *(_DWORD *)(a2 + 24) = (char *)malloc(4 * *(_DWORD *)a2 + 16) + 16;
  v3 = -16;
  do
  {
    *(_DWORD *)(v3 + *(_DWORD *)(a2 + 24)) = 0;
    v3 += 4;
  }
  while ( v3 < 0 );
  if ( *(int *)a2 > 0 )
  {
    do
    {
      v7 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a2 + 8) = 69069 * *(_DWORD *)(a2 + 8) + 123;
      v4 = (*(int (__cdecl **)(int))(a2 + 20))(v7);
      v5 = v4 + *(_DWORD *)(a2 + 8);
      *(_DWORD *)(a2 + 12) = v4;
      *(_DWORD *)(*(_DWORD *)(a2 + 24) + 4 * v2++) = v5;
    }
    while ( v2 < *(_DWORD *)a2 );
  }
  result = *(_DWORD *)a2 - 1;
  *(_DWORD *)(a2 + 4) = result;
  return result;
}

//----- (00472E11) --------------------------------------------------------
unsigned int __cdecl sub_472E11(int *a1)
{
  int v2; // ecx
  int v3; // edx
  unsigned int *v4; // ecx
  int v5; // edi
  unsigned int *v6; // ecx
  _DWORD *v7; // ecx
  int v8; // eax
  unsigned int v9; // ecx
  unsigned int v10; // ecx
  int v12; // [esp+Ch] [ebp+8h]

  v2 = a1[1];
  if ( v2 >= *a1 )
  {
    if ( v2 == *a1 + 1 )
      sub_472CD2(a1);
    v3 = -4;
    do
    {
      *(_DWORD *)(a1[4] + 4 * v3) = *(_DWORD *)(a1[4] + 4 * (v3 + *a1));
      ++v3;
    }
    while ( v3 < 0 );
    while ( 1 )
    {
      v12 = v3;
      if ( v3 >= *a1 - 397 )
        break;
      v4 = (unsigned int *)(4 * v3 + a1[4]);
      *v4 = ((*v4 ^ (*v4 ^ v4[1]) & 0x7FFFFFFF) >> 1) ^ v4[397] ^ a1[(v4[1] & 1) + 2];
      ++v3;
    }
    while ( v3 < *a1 - 1 )
    {
      v5 = a1[4];
      v6 = (unsigned int *)(v5 + 4 * v3);
      *v6 = ((*v6 ^ (*v6 ^ v6[1]) & 0x7FFFFFFF) >> 1) ^ a1[(v6[1] & 1) + 2] ^ *(_DWORD *)(v5 + 4 * (v3 - *a1) + 1588);
      v3 = ++v12;
    }
    v7 = (_DWORD *)a1[4];
    v7[*a1 - 1] = ((v7[*a1 - 1] ^ (v7[*a1 - 1] ^ *v7) & 0x7FFFFFFFu) >> 1) ^ v7[396] ^ a1[(*(_BYTE *)v7 & 1) + 2];
    a1[1] = 0;
  }
  v8 = a1[1];
  v9 = dword_4A4F44 ^ *(_DWORD *)(a1[4] + 4 * v8);
  a1[1] = v8 + 1;
  v10 = ((((v9 >> 11) ^ v9) & 0xFF3A58AD) << 7) ^ (v9 >> 11) ^ v9;
  return ((v10 & 0xFFFFDF8C) << 15) ^ v10 ^ ((((v10 & 0xFFFFDF8C) << 15) ^ v10) >> 18);
}
// 4A4F44: using guessed type int dword_4A4F44;

//----- (00472F28) --------------------------------------------------------
unsigned int __cdecl sub_472F28(int *a1)
{
  int v2; // ecx
  int v3; // edx
  unsigned int *v4; // ecx
  int v5; // edi
  unsigned int *v6; // ecx
  _DWORD *v7; // ecx
  int v8; // eax
  unsigned int v9; // ecx
  unsigned int v10; // ecx
  int v12; // [esp+Ch] [ebp+8h]

  v2 = a1[1];
  if ( v2 >= *a1 )
  {
    if ( v2 == *a1 + 1 )
      sub_472CD2(a1);
    v3 = -4;
    do
    {
      *(_DWORD *)(a1[4] + 4 * v3) = *(_DWORD *)(a1[4] + 4 * (v3 + *a1));
      ++v3;
    }
    while ( v3 < 0 );
    while ( 1 )
    {
      v12 = v3;
      if ( v3 >= *a1 - 397 )
        break;
      v4 = (unsigned int *)(4 * v3 + a1[4]);
      *v4 = ((*v4 ^ (*v4 ^ v4[1]) & 0x7FFFFFFF) >> 1) ^ v4[397] ^ a1[(v4[1] & 1) + 2];
      ++v3;
    }
    while ( v3 < *a1 - 1 )
    {
      v5 = a1[4];
      v6 = (unsigned int *)(v5 + 4 * v3);
      *v6 = ((*v6 ^ (*v6 ^ v6[1]) & 0x7FFFFFFF) >> 1) ^ a1[(v6[1] & 1) + 2] ^ *(_DWORD *)(v5 + 4 * (v3 - *a1) + 1588);
      v3 = ++v12;
    }
    v7 = (_DWORD *)a1[4];
    v7[*a1 - 1] = ((v7[*a1 - 1] ^ (v7[*a1 - 1] ^ *v7) & 0x7FFFFFFFu) >> 1) ^ v7[396] ^ a1[(*(_BYTE *)v7 & 1) + 2];
    a1[1] = 0;
  }
  v8 = a1[1];
  v9 = *(_DWORD *)(a1[4] + 4 * v8);
  a1[1] = v8 + 1;
  v10 = ((((v9 >> 11) ^ v9) & 0xFF3A58AD) << 7) ^ (v9 >> 11) ^ v9;
  return ((v10 & 0xFFFFDF8C) << 15) ^ v10 ^ ((((v10 & 0xFFFFDF8C) << 15) ^ v10) >> 18);
}

//----- (0047304A) --------------------------------------------------------
int __usercall sub_47304A@<eax>(int a1@<esi>)
{
  int v1; // eax

  v1 = (*(int (__cdecl **)(_DWORD))(a1 + 8))(*(_DWORD *)a1);
  return sub_472D0B(v1);
}

//----- (0047305B) --------------------------------------------------------
_DWORD *sub_47305B()
{
  _DWORD *v0; // esi
  _DWORD *v1; // eax

  v0 = malloc(0x24u);
  v1 = malloc(0x14u);
  *v1 = 624;
  v1[1] = 625;
  v1[2] = 0;
  v1[3] = -1727483681;
  v1[4] = 0;
  *v0 = v1;
  v0[1] = sub_472B66;
  v0[2] = sub_472F28;
  v0[3] = sub_472E11;
  v0[4] = sub_472B48;
  v0[5] = sub_472B50;
  return v0;
}
// 472B48: using guessed type int sub_472B48();
// 472B50: using guessed type int sub_472B50();

//----- (004730B3) --------------------------------------------------------
int __usercall sub_4730B3@<eax>(_DWORD *a1@<esi>)
{
  __time32_t v1; // edi
  DWORD CurrentProcessId; // eax

  v1 = _time32(0);
  CurrentProcessId = GetCurrentProcessId();
  *a1 = 4096;
  return sub_472D69(v1 + CurrentProcessId, (int)a1);
}

//----- (004730D6) --------------------------------------------------------
int __cdecl sub_4730D6(int a1)
{
  int v1; // eax
  int v2; // ecx
  int i; // edi
  int v4; // ecx
  int result; // eax
  int v6; // [esp-8h] [ebp-Ch]

  v1 = *(_DWORD *)(a1 + 4);
  if ( v1 >= *(_DWORD *)a1 )
  {
    if ( v1 > *(_DWORD *)a1 )
      sub_4730B3((_DWORD *)a1);
    v2 = -4;
    do
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 24) + 4 * v2) = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 4 * (v2 + *(_DWORD *)a1));
      ++v2;
    }
    while ( v2 < 0 );
    for ( i = 0; i < *(_DWORD *)a1; ++i )
    {
      v6 = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 8) = 69069 * *(_DWORD *)(a1 + 8) + 123;
      *(_DWORD *)(a1 + 12) = (*(int (__cdecl **)(int))(a1 + 20))(v6);
      *(_DWORD *)(*(_DWORD *)(a1 + 24) + 4 * i) = *(_DWORD *)(a1 + 12) + *(_DWORD *)(a1 + 8) + sub_472C7D((_DWORD *)a1);
    }
    *(_DWORD *)(a1 + 4) = 0;
  }
  v4 = *(_DWORD *)(a1 + 4);
  result = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 4 * v4);
  *(_DWORD *)(a1 + 4) = v4 + 1;
  return result;
}

//----- (0047315E) --------------------------------------------------------
_DWORD *sub_47315E()
{
  _DWORD *v0; // esi
  _DWORD *v1; // eax

  v0 = malloc(0x24u);
  v1 = malloc(0x1Cu);
  *v1 = 4096;
  v1[1] = 4097;
  v1[2] = 1236789;
  v1[3] = 521288629;
  v1[4] = 362;
  v1[5] = 0;
  v1[6] = 0;
  *v0 = v1;
  v0[1] = sub_472D69;
  v0[2] = sub_4730D6;
  v0[3] = sub_47314A;
  v0[4] = sub_472AAE;
  v0[5] = sub_472AB6;
  return v0;
}
// 472AAE: using guessed type int sub_472AAE();
// 472AB6: using guessed type int sub_472AB6();
// 47314A: using guessed type int sub_47314A();

//----- (00473200) --------------------------------------------------------
void __noreturn sub_473200()
{
  exit(1);
}
// 473200: using guessed type void __noreturn sub_473200();

//----- (0047320D) --------------------------------------------------------
char *sub_47320D()
{
  HMODULE ModuleHandleA; // eax
  unsigned int v1; // esi
  char *result; // eax
  char v3; // cl
  FILE *v4; // eax
  const char *v5; // [esp-4h] [ebp-42Ch]
  struct _stat32 Stat; // [esp+0h] [ebp-428h] BYREF
  CHAR Filename[1024]; // [esp+24h] [ebp-404h] BYREF

  ModuleHandleA = GetModuleHandleA(0);
  GetModuleFileNameA(ModuleHandleA, Filename, 0x104u);
  if ( _stat32(Filename, &Stat) )
  {
    v5 = (const char *)sub_473493((int)&unk_4A4F88);
    v4 = (FILE *)sub_44F01A();
    fprintf(v4 + 2, v5);
    exit(126);
  }
  v1 = strlen(Filename);
  for ( result = _strdup(Filename); v1; --v1 )
  {
    v3 = result[v1];
    if ( v3 == 47 )
      break;
    if ( v3 == 92 )
      break;
  }
  result[v1] = 0;
  return result;
}

//----- (004732D9) --------------------------------------------------------
int sub_4732D9()
{
  int result; // eax

  *((_DWORD *)dword_4A80FC + 1) += 32;
  result = off_4A4FE8(*((_DWORD *)dword_4A80FC + 2), 4 * *((_DWORD *)dword_4A80FC + 1));
  *((_DWORD *)dword_4A80FC + 2) = result;
  return result;
}
// 4A4FE8: using guessed type int (__cdecl *off_4A4FE8)(_DWORD, _DWORD);

//----- (00473303) --------------------------------------------------------
int sub_473303()
{
  int result; // eax

  result = *((_DWORD *)dword_4A80FC + 2);
  if ( result )
    return off_4A4FEC(*((_DWORD *)dword_4A80FC + 2));
  return result;
}
// 4A4FEC: using guessed type int (__cdecl *off_4A4FEC)(_DWORD);

//----- (004733A9) --------------------------------------------------------
void *sub_4733A9()
{
  void *result; // eax

  result = calloc(0x5CFu, 4u);
  dword_4A80F8 = (int)result;
  return result;
}
// 4A80F8: using guessed type int dword_4A80F8;

//----- (004733BD) --------------------------------------------------------
_BYTE *__usercall sub_4733BD@<eax>(unsigned __int8 *a1@<eax>)
{
  int v1; // ecx
  unsigned __int8 *v2; // eax
  int v3; // ecx
  _BYTE *result; // eax
  int i; // esi

  v1 = *a1;
  v2 = a1 + 1;
  v3 = (*v2 << 8) + v1;
  result = v2 + 1;
  for ( i = 0; i <= v3; ++result )
    *result ^= byte_4820BC[((_BYTE)i++ + (_BYTE)v3) & 0xF];
  return result;
}

//----- (004733E7) --------------------------------------------------------
_BYTE *__usercall sub_4733E7@<eax>(unsigned __int8 *a1@<eax>)
{
  int v1; // ecx
  _BYTE *result; // eax
  int i; // esi

  v1 = *a1;
  result = a1 + 1;
  for ( i = 0; i <= v1; ++i )
    *result++ ^= byte_4820BC[((_BYTE)i + (_BYTE)v1) & 0xF];
  return result;
}

//----- (00473408) --------------------------------------------------------
int __cdecl sub_473408(int Src)
{
  _DWORD *v2; // edi
  _DWORD *v3; // ebp
  _DWORD *v4; // eax
  char *v5; // ebx
  void *Srca; // [esp+10h] [ebp+4h]

  if ( !dword_4A80F8 )
    sub_4733A9();
  v2 = (_DWORD *)(dword_4A80F8 + 4 * ((Src >> 3) & 0x5CE));
  v3 = (_DWORD *)*v2;
  v4 = (_DWORD *)*v2;
  if ( !*v2 )
    goto LABEL_7;
  do
  {
    if ( *v4 == Src )
      break;
    v4 = (_DWORD *)v4[2];
  }
  while ( v4 );
  if ( !v4 )
  {
LABEL_7:
    Srca = (void *)((*(unsigned __int8 *)(Src + 1) << 8) + *(unsigned __int8 *)Src + 3);
    v5 = (char *)malloc((size_t)Srca);
    memcpy(v5, (const void *)Src, (size_t)Srca);
    sub_4733BD((unsigned __int8 *)v5);
    v4 = malloc(0xCu);
    v4[1] = v5 + 2;
    *v4 = Src;
    v4[2] = v3;
    *v2 = v4;
  }
  return v4[1];
}
// 4A80F8: using guessed type int dword_4A80F8;

//----- (00473493) --------------------------------------------------------
int __cdecl sub_473493(int Src)
{
  void **v1; // edi
  _DWORD *v2; // eax
  size_t v3; // esi
  char *v4; // ebp
  void *v5; // ecx

  if ( !dword_4A80F8 )
    sub_4733A9();
  v1 = (void **)(dword_4A80F8 + 4 * ((Src >> 3) & 0x5CE));
  v2 = *v1;
  if ( !*v1 )
    goto LABEL_7;
  do
  {
    if ( *v2 == Src )
      break;
    v2 = (_DWORD *)v2[2];
  }
  while ( v2 );
  if ( !v2 )
  {
LABEL_7:
    v3 = *(unsigned __int8 *)Src + 2;
    v4 = (char *)malloc(v3);
    memcpy(v4, (const void *)Src, v3);
    sub_4733E7((unsigned __int8 *)v4);
    v2 = malloc(0xCu);
    v5 = *v1;
    v2[1] = v4 + 1;
    *v2 = Src;
    v2[2] = v5;
    *v1 = v2;
  }
  return v2[1];
}
// 4A80F8: using guessed type int dword_4A80F8;

//----- (00473510) --------------------------------------------------------
int __cdecl zend_list_addref(int a1)
{
  int v1; // ecx
  int v3; // [esp+0h] [ebp-4h] BYREF

  v3 = v1;
  if ( zend_hash_index_find((int)dword_4AB158, a1, &v3) )
    return -1;
  ++*(_DWORD *)(v3 + 8);
  return 0;
}
// 473510: variable 'v1' is possibly undefined
// 4AB158: using guessed type _DWORD dword_4AB158[31];

//----- (00473540) --------------------------------------------------------
int __cdecl zend_list_find(int a1, _DWORD *a2)
{
  int v2; // ecx
  int v3; // eax
  int v5; // [esp+0h] [ebp-4h] BYREF

  v5 = v2;
  if ( zend_hash_index_find((int)dword_4AB158, a1, &v5) )
  {
    *a2 = -1;
    return 0;
  }
  else
  {
    v3 = v5;
    *a2 = *(_DWORD *)(v5 + 4);
    return *(_DWORD *)v3;
  }
}
// 473540: variable 'v2' is possibly undefined
// 4AB158: using guessed type _DWORD dword_4AB158[31];

//----- (00473580) --------------------------------------------------------
int __cdecl zend_list_delete(int a1)
{
  int v1; // eax
  int v3; // [esp+4h] [ebp-4h] BYREF

  if ( zend_hash_index_find((int)dword_4AB158, a1, &v3) )
    return -1;
  v1 = v3;
  --*(_DWORD *)(v3 + 8);
  if ( *(int *)(v1 + 8) > 0 )
    return 0;
  else
    return zend_hash_del_key_or_index(dword_4AB158, 0, 0, a1, 1);
}
// 4AB158: using guessed type _DWORD dword_4AB158[31];

//----- (004735D0) --------------------------------------------------------
int __cdecl zend_list_insert(int a1, int a2)
{
  int free_element; // esi
  int Src[3]; // [esp+4h] [ebp-Ch] BYREF

  Src[0] = a1;
  Src[1] = a2;
  Src[2] = 1;
  free_element = zend_hash_next_free_element((int)dword_4AB158);
  zend_hash_index_update_or_next_insert((int)dword_4AB158, free_element, Src, 0xCu, 0, 1);
  return free_element;
}
// 4AB158: using guessed type _DWORD dword_4AB158[31];

// nfuncs=1975 queued=1504 decompiled=1504 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 1504 function(s)"
